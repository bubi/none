; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\security_dispatcher.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\security_dispatcher.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\security_dispatcher.crf ..\..\..\..\..\..\components\ble\peer_manager\security_dispatcher.c]
                          THUMB

                          AREA ||i.auth_status_failure_process||, CODE, READONLY, ALIGN=1

                  auth_status_failure_process PROC
;;;432     */
;;;433    static void auth_status_failure_process(ble_gap_evt_t * p_gap_evt)
000000  b510              PUSH     {r4,lr}
;;;434    {
000002  4604              MOV      r4,r0
;;;435        link_secure_failure(p_gap_evt->conn_handle,
000004  7963              LDRB     r3,[r4,#5]
000006  f0030203          AND      r2,r3,#3
00000a  7921              LDRB     r1,[r4,#4]
00000c  8820              LDRH     r0,[r4,#0]
00000e  f7fffffe          BL       link_secure_failure
;;;436                            p_gap_evt->params.auth_status.auth_status,
;;;437                            p_gap_evt->params.auth_status.error_src);
;;;438    }
000012  bd10              POP      {r4,pc}
;;;439    
                          ENDP


                          AREA ||i.auth_status_process||, CODE, READONLY, ALIGN=1

                  auth_status_process PROC
;;;444     */
;;;445    static void auth_status_process(ble_gap_evt_t * p_gap_evt)
000000  b510              PUSH     {r4,lr}
;;;446    {
000002  4604              MOV      r4,r0
;;;447        switch (p_gap_evt->params.auth_status.auth_status)
000004  7920              LDRB     r0,[r4,#4]
000006  b918              CBNZ     r0,|L2.16|
;;;448        {
;;;449            case BLE_GAP_SEC_STATUS_SUCCESS:
;;;450                auth_status_success_process(p_gap_evt);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       auth_status_success_process
;;;451                break;
00000e  e003              B        |L2.24|
                  |L2.16|
;;;452    
;;;453            default:
;;;454                auth_status_failure_process(p_gap_evt);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       auth_status_failure_process
;;;455                break;
000016  bf00              NOP      
                  |L2.24|
000018  bf00              NOP                            ;451
;;;456        }
;;;457    }
00001a  bd10              POP      {r4,pc}
;;;458    
                          ENDP


                          AREA ||i.auth_status_success_process||, CODE, READONLY, ALIGN=2

                  auth_status_success_process PROC
;;;243     */
;;;244    static void auth_status_success_process(ble_gap_evt_t * p_gap_evt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;245    {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
;;;246        ret_code_t           err_code   = NRF_SUCCESS;
000008  2500              MOVS     r5,#0
;;;247        uint8_t              role       = ble_conn_state_role(p_gap_evt->conn_handle);
00000a  8820              LDRH     r0,[r4,#0]
00000c  f7fffffe          BL       ble_conn_state_role
000010  4607              MOV      r7,r0
;;;248        pm_peer_id_t         peer_id    = im_peer_id_get_by_conn_handle(p_gap_evt->conn_handle);
000012  8820              LDRH     r0,[r4,#0]
000014  f7fffffe          BL       im_peer_id_get_by_conn_handle
000018  4606              MOV      r6,r0
;;;249        ble_gap_sec_kdist_t  kdist_own  = p_gap_evt->params.auth_status.kdist_own;
00001a  68a0              LDR      r0,[r4,#8]
00001c  9007              STR      r0,[sp,#0x1c]
;;;250        ble_gap_sec_kdist_t  kdist_peer = p_gap_evt->params.auth_status.kdist_peer;
00001e  7a60              LDRB     r0,[r4,#9]
000020  9006              STR      r0,[sp,#0x18]
;;;251    
;;;252        ble_conn_state_user_flag_set(p_gap_evt->conn_handle, m_flag_sec_proc, false);
000022  8820              LDRH     r0,[r4,#0]
000024  2200              MOVS     r2,#0
000026  4923              LDR      r1,|L3.180|
000028  7809              LDRB     r1,[r1,#0]  ; m_flag_sec_proc
00002a  f7fffffe          BL       ble_conn_state_user_flag_set
;;;253    
;;;254        if (role == BLE_GAP_ROLE_INVALID)
00002e  b917              CBNZ     r7,|L3.54|
                  |L3.48|
;;;255        {
;;;256            /* Unlikely, but maybe possible? */
;;;257            return;
;;;258        }
;;;259    
;;;260        if (p_gap_evt->params.auth_status.bonded)
;;;261        {
;;;262    
;;;263            err_code = pdb_write_buf_store(peer_id, PM_PEER_DATA_ID_BONDING);
;;;264            if (err_code != NRF_SUCCESS)
;;;265            {
;;;266                /* Unexpected */
;;;267                smd_evt_t error_evt;
;;;268    
;;;269                error_evt.evt_id                            = SMD_EVT_ERROR_BONDING_INFO;
;;;270                error_evt.conn_handle                       = p_gap_evt->conn_handle;
;;;271                error_evt.params.error_bonding_info.peer_id = peer_id;
;;;272                error_evt.params.error_bonding_info.error   = err_code;
;;;273    
;;;274                evt_send(&error_evt);
;;;275            }
;;;276    
;;;277        }
;;;278        else if (ble_conn_state_user_flag_get(p_gap_evt->conn_handle, m_flag_sec_proc_new_peer))
;;;279        {
;;;280            ret_code_t err_code_free = im_peer_free(peer_id);
;;;281            UNUSED_VARIABLE(err_code_free); // Errors can be safely ignored.
;;;282        }
;;;283    
;;;284        smd_evt_t pairing_success_evt;
;;;285    
;;;286        pairing_success_evt.evt_id                            = SMD_EVT_PAIRING_SUCCESS;
;;;287        pairing_success_evt.conn_handle                       = p_gap_evt->conn_handle;
;;;288        pairing_success_evt.params.pairing_success.bonded     = p_gap_evt->params.auth_status.bonded;
;;;289        pairing_success_evt.params.pairing_success.mitm       = p_gap_evt->params.auth_status.sm1_levels.lv3;
;;;290        pairing_success_evt.params.pairing_success.kdist_own  = kdist_own;
;;;291        pairing_success_evt.params.pairing_success.kdist_peer = kdist_peer;
;;;292    
;;;293        evt_send(&pairing_success_evt);
;;;294        return;
;;;295    }
000030  b008              ADD      sp,sp,#0x20
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L3.54|
000036  7960              LDRB     r0,[r4,#5]            ;260
000038  f3c00080          UBFX     r0,r0,#2,#1           ;260
00003c  b190              CBZ      r0,|L3.100|
00003e  2107              MOVS     r1,#7                 ;263
000040  4630              MOV      r0,r6                 ;263
000042  f7fffffe          BL       pdb_write_buf_store
000046  4605              MOV      r5,r0                 ;263
000048  b1bd              CBZ      r5,|L3.122|
00004a  2008              MOVS     r0,#8                 ;269
00004c  f88d0000          STRB     r0,[sp,#0]            ;269
000050  8820              LDRH     r0,[r4,#0]            ;270
000052  f8ad0002          STRH     r0,[sp,#2]            ;270
000056  f8ad6004          STRH     r6,[sp,#4]            ;271
00005a  9502              STR      r5,[sp,#8]            ;272
00005c  4668              MOV      r0,sp                 ;274
00005e  f7fffffe          BL       evt_send
000062  e00a              B        |L3.122|
                  |L3.100|
000064  8820              LDRH     r0,[r4,#0]            ;278
000066  4914              LDR      r1,|L3.184|
000068  7809              LDRB     r1,[r1,#0]            ;278  ; m_flag_sec_proc_new_peer
00006a  f7fffffe          BL       ble_conn_state_user_flag_get
00006e  b120              CBZ      r0,|L3.122|
000070  4630              MOV      r0,r6                 ;280
000072  f7fffffe          BL       im_peer_free
000076  4680              MOV      r8,r0                 ;280
000078  bf00              NOP                            ;282
                  |L3.122|
00007a  2003              MOVS     r0,#3                 ;286
00007c  f88d000c          STRB     r0,[sp,#0xc]          ;286
000080  8820              LDRH     r0,[r4,#0]            ;287
000082  f8ad000e          STRH     r0,[sp,#0xe]          ;287
000086  7960              LDRB     r0,[r4,#5]            ;288
000088  f3c00080          UBFX     r0,r0,#2,#1           ;288
00008c  f88d0010          STRB     r0,[sp,#0x10]         ;288
000090  79a0              LDRB     r0,[r4,#6]            ;289
000092  f3c00180          UBFX     r1,r0,#2,#1           ;289
000096  f88d1011          STRB     r1,[sp,#0x11]         ;289
00009a  f89d101c          LDRB     r1,[sp,#0x1c]         ;290
00009e  f88d1012          STRB     r1,[sp,#0x12]         ;290
0000a2  f89d1018          LDRB     r1,[sp,#0x18]         ;291
0000a6  f88d1013          STRB     r1,[sp,#0x13]         ;291
0000aa  a803              ADD      r0,sp,#0xc            ;293
0000ac  f7fffffe          BL       evt_send
0000b0  bf00              NOP                            ;294
0000b2  e7bd              B        |L3.48|
;;;296    
                          ENDP

                  |L3.180|
                          DCD      m_flag_sec_proc
                  |L3.184|
                          DCD      m_flag_sec_proc_new_peer

                          AREA ||i.conn_sec_update_process||, CODE, READONLY, ALIGN=2

                  conn_sec_update_process PROC
;;;463     */
;;;464    static void conn_sec_update_process(ble_gap_evt_t * p_gap_evt)
000000  b53e              PUSH     {r1-r5,lr}
;;;465    {
000002  4604              MOV      r4,r0
;;;466        if (ble_conn_state_encrypted(p_gap_evt->conn_handle))
000004  8820              LDRH     r0,[r4,#0]
000006  f7fffffe          BL       ble_conn_state_encrypted
00000a  b1d0              CBZ      r0,|L4.66|
;;;467        {
;;;468            if (!ble_conn_state_user_flag_get(p_gap_evt->conn_handle, m_flag_sec_proc_pairing))
00000c  8820              LDRH     r0,[r4,#0]
00000e  4910              LDR      r1,|L4.80|
000010  7809              LDRB     r1,[r1,#0]  ; m_flag_sec_proc_pairing
000012  f7fffffe          BL       ble_conn_state_user_flag_get
000016  b928              CBNZ     r0,|L4.36|
;;;469            {
;;;470                ble_conn_state_user_flag_set(p_gap_evt->conn_handle, m_flag_sec_proc, false);
000018  8820              LDRH     r0,[r4,#0]
00001a  2200              MOVS     r2,#0
00001c  490d              LDR      r1,|L4.84|
00001e  7809              LDRB     r1,[r1,#0]  ; m_flag_sec_proc
000020  f7fffffe          BL       ble_conn_state_user_flag_set
                  |L4.36|
;;;471            }
;;;472    
;;;473            smd_evt_t evt;
;;;474    
;;;475            evt.conn_handle = p_gap_evt->conn_handle;
000024  8820              LDRH     r0,[r4,#0]
000026  f8ad0002          STRH     r0,[sp,#2]
;;;476            evt.evt_id = SMD_EVT_LINK_ENCRYPTION_UPDATE;
00002a  2005              MOVS     r0,#5
00002c  f88d0000          STRB     r0,[sp,#0]
;;;477            evt.params.link_encryption_update.mitm_protected
000030  8820              LDRH     r0,[r4,#0]
000032  f7fffffe          BL       ble_conn_state_mitm_protected
000036  f88d0004          STRB     r0,[sp,#4]
;;;478                                    = ble_conn_state_mitm_protected(p_gap_evt->conn_handle);
;;;479            evt_send(&evt);
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       evt_send
;;;480        }
000040  e005              B        |L4.78|
                  |L4.66|
;;;481        else
;;;482        {
;;;483            encryption_failure(p_gap_evt->conn_handle,
000042  8820              LDRH     r0,[r4,#0]
000044  2201              MOVS     r2,#1
000046  f2410106          MOV      r1,#0x1006
00004a  f7fffffe          BL       encryption_failure
                  |L4.78|
;;;484                               PM_CONN_SEC_ERROR_PIN_OR_KEY_MISSING,
;;;485                               BLE_GAP_SEC_STATUS_SOURCE_REMOTE);
;;;486        }
;;;487    }
00004e  bd3e              POP      {r1-r5,pc}
;;;488    
                          ENDP

                  |L4.80|
                          DCD      m_flag_sec_proc_pairing
                  |L4.84|
                          DCD      m_flag_sec_proc

                          AREA ||i.disconnect_process||, CODE, READONLY, ALIGN=1

                  disconnect_process PROC
;;;417     */
;;;418    static void disconnect_process(ble_gap_evt_t * p_gap_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;419    {
000002  4604              MOV      r4,r0
;;;420        pm_sec_error_code_t error = (p_gap_evt->params.disconnected.reason
000004  7920              LDRB     r0,[r4,#4]
000006  283d              CMP      r0,#0x3d
000008  d102              BNE      |L5.16|
;;;421                                            == BLE_HCI_CONN_TERMINATED_DUE_TO_MIC_FAILURE)
;;;422                                    ? PM_CONN_SEC_ERROR_MIC_FAILURE : PM_CONN_SEC_ERROR_DISCONNECT;
00000a  f241003d          MOV      r0,#0x103d
00000e  e001              B        |L5.20|
                  |L5.16|
000010  f44f5088          MOV      r0,#0x1100
                  |L5.20|
000014  4605              MOV      r5,r0
;;;423    
;;;424        link_secure_failure(p_gap_evt->conn_handle, error, BLE_GAP_SEC_STATUS_SOURCE_LOCAL);
000016  8820              LDRH     r0,[r4,#0]
000018  2200              MOVS     r2,#0
00001a  4629              MOV      r1,r5
00001c  f7fffffe          BL       link_secure_failure
;;;425    }
000020  bd70              POP      {r4-r6,pc}
;;;426    
                          ENDP


                          AREA ||i.encryption_failure||, CODE, READONLY, ALIGN=2

                  encryption_failure PROC
;;;358     */
;;;359    static void encryption_failure(uint16_t            conn_handle,
000000  b5fe              PUSH     {r1-r7,lr}
;;;360                                   pm_sec_error_code_t error,
;;;361                                   uint8_t             error_src)
;;;362    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;363        smd_evt_t evt =
000008  4a09              LDR      r2,|L6.48|
00000a  ca07              LDM      r2,{r0-r2}
00000c  e88d0007          STM      sp,{r0-r2}
000010  f8ad4002          STRH     r4,[sp,#2]
000014  f8ad5004          STRH     r5,[sp,#4]
000018  f88d6006          STRB     r6,[sp,#6]
;;;364        {
;;;365            .evt_id = SMD_EVT_LINK_ENCRYPTION_FAILED,
;;;366            .conn_handle = conn_handle,
;;;367            .params =
;;;368            {
;;;369                .link_encryption_failed =
;;;370                {
;;;371                    .error     = error,
;;;372                    .error_src = error_src,
;;;373                }
;;;374            }
;;;375        };
;;;376    
;;;377        ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc, false);
00001c  2200              MOVS     r2,#0
00001e  4805              LDR      r0,|L6.52|
000020  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       ble_conn_state_user_flag_set
;;;378    
;;;379        evt_send(&evt);
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       evt_send
;;;380        return;
;;;381    }
00002e  bdfe              POP      {r1-r7,pc}
;;;382    
                          ENDP

                  |L6.48|
                          DCD      ||.constdata||+0x38
                  |L6.52|
                          DCD      m_flag_sec_proc

                          AREA ||i.evt_send||, CODE, READONLY, ALIGN=2

                  evt_send PROC
;;;50     
;;;51     static void evt_send(smd_evt_t * p_event)
000000  b570              PUSH     {r4-r6,lr}
;;;52     {
000002  4605              MOV      r5,r0
;;;53         for (uint32_t i = 0; i < SMD_EVENT_HANDLERS_CNT; i++)
000004  2400              MOVS     r4,#0
000006  e005              B        |L7.20|
                  |L7.8|
;;;54         {
;;;55             m_evt_handlers[i](p_event);
000008  4804              LDR      r0,|L7.28|
00000a  f8501024          LDR      r1,[r0,r4,LSL #2]
00000e  4628              MOV      r0,r5
000010  4788              BLX      r1
000012  1c64              ADDS     r4,r4,#1              ;53
                  |L7.20|
000014  2c02              CMP      r4,#2                 ;53
000016  d3f7              BCC      |L7.8|
;;;56         }
;;;57     }
000018  bd70              POP      {r4-r6,pc}
;;;58     
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      m_evt_handlers

                          AREA ||i.flag_id_init||, CODE, READONLY, ALIGN=1

                  flag_id_init PROC
;;;493     */
;;;494    static void flag_id_init(ble_conn_state_user_flag_id_t * p_flag_id)
000000  b510              PUSH     {r4,lr}
;;;495    {
000002  4604              MOV      r4,r0
;;;496        if (*p_flag_id == BLE_CONN_STATE_USER_FLAG_INVALID)
000004  7820              LDRB     r0,[r4,#0]
000006  2818              CMP      r0,#0x18
000008  d102              BNE      |L8.16|
;;;497        {
;;;498            *p_flag_id = ble_conn_state_user_flag_acquire();
00000a  f7fffffe          BL       ble_conn_state_user_flag_acquire
00000e  7020              STRB     r0,[r4,#0]
                  |L8.16|
;;;499        }
;;;500    }
000010  bd10              POP      {r4,pc}
;;;501    
                          ENDP


                          AREA ||i.link_secure_central||, CODE, READONLY, ALIGN=1

                  link_secure_central PROC
;;;755    
;;;756    static ret_code_t link_secure_central(uint16_t               conn_handle,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;757                                          ble_gap_sec_params_t * p_sec_params,
;;;758                                          bool                   force_repairing)
;;;759    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;760        ret_code_t           err_code;
;;;761        pm_peer_id_t         peer_id;
;;;762    
;;;763        if (p_sec_params == NULL)
00000a  b926              CBNZ     r6,|L9.22|
;;;764        {
;;;765            return sd_ble_gap_authenticate(conn_handle, NULL);
00000c  2100              MOVS     r1,#0
00000e  4638              MOV      r0,r7
000010  df7e              SVC      #0x7e
                  |L9.18|
;;;766        }
;;;767    
;;;768        pm_conn_sec_procedure_t procedure = p_sec_params->bond ? PM_LINK_SECURED_PROCEDURE_BONDING
;;;769                                                               : PM_LINK_SECURED_PROCEDURE_PAIRING;
;;;770    
;;;771        peer_id = im_peer_id_get_by_conn_handle(conn_handle);
;;;772    
;;;773        if (peer_id != PM_PEER_ID_INVALID)
;;;774        {
;;;775            // There is already data in flash for this peer.
;;;776            err_code = link_secure_central_existing_peer(conn_handle,
;;;777                                                         p_sec_params,
;;;778                                                         force_repairing,
;;;779                                                         peer_id,
;;;780                                                         &procedure);
;;;781        }
;;;782        else if (p_sec_params->bond)
;;;783        {
;;;784            // New peer is required.
;;;785            err_code = link_secure_central_new_peer(conn_handle, p_sec_params);
;;;786        }
;;;787        else
;;;788        {
;;;789            // No bonding, only pairing.
;;;790            err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
;;;791    
;;;792            sec_proc_start(conn_handle, peer_id, err_code == NRF_SUCCESS, true, false);
;;;793        }
;;;794    
;;;795        if (err_code == NRF_SUCCESS)
;;;796        {
;;;797            sec_start_send(conn_handle, procedure);
;;;798        }
;;;799    
;;;800        return err_code;
;;;801    }
000012  e8bd81fc          POP      {r2-r8,pc}
                  |L9.22|
000016  7830              LDRB     r0,[r6,#0]            ;768
000018  f0000001          AND      r0,r0,#1              ;768
00001c  b108              CBZ      r0,|L9.34|
00001e  2001              MOVS     r0,#1                 ;768
000020  e000              B        |L9.36|
                  |L9.34|
000022  2002              MOVS     r0,#2                 ;769
                  |L9.36|
000024  9001              STR      r0,[sp,#4]            ;769
000026  4638              MOV      r0,r7                 ;771
000028  f7fffffe          BL       im_peer_id_get_by_conn_handle
00002c  4605              MOV      r5,r0                 ;771
00002e  f64f70ff          MOV      r0,#0xffff            ;773
000032  4285              CMP      r5,r0                 ;773
000034  d009              BEQ      |L9.74|
000036  a801              ADD      r0,sp,#4              ;776
000038  462b              MOV      r3,r5                 ;776
00003a  4642              MOV      r2,r8                 ;776
00003c  4631              MOV      r1,r6                 ;776
00003e  9000              STR      r0,[sp,#0]            ;776
000040  4638              MOV      r0,r7                 ;776
000042  f7fffffe          BL       link_secure_central_existing_peer
000046  4604              MOV      r4,r0                 ;776
000048  e019              B        |L9.126|
                  |L9.74|
00004a  7830              LDRB     r0,[r6,#0]            ;782
00004c  f0000001          AND      r0,r0,#1              ;782
000050  b128              CBZ      r0,|L9.94|
000052  4631              MOV      r1,r6                 ;785
000054  4638              MOV      r0,r7                 ;785
000056  f7fffffe          BL       link_secure_central_new_peer
00005a  4604              MOV      r4,r0                 ;785
00005c  e00f              B        |L9.126|
                  |L9.94|
00005e  4631              MOV      r1,r6                 ;790
000060  4638              MOV      r0,r7                 ;790
000062  df7e              SVC      #0x7e                 ;790
000064  4604              MOV      r4,r0                 ;790
000066  2000              MOVS     r0,#0                 ;792
000068  9000              STR      r0,[sp,#0]            ;792
00006a  b90c              CBNZ     r4,|L9.112|
00006c  2001              MOVS     r0,#1                 ;792
00006e  e000              B        |L9.114|
                  |L9.112|
000070  2000              MOVS     r0,#0                 ;792
                  |L9.114|
000072  4602              MOV      r2,r0                 ;792
000074  2301              MOVS     r3,#1                 ;792
000076  4629              MOV      r1,r5                 ;792
000078  4638              MOV      r0,r7                 ;792
00007a  f7fffffe          BL       sec_proc_start
                  |L9.126|
00007e  b924              CBNZ     r4,|L9.138|
000080  f89d1004          LDRB     r1,[sp,#4]            ;797
000084  4638              MOV      r0,r7                 ;797
000086  f7fffffe          BL       sec_start_send
                  |L9.138|
00008a  4620              MOV      r0,r4                 ;800
00008c  e7c1              B        |L9.18|
;;;802    
                          ENDP


                          AREA ||i.link_secure_central_existing_peer||, CODE, READONLY, ALIGN=1

                  link_secure_central_existing_peer PROC
;;;633    
;;;634    static ret_code_t link_secure_central_existing_peer(uint16_t                  conn_handle,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;635                                                        ble_gap_sec_params_t    * p_sec_params,
;;;636                                                        bool                      force_repairing,
;;;637                                                        pm_peer_id_t              peer_id,
;;;638                                                        pm_conn_sec_procedure_t * procedure)
;;;639    {
000004  b085              SUB      sp,sp,#0x14
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
00000c  f8dd9048          LDR      r9,[sp,#0x48]
;;;640        pm_peer_data_flash_t      peer_data;
;;;641        pm_peer_data_t            dummy_peer_data;
;;;642        ret_code_t                err_code;
;;;643        ble_gap_enc_key_t const * p_existing_key = NULL;
000010  2500              MOVS     r5,#0
;;;644        bool                      lesc = false;
000012  46aa              MOV      r10,r5
;;;645    
;;;646        err_code = pdb_peer_data_ptr_get(peer_id, PM_PEER_DATA_ID_BONDING, &peer_data);
000014  aa03              ADD      r2,sp,#0xc
000016  2107              MOVS     r1,#7
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       pdb_peer_data_ptr_get
00001e  4604              MOV      r4,r0
;;;647    
;;;648        if (err_code == NRF_SUCCESS)
000020  b96c              CBNZ     r4,|L10.62|
;;;649        {
;;;650            // Use peer's key since they are peripheral.
;;;651            p_existing_key = &(peer_data.p_bonding_data->peer_ltk);
000022  9804              LDR      r0,[sp,#0x10]
000024  f1000518          ADD      r5,r0,#0x18
;;;652    
;;;653            lesc = peer_data.p_bonding_data->own_ltk.enc_info.lesc;
000028  9804              LDR      r0,[sp,#0x10]
00002a  f8900044          LDRB     r0,[r0,#0x44]
00002e  f0000a01          AND      r10,r0,#1
;;;654            if  (lesc) // LESC was used during bonding.
000032  f1ba0f00          CMP      r10,#0
000036  d002              BEQ      |L10.62|
;;;655            {
;;;656                // For LESC, always use own key.
;;;657                p_existing_key = &(peer_data.p_bonding_data->own_ltk);
000038  9804              LDR      r0,[sp,#0x10]
00003a  f1000534          ADD      r5,r0,#0x34
                  |L10.62|
;;;658            }
;;;659        }
;;;660    
;;;661        if     (!force_repairing
00003e  f1b80f00          CMP      r8,#0
000042  d113              BNE      |L10.108|
;;;662             && (err_code == NRF_SUCCESS)
000044  b994              CBNZ     r4,|L10.108|
;;;663             && (p_existing_key != NULL)
000046  b18d              CBZ      r5,|L10.108|
;;;664             && (lesc || im_master_id_is_valid(&(p_existing_key->master_id)))) /* There is a valid LTK stored. */
000048  f1ba0f00          CMP      r10,#0
00004c  d104              BNE      |L10.88|
00004e  f1050012          ADD      r0,r5,#0x12
000052  f7fffffe          BL       im_master_id_is_valid
000056  b148              CBZ      r0,|L10.108|
                  |L10.88|
;;;665             //&& (p_existing_key->enc_info.auth >= p_sec_params->mitm)          /* The requested MITM security is at or below the existing level. */
;;;666             //&& (!p_sec_params->mitm || (lesc >= p_sec_params->lesc)))         /* The requested LESC security is at or below the existing level. We only care about LESC if MITM is required. */
;;;667        {
;;;668            err_code = sd_ble_gap_encrypt(conn_handle, &(p_existing_key->master_id), &(p_existing_key->enc_info));
000058  462a              MOV      r2,r5
00005a  f1050112          ADD      r1,r5,#0x12
00005e  9805              LDR      r0,[sp,#0x14]
000060  df85              SVC      #0x85
000062  4604              MOV      r4,r0
;;;669    
;;;670            *procedure = PM_LINK_SECURED_PROCEDURE_ENCRYPTION;
000064  2000              MOVS     r0,#0
000066  f8890000          STRB     r0,[r9,#0]
00006a  e027              B        |L10.188|
                  |L10.108|
;;;671        }
;;;672        else if ((err_code == NRF_SUCCESS) || (err_code == NRF_ERROR_NOT_FOUND))
00006c  b10c              CBZ      r4,|L10.114|
00006e  2c05              CMP      r4,#5
000070  d124              BNE      |L10.188|
                  |L10.114|
;;;673        {
;;;674            /* Re-pairing is needed, because there is no LTK available or the existing key is not
;;;675               secure enough */
;;;676            err_code = NRF_SUCCESS;
000072  2400              MOVS     r4,#0
;;;677    
;;;678            if (p_sec_params->bond)
000074  7838              LDRB     r0,[r7,#0]
000076  f0000001          AND      r0,r0,#1
00007a  b160              CBZ      r0,|L10.150|
;;;679            {
;;;680                err_code = pdb_write_buf_get(peer_id, PM_PEER_DATA_ID_BONDING, 1, &dummy_peer_data);
00007c  ab01              ADD      r3,sp,#4
00007e  2201              MOVS     r2,#1
000080  2107              MOVS     r1,#7
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       pdb_write_buf_get
000088  4604              MOV      r4,r0
;;;681                if (err_code == NRF_SUCCESS)
00008a  b924              CBNZ     r4,|L10.150|
;;;682                {
;;;683                    err_code = pdb_write_buf_store_prepare(peer_id, PM_PEER_DATA_ID_BONDING);
00008c  2107              MOVS     r1,#7
00008e  4630              MOV      r0,r6
000090  f7fffffe          BL       pdb_write_buf_store_prepare
000094  4604              MOV      r4,r0
                  |L10.150|
;;;684                }
;;;685            }
;;;686    
;;;687            if (err_code == NRF_SUCCESS)
000096  b91c              CBNZ     r4,|L10.160|
;;;688            {
;;;689                err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
000098  4639              MOV      r1,r7
00009a  9805              LDR      r0,[sp,#0x14]
00009c  df7e              SVC      #0x7e
00009e  4604              MOV      r4,r0
                  |L10.160|
;;;690            }
;;;691    
;;;692            if (err_code != NRF_SUCCESS)
0000a0  b164              CBZ      r4,|L10.188|
;;;693            {
;;;694                ret_code_t err_code_release = pdb_write_buf_release(peer_id, PM_PEER_DATA_ID_BONDING);
0000a2  2107              MOVS     r1,#7
0000a4  4630              MOV      r0,r6
0000a6  f7fffffe          BL       pdb_write_buf_release
0000aa  4683              MOV      r11,r0
;;;695                if ((err_code_release != NRF_SUCCESS) && (err_code_release != NRF_ERROR_NOT_FOUND))
0000ac  f1bb0f00          CMP      r11,#0
0000b0  d003              BEQ      |L10.186|
0000b2  f1bb0f05          CMP      r11,#5
0000b6  d000              BEQ      |L10.186|
;;;696                {
;;;697                    err_code = NRF_ERROR_INTERNAL;
0000b8  2403              MOVS     r4,#3
                  |L10.186|
;;;698                }
;;;699            }
0000ba  bf00              NOP      
                  |L10.188|
;;;700        }
;;;701    
;;;702        sec_proc_start(conn_handle,
0000bc  2000              MOVS     r0,#0
0000be  9000              STR      r0,[sp,#0]
0000c0  f8990000          LDRB     r0,[r9,#0]
0000c4  b108              CBZ      r0,|L10.202|
0000c6  2001              MOVS     r0,#1
0000c8  e000              B        |L10.204|
                  |L10.202|
0000ca  2000              MOVS     r0,#0
                  |L10.204|
0000cc  4603              MOV      r3,r0
0000ce  b90c              CBNZ     r4,|L10.212|
0000d0  2001              MOVS     r0,#1
0000d2  e000              B        |L10.214|
                  |L10.212|
0000d4  2000              MOVS     r0,#0
                  |L10.214|
0000d6  4602              MOV      r2,r0
0000d8  4631              MOV      r1,r6
0000da  9805              LDR      r0,[sp,#0x14]
0000dc  f7fffffe          BL       sec_proc_start
;;;703                       peer_id,
;;;704                       err_code == NRF_SUCCESS,
;;;705                       *procedure != PM_LINK_SECURED_PROCEDURE_ENCRYPTION,
;;;706                       false);
;;;707    
;;;708        return err_code;
0000e0  4620              MOV      r0,r4
;;;709    }
0000e2  b009              ADD      sp,sp,#0x24
0000e4  e8bd8ff0          POP      {r4-r11,pc}
;;;710    
                          ENDP


                          AREA ||i.link_secure_central_new_peer||, CODE, READONLY, ALIGN=1

                  link_secure_central_new_peer PROC
;;;711    
;;;712    static ret_code_t link_secure_central_new_peer(uint16_t               conn_handle,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;713                                                   ble_gap_sec_params_t * p_sec_params)
;;;714    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;715        pm_peer_id_t    peer_id = pdb_peer_allocate();
000008  f7fffffe          BL       pdb_peer_allocate
00000c  4605              MOV      r5,r0
;;;716        pm_peer_data_t  dummy_peer_data;
;;;717        ret_code_t      err_code;
;;;718    
;;;719        if (peer_id != PM_PEER_ID_INVALID)
00000e  f64f70ff          MOV      r0,#0xffff
000012  4285              CMP      r5,r0
000014  d01c              BEQ      |L11.80|
;;;720        {
;;;721            err_code = pdb_write_buf_get(peer_id, PM_PEER_DATA_ID_BONDING, 1, &dummy_peer_data);
000016  ab01              ADD      r3,sp,#4
000018  2201              MOVS     r2,#1
00001a  2107              MOVS     r1,#7
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       pdb_write_buf_get
000022  4604              MOV      r4,r0
;;;722            if (err_code == NRF_SUCCESS)
000024  b924              CBNZ     r4,|L11.48|
;;;723            {
;;;724                err_code = pdb_write_buf_store_prepare(peer_id, PM_PEER_DATA_ID_BONDING);
000026  2107              MOVS     r1,#7
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       pdb_write_buf_store_prepare
00002e  4604              MOV      r4,r0
                  |L11.48|
;;;725            }
;;;726    
;;;727            if (err_code == NRF_SUCCESS)
000030  b91c              CBNZ     r4,|L11.58|
;;;728            {
;;;729                err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
000032  4641              MOV      r1,r8
000034  4638              MOV      r0,r7
000036  df7e              SVC      #0x7e
000038  4604              MOV      r4,r0
                  |L11.58|
;;;730            }
;;;731    
;;;732            if (err_code != NRF_SUCCESS)
00003a  b154              CBZ      r4,|L11.82|
;;;733            {
;;;734                ret_code_t err_code_free = pdb_write_buf_release(peer_id, PM_PEER_DATA_ID_BONDING);
00003c  2107              MOVS     r1,#7
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       pdb_write_buf_release
000044  4606              MOV      r6,r0
;;;735                if ((err_code_free != NRF_SUCCESS) && (err_code_free != NRF_ERROR_NOT_FOUND))
000046  b116              CBZ      r6,|L11.78|
000048  2e05              CMP      r6,#5
00004a  d000              BEQ      |L11.78|
;;;736                {
;;;737                    err_code = NRF_ERROR_INTERNAL;
00004c  2403              MOVS     r4,#3
                  |L11.78|
;;;738                }
;;;739            }
00004e  e000              B        |L11.82|
                  |L11.80|
;;;740        }
;;;741        else
;;;742        {
;;;743            err_code = NRF_ERROR_INTERNAL;
000050  2403              MOVS     r4,#3
                  |L11.82|
;;;744        }
;;;745    
;;;746        sec_proc_start(conn_handle,
000052  f64f70ff          MOV      r0,#0xffff
000056  4285              CMP      r5,r0
000058  d001              BEQ      |L11.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L11.96|
                  |L11.94|
00005e  2000              MOVS     r0,#0
                  |L11.96|
000060  9000              STR      r0,[sp,#0]
000062  b90c              CBNZ     r4,|L11.104|
000064  2001              MOVS     r0,#1
000066  e000              B        |L11.106|
                  |L11.104|
000068  2000              MOVS     r0,#0
                  |L11.106|
00006a  4602              MOV      r2,r0
00006c  2301              MOVS     r3,#1
00006e  4629              MOV      r1,r5
000070  4638              MOV      r0,r7
000072  f7fffffe          BL       sec_proc_start
;;;747                       peer_id,
;;;748                       err_code == NRF_SUCCESS,
;;;749                       true,
;;;750                       peer_id != PM_PEER_ID_INVALID);
;;;751    
;;;752        return err_code;
000076  4620              MOV      r0,r4
;;;753    }
000078  e8bd83fe          POP      {r1-r9,pc}
;;;754    
                          ENDP


                          AREA ||i.link_secure_failure||, CODE, READONLY, ALIGN=2

                  link_secure_failure PROC
;;;390     */
;;;391    static void link_secure_failure(uint16_t            conn_handle,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;392                                    pm_sec_error_code_t error,
;;;393                                    uint8_t             error_src)
;;;394    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;395        if (ble_conn_state_user_flag_get(conn_handle, m_flag_sec_proc))
00000a  4811              LDR      r0,|L12.80|
00000c  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       ble_conn_state_user_flag_get
000014  b1d0              CBZ      r0,|L12.76|
;;;396        {
;;;397            pm_peer_id_t  peer_id = im_peer_id_get_by_conn_handle(conn_handle);
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       im_peer_id_get_by_conn_handle
00001c  4606              MOV      r6,r0
;;;398    
;;;399            if (peer_id != PM_PEER_ID_INVALID)
00001e  f64f70ff          MOV      r0,#0xffff
000022  4286              CMP      r6,r0
000024  d011              BEQ      |L12.74|
;;;400            {
;;;401                if (ble_conn_state_user_flag_get(conn_handle, m_flag_sec_proc_pairing))
000026  480b              LDR      r0,|L12.84|
000028  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_pairing
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       ble_conn_state_user_flag_get
000030  b130              CBZ      r0,|L12.64|
;;;402                {
;;;403                    pairing_failure(conn_handle, peer_id, error, error_src);
000032  462b              MOV      r3,r5
000034  4622              MOV      r2,r4
000036  4631              MOV      r1,r6
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       pairing_failure
00003e  e004              B        |L12.74|
                  |L12.64|
;;;404                }
;;;405                else
;;;406                {
;;;407                    encryption_failure(conn_handle, error, error_src);
000040  462a              MOV      r2,r5
000042  4621              MOV      r1,r4
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       encryption_failure
                  |L12.74|
;;;408                }
;;;409            }
;;;410        }
00004a  bf00              NOP      
                  |L12.76|
;;;411    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;412    
                          ENDP

                  |L12.80|
                          DCD      m_flag_sec_proc
                  |L12.84|
                          DCD      m_flag_sec_proc_pairing

                          AREA ||i.link_secure_peripheral||, CODE, READONLY, ALIGN=1

                  link_secure_peripheral PROC
;;;803    
;;;804    static ret_code_t link_secure_peripheral(uint16_t conn_handle, ble_gap_sec_params_t * p_sec_params)
000000  b570              PUSH     {r4-r6,lr}
;;;805    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;806        // This should never happen for a peripheral.
;;;807        NRF_PM_DEBUG_CHECK(p_sec_params != NULL);
;;;808    
;;;809        // VERIFY_PARAM_NOT_NULL(p_sec_params);
;;;810    
;;;811        ret_code_t err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  df7e              SVC      #0x7e
00000c  4606              MOV      r6,r0
;;;812    
;;;813        return err_code;
00000e  4630              MOV      r0,r6
;;;814    }
000010  bd70              POP      {r4-r6,pc}
;;;815    
                          ENDP


                          AREA ||i.pairing_failure||, CODE, READONLY, ALIGN=2

                  pairing_failure PROC
;;;304     */
;;;305    static void pairing_failure(uint16_t            conn_handle,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;306                                pm_peer_id_t        peer_id,
;;;307                                pm_sec_error_code_t error,
;;;308                                uint8_t             error_src)
;;;309    {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
00000c  4698              MOV      r8,r3
;;;310        ret_code_t err_code = NRF_SUCCESS;
00000e  2500              MOVS     r5,#0
;;;311    
;;;312        smd_evt_t evt =
000010  4a19              LDR      r2,|L14.120|
000012  ca07              LDM      r2,{r0-r2}
000014  e9cd1204          STRD     r1,r2,[sp,#0x10]
000018  9003              STR      r0,[sp,#0xc]
00001a  f8ad400e          STRH     r4,[sp,#0xe]
00001e  f8ad7010          STRH     r7,[sp,#0x10]
000022  f88d8012          STRB     r8,[sp,#0x12]
;;;313        {
;;;314            .evt_id      = SMD_EVT_PAIRING_FAIL,
;;;315            .conn_handle = conn_handle,
;;;316            .params =
;;;317            {
;;;318                .pairing_failed =
;;;319                {
;;;320                    .error     = error,
;;;321                    .error_src = error_src,
;;;322                }
;;;323            }
;;;324        };
;;;325    
;;;326        if (ble_conn_state_user_flag_get(conn_handle, m_flag_sec_proc_new_peer))
000026  4815              LDR      r0,|L14.124|
000028  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_new_peer
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       ble_conn_state_user_flag_get
000030  b120              CBZ      r0,|L14.60|
;;;327        {
;;;328            // The peer_id was created during the procedure, and should be freed, because no data is
;;;329            // stored under it.
;;;330            err_code = im_peer_free(peer_id);  // Attempt to free allocated peer.
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       im_peer_free
000038  4605              MOV      r5,r0
;;;331            UNUSED_VARIABLE(err_code);
00003a  e011              B        |L14.96|
                  |L14.60|
;;;332        }
;;;333        else
;;;334        {
;;;335            err_code = pdb_write_buf_release(peer_id, PM_PEER_DATA_ID_BONDING);
00003c  2107              MOVS     r1,#7
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       pdb_write_buf_release
000044  4605              MOV      r5,r0
;;;336            if ((err_code != NRF_SUCCESS) && (err_code == NRF_ERROR_NOT_FOUND /* No buffer was allocated */))
000046  b15d              CBZ      r5,|L14.96|
000048  2d05              CMP      r5,#5
00004a  d109              BNE      |L14.96|
;;;337            {
;;;338                smd_evt_t error_evt;
;;;339                error_evt.evt_id = SMD_EVT_ERROR_UNEXPECTED;
00004c  2009              MOVS     r0,#9
00004e  f88d0000          STRB     r0,[sp,#0]
;;;340                error_evt.conn_handle = conn_handle;
000052  f8ad4002          STRH     r4,[sp,#2]
;;;341                error_evt.params.error_unexpected.error = err_code;
000056  9501              STR      r5,[sp,#4]
;;;342                evt_send(&error_evt);
000058  4668              MOV      r0,sp
00005a  f7fffffe          BL       evt_send
;;;343            }
00005e  bf00              NOP      
                  |L14.96|
;;;344        }
;;;345    
;;;346        ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc, false);
000060  2200              MOVS     r2,#0
000062  4807              LDR      r0,|L14.128|
000064  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       ble_conn_state_user_flag_set
;;;347    
;;;348        evt_send(&evt);
00006c  a803              ADD      r0,sp,#0xc
00006e  f7fffffe          BL       evt_send
;;;349        return;
;;;350    }
000072  b006              ADD      sp,sp,#0x18
000074  e8bd81f0          POP      {r4-r8,pc}
;;;351    
                          ENDP

                  |L14.120|
                          DCD      ||.constdata||+0x2c
                  |L14.124|
                          DCD      m_flag_sec_proc_new_peer
                  |L14.128|
                          DCD      m_flag_sec_proc

                          AREA ||i.sec_info_request_process||, CODE, READONLY, ALIGN=1

                  sec_info_request_process PROC
;;;149     */
;;;150    static void sec_info_request_process(ble_gap_evt_t * p_gap_evt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;151    {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
;;;152        ret_code_t                 err_code;
;;;153        ble_gap_enc_info_t const * p_enc_info = NULL;
000008  f04f0800          MOV      r8,#0
;;;154        pm_peer_data_flash_t       peer_data;
;;;155        pm_peer_id_t               peer_id = im_peer_id_get_by_master_id(&p_gap_evt->params.sec_info_request.master_id);
00000c  f104000c          ADD      r0,r4,#0xc
000010  f7fffffe          BL       im_peer_id_get_by_master_id
000014  4606              MOV      r6,r0
;;;156        smd_evt_t evt;
;;;157    
;;;158        evt.conn_handle = p_gap_evt->conn_handle;
000016  8820              LDRH     r0,[r4,#0]
000018  f8ad0006          STRH     r0,[sp,#6]
;;;159    
;;;160        if (peer_id == PM_PEER_ID_INVALID)
00001c  f64f70ff          MOV      r0,#0xffff
000020  4286              CMP      r6,r0
000022  d103              BNE      |L15.44|
;;;161        {
;;;162            peer_id = im_peer_id_get_by_conn_handle(p_gap_evt->conn_handle);
000024  8820              LDRH     r0,[r4,#0]
000026  f7fffffe          BL       im_peer_id_get_by_conn_handle
00002a  4606              MOV      r6,r0
                  |L15.44|
;;;163        }
;;;164    
;;;165        if (peer_id != PM_PEER_ID_INVALID)
00002c  f64f70ff          MOV      r0,#0xffff
000030  4286              CMP      r6,r0
000032  d016              BEQ      |L15.98|
;;;166        {
;;;167            err_code = pdb_peer_data_ptr_get(peer_id, PM_PEER_DATA_ID_BONDING, &peer_data);
000034  aa04              ADD      r2,sp,#0x10
000036  2107              MOVS     r1,#7
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       pdb_peer_data_ptr_get
00003e  4605              MOV      r5,r0
;;;168    
;;;169            if (err_code == NRF_SUCCESS)
000040  b97d              CBNZ     r5,|L15.98|
;;;170            {
;;;171                // There is stored bonding data for this peer.
;;;172                ble_gap_enc_key_t const * p_existing_key = &peer_data.p_bonding_data->own_ltk;
000042  9805              LDR      r0,[sp,#0x14]
000044  f1000734          ADD      r7,r0,#0x34
;;;173    
;;;174                if (   p_existing_key->enc_info.lesc
000048  7c38              LDRB     r0,[r7,#0x10]
00004a  f0000001          AND      r0,r0,#1
00004e  b930              CBNZ     r0,|L15.94|
;;;175                    || (im_master_ids_compare(&p_existing_key->master_id,
000050  f104010c          ADD      r1,r4,#0xc
000054  f1070012          ADD      r0,r7,#0x12
000058  f7fffffe          BL       im_master_ids_compare
00005c  b100              CBZ      r0,|L15.96|
                  |L15.94|
;;;176                                              &p_gap_evt->params.sec_info_request.master_id)))
;;;177                {
;;;178                    p_enc_info = &p_existing_key->enc_info;
00005e  46b8              MOV      r8,r7
                  |L15.96|
;;;179                }
;;;180            }
000060  bf00              NOP      
                  |L15.98|
;;;181        }
;;;182    
;;;183        // All return values from the following can be safely ignored.
;;;184        err_code = sd_ble_gap_sec_info_reply(p_gap_evt->conn_handle, p_enc_info, NULL, NULL);
000062  8820              LDRH     r0,[r4,#0]
000064  2300              MOVS     r3,#0
000066  461a              MOV      r2,r3
000068  4641              MOV      r1,r8
00006a  df86              SVC      #0x86
00006c  4605              MOV      r5,r0
;;;185    
;;;186        if (err_code != NRF_SUCCESS)
00006e  b13d              CBZ      r5,|L15.128|
;;;187        {
;;;188            evt.evt_id                        = SMD_EVT_ERROR_UNEXPECTED;
000070  2009              MOVS     r0,#9
000072  f88d0004          STRB     r0,[sp,#4]
;;;189            evt.params.error_unexpected.error = err_code;
000076  9502              STR      r5,[sp,#8]
;;;190    
;;;191            evt_send(&evt);
000078  a801              ADD      r0,sp,#4
00007a  f7fffffe          BL       evt_send
00007e  e028              B        |L15.210|
                  |L15.128|
;;;192        }
;;;193        else if (p_enc_info == NULL)
000080  f1b80f00          CMP      r8,#0
000084  d115              BNE      |L15.178|
;;;194        {
;;;195            evt.evt_id                                  = SMD_EVT_LINK_ENCRYPTION_FAILED;
000086  2006              MOVS     r0,#6
000088  f88d0004          STRB     r0,[sp,#4]
;;;196            evt.params.link_encryption_failed.error     = PM_CONN_SEC_ERROR_PIN_OR_KEY_MISSING;
00008c  f2410006          MOV      r0,#0x1006
000090  f8ad0008          STRH     r0,[sp,#8]
;;;197            evt.params.link_encryption_failed.error_src = BLE_GAP_SEC_STATUS_SOURCE_LOCAL;
000094  2100              MOVS     r1,#0
000096  f88d100a          STRB     r1,[sp,#0xa]
;;;198    
;;;199            evt_send(&evt);
00009a  a801              ADD      r0,sp,#4
00009c  f7fffffe          BL       evt_send
;;;200    
;;;201            sec_proc_start(p_gap_evt->conn_handle, peer_id, false, false, false);
0000a0  2000              MOVS     r0,#0
0000a2  9000              STR      r0,[sp,#0]
0000a4  8820              LDRH     r0,[r4,#0]
0000a6  2300              MOVS     r3,#0
0000a8  461a              MOV      r2,r3
0000aa  4631              MOV      r1,r6
0000ac  f7fffffe          BL       sec_proc_start
0000b0  e00f              B        |L15.210|
                  |L15.178|
;;;202        }
;;;203        else
;;;204        {
;;;205            sec_start_send(p_gap_evt->conn_handle, PM_LINK_SECURED_PROCEDURE_ENCRYPTION);
0000b2  8820              LDRH     r0,[r4,#0]
0000b4  2100              MOVS     r1,#0
0000b6  f7fffffe          BL       sec_start_send
;;;206    
;;;207            sec_proc_start(p_gap_evt->conn_handle, peer_id, err_code == NRF_SUCCESS, false, false);
0000ba  2000              MOVS     r0,#0
0000bc  9000              STR      r0,[sp,#0]
0000be  b90d              CBNZ     r5,|L15.196|
0000c0  2101              MOVS     r1,#1
0000c2  e000              B        |L15.198|
                  |L15.196|
0000c4  2100              MOVS     r1,#0
                  |L15.198|
0000c6  460a              MOV      r2,r1
0000c8  8820              LDRH     r0,[r4,#0]
0000ca  2300              MOVS     r3,#0
0000cc  4631              MOV      r1,r6
0000ce  f7fffffe          BL       sec_proc_start
                  |L15.210|
;;;208        }
;;;209    
;;;210    
;;;211        return;
;;;212    }
0000d2  b006              ADD      sp,sp,#0x18
0000d4  e8bd81f0          POP      {r4-r8,pc}
;;;213    
                          ENDP


                          AREA ||i.sec_params_request_process||, CODE, READONLY, ALIGN=1

                  sec_params_request_process PROC
;;;95      */
;;;96     static void sec_params_request_process(ble_gap_evt_t * p_gap_evt)
000000  b53e              PUSH     {r1-r5,lr}
;;;97     {
000002  4604              MOV      r4,r0
;;;98         smd_evt_t evt =
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
00000c  8820              LDRH     r0,[r4,#0]
00000e  f8ad0002          STRH     r0,[sp,#2]
;;;99         {
;;;100            .evt_id      = SMD_EVT_PARAMS_REQ,
;;;101            .conn_handle = p_gap_evt->conn_handle
;;;102        };
;;;103        evt_send(&evt);
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       evt_send
;;;104        return;
;;;105    }
000018  bd3e              POP      {r1-r5,pc}
;;;106    
                          ENDP


                          AREA ||i.sec_proc_start||, CODE, READONLY, ALIGN=2

                  sec_proc_start PROC
;;;115     */
;;;116    static void sec_proc_start(uint16_t     conn_handle,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;117                               pm_peer_id_t peer_id,
;;;118                               bool         success,
;;;119                               bool         pairing,
;;;120                               bool         new_peer_created)
;;;121    {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  9c08              LDR      r4,[sp,#0x20]
;;;122        ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc, success);
00000e  4632              MOV      r2,r6
000010  480f              LDR      r0,|L17.80|
000012  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
000014  4640              MOV      r0,r8
000016  f7fffffe          BL       ble_conn_state_user_flag_set
;;;123    
;;;124        if (success)
00001a  b18e              CBZ      r6,|L17.64|
;;;125        {
;;;126            ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc_pairing, pairing);
00001c  463a              MOV      r2,r7
00001e  480d              LDR      r0,|L17.84|
000020  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_pairing
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       ble_conn_state_user_flag_set
;;;127            ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc_new_peer, new_peer_created);
000028  4622              MOV      r2,r4
00002a  480b              LDR      r0,|L17.88|
00002c  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_new_peer
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       ble_conn_state_user_flag_set
;;;128    
;;;129            if (new_peer_created)
000034  b154              CBZ      r4,|L17.76|
;;;130            {
;;;131                im_new_peer_id(conn_handle, peer_id);
000036  4629              MOV      r1,r5
000038  4640              MOV      r0,r8
00003a  f7fffffe          BL       im_new_peer_id
00003e  e005              B        |L17.76|
                  |L17.64|
;;;132            }
;;;133        }
;;;134        else
;;;135        {
;;;136            if (new_peer_created)
000040  b124              CBZ      r4,|L17.76|
;;;137            {
;;;138                ret_code_t err_code = im_peer_free(peer_id); // Attempt to free allocated peer.
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       im_peer_free
000048  4681              MOV      r9,r0
;;;139                UNUSED_VARIABLE(err_code);
;;;140            }
00004a  bf00              NOP      
                  |L17.76|
;;;141        }
;;;142    }
00004c  e8bd87f0          POP      {r4-r10,pc}
;;;143    
                          ENDP

                  |L17.80|
                          DCD      m_flag_sec_proc
                  |L17.84|
                          DCD      m_flag_sec_proc_pairing
                  |L17.88|
                          DCD      m_flag_sec_proc_new_peer

                          AREA ||i.sec_request_process||, CODE, READONLY, ALIGN=2

                  sec_request_process PROC
;;;218     */
;;;219    static void sec_request_process(ble_gap_evt_t * p_gap_evt)
000000  b53e              PUSH     {r1-r5,lr}
;;;220    {
000002  4604              MOV      r4,r0
;;;221        smd_evt_t evt =
000004  4a0a              LDR      r2,|L18.48|
000006  ca07              LDM      r2,{r0-r2}
000008  e88d0007          STM      sp,{r0-r2}
00000c  8820              LDRH     r0,[r4,#0]
00000e  f8ad0002          STRH     r0,[sp,#2]
000012  7920              LDRB     r0,[r4,#4]
000014  f0000001          AND      r0,r0,#1
000018  f88d0004          STRB     r0,[sp,#4]
00001c  7920              LDRB     r0,[r4,#4]
00001e  f3c00140          UBFX     r1,r0,#1,#1
000022  f88d1005          STRB     r1,[sp,#5]
;;;222        {
;;;223            .evt_id = SMD_EVT_SLAVE_SECURITY_REQ,
;;;224            .conn_handle = p_gap_evt->conn_handle,
;;;225            .params =
;;;226            {
;;;227                .slave_security_req =
;;;228                {
;;;229                    .bond = p_gap_evt->params.sec_request.bond,
;;;230                    .mitm = p_gap_evt->params.sec_request.mitm,
;;;231                }
;;;232            }
;;;233        };
;;;234        evt_send(&evt);
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       evt_send
;;;235        return;
;;;236    }
00002c  bd3e              POP      {r1-r5,pc}
;;;237    
                          ENDP

00002e  0000              DCW      0x0000
                  |L18.48|
                          DCD      ||.constdata||+0x20

                          AREA ||i.sec_start_send||, CODE, READONLY, ALIGN=2

                  sec_start_send PROC
;;;59     
;;;60     static void sec_start_send(uint16_t conn_handle, pm_conn_sec_procedure_t procedure)
000000  b53e              PUSH     {r1-r5,lr}
;;;61     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;62         smd_evt_t evt =
000006  4a06              LDR      r2,|L19.32|
000008  ca07              LDM      r2,{r0-r2}
00000a  e88d0007          STM      sp,{r0-r2}
00000e  f8ad5002          STRH     r5,[sp,#2]
000012  f88d4004          STRB     r4,[sp,#4]
;;;63         {
;;;64             .evt_id      = SMD_EVT_SEC_PROCEDURE_START,
;;;65             .conn_handle = conn_handle,
;;;66             .params      = {.sec_procedure_start = {.procedure = procedure}}
;;;67         };
;;;68         evt_send(&evt);
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       evt_send
;;;69     }
00001c  bd3e              POP      {r1-r5,pc}
;;;70     
                          ENDP

00001e  0000              DCW      0x0000
                  |L19.32|
                          DCD      ||.constdata||+0x8

                          AREA ||i.smd_ble_evt_handler||, CODE, READONLY, ALIGN=1

                  smd_ble_evt_handler PROC
;;;838    
;;;839    void smd_ble_evt_handler(ble_evt_t * p_ble_evt)
000000  b510              PUSH     {r4,lr}
;;;840    {
000002  4604              MOV      r4,r0
;;;841        switch (p_ble_evt->header.evt_id)
000004  8820              LDRH     r0,[r4,#0]
000006  2819              CMP      r0,#0x19
000008  d01c              BEQ      |L20.68|
00000a  dc06              BGT      |L20.26|
00000c  2811              CMP      r0,#0x11
00000e  d009              BEQ      |L20.36|
000010  2813              CMP      r0,#0x13
000012  d00b              BEQ      |L20.44|
000014  2814              CMP      r0,#0x14
000016  d11d              BNE      |L20.84|
000018  e00c              B        |L20.52|
                  |L20.26|
00001a  281a              CMP      r0,#0x1a
00001c  d016              BEQ      |L20.76|
00001e  281e              CMP      r0,#0x1e
000020  d118              BNE      |L20.84|
000022  e00b              B        |L20.60|
                  |L20.36|
;;;842        {
;;;843            case BLE_GAP_EVT_DISCONNECTED:
;;;844                disconnect_process(&(p_ble_evt->evt.gap_evt));
000024  1d20              ADDS     r0,r4,#4
000026  f7fffffe          BL       disconnect_process
;;;845                break;
00002a  e013              B        |L20.84|
                  |L20.44|
;;;846    
;;;847            case BLE_GAP_EVT_SEC_PARAMS_REQUEST:
;;;848                sec_params_request_process(&(p_ble_evt->evt.gap_evt));
00002c  1d20              ADDS     r0,r4,#4
00002e  f7fffffe          BL       sec_params_request_process
;;;849                break;
000032  e00f              B        |L20.84|
                  |L20.52|
;;;850    
;;;851            case BLE_GAP_EVT_SEC_INFO_REQUEST:
;;;852                sec_info_request_process(&(p_ble_evt->evt.gap_evt));
000034  1d20              ADDS     r0,r4,#4
000036  f7fffffe          BL       sec_info_request_process
;;;853                break;
00003a  e00b              B        |L20.84|
                  |L20.60|
;;;854    
;;;855            case BLE_GAP_EVT_SEC_REQUEST:
;;;856                sec_request_process(&(p_ble_evt->evt.gap_evt));
00003c  1d20              ADDS     r0,r4,#4
00003e  f7fffffe          BL       sec_request_process
;;;857                break;
000042  e007              B        |L20.84|
                  |L20.68|
;;;858    
;;;859            case BLE_GAP_EVT_AUTH_STATUS:
;;;860                auth_status_process(&(p_ble_evt->evt.gap_evt));
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       auth_status_process
;;;861                break;
00004a  e003              B        |L20.84|
                  |L20.76|
;;;862    
;;;863            case BLE_GAP_EVT_CONN_SEC_UPDATE:
;;;864                conn_sec_update_process(&(p_ble_evt->evt.gap_evt));
00004c  1d20              ADDS     r0,r4,#4
00004e  f7fffffe          BL       conn_sec_update_process
;;;865                break;
000052  bf00              NOP      
                  |L20.84|
000054  bf00              NOP                            ;845
;;;866        };
;;;867    }
000056  bd10              POP      {r4,pc}
;;;868    #endif //PEER_MANAGER_ENABLED
                          ENDP


                          AREA ||i.smd_init||, CODE, READONLY, ALIGN=2

                  smd_init PROC
;;;502    
;;;503    ret_code_t smd_init(void)
000000  b510              PUSH     {r4,lr}
;;;504    {
;;;505        NRF_PM_DEBUG_CHECK(!m_module_initialized);
;;;506    
;;;507        flag_id_init(&m_flag_sec_proc);
000002  480e              LDR      r0,|L21.60|
000004  f7fffffe          BL       flag_id_init
;;;508        flag_id_init(&m_flag_sec_proc_pairing);
000008  480d              LDR      r0,|L21.64|
00000a  f7fffffe          BL       flag_id_init
;;;509        flag_id_init(&m_flag_sec_proc_new_peer);
00000e  480d              LDR      r0,|L21.68|
000010  f7fffffe          BL       flag_id_init
;;;510    
;;;511        if ((m_flag_sec_proc          == BLE_CONN_STATE_USER_FLAG_INVALID) ||
000014  4809              LDR      r0,|L21.60|
000016  7800              LDRB     r0,[r0,#0]  ; m_flag_sec_proc
000018  2818              CMP      r0,#0x18
00001a  d007              BEQ      |L21.44|
;;;512            (m_flag_sec_proc_pairing  == BLE_CONN_STATE_USER_FLAG_INVALID) ||
00001c  4808              LDR      r0,|L21.64|
00001e  7800              LDRB     r0,[r0,#0]  ; m_flag_sec_proc_pairing
000020  2818              CMP      r0,#0x18
000022  d003              BEQ      |L21.44|
;;;513            (m_flag_sec_proc_new_peer == BLE_CONN_STATE_USER_FLAG_INVALID))
000024  4807              LDR      r0,|L21.68|
000026  7800              LDRB     r0,[r0,#0]  ; m_flag_sec_proc_new_peer
000028  2818              CMP      r0,#0x18
00002a  d101              BNE      |L21.48|
                  |L21.44|
;;;514        {
;;;515            return NRF_ERROR_INTERNAL;
00002c  2003              MOVS     r0,#3
                  |L21.46|
;;;516        }
;;;517    
;;;518        m_module_initialized = true;
;;;519    
;;;520        return NRF_SUCCESS;
;;;521    }
00002e  bd10              POP      {r4,pc}
                  |L21.48|
000030  2001              MOVS     r0,#1                 ;518
000032  4905              LDR      r1,|L21.72|
000034  7008              STRB     r0,[r1,#0]            ;518
000036  2000              MOVS     r0,#0                 ;520
000038  e7f9              B        |L21.46|
;;;522    
                          ENDP

00003a  0000              DCW      0x0000
                  |L21.60|
                          DCD      m_flag_sec_proc
                  |L21.64|
                          DCD      m_flag_sec_proc_pairing
                  |L21.68|
                          DCD      m_flag_sec_proc_new_peer
                  |L21.72|
                          DCD      m_module_initialized

                          AREA ||i.smd_link_secure||, CODE, READONLY, ALIGN=1

                  smd_link_secure PROC
;;;816    
;;;817    ret_code_t smd_link_secure(uint16_t               conn_handle,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;818                               ble_gap_sec_params_t * p_sec_params,
;;;819                               bool                   force_repairing)
;;;820    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;821        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;822    
;;;823        uint8_t role = ble_conn_state_role(conn_handle);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       ble_conn_state_role
000010  4607              MOV      r7,r0
;;;824    
;;;825        switch (role)
000012  2f01              CMP      r7,#1
000014  d008              BEQ      |L22.40|
000016  2f02              CMP      r7,#2
000018  d10b              BNE      |L22.50|
;;;826        {
;;;827            case BLE_GAP_ROLE_CENTRAL:
;;;828                return link_secure_central(conn_handle, p_sec_params, force_repairing);
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       link_secure_central
                  |L22.36|
;;;829    
;;;830            case BLE_GAP_ROLE_PERIPH:
;;;831                return link_secure_peripheral(conn_handle, p_sec_params);
;;;832    
;;;833            default:
;;;834                return BLE_ERROR_INVALID_CONN_HANDLE;
;;;835        }
;;;836    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L22.40|
000028  4629              MOV      r1,r5                 ;831
00002a  4620              MOV      r0,r4                 ;831
00002c  f7fffffe          BL       link_secure_peripheral
000030  e7f8              B        |L22.36|
                  |L22.50|
000032  f2430002          MOV      r0,#0x3002            ;834
000036  e7f5              B        |L22.36|
;;;837    
                          ENDP


                          AREA ||i.smd_params_reply||, CODE, READONLY, ALIGN=2

                  smd_params_reply PROC
;;;523    
;;;524    ret_code_t smd_params_reply(uint16_t                 conn_handle,
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;525                                ble_gap_sec_params_t   * p_sec_params,
;;;526                                ble_gap_lesc_p256_pk_t * p_public_key)
;;;527    {
000004  b08a              SUB      sp,sp,#0x28
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;528        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;529    
;;;530        uint8_t              role = ble_conn_state_role(conn_handle);
00000a  980a              LDR      r0,[sp,#0x28]
00000c  f7fffffe          BL       ble_conn_state_role
000010  4607              MOV      r7,r0
;;;531        pm_peer_id_t         peer_id = PM_PEER_ID_INVALID;
000012  f64f76ff          MOV      r6,#0xffff
;;;532        ret_code_t           err_code = NRF_SUCCESS;
000016  2500              MOVS     r5,#0
;;;533        uint8_t              sec_status = BLE_GAP_SEC_STATUS_SUCCESS;
000018  46a9              MOV      r9,r5
;;;534        ble_gap_sec_keyset_t sec_keyset;
;;;535        bool                 new_peer_created = false;
00001a  46aa              MOV      r10,r5
;;;536    
;;;537        memset(&sec_keyset, 0, sizeof(ble_gap_sec_keyset_t));
00001c  2120              MOVS     r1,#0x20
00001e  a802              ADD      r0,sp,#8
000020  f7fffffe          BL       __aeabi_memclr4
;;;538    
;;;539        if (role == BLE_GAP_ROLE_INVALID)
000024  b927              CBNZ     r7,|L23.48|
;;;540        {
;;;541            return BLE_ERROR_INVALID_CONN_HANDLE;
000026  f2430002          MOV      r0,#0x3002
                  |L23.42|
;;;542        }
;;;543    
;;;544        if (p_sec_params == NULL)
;;;545        {
;;;546            // NULL params means reject pairing.
;;;547            sec_status = BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP;
;;;548        }
;;;549        else if (p_sec_params->bond)
;;;550        {
;;;551            // Bonding is to be performed, prepare to receive bonding data.
;;;552            pm_peer_data_t       peer_data;
;;;553    
;;;554            peer_id = im_peer_id_get_by_conn_handle(conn_handle);
;;;555    
;;;556            if (peer_id == PM_PEER_ID_INVALID)
;;;557            {
;;;558                // Peer is unknown to us, allocate a new peer ID for it.
;;;559                peer_id = pdb_peer_allocate();
;;;560                if (peer_id != PM_PEER_ID_INVALID)
;;;561                {
;;;562                    new_peer_created = true;
;;;563                }
;;;564                else
;;;565                {
;;;566                    err_code = NRF_ERROR_INTERNAL;
;;;567                }
;;;568            }
;;;569    
;;;570            if (err_code == NRF_SUCCESS)
;;;571            {
;;;572                // Peer ID is ready, acquire a memory buffer to receive bonding data into.
;;;573                err_code = pdb_write_buf_get(peer_id, PM_PEER_DATA_ID_BONDING, 1, &peer_data);
;;;574                if (err_code == NRF_SUCCESS)
;;;575                {
;;;576                    memset(peer_data.p_bonding_data, 0, sizeof(pm_peer_data_bonding_t));
;;;577    
;;;578                    peer_data.p_bonding_data->own_role = role;
;;;579    
;;;580                    sec_keyset.keys_own.p_enc_key  = &peer_data.p_bonding_data->own_ltk;
;;;581                    sec_keyset.keys_own.p_pk       = p_public_key;
;;;582                    sec_keyset.keys_peer.p_enc_key = &peer_data.p_bonding_data->peer_ltk;
;;;583                    sec_keyset.keys_peer.p_id_key  = &peer_data.p_bonding_data->peer_id;
;;;584                    sec_keyset.keys_peer.p_pk      = &m_peer_pk;
;;;585    
;;;586                    // Retrieve the address the peer used during connection establishment.
;;;587                    // This address will be overwritten if ID is shared. Should not fail.
;;;588                    ret_code_t err_code_addr = im_ble_addr_get(conn_handle,
;;;589                        &peer_data.p_bonding_data->peer_id.id_addr_info);
;;;590                    UNUSED_VARIABLE(err_code_addr);
;;;591    
;;;592                    // Buffer is OK, reserve room in flash for the data.
;;;593                    err_code = pdb_write_buf_store_prepare(peer_id, PM_PEER_DATA_ID_BONDING);
;;;594                }
;;;595            }
;;;596        }
;;;597        else
;;;598        {
;;;599            // Pairing only, no action needed.
;;;600        }
;;;601    
;;;602        if (err_code == NRF_SUCCESS)
;;;603        {
;;;604            // Everything OK, reply to SoftDevice. If an error happened, the user is given an
;;;605            // opportunity to change the parameters and retry the call.
;;;606            if (role == BLE_GAP_ROLE_CENTRAL)
;;;607            {
;;;608                err_code = sd_ble_gap_sec_params_reply(conn_handle, sec_status, NULL, &sec_keyset);
;;;609            }
;;;610            else
;;;611            {
;;;612                err_code = sd_ble_gap_sec_params_reply(conn_handle, sec_status, p_sec_params, &sec_keyset);
;;;613    
;;;614                if ((p_sec_params != NULL) && (err_code == NRF_SUCCESS))
;;;615                {
;;;616                    pm_conn_sec_procedure_t procedure = p_sec_params->bond
;;;617                                                   ? PM_LINK_SECURED_PROCEDURE_BONDING
;;;618                                                   : PM_LINK_SECURED_PROCEDURE_PAIRING;
;;;619                    sec_start_send(conn_handle, procedure);
;;;620                }
;;;621            }
;;;622        }
;;;623    
;;;624        sec_proc_start(conn_handle,
;;;625                       peer_id,
;;;626                       (err_code == NRF_SUCCESS) && (sec_status != BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP),
;;;627                       true,
;;;628                       new_peer_created);
;;;629    
;;;630        return err_code;
;;;631    }
00002a  b00d              ADD      sp,sp,#0x34
00002c  e8bd8ff0          POP      {r4-r11,pc}
                  |L23.48|
000030  b914              CBNZ     r4,|L23.56|
000032  f04f0985          MOV      r9,#0x85              ;547
000036  e041              B        |L23.188|
                  |L23.56|
000038  7820              LDRB     r0,[r4,#0]            ;549
00003a  f0000001          AND      r0,r0,#1              ;549
00003e  2800              CMP      r0,#0                 ;549
000040  d03c              BEQ      |L23.188|
000042  980a              LDR      r0,[sp,#0x28]         ;554
000044  f7fffffe          BL       im_peer_id_get_by_conn_handle
000048  4606              MOV      r6,r0                 ;554
00004a  f64f70ff          MOV      r0,#0xffff            ;556
00004e  4286              CMP      r6,r0                 ;556
000050  d10a              BNE      |L23.104|
000052  f7fffffe          BL       pdb_peer_allocate
000056  4606              MOV      r6,r0                 ;559
000058  f64f70ff          MOV      r0,#0xffff            ;560
00005c  4286              CMP      r6,r0                 ;560
00005e  d002              BEQ      |L23.102|
000060  f04f0a01          MOV      r10,#1                ;562
000064  e000              B        |L23.104|
                  |L23.102|
000066  2503              MOVS     r5,#3                 ;566
                  |L23.104|
000068  bb3d              CBNZ     r5,|L23.186|
00006a  466b              MOV      r3,sp                 ;573
00006c  2201              MOVS     r2,#1                 ;573
00006e  2107              MOVS     r1,#7                 ;573
000070  4630              MOV      r0,r6                 ;573
000072  f7fffffe          BL       pdb_write_buf_get
000076  4605              MOV      r5,r0                 ;573
000078  b9fd              CBNZ     r5,|L23.186|
00007a  2150              MOVS     r1,#0x50              ;576
00007c  9801              LDR      r0,[sp,#4]            ;576
00007e  f7fffffe          BL       __aeabi_memclr
000082  9801              LDR      r0,[sp,#4]            ;578
000084  7007              STRB     r7,[r0,#0]            ;578
000086  9801              LDR      r0,[sp,#4]            ;580
000088  3034              ADDS     r0,r0,#0x34           ;580
00008a  9002              STR      r0,[sp,#8]            ;580
00008c  f8cd8014          STR      r8,[sp,#0x14]         ;581
000090  9801              LDR      r0,[sp,#4]            ;582
000092  3018              ADDS     r0,r0,#0x18           ;582
000094  9006              STR      r0,[sp,#0x18]         ;582
000096  9801              LDR      r0,[sp,#4]            ;583
000098  1c40              ADDS     r0,r0,#1              ;583
00009a  9007              STR      r0,[sp,#0x1c]         ;583
00009c  491f              LDR      r1,|L23.284|
00009e  9109              STR      r1,[sp,#0x24]         ;584
0000a0  9801              LDR      r0,[sp,#4]            ;588
0000a2  f1000111          ADD      r1,r0,#0x11           ;588
0000a6  980a              LDR      r0,[sp,#0x28]         ;588
0000a8  f7fffffe          BL       im_ble_addr_get
0000ac  4683              MOV      r11,r0                ;588
0000ae  2107              MOVS     r1,#7                 ;593
0000b0  4630              MOV      r0,r6                 ;593
0000b2  f7fffffe          BL       pdb_write_buf_store_prepare
0000b6  4605              MOV      r5,r0                 ;593
0000b8  bf00              NOP                            ;594
                  |L23.186|
0000ba  bf00              NOP                            ;596
                  |L23.188|
0000bc  b9ed              CBNZ     r5,|L23.250|
0000be  2f02              CMP      r7,#2                 ;606
0000c0  d106              BNE      |L23.208|
0000c2  ab02              ADD      r3,sp,#8              ;608
0000c4  2200              MOVS     r2,#0                 ;608
0000c6  4649              MOV      r1,r9                 ;608
0000c8  980a              LDR      r0,[sp,#0x28]         ;608
0000ca  df7f              SVC      #0x7f                 ;608
0000cc  4605              MOV      r5,r0                 ;608
0000ce  e014              B        |L23.250|
                  |L23.208|
0000d0  ab02              ADD      r3,sp,#8              ;612
0000d2  4622              MOV      r2,r4                 ;612
0000d4  4649              MOV      r1,r9                 ;612
0000d6  980a              LDR      r0,[sp,#0x28]         ;612
0000d8  df7f              SVC      #0x7f                 ;612
0000da  4605              MOV      r5,r0                 ;612
0000dc  b16c              CBZ      r4,|L23.250|
0000de  b965              CBNZ     r5,|L23.250|
0000e0  7820              LDRB     r0,[r4,#0]            ;616
0000e2  f0000001          AND      r0,r0,#1              ;616
0000e6  b108              CBZ      r0,|L23.236|
0000e8  2001              MOVS     r0,#1                 ;617
0000ea  e000              B        |L23.238|
                  |L23.236|
0000ec  2002              MOVS     r0,#2                 ;618
                  |L23.238|
0000ee  4683              MOV      r11,r0                ;618
0000f0  4659              MOV      r1,r11                ;619
0000f2  980a              LDR      r0,[sp,#0x28]         ;619
0000f4  f7fffffe          BL       sec_start_send
0000f8  bf00              NOP                            ;620
                  |L23.250|
0000fa  f8cda000          STR      r10,[sp,#0]           ;624
0000fe  b925              CBNZ     r5,|L23.266|
000100  f1b90f85          CMP      r9,#0x85              ;626
000104  d001              BEQ      |L23.266|
000106  2001              MOVS     r0,#1                 ;626
000108  e000              B        |L23.268|
                  |L23.266|
00010a  2000              MOVS     r0,#0                 ;626
                  |L23.268|
00010c  4602              MOV      r2,r0                 ;626
00010e  2301              MOVS     r3,#1                 ;626
000110  4631              MOV      r1,r6                 ;626
000112  980a              LDR      r0,[sp,#0x28]         ;626
000114  f7fffffe          BL       sec_proc_start
000118  4628              MOV      r0,r5                 ;630
00011a  e786              B        |L23.42|
;;;632    
                          ENDP

                  |L23.284|
                          DCD      m_peer_pk

                          AREA ||i.smd_pdb_evt_handler||, CODE, READONLY, ALIGN=2

                  smd_pdb_evt_handler PROC
;;;76      */
;;;77     void smd_pdb_evt_handler(pdb_evt_t const * p_event)
000000  b53e              PUSH     {r1-r5,lr}
;;;78     {
000002  4604              MOV      r4,r0
;;;79         if ((p_event->evt_id == PDB_EVT_WRITE_BUF_STORED) && (p_event->data_id == PM_PEER_DATA_ID_BONDING))
000004  7820              LDRB     r0,[r4,#0]
000006  b990              CBNZ     r0,|L24.46|
000008  7920              LDRB     r0,[r4,#4]
00000a  2807              CMP      r0,#7
00000c  d10f              BNE      |L24.46|
;;;80         {
;;;81             smd_evt_t evt =
00000e  4a08              LDR      r2,|L24.48|
000010  ca07              LDM      r2,{r0-r2}
000012  e88d0007          STM      sp,{r0-r2}
000016  8860              LDRH     r0,[r4,#2]
000018  f7fffffe          BL       im_conn_handle_get
00001c  f8ad0002          STRH     r0,[sp,#2]
000020  8860              LDRH     r0,[r4,#2]
000022  f8ad0004          STRH     r0,[sp,#4]
;;;82             {
;;;83                 .evt_id      = SMD_EVT_BONDING_INFO_STORED,
;;;84                 .conn_handle = im_conn_handle_get(p_event->peer_id),
;;;85                 .params      = {.bonding_info_stored = {.peer_id = p_event->peer_id}}
;;;86             };
;;;87             evt_send(&evt);
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       evt_send
;;;88         }
00002c  bf00              NOP      
                  |L24.46|
;;;89     }
00002e  bd3e              POP      {r1-r5,pc}
;;;90     
                          ENDP

                  |L24.48|
                          DCD      ||.constdata||+0x14

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  m_peer_pk
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  m_evt_handlers
                          DCD      sm_smd_evt_handler
                          DCD      gcm_smd_evt_handler
000008  0200              DCB      0x02,0x00
00000a  0000              DCW      0x0000
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000014  0700              DCB      0x07,0x00
000016  0000              DCW      0x0000
000018  0000              DCW      0x0000
00001a  0000              DCB      0x00,0x00
                          DCD      0x00000000
000020  0100              DCB      0x01,0x00
000022  0000              DCW      0x0000
000024  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
00002c  0400              DCB      0x04,0x00
00002e  0000              DCW      0x0000
000030  0000              DCW      0x0000
000032  0000              DCB      0x00,0x00
                          DCD      0x00000000
000038  0600              DCB      0x06,0x00
00003a  0000              DCW      0x0000
00003c  0000              DCW      0x0000
00003e  0000              DCB      0x00,0x00
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=0

                  m_module_initialized
000000  00                DCB      0x00
                  m_flag_sec_proc
000001  18                DCB      0x18
                  m_flag_sec_proc_pairing
000002  18                DCB      0x18
                  m_flag_sec_proc_new_peer
000003  18                DCB      0x18

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\peer_manager\\security_dispatcher.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_security_dispatcher_c_15a53087____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_security_dispatcher_c_15a53087____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_security_dispatcher_c_15a53087____REVSH|
#line 402
|__asm___21_security_dispatcher_c_15a53087____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_security_dispatcher_c_15a53087____RRX|
#line 587
|__asm___21_security_dispatcher_c_15a53087____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
