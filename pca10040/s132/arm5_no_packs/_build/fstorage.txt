; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\fstorage.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\fstorage.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\fstorage.crf ..\..\..\..\..\..\components\libraries\fstorage\fstorage.c]
                          THUMB

                          AREA ||i.check_config||, CODE, READONLY, ALIGN=2

                  check_config PROC
;;;58     // Checks that a configuration is non-NULL and within section variable bounds.
;;;59     static bool check_config(fs_config_t const * const config)
000000  4601              MOV      r1,r0
;;;60     {
;;;61     #ifndef DFU_SUPPORT_SIGNING
;;;62         if ((config != NULL) &&
000002  b139              CBZ      r1,|L1.20|
;;;63             (FS_SECTION_VARS_START_ADDR <= (uint32_t)config) &&
000004  4804              LDR      r0,|L1.24|
000006  4288              CMP      r0,r1
000008  d804              BHI      |L1.20|
;;;64             (FS_SECTION_VARS_END_ADDR   >  (uint32_t)config))
00000a  4804              LDR      r0,|L1.28|
00000c  4288              CMP      r0,r1
00000e  d901              BLS      |L1.20|
;;;65         {
;;;66             return true;
000010  2001              MOVS     r0,#1
                  |L1.18|
;;;67         }
;;;68     
;;;69         return false;
;;;70     #else
;;;71         return true;
;;;72     #endif
;;;73     }
000012  4770              BX       lr
                  |L1.20|
000014  2000              MOVS     r0,#0                 ;69
000016  e7fc              B        |L1.18|
;;;74     
                          ENDP

                  |L1.24|
                          DCD      ||fs_data$$Base||
                  |L1.28|
                          DCD      ||fs_data$$Limit||

                          AREA ||i.erase_execute||, CODE, READONLY, ALIGN=1

                  erase_execute PROC
;;;96     // Executes an erase operation.
;;;97     static uint32_t erase_execute(fs_op_t const * const p_op)
000000  b510              PUSH     {r4,lr}
;;;98     {
000002  4604              MOV      r4,r0
;;;99         return sd_flash_page_erase(p_op->erase.page);
000004  89a0              LDRH     r0,[r4,#0xc]
000006  df28              SVC      #0x28
;;;100    }
000008  bd10              POP      {r4,pc}
;;;101    
                          ENDP


                          AREA ||i.fs_erase||, CODE, READONLY, ALIGN=2

                  fs_erase PROC
;;;416    
;;;417    fs_ret_t fs_erase(fs_config_t const * const p_config,
000000  b5f8              PUSH     {r3-r7,lr}
;;;418                      uint32_t    const * const p_page_addr,
;;;419                      uint16_t    const         num_pages,
;;;420                      void *                    p_context)
;;;421    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;422        fs_op_t * p_op;
;;;423    
;;;424        if (!(m_flags & FS_FLAG_INITIALIZED))
00000a  481c              LDR      r0,|L3.124|
00000c  7800              LDRB     r0,[r0,#0]  ; m_flags
00000e  f0000001          AND      r0,r0,#1
000012  b908              CBNZ     r0,|L3.24|
;;;425        {
;;;426            return FS_ERR_NOT_INITIALIZED;
000014  2001              MOVS     r0,#1
                  |L3.22|
;;;427        }
;;;428    
;;;429        if (!check_config(p_config))
;;;430        {
;;;431            return FS_ERR_INVALID_CFG;
;;;432        }
;;;433    
;;;434        if (p_page_addr == NULL)
;;;435        {
;;;436            return FS_ERR_NULL_ARG;
;;;437        }
;;;438    
;;;439        // Check that the page is aligned to a page boundary.
;;;440        if (((uint32_t)p_page_addr & (FS_PAGE_SIZE-1)) != 0)
;;;441        {
;;;442            return FS_ERR_UNALIGNED_ADDR;
;;;443        }
;;;444    
;;;445        // Check that the operation doesn't go outside the client's memory boundaries.
;;;446        if ((p_page_addr < p_config->p_start_addr) ||
;;;447            (p_page_addr + (FS_PAGE_SIZE_WORDS * num_pages) > p_config->p_end_addr))
;;;448        {
;;;449            return FS_ERR_INVALID_ADDR;
;;;450        }
;;;451    
;;;452        if (num_pages == 0)
;;;453        {
;;;454            return FS_ERR_INVALID_ARG;
;;;455        }
;;;456    
;;;457        if (!queue_get_next_free(&p_op))
;;;458        {
;;;459            return FS_ERR_QUEUE_FULL;
;;;460        }
;;;461    
;;;462        // Initialize the operation.
;;;463        p_op->p_context            = p_context;
;;;464        p_op->p_config             = p_config;
;;;465        p_op->op_code              = FS_OP_ERASE;
;;;466        p_op->erase.page           = ((uint32_t)p_page_addr / FS_PAGE_SIZE);
;;;467        p_op->erase.pages_to_erase = num_pages;
;;;468    
;;;469        queue_start();
;;;470    
;;;471        return FS_SUCCESS;
;;;472    }
000016  bdf8              POP      {r3-r7,pc}
                  |L3.24|
000018  4628              MOV      r0,r5                 ;429
00001a  f7fffffe          BL       check_config
00001e  b908              CBNZ     r0,|L3.36|
000020  2002              MOVS     r0,#2                 ;431
000022  e7f8              B        |L3.22|
                  |L3.36|
000024  b90c              CBNZ     r4,|L3.42|
000026  2003              MOVS     r0,#3                 ;436
000028  e7f5              B        |L3.22|
                  |L3.42|
00002a  f3c4000b          UBFX     r0,r4,#0,#12          ;440
00002e  b108              CBZ      r0,|L3.52|
000030  2006              MOVS     r0,#6                 ;442
000032  e7f0              B        |L3.22|
                  |L3.52|
000034  6828              LDR      r0,[r5,#0]            ;446
000036  42a0              CMP      r0,r4                 ;446
000038  d804              BHI      |L3.68|
00003a  eb043006          ADD      r0,r4,r6,LSL #12      ;447
00003e  6869              LDR      r1,[r5,#4]            ;447
000040  4288              CMP      r0,r1                 ;447
000042  d901              BLS      |L3.72|
                  |L3.68|
000044  2005              MOVS     r0,#5                 ;449
000046  e7e6              B        |L3.22|
                  |L3.72|
000048  b90e              CBNZ     r6,|L3.78|
00004a  2004              MOVS     r0,#4                 ;454
00004c  e7e3              B        |L3.22|
                  |L3.78|
00004e  4668              MOV      r0,sp                 ;457
000050  f7fffffe          BL       queue_get_next_free
000054  b908              CBNZ     r0,|L3.90|
000056  2007              MOVS     r0,#7                 ;459
000058  e7dd              B        |L3.22|
                  |L3.90|
00005a  9800              LDR      r0,[sp,#0]            ;463
00005c  6047              STR      r7,[r0,#4]            ;463
00005e  9800              LDR      r0,[sp,#0]            ;464
000060  6005              STR      r5,[r0,#0]            ;464
000062  2002              MOVS     r0,#2                 ;465
000064  9900              LDR      r1,[sp,#0]            ;465
000066  7208              STRB     r0,[r1,#8]            ;465
000068  f3c4300f          UBFX     r0,r4,#12,#16         ;466
00006c  9900              LDR      r1,[sp,#0]            ;466
00006e  8188              STRH     r0,[r1,#0xc]          ;466
000070  9800              LDR      r0,[sp,#0]            ;467
000072  8206              STRH     r6,[r0,#0x10]         ;467
000074  f7fffffe          BL       queue_start
000078  2000              MOVS     r0,#0                 ;471
00007a  e7cc              B        |L3.22|
;;;473    
                          ENDP

                  |L3.124|
                          DCD      m_flags

                          AREA ||i.fs_fake_init||, CODE, READONLY, ALIGN=2

                  fs_fake_init PROC
;;;348    
;;;349    fs_ret_t fs_fake_init(void)
000000  4803              LDR      r0,|L4.16|
;;;350    {
;;;351        m_flags |= FS_FLAG_INITIALIZED;
000002  7800              LDRB     r0,[r0,#0]  ; m_flags
000004  f0400001          ORR      r0,r0,#1
000008  4901              LDR      r1,|L4.16|
00000a  7008              STRB     r0,[r1,#0]
;;;352        return FS_SUCCESS;
00000c  2000              MOVS     r0,#0
;;;353    }
00000e  4770              BX       lr
;;;354    
                          ENDP

                  |L4.16|
                          DCD      m_flags

                          AREA ||i.fs_flash_page_end_addr||, CODE, READONLY, ALIGN=1

                  fs_flash_page_end_addr PROC
;;;117    // Function to obtain the end of the flash space available to fstorage.
;;;118    static uint32_t const * fs_flash_page_end_addr()
000000  f04f2010          MOV      r0,#0x10001000
;;;119    {
;;;120        uint32_t const bootloader_addr = NRF_UICR->NRFFW[0];
000004  6941              LDR      r1,[r0,#0x14]
;;;121    
;;;122        return  (uint32_t*)((bootloader_addr != FS_ERASED_WORD) ? bootloader_addr :
000006  1c48              ADDS     r0,r1,#1
000008  b108              CBZ      r0,|L5.14|
00000a  4608              MOV      r0,r1
                  |L5.12|
;;;123                                                                  NRF_FICR->CODESIZE * FS_PAGE_SIZE);
;;;124    }
00000c  4770              BX       lr
                  |L5.14|
00000e  f04f5080          MOV      r0,#0x10000000        ;123
000012  6940              LDR      r0,[r0,#0x14]         ;123
000014  0300              LSLS     r0,r0,#12             ;123
000016  e7f9              B        |L5.12|
;;;125    
                          ENDP


                          AREA ||i.fs_init||, CODE, READONLY, ALIGN=2

                  fs_init PROC
;;;265    
;;;266    fs_ret_t fs_init(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;267    {
;;;268        uint32_t const   total_users     = FS_SECTION_VARS_COUNT;
000004  482b              LDR      r0,|L6.180|
000006  492c              LDR      r1,|L6.184|
000008  1a40              SUBS     r0,r0,r1
00000a  0904              LSRS     r4,r0,#4
;;;269        uint32_t         configs_to_init = FS_SECTION_VARS_COUNT;
00000c  4829              LDR      r0,|L6.180|
00000e  1a40              SUBS     r0,r0,r1
000010  0905              LSRS     r5,r0,#4
;;;270        uint32_t const * p_current_end   = FS_PAGE_END_ADDR;
000012  f7fffffe          BL       fs_flash_page_end_addr
000016  4606              MOV      r6,r0
;;;271    
;;;272        if (m_flags & FS_FLAG_INITIALIZED)
000018  4828              LDR      r0,|L6.188|
00001a  7800              LDRB     r0,[r0,#0]  ; m_flags
00001c  f0000001          AND      r0,r0,#1
000020  b110              CBZ      r0,|L6.40|
;;;273        {
;;;274            return FS_SUCCESS;
000022  2000              MOVS     r0,#0
                  |L6.36|
;;;275        }
;;;276    
;;;277        // Each fstorage user has registered one configuration.
;;;278        // The total number of users (and thus the total number of configurations) is
;;;279        // kept in total_users. Some of these users might have specified their flash
;;;280        // boundaries in their configurations. This function sets the flash boundaries
;;;281        // for the remaining user configurations without further user interaction.
;;;282    
;;;283        // First, determine how many user configurations this function has to initialize,
;;;284        // out of the total. This number will be kept in configs_to_init.
;;;285    
;;;286        for (uint32_t i = 0; i < total_users; i++)
;;;287        {
;;;288            fs_config_t const * const p_config = FS_SECTION_VARS_GET(i);
;;;289    
;;;290            if ((p_config->p_start_addr != NULL) &&
;;;291                (p_config->p_end_addr   != NULL))
;;;292            {
;;;293                configs_to_init--;
;;;294            }
;;;295        }
;;;296    
;;;297        // For each configuration to initialize, assign flash space based on the priority
;;;298        // specified. Higher priority means a higher memory address.
;;;299    
;;;300        for (uint32_t i = 0; i < configs_to_init; i++)
;;;301        {
;;;302            fs_config_t * p_config_i   = FS_SECTION_VARS_GET(i);
;;;303            uint8_t       max_priority = 0;
;;;304            uint8_t       max_index    = i;
;;;305    
;;;306            for (uint32_t j = 0; j < total_users; j++)
;;;307            {
;;;308                fs_config_t const * const p_config_j = FS_SECTION_VARS_GET(j);
;;;309    
;;;310                #if 0
;;;311                if (p_config_j->priority == p_config_i->priority)
;;;312                {
;;;313                    // Duplicated priorities are not allowed.
;;;314                    return FS_ERR_INVALID_CFG;
;;;315                }
;;;316                #endif
;;;317    
;;;318                if ((p_config_j->p_start_addr != NULL) &&
;;;319                    (p_config_j->p_end_addr   != NULL))
;;;320                {
;;;321                    // When calculating the configuration with the next highest priority
;;;322                    // skip configurations which were already set during a previous iteration.
;;;323                    // This check needs to be here to prevent re-using the configurations
;;;324                    // with higher priorities which we used in previous iterations.
;;;325                    continue;
;;;326                }
;;;327    
;;;328                if (p_config_j->priority > max_priority)
;;;329                {
;;;330                    max_priority = p_config_j->priority;
;;;331                    max_index    = j;
;;;332                }
;;;333            }
;;;334    
;;;335            p_config_i = FS_SECTION_VARS_GET(max_index);
;;;336    
;;;337            p_config_i->p_end_addr   = p_current_end;
;;;338            p_config_i->p_start_addr = p_current_end - (p_config_i->num_pages * FS_PAGE_SIZE_WORDS);
;;;339    
;;;340            p_current_end = p_config_i->p_start_addr;
;;;341        }
;;;342    
;;;343        m_flags |= FS_FLAG_INITIALIZED;
;;;344    
;;;345        return FS_SUCCESS;
;;;346    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L6.40|
000028  2000              MOVS     r0,#0                 ;286
00002a  e008              B        |L6.62|
                  |L6.44|
00002c  4a22              LDR      r2,|L6.184|
00002e  eb021100          ADD      r1,r2,r0,LSL #4       ;288
000032  680a              LDR      r2,[r1,#0]            ;290
000034  b112              CBZ      r2,|L6.60|
000036  684a              LDR      r2,[r1,#4]            ;291
000038  b102              CBZ      r2,|L6.60|
00003a  1e6d              SUBS     r5,r5,#1              ;293
                  |L6.60|
00003c  1c40              ADDS     r0,r0,#1              ;286
                  |L6.62|
00003e  42a0              CMP      r0,r4                 ;286
000040  d3f4              BCC      |L6.44|
000042  2000              MOVS     r0,#0                 ;300
000044  e02b              B        |L6.158|
                  |L6.70|
000046  491c              LDR      r1,|L6.184|
000048  eb011200          ADD      r2,r1,r0,LSL #4       ;302
00004c  f04f0c00          MOV      r12,#0                ;303
000050  b2c7              UXTB     r7,r0                 ;304
000052  2100              MOVS     r1,#0                 ;306
000054  e017              B        |L6.134|
                  |L6.86|
000056  f8df8060          LDR      r8,|L6.184|
00005a  eb081301          ADD      r3,r8,r1,LSL #4       ;308
00005e  f8d38000          LDR      r8,[r3,#0]            ;318
000062  f1b80f00          CMP      r8,#0                 ;318
000066  d005              BEQ      |L6.116|
000068  f8d38004          LDR      r8,[r3,#4]            ;319
00006c  f1b80f00          CMP      r8,#0                 ;319
000070  d000              BEQ      |L6.116|
000072  e007              B        |L6.132|
                  |L6.116|
000074  f893800d          LDRB     r8,[r3,#0xd]          ;328
000078  45e0              CMP      r8,r12                ;328
00007a  dd02              BLE      |L6.130|
00007c  f893c00d          LDRB     r12,[r3,#0xd]         ;330
000080  b2cf              UXTB     r7,r1                 ;331
                  |L6.130|
000082  bf00              NOP                            ;325
                  |L6.132|
000084  1c49              ADDS     r1,r1,#1              ;306
                  |L6.134|
000086  42a1              CMP      r1,r4                 ;306
000088  d3e5              BCC      |L6.86|
00008a  490b              LDR      r1,|L6.184|
00008c  eb011207          ADD      r2,r1,r7,LSL #4       ;335
000090  6056              STR      r6,[r2,#4]            ;337
000092  7b11              LDRB     r1,[r2,#0xc]          ;338
000094  eba63101          SUB      r1,r6,r1,LSL #12      ;338
000098  6011              STR      r1,[r2,#0]            ;338
00009a  6816              LDR      r6,[r2,#0]            ;340
00009c  1c40              ADDS     r0,r0,#1              ;300
                  |L6.158|
00009e  42a8              CMP      r0,r5                 ;300
0000a0  d3d1              BCC      |L6.70|
0000a2  4806              LDR      r0,|L6.188|
0000a4  7800              LDRB     r0,[r0,#0]            ;343  ; m_flags
0000a6  f0400001          ORR      r0,r0,#1              ;343
0000aa  4904              LDR      r1,|L6.188|
0000ac  7008              STRB     r0,[r1,#0]            ;343
0000ae  2000              MOVS     r0,#0                 ;345
0000b0  e7b8              B        |L6.36|
;;;347    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L6.180|
                          DCD      ||fs_data$$Limit||
                  |L6.184|
                          DCD      ||fs_data$$Base||
                  |L6.188|
                          DCD      m_flags

                          AREA ||i.fs_queued_op_count_get||, CODE, READONLY, ALIGN=2

                  fs_queued_op_count_get PROC
;;;474    
;;;475    fs_ret_t fs_queued_op_count_get(uint32_t * const p_op_count)
000000  4601              MOV      r1,r0
;;;476    {
;;;477        if (p_op_count == NULL)
000002  b909              CBNZ     r1,|L7.8|
;;;478        {
;;;479            return FS_ERR_NULL_ARG;
000004  2003              MOVS     r0,#3
                  |L7.6|
;;;480        }
;;;481    
;;;482        *p_op_count = m_queue.count;
;;;483    
;;;484        return FS_SUCCESS;
;;;485    }
000006  4770              BX       lr
                  |L7.8|
000008  4802              LDR      r0,|L7.20|
00000a  6e40              LDR      r0,[r0,#0x64]         ;482  ; m_queue
00000c  6008              STR      r0,[r1,#0]            ;482
00000e  2000              MOVS     r0,#0                 ;484
000010  e7f9              B        |L7.6|
;;;486    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      m_queue

                          AREA ||i.fs_store||, CODE, READONLY, ALIGN=2

                  fs_store PROC
;;;355    
;;;356    fs_ret_t fs_store(fs_config_t const * const p_config,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;357                      uint32_t    const * const p_dest,
;;;358                      uint32_t    const * const p_src,
;;;359                      uint16_t    const         length_words,
;;;360                      void *                    p_context)
;;;361    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;362        fs_op_t * p_op;
;;;363    
;;;364        if (!(m_flags & FS_FLAG_INITIALIZED))
000010  481f              LDR      r0,|L8.144|
000012  7800              LDRB     r0,[r0,#0]  ; m_flags
000014  f0000001          AND      r0,r0,#1
000018  b910              CBNZ     r0,|L8.32|
;;;365        {
;;;366            return FS_ERR_NOT_INITIALIZED;
00001a  2001              MOVS     r0,#1
                  |L8.28|
;;;367        }
;;;368    
;;;369        if (!check_config(p_config))
;;;370        {
;;;371            return FS_ERR_INVALID_CFG;
;;;372        }
;;;373    
;;;374        if ((p_src == NULL) || (p_dest == NULL))
;;;375        {
;;;376            return FS_ERR_NULL_ARG;
;;;377        }
;;;378    
;;;379        // Check that both pointers are word aligned.
;;;380        if (((uint32_t)p_src  & 0x03) ||
;;;381            ((uint32_t)p_dest & 0x03))
;;;382        {
;;;383            return FS_ERR_UNALIGNED_ADDR;
;;;384        }
;;;385    
;;;386        // Check that the operation doesn't go outside the client's memory boundaries.
;;;387        if ((p_config->p_start_addr > p_dest) ||
;;;388            (p_config->p_end_addr   < (p_dest + length_words)))
;;;389        {
;;;390            return FS_ERR_INVALID_ADDR;
;;;391        }
;;;392    
;;;393        if (length_words == 0)
;;;394        {
;;;395            return FS_ERR_INVALID_ARG;
;;;396        }
;;;397    
;;;398        if (!queue_get_next_free(&p_op))
;;;399        {
;;;400            return FS_ERR_QUEUE_FULL;
;;;401        }
;;;402    
;;;403        // Initialize the operation.
;;;404        p_op->p_context          = p_context;
;;;405        p_op->p_config           = p_config;
;;;406        p_op->op_code            = FS_OP_STORE;
;;;407        p_op->store.p_src        = p_src;
;;;408        p_op->store.p_dest       = p_dest;
;;;409        p_op->store.length_words = length_words;
;;;410    
;;;411        queue_start();
;;;412    
;;;413        return FS_SUCCESS;
;;;414    }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L8.32|
000020  4628              MOV      r0,r5                 ;369
000022  f7fffffe          BL       check_config
000026  b908              CBNZ     r0,|L8.44|
000028  2002              MOVS     r0,#2                 ;371
00002a  e7f7              B        |L8.28|
                  |L8.44|
00002c  b106              CBZ      r6,|L8.48|
00002e  b90c              CBNZ     r4,|L8.52|
                  |L8.48|
000030  2003              MOVS     r0,#3                 ;376
000032  e7f3              B        |L8.28|
                  |L8.52|
000034  f0060003          AND      r0,r6,#3              ;380
000038  b910              CBNZ     r0,|L8.64|
00003a  f0040003          AND      r0,r4,#3              ;381
00003e  b108              CBZ      r0,|L8.68|
                  |L8.64|
000040  2006              MOVS     r0,#6                 ;383
000042  e7eb              B        |L8.28|
                  |L8.68|
000044  6828              LDR      r0,[r5,#0]            ;387
000046  42a0              CMP      r0,r4                 ;387
000048  d804              BHI      |L8.84|
00004a  eb040187          ADD      r1,r4,r7,LSL #2       ;388
00004e  6868              LDR      r0,[r5,#4]            ;388
000050  4288              CMP      r0,r1                 ;388
000052  d201              BCS      |L8.88|
                  |L8.84|
000054  2005              MOVS     r0,#5                 ;390
000056  e7e1              B        |L8.28|
                  |L8.88|
000058  b90f              CBNZ     r7,|L8.94|
00005a  2004              MOVS     r0,#4                 ;395
00005c  e7de              B        |L8.28|
                  |L8.94|
00005e  4668              MOV      r0,sp                 ;398
000060  f7fffffe          BL       queue_get_next_free
000064  b908              CBNZ     r0,|L8.106|
000066  2007              MOVS     r0,#7                 ;400
000068  e7d8              B        |L8.28|
                  |L8.106|
00006a  9800              LDR      r0,[sp,#0]            ;404
00006c  f8c08004          STR      r8,[r0,#4]            ;404
000070  9800              LDR      r0,[sp,#0]            ;405
000072  6005              STR      r5,[r0,#0]            ;405
000074  2001              MOVS     r0,#1                 ;406
000076  9900              LDR      r1,[sp,#0]            ;406
000078  7208              STRB     r0,[r1,#8]            ;406
00007a  9800              LDR      r0,[sp,#0]            ;407
00007c  60c6              STR      r6,[r0,#0xc]          ;407
00007e  9800              LDR      r0,[sp,#0]            ;408
000080  6104              STR      r4,[r0,#0x10]         ;408
000082  9800              LDR      r0,[sp,#0]            ;409
000084  8287              STRH     r7,[r0,#0x14]         ;409
000086  f7fffffe          BL       queue_start
00008a  2000              MOVS     r0,#0                 ;413
00008c  e7c6              B        |L8.28|
;;;415    
                          ENDP

00008e  0000              DCW      0x0000
                  |L8.144|
                          DCD      m_flags

                          AREA ||i.fs_sys_event_handler||, CODE, READONLY, ALIGN=2

                  fs_sys_event_handler PROC
;;;487    
;;;488    void fs_sys_event_handler(uint32_t sys_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;489    {
000002  4604              MOV      r4,r0
;;;490        fs_op_t * const p_op = &m_queue.op[m_queue.rp];
000004  4817              LDR      r0,|L9.100|
000006  6e00              LDR      r0,[r0,#0x60]  ; m_queue
000008  eb000040          ADD      r0,r0,r0,LSL #1
00000c  4915              LDR      r1,|L9.100|
00000e  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;491    
;;;492        if (m_flags & FS_FLAG_PROCESSING)
000012  4815              LDR      r0,|L9.104|
000014  7800              LDRB     r0,[r0,#0]  ; m_flags
000016  f0000002          AND      r0,r0,#2
00001a  b168              CBZ      r0,|L9.56|
;;;493        {
;;;494            // A flash operation was initiated by this module. Handle the result.
;;;495            switch (sys_evt)
00001c  2c02              CMP      r4,#2
00001e  d002              BEQ      |L9.38|
000020  2c03              CMP      r4,#3
000022  d108              BNE      |L9.54|
000024  e003              B        |L9.46|
                  |L9.38|
;;;496            {
;;;497                case NRF_EVT_FLASH_OPERATION_SUCCESS:
;;;498                    on_operation_success(p_op);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       on_operation_success
;;;499                    break;
00002c  e003              B        |L9.54|
                  |L9.46|
;;;500    
;;;501                case NRF_EVT_FLASH_OPERATION_ERROR:
;;;502                    on_operation_failure(p_op);
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       on_operation_failure
;;;503                    break;
000034  bf00              NOP      
                  |L9.54|
000036  e012              B        |L9.94|
                  |L9.56|
;;;504            }
;;;505        }
;;;506        else if ((m_flags & FS_FLAG_FLASH_REQ_PENDING))
000038  480b              LDR      r0,|L9.104|
00003a  7800              LDRB     r0,[r0,#0]  ; m_flags
00003c  f0000004          AND      r0,r0,#4
000040  b168              CBZ      r0,|L9.94|
;;;507        {
;;;508            // A flash operation was initiated outside this module.
;;;509            // A callback which indicates that it has finished was received.
;;;510            m_flags &= ~FS_FLAG_FLASH_REQ_PENDING;
000042  4809              LDR      r0,|L9.104|
000044  7800              LDRB     r0,[r0,#0]  ; m_flags
000046  f0200004          BIC      r0,r0,#4
00004a  4907              LDR      r1,|L9.104|
00004c  7008              STRB     r0,[r1,#0]
;;;511    
;;;512            // If there are any elements left in the queue, set FS_FLAG_PROCESSING.
;;;513            if (m_queue.count > 0)
00004e  4805              LDR      r0,|L9.100|
000050  6e40              LDR      r0,[r0,#0x64]  ; m_queue
000052  b120              CBZ      r0,|L9.94|
;;;514            {
;;;515               m_flags |= FS_FLAG_PROCESSING;
000054  4608              MOV      r0,r1
000056  7800              LDRB     r0,[r0,#0]  ; m_flags
000058  f0400002          ORR      r0,r0,#2
00005c  7008              STRB     r0,[r1,#0]
                  |L9.94|
;;;516            }
;;;517        }
;;;518    
;;;519        // Resume processing the queue, if necessary.
;;;520        queue_process();
00005e  f7fffffe          BL       queue_process
;;;521    }
000062  bd70              POP      {r4-r6,pc}
;;;522    #endif //FSTORAGE_ENABLED
                          ENDP

                  |L9.100|
                          DCD      m_queue
                  |L9.104|
                          DCD      m_flags

                          AREA ||i.on_operation_failure||, CODE, READONLY, ALIGN=2

                  on_operation_failure PROC
;;;228    // been reached, notifies the application and advances the queue.
;;;229    static void on_operation_failure(fs_op_t const * const p_op)
000000  b510              PUSH     {r4,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231        if (++m_retry_count > FS_OP_MAX_RETRIES)
000004  4808              LDR      r0,|L10.40|
000006  7800              LDRB     r0,[r0,#0]  ; m_retry_count
000008  1c40              ADDS     r0,r0,#1
00000a  b2c0              UXTB     r0,r0
00000c  4906              LDR      r1,|L10.40|
00000e  7008              STRB     r0,[r1,#0]
000010  2803              CMP      r0,#3
000012  dd07              BLE      |L10.36|
;;;232        {
;;;233            m_retry_count = 0;
000014  2000              MOVS     r0,#0
000016  7008              STRB     r0,[r1,#0]
;;;234    
;;;235            send_event(p_op, FS_ERR_OPERATION_TIMEOUT);
000018  2108              MOVS     r1,#8
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       send_event
;;;236            queue_advance();
000020  f7fffffe          BL       queue_advance
                  |L10.36|
;;;237        }
;;;238    }
000024  bd10              POP      {r4,pc}
;;;239    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      m_retry_count

                          AREA ||i.on_operation_success||, CODE, READONLY, ALIGN=2

                  on_operation_success PROC
;;;176    // If it has finished, advances the queue and notifies the application.
;;;177    static void on_operation_success(fs_op_t * const p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;178    {
000002  4604              MOV      r4,r0
;;;179        m_retry_count = 0;
000004  2000              MOVS     r0,#0
000006  491b              LDR      r1,|L11.116|
000008  7008              STRB     r0,[r1,#0]
;;;180    
;;;181        switch (p_op->op_code)
00000a  7a20              LDRB     r0,[r4,#8]
00000c  2801              CMP      r0,#1
00000e  d002              BEQ      |L11.22|
000010  2802              CMP      r0,#2
000012  d12c              BNE      |L11.110|
000014  e01a              B        |L11.76|
                  |L11.22|
;;;182        {
;;;183            case FS_OP_STORE:
;;;184            {
;;;185                uint16_t chunk_len;
;;;186    
;;;187                if ((p_op->store.length_words - p_op->store.offset) < FS_MAX_WRITE_SIZE_WORDS)
000016  8aa1              LDRH     r1,[r4,#0x14]
000018  8ae0              LDRH     r0,[r4,#0x16]
00001a  1a08              SUBS     r0,r1,r0
00001c  f5b06f80          CMP      r0,#0x400
000020  da04              BGE      |L11.44|
;;;188                {
;;;189                    chunk_len = p_op->store.length_words - p_op->store.offset;
000022  8aa1              LDRH     r1,[r4,#0x14]
000024  8ae0              LDRH     r0,[r4,#0x16]
000026  1a08              SUBS     r0,r1,r0
000028  b285              UXTH     r5,r0
00002a  e001              B        |L11.48|
                  |L11.44|
;;;190                }
;;;191                else
;;;192                {
;;;193                    chunk_len = FS_MAX_WRITE_SIZE_WORDS;
00002c  f44f6580          MOV      r5,#0x400
                  |L11.48|
;;;194                }
;;;195    
;;;196                p_op->store.offset += chunk_len;
000030  8ae0              LDRH     r0,[r4,#0x16]
000032  4428              ADD      r0,r0,r5
000034  82e0              STRH     r0,[r4,#0x16]
;;;197    
;;;198                if (p_op->store.offset == p_op->store.length_words)
000036  8ae1              LDRH     r1,[r4,#0x16]
000038  8aa0              LDRH     r0,[r4,#0x14]
00003a  4281              CMP      r1,r0
00003c  d105              BNE      |L11.74|
;;;199                {
;;;200                    // The operation has finished.
;;;201                    send_event(p_op, FS_SUCCESS);
00003e  2100              MOVS     r1,#0
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       send_event
;;;202                    queue_advance();
000046  f7fffffe          BL       queue_advance
                  |L11.74|
;;;203                }
;;;204            }
;;;205            break;
00004a  e011              B        |L11.112|
                  |L11.76|
;;;206    
;;;207            case FS_OP_ERASE:
;;;208            {
;;;209                p_op->erase.page++;
00004c  89a0              LDRH     r0,[r4,#0xc]
00004e  1c40              ADDS     r0,r0,#1
000050  81a0              STRH     r0,[r4,#0xc]
;;;210                p_op->erase.pages_erased++;
000052  89e0              LDRH     r0,[r4,#0xe]
000054  1c40              ADDS     r0,r0,#1
000056  81e0              STRH     r0,[r4,#0xe]
;;;211    
;;;212                if (p_op->erase.pages_erased == p_op->erase.pages_to_erase)
000058  89e1              LDRH     r1,[r4,#0xe]
00005a  8a20              LDRH     r0,[r4,#0x10]
00005c  4281              CMP      r1,r0
00005e  d105              BNE      |L11.108|
;;;213                {
;;;214                    send_event(p_op, FS_SUCCESS);
000060  2100              MOVS     r1,#0
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       send_event
;;;215                    queue_advance();
000068  f7fffffe          BL       queue_advance
                  |L11.108|
;;;216                }
;;;217            }
;;;218            break;
00006c  e000              B        |L11.112|
                  |L11.110|
;;;219    
;;;220            default:
;;;221                // Should not happen.
;;;222                break;
00006e  bf00              NOP      
                  |L11.112|
000070  bf00              NOP                            ;205
;;;223        }
;;;224    }
000072  bd70              POP      {r4-r6,pc}
;;;225    
                          ENDP

                  |L11.116|
                          DCD      m_retry_count

                          AREA ||i.queue_advance||, CODE, READONLY, ALIGN=2

                  queue_advance PROC
;;;104    // If no elements are left in the queue, clears the FS_FLAG_PROCESSING flag.
;;;105    static void queue_advance(void)
000000  480a              LDR      r0,|L12.44|
;;;106    {
;;;107        if (--m_queue.count == 0)
000002  6e40              LDR      r0,[r0,#0x64]  ; m_queue
000004  1e40              SUBS     r0,r0,#1
000006  4909              LDR      r1,|L12.44|
000008  6648              STR      r0,[r1,#0x64]  ; m_queue
00000a  b928              CBNZ     r0,|L12.24|
;;;108        {
;;;109            m_flags &= ~FS_FLAG_PROCESSING;
00000c  4808              LDR      r0,|L12.48|
00000e  7800              LDRB     r0,[r0,#0]  ; m_flags
000010  f0200002          BIC      r0,r0,#2
000014  4906              LDR      r1,|L12.48|
000016  7008              STRB     r0,[r1,#0]
                  |L12.24|
;;;110        }
;;;111    
;;;112        if (++m_queue.rp == FS_QUEUE_SIZE)
000018  4804              LDR      r0,|L12.44|
00001a  6e00              LDR      r0,[r0,#0x60]  ; m_queue
00001c  1c40              ADDS     r0,r0,#1
00001e  4903              LDR      r1,|L12.44|
000020  6608              STR      r0,[r1,#0x60]  ; m_queue
000022  2804              CMP      r0,#4
000024  d101              BNE      |L12.42|
;;;113        {
;;;114            m_queue.rp = 0;
000026  2000              MOVS     r0,#0
000028  6608              STR      r0,[r1,#0x60]  ; m_queue
                  |L12.42|
;;;115        }
;;;116    }
00002a  4770              BX       lr
;;;117    
                          ENDP

                  |L12.44|
                          DCD      m_queue
                  |L12.48|
                          DCD      m_flags

                          AREA ||i.queue_get_next_free||, CODE, READONLY, ALIGN=2

                  queue_get_next_free PROC
;;;242    // Additionally, increases the number of elements stored in the queue.
;;;243    static bool queue_get_next_free(fs_op_t ** p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245        uint32_t idx;
;;;246    
;;;247        if (m_queue.count == FS_QUEUE_SIZE)
000004  4817              LDR      r0,|L13.100|
000006  6e40              LDR      r0,[r0,#0x64]  ; m_queue
000008  2804              CMP      r0,#4
00000a  d101              BNE      |L13.16|
;;;248        {
;;;249            return false;
00000c  2000              MOVS     r0,#0
                  |L13.14|
;;;250        }
;;;251    
;;;252        idx = ((m_queue.rp + m_queue.count) < FS_QUEUE_SIZE) ?
;;;253               (m_queue.rp + m_queue.count) : ((m_queue.rp + m_queue.count)-FS_QUEUE_SIZE);
;;;254    
;;;255        m_queue.count++;
;;;256    
;;;257        // Zero the element so that unassigned fields will be zero.
;;;258        memset(&m_queue.op[idx], 0x00, sizeof(fs_op_t));
;;;259    
;;;260        *p_op = &m_queue.op[idx];
;;;261    
;;;262        return true;
;;;263    }
00000e  bd70              POP      {r4-r6,pc}
                  |L13.16|
000010  4814              LDR      r0,|L13.100|
000012  6e00              LDR      r0,[r0,#0x60]         ;252  ; m_queue
000014  4913              LDR      r1,|L13.100|
000016  6e49              LDR      r1,[r1,#0x64]         ;252  ; m_queue
000018  4408              ADD      r0,r0,r1              ;252
00001a  2804              CMP      r0,#4                 ;252
00001c  d205              BCS      |L13.42|
00001e  4811              LDR      r0,|L13.100|
000020  6e00              LDR      r0,[r0,#0x60]         ;253  ; m_queue
000022  4910              LDR      r1,|L13.100|
000024  6e49              LDR      r1,[r1,#0x64]         ;253  ; m_queue
000026  4408              ADD      r0,r0,r1              ;253
000028  e005              B        |L13.54|
                  |L13.42|
00002a  480e              LDR      r0,|L13.100|
00002c  6e00              LDR      r0,[r0,#0x60]         ;253  ; m_queue
00002e  490d              LDR      r1,|L13.100|
000030  6e49              LDR      r1,[r1,#0x64]         ;253  ; m_queue
000032  4408              ADD      r0,r0,r1              ;253
000034  1f00              SUBS     r0,r0,#4              ;253
                  |L13.54|
000036  4605              MOV      r5,r0                 ;253
000038  480a              LDR      r0,|L13.100|
00003a  6e40              LDR      r0,[r0,#0x64]         ;255  ; m_queue
00003c  1c40              ADDS     r0,r0,#1              ;255
00003e  4909              LDR      r1,|L13.100|
000040  6648              STR      r0,[r1,#0x64]         ;255  ; m_queue
000042  eb050145          ADD      r1,r5,r5,LSL #1       ;258
000046  4a07              LDR      r2,|L13.100|
000048  eb0200c1          ADD      r0,r2,r1,LSL #3       ;258
00004c  2118              MOVS     r1,#0x18              ;258
00004e  f7fffffe          BL       __aeabi_memclr4
000052  eb050045          ADD      r0,r5,r5,LSL #1       ;260
000056  4903              LDR      r1,|L13.100|
000058  eb0100c0          ADD      r0,r1,r0,LSL #3       ;260
00005c  6020              STR      r0,[r4,#0]            ;260
00005e  2001              MOVS     r0,#1                 ;262
000060  e7d5              B        |L13.14|
;;;264    
                          ENDP

000062  0000              DCW      0x0000
                  |L13.100|
                          DCD      m_queue

                          AREA ||i.queue_process||, CODE, READONLY, ALIGN=2

                  queue_process PROC
;;;119    // Processes the current element in the queue. If the queue is empty, does nothing.
;;;120    static void queue_process(void)
000000  b570              PUSH     {r4-r6,lr}
;;;121    {
;;;122        uint32_t         ret;
;;;123        fs_op_t  * const p_op = &m_queue.op[m_queue.rp];
000002  4818              LDR      r0,|L14.100|
000004  6e00              LDR      r0,[r0,#0x60]  ; m_queue
000006  eb000040          ADD      r0,r0,r0,LSL #1
00000a  4916              LDR      r1,|L14.100|
00000c  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;124    
;;;125        if (m_queue.count > 0)
000010  4608              MOV      r0,r1
000012  6e40              LDR      r0,[r0,#0x64]  ; m_queue
000014  b1f8              CBZ      r0,|L14.86|
;;;126        {
;;;127            switch (p_op->op_code)
000016  7a28              LDRB     r0,[r5,#8]
000018  2801              CMP      r0,#1
00001a  d002              BEQ      |L14.34|
00001c  2802              CMP      r0,#2
00001e  d10a              BNE      |L14.54|
000020  e004              B        |L14.44|
                  |L14.34|
;;;128            {
;;;129                case FS_OP_STORE:
;;;130                    ret = store_execute(p_op);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       store_execute
000028  4604              MOV      r4,r0
;;;131                    break;
00002a  e006              B        |L14.58|
                  |L14.44|
;;;132    
;;;133                case FS_OP_ERASE:
;;;134                    ret = erase_execute(p_op);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       erase_execute
000032  4604              MOV      r4,r0
;;;135                    break;
000034  e001              B        |L14.58|
                  |L14.54|
;;;136    
;;;137                 default:
;;;138                    ret = FS_ERR_INTERNAL;
000036  2409              MOVS     r4,#9
;;;139                    break;
000038  bf00              NOP      
                  |L14.58|
00003a  bf00              NOP                            ;131
;;;140            }
;;;141    
;;;142            // There is a pending flash operation which was not initiated by this module.
;;;143            // Stop processing the queue and wait for a system event.
;;;144            if (ret == NRF_ERROR_BUSY)
00003c  2c11              CMP      r4,#0x11
00003e  d10b              BNE      |L14.88|
;;;145            {
;;;146                m_flags &= ~FS_FLAG_PROCESSING;
000040  4809              LDR      r0,|L14.104|
000042  7800              LDRB     r0,[r0,#0]  ; m_flags
000044  f0200002          BIC      r0,r0,#2
000048  4907              LDR      r1,|L14.104|
00004a  7008              STRB     r0,[r1,#0]
;;;147                m_flags |= FS_FLAG_FLASH_REQ_PENDING;
00004c  4608              MOV      r0,r1
00004e  7800              LDRB     r0,[r0,#0]  ; m_flags
000050  f0400004          ORR      r0,r0,#4
000054  7008              STRB     r0,[r1,#0]
                  |L14.86|
000056  e004              B        |L14.98|
                  |L14.88|
;;;148            }
;;;149            else if (ret != NRF_SUCCESS)
000058  b11c              CBZ      r4,|L14.98|
;;;150            {
;;;151                // An error has occurred.
;;;152                send_event(p_op, FS_ERR_INTERNAL);
00005a  2109              MOVS     r1,#9
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       send_event
                  |L14.98|
;;;153            }
;;;154            else
;;;155            {
;;;156                // Operation is executing.
;;;157            }
;;;158        }
;;;159    }
000062  bd70              POP      {r4-r6,pc}
;;;160    
                          ENDP

                  |L14.100|
                          DCD      m_queue
                  |L14.104|
                          DCD      m_flags

                          AREA ||i.queue_start||, CODE, READONLY, ALIGN=2

                  queue_start PROC
;;;163    // outside this module. Returns immediately otherwise.
;;;164    static void queue_start(void)
000000  b510              PUSH     {r4,lr}
;;;165    {
;;;166        if (!(m_flags & FS_FLAG_PROCESSING) &&
000002  4809              LDR      r0,|L15.40|
000004  7800              LDRB     r0,[r0,#0]  ; m_flags
000006  f0000002          AND      r0,r0,#2
00000a  b960              CBNZ     r0,|L15.38|
;;;167            !(m_flags & FS_FLAG_FLASH_REQ_PENDING))
00000c  4806              LDR      r0,|L15.40|
00000e  7800              LDRB     r0,[r0,#0]  ; m_flags
000010  f0000004          AND      r0,r0,#4
000014  b938              CBNZ     r0,|L15.38|
;;;168        {
;;;169            m_flags |= FS_FLAG_PROCESSING;
000016  4804              LDR      r0,|L15.40|
000018  7800              LDRB     r0,[r0,#0]  ; m_flags
00001a  f0400002          ORR      r0,r0,#2
00001e  4902              LDR      r1,|L15.40|
000020  7008              STRB     r0,[r1,#0]
;;;170            queue_process();
000022  f7fffffe          BL       queue_process
                  |L15.38|
;;;171        }
;;;172    }
000026  bd10              POP      {r4,pc}
;;;173    
                          ENDP

                  |L15.40|
                          DCD      m_flags

                          AREA ||i.send_event||, CODE, READONLY, ALIGN=1

                  send_event PROC
;;;28     // Sends events to the application.
;;;29     static void send_event(fs_op_t const * const p_op, fs_ret_t result)
000000  b57f              PUSH     {r0-r6,lr}
;;;30     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;31         fs_evt_t evt;
;;;32         memset(&evt, 0x00, sizeof(fs_evt_t));
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  9001              STR      r0,[sp,#4]
00000c  9002              STR      r0,[sp,#8]
00000e  9003              STR      r0,[sp,#0xc]
;;;33     
;;;34         switch (p_op->op_code)
000010  7a20              LDRB     r0,[r4,#8]
000012  2801              CMP      r0,#1
000014  d002              BEQ      |L16.28|
000016  2802              CMP      r0,#2
000018  d116              BNE      |L16.72|
00001a  e008              B        |L16.46|
                  |L16.28|
;;;35         {
;;;36             case FS_OP_STORE:
;;;37                 evt.id                 = FS_EVT_STORE;
00001c  2000              MOVS     r0,#0
00001e  f88d0000          STRB     r0,[sp,#0]
;;;38                 evt.store.p_data       = p_op->store.p_dest;
000022  6920              LDR      r0,[r4,#0x10]
000024  9002              STR      r0,[sp,#8]
;;;39                 evt.store.length_words = p_op->store.length_words;
000026  8aa1              LDRH     r1,[r4,#0x14]
000028  f8ad100c          STRH     r1,[sp,#0xc]
;;;40                 break;
00002c  e00d              B        |L16.74|
                  |L16.46|
;;;41     
;;;42             case FS_OP_ERASE:
;;;43                 evt.id               = FS_EVT_ERASE;
00002e  2001              MOVS     r0,#1
000030  f88d0000          STRB     r0,[sp,#0]
;;;44                 evt.erase.first_page = p_op->erase.page - p_op->erase.pages_erased;
000034  89a1              LDRH     r1,[r4,#0xc]
000036  89e0              LDRH     r0,[r4,#0xe]
000038  1a08              SUBS     r0,r1,r0
00003a  b280              UXTH     r0,r0
00003c  f8ad0008          STRH     r0,[sp,#8]
;;;45                 evt.erase.last_page  = p_op->erase.page;
000040  89a1              LDRH     r1,[r4,#0xc]
000042  f8ad100a          STRH     r1,[sp,#0xa]
;;;46                 break;
000046  e000              B        |L16.74|
                  |L16.72|
;;;47     
;;;48             default:
;;;49                 // Should not happen.
;;;50                 break;
000048  bf00              NOP      
                  |L16.74|
00004a  bf00              NOP                            ;40
;;;51         }
;;;52         evt.p_context = p_op->p_context;
00004c  6860              LDR      r0,[r4,#4]
00004e  9001              STR      r0,[sp,#4]
;;;53     
;;;54         p_op->p_config->callback(&evt, result);
000050  6820              LDR      r0,[r4,#0]
000052  4629              MOV      r1,r5
000054  6882              LDR      r2,[r0,#8]
000056  4668              MOV      r0,sp
000058  4790              BLX      r2
;;;55     }
00005a  bd7f              POP      {r0-r6,pc}
;;;56     
                          ENDP


                          AREA ||i.store_execute||, CODE, READONLY, ALIGN=1

                  store_execute PROC
;;;76     // Executes a store operation.
;;;77     static uint32_t store_execute(fs_op_t const * const p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;78     {
000002  4604              MOV      r4,r0
;;;79         uint16_t chunk_len;
;;;80     
;;;81         if ((p_op->store.length_words - p_op->store.offset) < FS_MAX_WRITE_SIZE_WORDS)
000004  8aa1              LDRH     r1,[r4,#0x14]
000006  8ae0              LDRH     r0,[r4,#0x16]
000008  1a08              SUBS     r0,r1,r0
00000a  f5b06f80          CMP      r0,#0x400
00000e  da04              BGE      |L17.26|
;;;82         {
;;;83             chunk_len = p_op->store.length_words - p_op->store.offset;
000010  8aa1              LDRH     r1,[r4,#0x14]
000012  8ae0              LDRH     r0,[r4,#0x16]
000014  1a08              SUBS     r0,r1,r0
000016  b285              UXTH     r5,r0
000018  e001              B        |L17.30|
                  |L17.26|
;;;84         }
;;;85         else
;;;86         {
;;;87             chunk_len = FS_MAX_WRITE_SIZE_WORDS;
00001a  f44f6580          MOV      r5,#0x400
                  |L17.30|
;;;88         }
;;;89     
;;;90         return sd_flash_write((uint32_t*)p_op->store.p_dest + p_op->store.offset,
00001e  8ae2              LDRH     r2,[r4,#0x16]
000020  68e3              LDR      r3,[r4,#0xc]
000022  eb030182          ADD      r1,r3,r2,LSL #2
000026  6923              LDR      r3,[r4,#0x10]
000028  eb030082          ADD      r0,r3,r2,LSL #2
00002c  462a              MOV      r2,r5
00002e  df29              SVC      #0x29
;;;91                               (uint32_t*)p_op->store.p_src  + p_op->store.offset,
;;;92                               chunk_len);
;;;93     }
000030  bd70              POP      {r4-r6,pc}
;;;94     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_queue
                          %        104

                          AREA ||.data||, DATA, ALIGN=0

                  m_flags
000000  00                DCB      0x00
                  m_retry_count
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\fstorage\\fstorage.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_fstorage_c_fs_init____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_fstorage_c_fs_init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_fstorage_c_fs_init____REVSH|
#line 402
|__asm___10_fstorage_c_fs_init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_fstorage_c_fs_init____RRX|
#line 587
|__asm___10_fstorage_c_fs_init____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
