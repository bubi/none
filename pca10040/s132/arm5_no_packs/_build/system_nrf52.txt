; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\system_nrf52.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\system_nrf52.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\system_nrf52.crf RTE\Device\nRF52832_xxAA\system_nrf52.c]
                          THUMB

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;57     
;;;58     void SystemCoreClockUpdate(void)
000000  4801              LDR      r0,|L1.8|
;;;59     {
;;;60         SystemCoreClock = __SYSTEM_CLOCK_64M;
000002  4902              LDR      r1,|L1.12|
000004  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;61     }
000006  4770              BX       lr
;;;62     
                          ENDP

                  |L1.8|
                          DCD      0x03d09000
                  |L1.12|
                          DCD      SystemCoreClock

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;62     
;;;63     void SystemInit(void)
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65         /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
;;;66            for your device located at https://infocenter.nordicsemi.com/ */
;;;67         if (errata_16()){
000002  f7fffffe          BL       errata_16
000006  b110              CBZ      r0,|L2.14|
;;;68             *(volatile uint32_t *)0x4007C074 = 3131961357ul;
000008  4882              LDR      r0,|L2.532|
00000a  4983              LDR      r1,|L2.536|
00000c  6748              STR      r0,[r1,#0x74]
                  |L2.14|
;;;69         }
;;;70     
;;;71         /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
;;;72            for your device located at https://infocenter.nordicsemi.com/ */
;;;73         if (errata_31()){
00000e  f7fffffe          BL       errata_31
000012  b128              CBZ      r0,|L2.32|
;;;74             *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
000014  4881              LDR      r0,|L2.540|
000016  6800              LDR      r0,[r0,#0]
000018  f3c03042          UBFX     r0,r0,#13,#3
00001c  4980              LDR      r1,|L2.544|
00001e  6008              STR      r0,[r1,#0]
                  |L2.32|
;;;75         }
;;;76     
;;;77         /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
;;;78            for your device located at https://infocenter.nordicsemi.com/ */
;;;79         if (errata_32()){
000020  f7fffffe          BL       errata_32
000024  b128              CBZ      r0,|L2.50|
;;;80             CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
000026  487f              LDR      r0,|L2.548|
000028  6800              LDR      r0,[r0,#0]
00002a  f0207080          BIC      r0,r0,#0x1000000
00002e  497d              LDR      r1,|L2.548|
000030  6008              STR      r0,[r1,#0]
                  |L2.50|
;;;81         }
;;;82     
;;;83         /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
;;;84            for your device located at https://infocenter.nordicsemi.com/  */
;;;85         if (errata_36()){
000032  f7fffffe          BL       errata_36
000036  b148              CBZ      r0,|L2.76|
;;;86             NRF_CLOCK->EVENTS_DONE = 0;
000038  2000              MOVS     r0,#0
00003a  497b              LDR      r1,|L2.552|
00003c  6008              STR      r0,[r1,#0]
;;;87             NRF_CLOCK->EVENTS_CTTO = 0;
00003e  f04f4180          MOV      r1,#0x40000000
000042  f8c10110          STR      r0,[r1,#0x110]
;;;88             NRF_CLOCK->CTIV = 0;
000046  4976              LDR      r1,|L2.544|
000048  1f09              SUBS     r1,r1,#4
00004a  6008              STR      r0,[r1,#0]
                  |L2.76|
;;;89         }
;;;90     
;;;91         /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
;;;92            for your device located at https://infocenter.nordicsemi.com/  */
;;;93         if (errata_37()){
00004c  f7fffffe          BL       errata_37
000050  b118              CBZ      r0,|L2.90|
;;;94             *(volatile uint32_t *)0x400005A0 = 0x3;
000052  2003              MOVS     r0,#3
000054  4972              LDR      r1,|L2.544|
000056  3164              ADDS     r1,r1,#0x64
000058  6008              STR      r0,[r1,#0]
                  |L2.90|
;;;95         }
;;;96     
;;;97         /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
;;;98            for your device located at https://infocenter.nordicsemi.com/  */
;;;99         if (errata_57()){
00005a  f7fffffe          BL       errata_57
00005e  b168              CBZ      r0,|L2.124|
;;;100            *(volatile uint32_t *)0x40005610 = 0x00000005;
000060  2005              MOVS     r0,#5
000062  4972              LDR      r1,|L2.556|
000064  6008              STR      r0,[r1,#0]
;;;101            *(volatile uint32_t *)0x40005688 = 0x00000001;
000066  2001              MOVS     r0,#1
000068  4970              LDR      r1,|L2.556|
00006a  3178              ADDS     r1,r1,#0x78
00006c  6008              STR      r0,[r1,#0]
;;;102            *(volatile uint32_t *)0x40005618 = 0x00000000;
00006e  2000              MOVS     r0,#0
000070  496e              LDR      r1,|L2.556|
000072  3108              ADDS     r1,r1,#8
000074  6008              STR      r0,[r1,#0]
;;;103            *(volatile uint32_t *)0x40005614 = 0x0000003F;
000076  203f              MOVS     r0,#0x3f
000078  1f09              SUBS     r1,r1,#4
00007a  6008              STR      r0,[r1,#0]
                  |L2.124|
;;;104        }
;;;105    
;;;106        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
;;;107           for your device located at https://infocenter.nordicsemi.com/  */
;;;108        if (errata_66()){
00007c  f7fffffe          BL       errata_66
000080  2800              CMP      r0,#0
000082  d055              BEQ      |L2.304|
;;;109            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
000084  486a              LDR      r0,|L2.560|
000086  6800              LDR      r0,[r0,#0]
000088  496a              LDR      r1,|L2.564|
00008a  6008              STR      r0,[r1,#0]
;;;110            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
00008c  4868              LDR      r0,|L2.560|
00008e  1d00              ADDS     r0,r0,#4
000090  6800              LDR      r0,[r0,#0]
000092  1d09              ADDS     r1,r1,#4
000094  6008              STR      r0,[r1,#0]
;;;111            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
000096  4866              LDR      r0,|L2.560|
000098  3008              ADDS     r0,r0,#8
00009a  6800              LDR      r0,[r0,#0]
00009c  1d09              ADDS     r1,r1,#4
00009e  6008              STR      r0,[r1,#0]
;;;112            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
0000a0  4863              LDR      r0,|L2.560|
0000a2  300c              ADDS     r0,r0,#0xc
0000a4  6800              LDR      r0,[r0,#0]
0000a6  1d09              ADDS     r1,r1,#4
0000a8  6008              STR      r0,[r1,#0]
;;;113            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
0000aa  4861              LDR      r0,|L2.560|
0000ac  3010              ADDS     r0,r0,#0x10
0000ae  6800              LDR      r0,[r0,#0]
0000b0  1d09              ADDS     r1,r1,#4
0000b2  6008              STR      r0,[r1,#0]
;;;114            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
0000b4  485e              LDR      r0,|L2.560|
0000b6  3014              ADDS     r0,r0,#0x14
0000b8  6800              LDR      r0,[r0,#0]
0000ba  1d09              ADDS     r1,r1,#4
0000bc  6008              STR      r0,[r1,#0]
;;;115            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
0000be  485c              LDR      r0,|L2.560|
0000c0  3018              ADDS     r0,r0,#0x18
0000c2  6800              LDR      r0,[r0,#0]
0000c4  495b              LDR      r1,|L2.564|
0000c6  3120              ADDS     r1,r1,#0x20
0000c8  6008              STR      r0,[r1,#0]
;;;116            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
0000ca  4859              LDR      r0,|L2.560|
0000cc  301c              ADDS     r0,r0,#0x1c
0000ce  6800              LDR      r0,[r0,#0]
0000d0  1d09              ADDS     r1,r1,#4
0000d2  6008              STR      r0,[r1,#0]
;;;117            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
0000d4  4856              LDR      r0,|L2.560|
0000d6  3020              ADDS     r0,r0,#0x20
0000d8  6800              LDR      r0,[r0,#0]
0000da  1d09              ADDS     r1,r1,#4
0000dc  6008              STR      r0,[r1,#0]
;;;118            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
0000de  4854              LDR      r0,|L2.560|
0000e0  3024              ADDS     r0,r0,#0x24
0000e2  6800              LDR      r0,[r0,#0]
0000e4  1d09              ADDS     r1,r1,#4
0000e6  6008              STR      r0,[r1,#0]
;;;119            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
0000e8  4851              LDR      r0,|L2.560|
0000ea  3028              ADDS     r0,r0,#0x28
0000ec  6800              LDR      r0,[r0,#0]
0000ee  1d09              ADDS     r1,r1,#4
0000f0  6008              STR      r0,[r1,#0]
;;;120            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
0000f2  484f              LDR      r0,|L2.560|
0000f4  302c              ADDS     r0,r0,#0x2c
0000f6  6800              LDR      r0,[r0,#0]
0000f8  1d09              ADDS     r1,r1,#4
0000fa  6008              STR      r0,[r1,#0]
;;;121            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
0000fc  484c              LDR      r0,|L2.560|
0000fe  3030              ADDS     r0,r0,#0x30
000100  6800              LDR      r0,[r0,#0]
000102  494c              LDR      r1,|L2.564|
000104  3140              ADDS     r1,r1,#0x40
000106  6008              STR      r0,[r1,#0]
;;;122            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
000108  4849              LDR      r0,|L2.560|
00010a  3034              ADDS     r0,r0,#0x34
00010c  6800              LDR      r0,[r0,#0]
00010e  1d09              ADDS     r1,r1,#4
000110  6008              STR      r0,[r1,#0]
;;;123            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
000112  4847              LDR      r0,|L2.560|
000114  3038              ADDS     r0,r0,#0x38
000116  6800              LDR      r0,[r0,#0]
000118  1d09              ADDS     r1,r1,#4
00011a  6008              STR      r0,[r1,#0]
;;;124            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
00011c  4844              LDR      r0,|L2.560|
00011e  303c              ADDS     r0,r0,#0x3c
000120  6800              LDR      r0,[r0,#0]
000122  1d09              ADDS     r1,r1,#4
000124  6008              STR      r0,[r1,#0]
;;;125            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
000126  4842              LDR      r0,|L2.560|
000128  3040              ADDS     r0,r0,#0x40
00012a  6800              LDR      r0,[r0,#0]
00012c  1d09              ADDS     r1,r1,#4
00012e  6008              STR      r0,[r1,#0]
                  |L2.304|
;;;126        }
;;;127    
;;;128        /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
;;;129           for your device located at https://infocenter.nordicsemi.com/  */
;;;130        if (errata_108()){
000130  f7fffffe          BL       errata_108
000134  b130              CBZ      r0,|L2.324|
;;;131            *(volatile uint32_t *)0x40000EE4 = *(volatile uint32_t *)0x10000258 & 0x0000004F;
000136  4839              LDR      r0,|L2.540|
000138  3014              ADDS     r0,r0,#0x14
00013a  6800              LDR      r0,[r0,#0]
00013c  f000004f          AND      r0,r0,#0x4f
000140  493d              LDR      r1,|L2.568|
000142  6008              STR      r0,[r1,#0]
                  |L2.324|
;;;132        }
;;;133        
;;;134        /* Enable the FPU if the compiler used floating point unit instructions. __FPU_USED is a MACRO defined by the
;;;135         * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
;;;136         * operations are not used in your code. */
;;;137        #if (__FPU_USED == 1)
;;;138            SCB->CPACR |= (3UL << 20) | (3UL << 22);
000144  4837              LDR      r0,|L2.548|
000146  3874              SUBS     r0,r0,#0x74
000148  6800              LDR      r0,[r0,#0]
00014a  f4400070          ORR      r0,r0,#0xf00000
00014e  4935              LDR      r1,|L2.548|
000150  3974              SUBS     r1,r1,#0x74
000152  6008              STR      r0,[r1,#0]
;;;139            __DSB();
000154  bf00              NOP      
000156  bf00              NOP      
000158  bf00              NOP      
00015a  f3bf8f4f          DSB      
00015e  bf00              NOP      
000160  bf00              NOP      
000162  bf00              NOP      
;;;140            __ISB();
000164  bf00              NOP      
000166  bf00              NOP      
000168  bf00              NOP      
00016a  f3bf8f6f          ISB      
00016e  bf00              NOP      
000170  bf00              NOP      
000172  bf00              NOP      
;;;141        #endif
;;;142    
;;;143        /* Configure NFCT pins as GPIOs if NFCT is not to be used in your code. If CONFIG_NFCT_PINS_AS_GPIOS is not defined,
;;;144           two GPIOs (see Product Specification to see which ones) will be reserved for NFC and will not be available as
;;;145           normal GPIOs. */
;;;146        #if defined (CONFIG_NFCT_PINS_AS_GPIOS)
;;;147            if ((NRF_UICR->NFCPINS & UICR_NFCPINS_PROTECT_Msk) == (UICR_NFCPINS_PROTECT_NFC << UICR_NFCPINS_PROTECT_Pos)){
;;;148                NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
;;;149                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
;;;150                NRF_UICR->NFCPINS &= ~UICR_NFCPINS_PROTECT_Msk;
;;;151                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
;;;152                NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
;;;153                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
;;;154                NVIC_SystemReset();
;;;155            }
;;;156        #endif
;;;157    
;;;158        /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
;;;159          defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
;;;160          reserved for PinReset and not available as normal GPIO. */
;;;161        #if defined (CONFIG_GPIO_AS_PINRESET)
;;;162            if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
000174  4831              LDR      r0,|L2.572|
000176  6800              LDR      r0,[r0,#0]
000178  f0004000          AND      r0,r0,#0x80000000
00017c  b930              CBNZ     r0,|L2.396|
;;;163                ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
00017e  482f              LDR      r0,|L2.572|
000180  1d00              ADDS     r0,r0,#4
000182  6800              LDR      r0,[r0,#0]
000184  f0004000          AND      r0,r0,#0x80000000
000188  2800              CMP      r0,#0
00018a  d040              BEQ      |L2.526|
                  |L2.396|
;;;164                NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
00018c  2001              MOVS     r0,#1
00018e  492c              LDR      r1,|L2.576|
000190  6008              STR      r0,[r1,#0]
;;;165                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
000192  bf00              NOP      
                  |L2.404|
000194  482b              LDR      r0,|L2.580|
000196  6800              LDR      r0,[r0,#0]
000198  2800              CMP      r0,#0
00019a  d0fb              BEQ      |L2.404|
;;;166                NRF_UICR->PSELRESET[0] = 21;
00019c  2015              MOVS     r0,#0x15
00019e  4927              LDR      r1,|L2.572|
0001a0  6008              STR      r0,[r1,#0]
;;;167                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
0001a2  bf00              NOP      
                  |L2.420|
0001a4  4827              LDR      r0,|L2.580|
0001a6  6800              LDR      r0,[r0,#0]
0001a8  2800              CMP      r0,#0
0001aa  d0fb              BEQ      |L2.420|
;;;168                NRF_UICR->PSELRESET[1] = 21;
0001ac  2115              MOVS     r1,#0x15
0001ae  4823              LDR      r0,|L2.572|
0001b0  1d00              ADDS     r0,r0,#4
0001b2  6001              STR      r1,[r0,#0]
;;;169                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
0001b4  bf00              NOP      
                  |L2.438|
0001b6  4823              LDR      r0,|L2.580|
0001b8  6800              LDR      r0,[r0,#0]
0001ba  2800              CMP      r0,#0
0001bc  d0fb              BEQ      |L2.438|
;;;170                NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
0001be  2000              MOVS     r0,#0
0001c0  491f              LDR      r1,|L2.576|
0001c2  6008              STR      r0,[r1,#0]
;;;171                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
0001c4  bf00              NOP      
                  |L2.454|
0001c6  481f              LDR      r0,|L2.580|
0001c8  6800              LDR      r0,[r0,#0]
0001ca  2800              CMP      r0,#0
0001cc  d0fb              BEQ      |L2.454|
;;;172                NVIC_SystemReset();
0001ce  bf00              NOP      
0001d0  bf00              NOP      
0001d2  bf00              NOP      
0001d4  bf00              NOP      
0001d6  bf00              NOP      
0001d8  f3bf8f4f          DSB      
0001dc  bf00              NOP      
0001de  bf00              NOP      
0001e0  bf00              NOP      
0001e2  4810              LDR      r0,|L2.548|
0001e4  38f0              SUBS     r0,r0,#0xf0
0001e6  6800              LDR      r0,[r0,#0]
0001e8  f40060e0          AND      r0,r0,#0x700
0001ec  4916              LDR      r1,|L2.584|
0001ee  4308              ORRS     r0,r0,r1
0001f0  1d00              ADDS     r0,r0,#4
0001f2  490c              LDR      r1,|L2.548|
0001f4  39f0              SUBS     r1,r1,#0xf0
0001f6  6008              STR      r0,[r1,#0]
0001f8  bf00              NOP      
0001fa  bf00              NOP      
0001fc  bf00              NOP      
0001fe  f3bf8f4f          DSB      
000202  bf00              NOP      
000204  bf00              NOP      
000206  bf00              NOP      
000208  bf00              NOP      
                  |L2.522|
00020a  bf00              NOP      
00020c  e7fd              B        |L2.522|
                  |L2.526|
;;;173            }
;;;174        #endif
;;;175    
;;;176        /* Enable SWO trace functionality. If ENABLE_SWO is not defined, SWO pin will be used as GPIO (see Product
;;;177           Specification to see which one). */
;;;178        #if defined (ENABLE_SWO)
;;;179            CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
;;;180            NRF_CLOCK->TRACECONFIG |= CLOCK_TRACECONFIG_TRACEMUX_Serial << CLOCK_TRACECONFIG_TRACEMUX_Pos;
;;;181            NRF_P0->PIN_CNF[18] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;182        #endif
;;;183    
;;;184        /* Enable Trace functionality. If ENABLE_TRACE is not defined, TRACE pins will be used as GPIOs (see Product
;;;185           Specification to see which ones). */
;;;186        #if defined (ENABLE_TRACE)
;;;187            CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
;;;188            NRF_CLOCK->TRACECONFIG |= CLOCK_TRACECONFIG_TRACEMUX_Parallel << CLOCK_TRACECONFIG_TRACEMUX_Pos;
;;;189            NRF_P0->PIN_CNF[14] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;190            NRF_P0->PIN_CNF[15] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;191            NRF_P0->PIN_CNF[16] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;192            NRF_P0->PIN_CNF[18] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;193            NRF_P0->PIN_CNF[20] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;194        #endif
;;;195    
;;;196        SystemCoreClockUpdate();
00020e  f7fffffe          BL       SystemCoreClockUpdate
;;;197    }
000212  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  |L2.532|
                          DCD      0xbaadf00d
                  |L2.536|
                          DCD      0x4007c000
                  |L2.540|
                          DCD      0x10000244
                  |L2.544|
                          DCD      0x4000053c
                  |L2.548|
                          DCD      0xe000edfc
                  |L2.552|
                          DCD      0x4000010c
                  |L2.556|
                          DCD      0x40005610
                  |L2.560|
                          DCD      0x10000404
                  |L2.564|
                          DCD      0x4000c520
                  |L2.568|
                          DCD      0x40000ee4
                  |L2.572|
                          DCD      0x10001200
                  |L2.576|
                          DCD      0x4001e504
                  |L2.580|
                          DCD      0x4001e400
                  |L2.584|
                          DCD      0x05fa0000

                          AREA ||i.errata_108||, CODE, READONLY, ALIGN=2

                  errata_108 PROC
;;;289    
;;;290    static bool errata_108(void)
000000  4813              LDR      r0,|L3.80|
;;;291    {
;;;292        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d120              BNE      |L3.74|
000008  4811              LDR      r0,|L3.80|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b9d0              CBNZ     r0,|L3.74|
;;;293            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  480e              LDR      r0,|L3.80|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L3.38|
;;;294                return true;
000022  2001              MOVS     r0,#1
                  |L3.36|
;;;295            }
;;;296            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
;;;297                return true;
;;;298            }
;;;299            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
;;;300                return true;
;;;301            }
;;;302        }
;;;303    
;;;304        return false;
;;;305    }
000024  4770              BX       lr
                  |L3.38|
000026  480a              LDR      r0,|L3.80|
000028  3008              ADDS     r0,r0,#8              ;296
00002a  7800              LDRB     r0,[r0,#0]            ;296
00002c  f00000f0          AND      r0,r0,#0xf0           ;296
000030  2840              CMP      r0,#0x40              ;296
000032  d101              BNE      |L3.56|
000034  2001              MOVS     r0,#1                 ;297
000036  e7f5              B        |L3.36|
                  |L3.56|
000038  4805              LDR      r0,|L3.80|
00003a  3008              ADDS     r0,r0,#8              ;299
00003c  7800              LDRB     r0,[r0,#0]            ;299
00003e  f00000f0          AND      r0,r0,#0xf0           ;299
000042  2850              CMP      r0,#0x50              ;299
000044  d101              BNE      |L3.74|
000046  2001              MOVS     r0,#1                 ;300
000048  e7ec              B        |L3.36|
                  |L3.74|
00004a  2000              MOVS     r0,#0                 ;304
00004c  e7ea              B        |L3.36|
;;;306    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      0xf0000fe0

                          AREA ||i.errata_16||, CODE, READONLY, ALIGN=2

                  errata_16 PROC
;;;199    
;;;200    static bool errata_16(void)
000000  480a              LDR      r0,|L4.44|
;;;201    {
;;;202        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d10e              BNE      |L4.38|
000008  4808              LDR      r0,|L4.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b940              CBNZ     r0,|L4.38|
;;;203            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  4805              LDR      r0,|L4.44|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L4.38|
;;;204                return true;
000022  2001              MOVS     r0,#1
                  |L4.36|
;;;205            }
;;;206        }
;;;207    
;;;208        return false;
;;;209    }
000024  4770              BX       lr
                  |L4.38|
000026  2000              MOVS     r0,#0                 ;208
000028  e7fc              B        |L4.36|
;;;210    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0xf0000fe0

                          AREA ||i.errata_31||, CODE, READONLY, ALIGN=2

                  errata_31 PROC
;;;210    
;;;211    static bool errata_31(void)
000000  4813              LDR      r0,|L5.80|
;;;212    {
;;;213        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d120              BNE      |L5.74|
000008  4811              LDR      r0,|L5.80|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b9d0              CBNZ     r0,|L5.74|
;;;214            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  480e              LDR      r0,|L5.80|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L5.38|
;;;215                return true;
000022  2001              MOVS     r0,#1
                  |L5.36|
;;;216            }
;;;217            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
;;;218                return true;
;;;219            }
;;;220            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
;;;221                return true;
;;;222            }
;;;223        }
;;;224    
;;;225        return false;
;;;226    }
000024  4770              BX       lr
                  |L5.38|
000026  480a              LDR      r0,|L5.80|
000028  3008              ADDS     r0,r0,#8              ;217
00002a  7800              LDRB     r0,[r0,#0]            ;217
00002c  f00000f0          AND      r0,r0,#0xf0           ;217
000030  2840              CMP      r0,#0x40              ;217
000032  d101              BNE      |L5.56|
000034  2001              MOVS     r0,#1                 ;218
000036  e7f5              B        |L5.36|
                  |L5.56|
000038  4805              LDR      r0,|L5.80|
00003a  3008              ADDS     r0,r0,#8              ;220
00003c  7800              LDRB     r0,[r0,#0]            ;220
00003e  f00000f0          AND      r0,r0,#0xf0           ;220
000042  2850              CMP      r0,#0x50              ;220
000044  d101              BNE      |L5.74|
000046  2001              MOVS     r0,#1                 ;221
000048  e7ec              B        |L5.36|
                  |L5.74|
00004a  2000              MOVS     r0,#0                 ;225
00004c  e7ea              B        |L5.36|
;;;227    
                          ENDP

00004e  0000              DCW      0x0000
                  |L5.80|
                          DCD      0xf0000fe0

                          AREA ||i.errata_32||, CODE, READONLY, ALIGN=2

                  errata_32 PROC
;;;227    
;;;228    static bool errata_32(void)
000000  480a              LDR      r0,|L6.44|
;;;229    {
;;;230        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d10e              BNE      |L6.38|
000008  4808              LDR      r0,|L6.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b940              CBNZ     r0,|L6.38|
;;;231            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  4805              LDR      r0,|L6.44|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L6.38|
;;;232                return true;
000022  2001              MOVS     r0,#1
                  |L6.36|
;;;233            }
;;;234        }
;;;235    
;;;236        return false;
;;;237    }
000024  4770              BX       lr
                  |L6.38|
000026  2000              MOVS     r0,#0                 ;236
000028  e7fc              B        |L6.36|
;;;238    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0xf0000fe0

                          AREA ||i.errata_36||, CODE, READONLY, ALIGN=2

                  errata_36 PROC
;;;238    
;;;239    static bool errata_36(void)
000000  4813              LDR      r0,|L7.80|
;;;240    {
;;;241        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d120              BNE      |L7.74|
000008  4811              LDR      r0,|L7.80|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b9d0              CBNZ     r0,|L7.74|
;;;242            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  480e              LDR      r0,|L7.80|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L7.38|
;;;243                return true;
000022  2001              MOVS     r0,#1
                  |L7.36|
;;;244            }
;;;245            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
;;;246                return true;
;;;247            }
;;;248            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
;;;249                return true;
;;;250            }
;;;251        }
;;;252    
;;;253        return false;
;;;254    }
000024  4770              BX       lr
                  |L7.38|
000026  480a              LDR      r0,|L7.80|
000028  3008              ADDS     r0,r0,#8              ;245
00002a  7800              LDRB     r0,[r0,#0]            ;245
00002c  f00000f0          AND      r0,r0,#0xf0           ;245
000030  2840              CMP      r0,#0x40              ;245
000032  d101              BNE      |L7.56|
000034  2001              MOVS     r0,#1                 ;246
000036  e7f5              B        |L7.36|
                  |L7.56|
000038  4805              LDR      r0,|L7.80|
00003a  3008              ADDS     r0,r0,#8              ;248
00003c  7800              LDRB     r0,[r0,#0]            ;248
00003e  f00000f0          AND      r0,r0,#0xf0           ;248
000042  2850              CMP      r0,#0x50              ;248
000044  d101              BNE      |L7.74|
000046  2001              MOVS     r0,#1                 ;249
000048  e7ec              B        |L7.36|
                  |L7.74|
00004a  2000              MOVS     r0,#0                 ;253
00004c  e7ea              B        |L7.36|
;;;255    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      0xf0000fe0

                          AREA ||i.errata_37||, CODE, READONLY, ALIGN=2

                  errata_37 PROC
;;;255    
;;;256    static bool errata_37(void)
000000  480a              LDR      r0,|L8.44|
;;;257    {
;;;258        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d10e              BNE      |L8.38|
000008  4808              LDR      r0,|L8.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b940              CBNZ     r0,|L8.38|
;;;259            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  4805              LDR      r0,|L8.44|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L8.38|
;;;260                return true;
000022  2001              MOVS     r0,#1
                  |L8.36|
;;;261            }
;;;262        }
;;;263    
;;;264        return false;
;;;265    }
000024  4770              BX       lr
                  |L8.38|
000026  2000              MOVS     r0,#0                 ;264
000028  e7fc              B        |L8.36|
;;;266    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0xf0000fe0

                          AREA ||i.errata_57||, CODE, READONLY, ALIGN=2

                  errata_57 PROC
;;;266    
;;;267    static bool errata_57(void)
000000  480a              LDR      r0,|L9.44|
;;;268    {
;;;269        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d10e              BNE      |L9.38|
000008  4808              LDR      r0,|L9.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b940              CBNZ     r0,|L9.38|
;;;270            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  4805              LDR      r0,|L9.44|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L9.38|
;;;271                return true;
000022  2001              MOVS     r0,#1
                  |L9.36|
;;;272            }
;;;273        }
;;;274    
;;;275        return false;
;;;276    }
000024  4770              BX       lr
                  |L9.38|
000026  2000              MOVS     r0,#0                 ;275
000028  e7fc              B        |L9.36|
;;;277    
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      0xf0000fe0

                          AREA ||i.errata_66||, CODE, READONLY, ALIGN=2

                  errata_66 PROC
;;;277    
;;;278    static bool errata_66(void)
000000  480a              LDR      r0,|L10.44|
;;;279    {
;;;280        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d10e              BNE      |L10.38|
000008  4808              LDR      r0,|L10.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b940              CBNZ     r0,|L10.38|
;;;281            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
000014  4805              LDR      r0,|L10.44|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2850              CMP      r0,#0x50
000020  d101              BNE      |L10.38|
;;;282                return true;
000022  2001              MOVS     r0,#1
                  |L10.36|
;;;283            }
;;;284        }
;;;285    
;;;286        return false;
;;;287    }
000024  4770              BX       lr
                  |L10.38|
000026  2000              MOVS     r0,#0                 ;286
000028  e7fc              B        |L10.36|
;;;288    
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      0xf0000fe0

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                  ||__tagsym$$used||
                          DCD      0x03d09000

;*** Start embedded assembler ***

#line 1 "RTE\\Device\\nRF52832_xxAA\\system_nrf52.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_system_nrf52_c_5d646a67____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_system_nrf52_c_5d646a67____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_system_nrf52_c_5d646a67____REVSH|
#line 402
|__asm___14_system_nrf52_c_5d646a67____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_system_nrf52_c_5d646a67____RRX|
#line 587
|__asm___14_system_nrf52_c_5d646a67____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
