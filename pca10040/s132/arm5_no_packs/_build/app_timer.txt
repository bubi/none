; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\app_timer.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\app_timer.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\app_timer.crf ..\..\..\..\..\..\components\libraries\timer\app_timer.c]
                          THUMB

                          AREA ||i.NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_ClearPendingIRQ PROC
;;;1671    */
;;;1672   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1673   {
;;;1674     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L1.20|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1675   }
000010  4770              BX       lr
;;;1676   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0xe000e280

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0942              LSRS     r2,r0,#5
00000a  0092              LSLS     r2,r2,#2
00000c  f10222e0          ADD      r2,r2,#0xe000e000
000010  f8c21100          STR      r1,[r2,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NVIC_SetPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_SetPendingIRQ PROC
;;;1660    */
;;;1661   __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1662   {
;;;1663     NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L3.20|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1664   }
000010  4770              BX       lr
;;;1665   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0xe000e200

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;1697    */
;;;1698   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;1699   {
;;;1700     if ((int32_t)(IRQn) < 0)
000002  2800              CMP      r0,#0
000004  da07              BGE      |L4.22|
;;;1701     {
;;;1702       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000006  074a              LSLS     r2,r1,#29
000008  0e14              LSRS     r4,r2,#24
00000a  4a05              LDR      r2,|L4.32|
00000c  f000030f          AND      r3,r0,#0xf
000010  1f1b              SUBS     r3,r3,#4
000012  54d4              STRB     r4,[r2,r3]
000014  e003              B        |L4.30|
                  |L4.22|
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000016  074a              LSLS     r2,r1,#29
000018  0e13              LSRS     r3,r2,#24
00001a  4a02              LDR      r2,|L4.36|
00001c  5413              STRB     r3,[r2,r0]
                  |L4.30|
;;;1707     }
;;;1708   }
00001e  bd10              POP      {r4,pc}
;;;1709   
                          ENDP

                  |L4.32|
                          DCD      0xe000ed18
                  |L4.36|
                          DCD      0xe000e400

                          AREA ||i.RTC1_IRQHandler||, CODE, READONLY, ALIGN=2

                  RTC1_IRQHandler PROC
;;;874     */
;;;875    void RTC1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;876    {
;;;877        // Clear all events (also unexpected ones)
;;;878        NRF_RTC1->EVENTS_COMPARE[0] = 0;
000002  2000              MOVS     r0,#0
000004  4909              LDR      r1,|L5.44|
000006  6008              STR      r0,[r1,#0]
;;;879        NRF_RTC1->EVENTS_COMPARE[1] = 0;
000008  2100              MOVS     r1,#0
00000a  4809              LDR      r0,|L5.48|
00000c  f8c01144          STR      r1,[r0,#0x144]
;;;880        NRF_RTC1->EVENTS_COMPARE[2] = 0;
000010  f8c01148          STR      r1,[r0,#0x148]
;;;881        NRF_RTC1->EVENTS_COMPARE[3] = 0;
000014  f8c0114c          STR      r1,[r0,#0x14c]
;;;882        NRF_RTC1->EVENTS_TICK       = 0;
000018  2000              MOVS     r0,#0
00001a  4905              LDR      r1,|L5.48|
00001c  f8c10100          STR      r0,[r1,#0x100]
;;;883        NRF_RTC1->EVENTS_OVRFLW     = 0;
000020  4902              LDR      r1,|L5.44|
000022  393c              SUBS     r1,r1,#0x3c
000024  6008              STR      r0,[r1,#0]
;;;884    
;;;885        // Check for expired timers
;;;886        timer_timeouts_check();
000026  f7fffffe          BL       timer_timeouts_check
;;;887    }
00002a  bd10              POP      {r4,pc}
;;;888    
                          ENDP

                  |L5.44|
                          DCD      0x40011140
                  |L5.48|
                          DCD      0x40011000

                          AREA ||i.SWI0_EGU0_IRQHandler||, CODE, READONLY, ALIGN=1

                  SWI0_EGU0_IRQHandler PROC
;;;893     */
;;;894    void SWI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;895    {
;;;896        timer_list_handler();
000002  f7fffffe          BL       timer_list_handler
;;;897    }
000006  bd10              POP      {r4,pc}
;;;898    
                          ENDP


                          AREA ||i.app_timer_cnt_diff_compute||, CODE, READONLY, ALIGN=1

                  app_timer_cnt_diff_compute PROC
;;;1036   
;;;1037   uint32_t app_timer_cnt_diff_compute(uint32_t   ticks_to,
000000  b570              PUSH     {r4-r6,lr}
;;;1038                                       uint32_t   ticks_from,
;;;1039                                       uint32_t * p_ticks_diff)
;;;1040   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1041       *p_ticks_diff = ticks_diff_get(ticks_to, ticks_from);
000008  4631              MOV      r1,r6
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ticks_diff_get
000010  6020              STR      r0,[r4,#0]
;;;1042       return NRF_SUCCESS;
000012  2000              MOVS     r0,#0
;;;1043   }
000014  bd70              POP      {r4-r6,pc}
;;;1044   
                          ENDP


                          AREA ||i.app_timer_cnt_get||, CODE, READONLY, ALIGN=1

                  app_timer_cnt_get PROC
;;;1030   
;;;1031   uint32_t app_timer_cnt_get(void)
000000  b510              PUSH     {r4,lr}
;;;1032   {
;;;1033       return rtc1_counter_get();
000002  f7fffffe          BL       rtc1_counter_get
;;;1034   }
000006  bd10              POP      {r4,pc}
;;;1035   
                          ENDP


                          AREA ||i.app_timer_create||, CODE, READONLY, ALIGN=2

                  app_timer_create PROC
;;;946    
;;;947    uint32_t app_timer_create(app_timer_id_t const *      p_timer_id,
000000  b510              PUSH     {r4,lr}
;;;948                              app_timer_mode_t            mode,
;;;949                              app_timer_timeout_handler_t timeout_handler)
;;;950    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;951        // Check state and parameters
;;;952        VERIFY_MODULE_INITIALIZED();
000006  bf00              NOP      
000008  480b              LDR      r0,|L9.56|
00000a  6840              LDR      r0,[r0,#4]  ; m_op_queue
00000c  b908              CBNZ     r0,|L9.18|
00000e  2008              MOVS     r0,#8
                  |L9.16|
;;;953    
;;;954        if (timeout_handler == NULL)
;;;955        {
;;;956            return NRF_ERROR_INVALID_PARAM;
;;;957        }
;;;958        if (p_timer_id == NULL)
;;;959        {
;;;960            return NRF_ERROR_INVALID_PARAM;
;;;961        }
;;;962        if (((timer_node_t*)*p_timer_id)->is_running)
;;;963        {
;;;964            return NRF_ERROR_INVALID_STATE;
;;;965        }
;;;966    
;;;967        timer_node_t * p_node     = (timer_node_t *)*p_timer_id;
;;;968        p_node->is_running        = false;
;;;969        p_node->mode              = mode;
;;;970        p_node->p_timeout_handler = timeout_handler;
;;;971        return NRF_SUCCESS;
;;;972    }
000010  bd10              POP      {r4,pc}
                  |L9.18|
000012  bf00              NOP                            ;952
000014  b90a              CBNZ     r2,|L9.26|
000016  2007              MOVS     r0,#7                 ;956
000018  e7fa              B        |L9.16|
                  |L9.26|
00001a  b90b              CBNZ     r3,|L9.32|
00001c  2007              MOVS     r0,#7                 ;960
00001e  e7f7              B        |L9.16|
                  |L9.32|
000020  6818              LDR      r0,[r3,#0]            ;962
000022  7c00              LDRB     r0,[r0,#0x10]         ;962
000024  b108              CBZ      r0,|L9.42|
000026  2008              MOVS     r0,#8                 ;964
000028  e7f2              B        |L9.16|
                  |L9.42|
00002a  6819              LDR      r1,[r3,#0]            ;967
00002c  2000              MOVS     r0,#0                 ;968
00002e  7408              STRB     r0,[r1,#0x10]         ;968
000030  744c              STRB     r4,[r1,#0x11]         ;969
000032  614a              STR      r2,[r1,#0x14]         ;970
000034  bf00              NOP                            ;971
000036  e7eb              B        |L9.16|
;;;973    
                          ENDP

                  |L9.56|
                          DCD      m_op_queue

                          AREA ||i.app_timer_init||, CODE, READONLY, ALIGN=2

                  app_timer_init PROC
;;;899    
;;;900    uint32_t app_timer_init(uint32_t                      prescaler,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;901                            uint8_t                       op_queue_size,
;;;902                            void *                        p_buffer,
;;;903                            app_timer_evt_schedule_func_t evt_schedule_func)
;;;904    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;905        // Check that buffer is correctly aligned
;;;906        if (!is_word_aligned(p_buffer))
00000c  4620              MOV      r0,r4
00000e  f0000103          AND      r1,r0,#3
000012  b909              CBNZ     r1,|L10.24|
000014  2101              MOVS     r1,#1
000016  e000              B        |L10.26|
                  |L10.24|
000018  2100              MOVS     r1,#0
                  |L10.26|
00001a  b911              CBNZ     r1,|L10.34|
;;;907        {
;;;908            return NRF_ERROR_INVALID_PARAM;
00001c  2007              MOVS     r0,#7
                  |L10.30|
;;;909        }
;;;910        // Check for NULL buffer
;;;911        if (p_buffer == NULL)
;;;912        {
;;;913            return NRF_ERROR_INVALID_PARAM;
;;;914        }
;;;915    
;;;916        // Stop RTC to prevent any running timers from expiring (in case of reinitialization)
;;;917        rtc1_stop();
;;;918    
;;;919        m_evt_schedule_func = evt_schedule_func;
;;;920    
;;;921        // Initialize operation queue
;;;922        m_op_queue.first           = 0;
;;;923        m_op_queue.last            = 0;
;;;924        m_op_queue.size            = op_queue_size;
;;;925        m_op_queue.p_user_op_queue = p_buffer;
;;;926    
;;;927        mp_timer_id_head            = NULL;
;;;928        m_ticks_elapsed_q_read_ind  = 0;
;;;929        m_ticks_elapsed_q_write_ind = 0;
;;;930    
;;;931    #if APP_TIMER_WITH_PROFILER
;;;932        m_max_user_op_queue_utilization   = 0;
;;;933    #endif
;;;934    
;;;935        NVIC_ClearPendingIRQ(SWI_IRQn);
;;;936        NVIC_SetPriority(SWI_IRQn, SWI_IRQ_PRI);
;;;937        NVIC_EnableIRQ(SWI_IRQn);
;;;938    
;;;939        rtc1_init(prescaler);
;;;940    
;;;941        m_ticks_latest = rtc1_counter_get();
;;;942    
;;;943        return NRF_SUCCESS;
;;;944    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L10.34|
000022  b90c              CBNZ     r4,|L10.40|
000024  2007              MOVS     r0,#7                 ;913
000026  e7fa              B        |L10.30|
                  |L10.40|
000028  f7fffffe          BL       rtc1_stop
00002c  4811              LDR      r0,|L10.116|
00002e  6006              STR      r6,[r0,#0]            ;919  ; m_evt_schedule_func
000030  2000              MOVS     r0,#0                 ;922
000032  4911              LDR      r1,|L10.120|
000034  7008              STRB     r0,[r1,#0]            ;922
000036  7048              STRB     r0,[r1,#1]            ;923
000038  4608              MOV      r0,r1                 ;924
00003a  7085              STRB     r5,[r0,#2]            ;924
00003c  6044              STR      r4,[r0,#4]            ;925  ; m_op_queue
00003e  2000              MOVS     r0,#0                 ;927
000040  490e              LDR      r1,|L10.124|
000042  6008              STR      r0,[r1,#0]            ;927  ; mp_timer_id_head
000044  490e              LDR      r1,|L10.128|
000046  7008              STRB     r0,[r1,#0]            ;928
000048  490e              LDR      r1,|L10.132|
00004a  7008              STRB     r0,[r1,#0]            ;929
00004c  2014              MOVS     r0,#0x14              ;935
00004e  f7fffffe          BL       NVIC_ClearPendingIRQ
000052  2106              MOVS     r1,#6                 ;936
000054  2014              MOVS     r0,#0x14              ;936
000056  f7fffffe          BL       NVIC_SetPriority
00005a  2014              MOVS     r0,#0x14              ;937
00005c  f7fffffe          BL       NVIC_EnableIRQ
000060  4638              MOV      r0,r7                 ;939
000062  f7fffffe          BL       rtc1_init
000066  f7fffffe          BL       rtc1_counter_get
00006a  4907              LDR      r1,|L10.136|
00006c  6008              STR      r0,[r1,#0]            ;941  ; m_ticks_latest
00006e  2000              MOVS     r0,#0                 ;943
000070  e7d5              B        |L10.30|
;;;945    
                          ENDP

000072  0000              DCW      0x0000
                  |L10.116|
                          DCD      m_evt_schedule_func
                  |L10.120|
                          DCD      m_op_queue
                  |L10.124|
                          DCD      mp_timer_id_head
                  |L10.128|
                          DCD      m_ticks_elapsed_q_read_ind
                  |L10.132|
                          DCD      m_ticks_elapsed_q_write_ind
                  |L10.136|
                          DCD      m_ticks_latest

                          AREA ||i.app_timer_start||, CODE, READONLY, ALIGN=2

                  app_timer_start PROC
;;;973    
;;;974    uint32_t app_timer_start(app_timer_id_t timer_id, uint32_t timeout_ticks, void * p_context)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;975    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;976        uint32_t timeout_periodic;
;;;977        timer_node_t * p_node = (timer_node_t*)timer_id;
00000a  4625              MOV      r5,r4
;;;978    
;;;979        // Check state and parameters
;;;980        VERIFY_MODULE_INITIALIZED();
00000c  bf00              NOP      
00000e  4810              LDR      r0,|L11.80|
000010  6840              LDR      r0,[r0,#4]  ; m_op_queue
000012  b910              CBNZ     r0,|L11.26|
000014  2008              MOVS     r0,#8
                  |L11.22|
;;;981    
;;;982        if (timer_id == 0)
;;;983        {
;;;984            return NRF_ERROR_INVALID_STATE;
;;;985        }
;;;986        if (timeout_ticks < APP_TIMER_MIN_TIMEOUT_TICKS)
;;;987        {
;;;988            return NRF_ERROR_INVALID_PARAM;
;;;989        }
;;;990        if (p_node->p_timeout_handler == NULL)
;;;991        {
;;;992            return NRF_ERROR_INVALID_STATE;
;;;993        }
;;;994    
;;;995        // Schedule timer start operation
;;;996        timeout_periodic = (p_node->mode == APP_TIMER_MODE_REPEATED) ? timeout_ticks : 0;
;;;997    
;;;998        return timer_start_op_schedule(p_node,
;;;999                                       timeout_ticks,
;;;1000                                      timeout_periodic,
;;;1001                                      p_context);
;;;1002   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L11.26|
00001a  bf00              NOP                            ;980
00001c  b90c              CBNZ     r4,|L11.34|
00001e  2008              MOVS     r0,#8                 ;984
000020  e7f9              B        |L11.22|
                  |L11.34|
000022  2e05              CMP      r6,#5                 ;986
000024  d201              BCS      |L11.42|
000026  2007              MOVS     r0,#7                 ;988
000028  e7f5              B        |L11.22|
                  |L11.42|
00002a  6968              LDR      r0,[r5,#0x14]         ;990
00002c  b908              CBNZ     r0,|L11.50|
00002e  2008              MOVS     r0,#8                 ;992
000030  e7f1              B        |L11.22|
                  |L11.50|
000032  7c68              LDRB     r0,[r5,#0x11]         ;996
000034  2801              CMP      r0,#1                 ;996
000036  d101              BNE      |L11.60|
000038  4630              MOV      r0,r6                 ;996
00003a  e000              B        |L11.62|
                  |L11.60|
00003c  2000              MOVS     r0,#0                 ;996
                  |L11.62|
00003e  4680              MOV      r8,r0                 ;996
000040  463b              MOV      r3,r7                 ;998
000042  4642              MOV      r2,r8                 ;998
000044  4631              MOV      r1,r6                 ;998
000046  4628              MOV      r0,r5                 ;998
000048  f7fffffe          BL       timer_start_op_schedule
00004c  e7e3              B        |L11.22|
;;;1003   
                          ENDP

00004e  0000              DCW      0x0000
                  |L11.80|
                          DCD      m_op_queue

                          AREA ||i.app_timer_stop||, CODE, READONLY, ALIGN=2

                  app_timer_stop PROC
;;;1004   
;;;1005   uint32_t app_timer_stop(app_timer_id_t timer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;1006   {
000002  4604              MOV      r4,r0
;;;1007       timer_node_t * p_node = (timer_node_t*)timer_id;
000004  4625              MOV      r5,r4
;;;1008       // Check state and parameters
;;;1009       VERIFY_MODULE_INITIALIZED();
000006  bf00              NOP      
000008  4808              LDR      r0,|L12.44|
00000a  6840              LDR      r0,[r0,#4]  ; m_op_queue
00000c  b908              CBNZ     r0,|L12.18|
00000e  2008              MOVS     r0,#8
                  |L12.16|
;;;1010   
;;;1011       if ((timer_id == NULL) || (p_node->p_timeout_handler == NULL))
;;;1012       {
;;;1013           return NRF_ERROR_INVALID_STATE;
;;;1014       }
;;;1015   
;;;1016       p_node->is_running = false;
;;;1017       // Schedule timer stop operation
;;;1018       return timer_stop_op_schedule(p_node, TIMER_USER_OP_TYPE_STOP);
;;;1019   }
000010  bd70              POP      {r4-r6,pc}
                  |L12.18|
000012  bf00              NOP                            ;1009
000014  b10c              CBZ      r4,|L12.26|
000016  6968              LDR      r0,[r5,#0x14]         ;1011
000018  b908              CBNZ     r0,|L12.30|
                  |L12.26|
00001a  2008              MOVS     r0,#8                 ;1013
00001c  e7f8              B        |L12.16|
                  |L12.30|
00001e  2000              MOVS     r0,#0                 ;1016
000020  7428              STRB     r0,[r5,#0x10]         ;1016
000022  2102              MOVS     r1,#2                 ;1018
000024  4628              MOV      r0,r5                 ;1018
000026  f7fffffe          BL       timer_stop_op_schedule
00002a  e7f1              B        |L12.16|
;;;1020   
                          ENDP

                  |L12.44|
                          DCD      m_op_queue

                          AREA ||i.app_timer_stop_all||, CODE, READONLY, ALIGN=2

                  app_timer_stop_all PROC
;;;1021   
;;;1022   uint32_t app_timer_stop_all(void)
000000  b510              PUSH     {r4,lr}
;;;1023   {
;;;1024       // Check state
;;;1025       VERIFY_MODULE_INITIALIZED();
000002  bf00              NOP      
000004  4805              LDR      r0,|L13.28|
000006  6840              LDR      r0,[r0,#4]  ; m_op_queue
000008  b908              CBNZ     r0,|L13.14|
00000a  2008              MOVS     r0,#8
                  |L13.12|
;;;1026   
;;;1027       return timer_stop_op_schedule(NULL, TIMER_USER_OP_TYPE_STOP_ALL);
;;;1028   }
00000c  bd10              POP      {r4,pc}
                  |L13.14|
00000e  bf00              NOP                            ;1025
000010  2103              MOVS     r1,#3                 ;1027
000012  2000              MOVS     r0,#0                 ;1027
000014  f7fffffe          BL       timer_stop_op_schedule
000018  e7f8              B        |L13.12|
;;;1029   
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      m_op_queue

                          AREA ||i.compare_reg_update||, CODE, READONLY, ALIGN=2

                  compare_reg_update PROC
;;;639     */
;;;640    static void compare_reg_update(timer_node_t * p_timer_id_head_old)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;641    {
000004  4682              MOV      r10,r0
;;;642        // Setup the timeout for timers on the head of the list
;;;643        if (mp_timer_id_head != NULL)
000006  481f              LDR      r0,|L14.132|
000008  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
00000a  2800              CMP      r0,#0
00000c  d036              BEQ      |L14.124|
;;;644        {
;;;645            uint32_t ticks_to_expire = mp_timer_id_head->ticks_to_expire;
00000e  481d              LDR      r0,|L14.132|
000010  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
000012  6805              LDR      r5,[r0,#0]
;;;646            uint32_t pre_counter_val = rtc1_counter_get();
000014  f7fffffe          BL       rtc1_counter_get
000018  4607              MOV      r7,r0
;;;647            uint32_t cc              = m_ticks_latest;
00001a  481b              LDR      r0,|L14.136|
00001c  6804              LDR      r4,[r0,#0]  ; m_ticks_latest
;;;648            uint32_t ticks_elapsed   = ticks_diff_get(pre_counter_val, cc) + RTC_COMPARE_OFFSET_MIN;
00001e  4621              MOV      r1,r4
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       ticks_diff_get
000026  1cc6              ADDS     r6,r0,#3
;;;649    
;;;650            if (!m_rtc1_running)
000028  4818              LDR      r0,|L14.140|
00002a  7800              LDRB     r0,[r0,#0]  ; m_rtc1_running
00002c  b908              CBNZ     r0,|L14.50|
;;;651            {
;;;652                // No timers were already running, start RTC
;;;653                rtc1_start();
00002e  f7fffffe          BL       rtc1_start
                  |L14.50|
;;;654            }
;;;655    
;;;656            cc += (ticks_elapsed < ticks_to_expire) ? ticks_to_expire : ticks_elapsed;
000032  42ae              CMP      r6,r5
000034  d201              BCS      |L14.58|
000036  4628              MOV      r0,r5
000038  e000              B        |L14.60|
                  |L14.58|
00003a  4630              MOV      r0,r6
                  |L14.60|
00003c  4404              ADD      r4,r4,r0
;;;657            cc &= MAX_RTC_COUNTER_VAL;
00003e  f024447f          BIC      r4,r4,#0xff000000
;;;658    
;;;659            rtc1_compare0_set(cc);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       rtc1_compare0_set
;;;660    
;;;661            uint32_t post_counter_val = rtc1_counter_get();
000048  f7fffffe          BL       rtc1_counter_get
00004c  4680              MOV      r8,r0
;;;662    
;;;663            if (
00004e  4639              MOV      r1,r7
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       ticks_diff_get
000056  f1000903          ADD      r9,r0,#3
00005a  4639              MOV      r1,r7
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       ticks_diff_get
000062  4581              CMP      r9,r0
000064  d909              BLS      |L14.122|
;;;664                (ticks_diff_get(post_counter_val, pre_counter_val) + RTC_COMPARE_OFFSET_MIN)
;;;665                >
;;;666                ticks_diff_get(cc, pre_counter_val)
;;;667               )
;;;668            {
;;;669                // When this happens the COMPARE event may not be triggered by the RTC.
;;;670                // The nRF51 Series User Specification states that if the COUNTER value is N
;;;671                // (i.e post_counter_val = N), writing N or N + 1 to a CC register may not trigger a
;;;672                // COMPARE event. Hence the RTC interrupt is forcefully pended by calling the following
;;;673                // function.
;;;674                rtc1_compare0_set(rtc1_counter_get());  // this should prevent CC to fire again in the background while the code is in RTC-ISR
000066  f7fffffe          BL       rtc1_counter_get
00006a  4681              MOV      r9,r0
00006c  f7fffffe          BL       rtc1_compare0_set
;;;675                nrf_delay_us(MAX_RTC_TASKS_DELAY);
000070  202f              MOVS     r0,#0x2f
000072  f7fffffe          BL       nrf_delay_us
;;;676                timer_timeouts_check_sched();
000076  f7fffffe          BL       timer_timeouts_check_sched
                  |L14.122|
;;;677            }
;;;678        }
00007a  e001              B        |L14.128|
                  |L14.124|
;;;679        else
;;;680        {
;;;681    #if (APP_TIMER_KEEPS_RTC_ACTIVE == 0)
;;;682            // No timers are running, stop RTC
;;;683            rtc1_stop();
00007c  f7fffffe          BL       rtc1_stop
                  |L14.128|
;;;684    #endif //(APP_TIMER_KEEPS_RTC_ACTIVE == 0)
;;;685        }
;;;686    }
000080  e8bd87f0          POP      {r4-r10,pc}
;;;687    
                          ENDP

                  |L14.132|
                          DCD      mp_timer_id_head
                  |L14.136|
                          DCD      m_ticks_latest
                  |L14.140|
                          DCD      m_rtc1_running

                          AREA ||i.elapsed_ticks_acquire||, CODE, READONLY, ALIGN=2

                  elapsed_ticks_acquire PROC
;;;418     */
;;;419    static bool elapsed_ticks_acquire(uint32_t * p_ticks_elapsed)
000000  4601              MOV      r1,r0
;;;420    {
;;;421        // Pick the elapsed value from queue.
;;;422        if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
000002  4814              LDR      r0,|L15.84|
000004  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
000006  4a14              LDR      r2,|L15.88|
000008  7812              LDRB     r2,[r2,#0]  ; m_ticks_elapsed_q_write_ind
00000a  4290              CMP      r0,r2
00000c  d01d              BEQ      |L15.74|
;;;423        {
;;;424            // Dequeue elapsed value.
;;;425            m_ticks_elapsed_q_read_ind++;
00000e  4811              LDR      r0,|L15.84|
000010  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
000012  1c40              ADDS     r0,r0,#1
000014  4a0f              LDR      r2,|L15.84|
000016  7010              STRB     r0,[r2,#0]
;;;426            if (m_ticks_elapsed_q_read_ind == CONTEXT_QUEUE_SIZE_MAX)
000018  4610              MOV      r0,r2
00001a  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
00001c  2802              CMP      r0,#2
00001e  d101              BNE      |L15.36|
;;;427            {
;;;428                m_ticks_elapsed_q_read_ind = 0;
000020  2000              MOVS     r0,#0
000022  7010              STRB     r0,[r2,#0]
                  |L15.36|
;;;429            }
;;;430    
;;;431            *p_ticks_elapsed = m_ticks_elapsed[m_ticks_elapsed_q_read_ind];
000024  480d              LDR      r0,|L15.92|
000026  4a0b              LDR      r2,|L15.84|
000028  7812              LDRB     r2,[r2,#0]  ; m_ticks_elapsed_q_read_ind
00002a  f8500022          LDR      r0,[r0,r2,LSL #2]
00002e  6008              STR      r0,[r1,#0]
;;;432    
;;;433            m_ticks_latest += *p_ticks_elapsed;
000030  4a0b              LDR      r2,|L15.96|
000032  6808              LDR      r0,[r1,#0]
000034  6812              LDR      r2,[r2,#0]  ; m_ticks_latest
000036  4410              ADD      r0,r0,r2
000038  4a09              LDR      r2,|L15.96|
00003a  6010              STR      r0,[r2,#0]  ; m_ticks_latest
;;;434            m_ticks_latest &= MAX_RTC_COUNTER_VAL;
00003c  4610              MOV      r0,r2
00003e  6800              LDR      r0,[r0,#0]  ; m_ticks_latest
000040  f020407f          BIC      r0,r0,#0xff000000
000044  6010              STR      r0,[r2,#0]  ; m_ticks_latest
;;;435    
;;;436            return true;
000046  2001              MOVS     r0,#1
                  |L15.72|
;;;437        }
;;;438        else
;;;439        {
;;;440            // No elapsed value in queue.
;;;441            *p_ticks_elapsed = 0;
;;;442            return false;
;;;443        }
;;;444    }
000048  4770              BX       lr
                  |L15.74|
00004a  2000              MOVS     r0,#0                 ;441
00004c  6008              STR      r0,[r1,#0]            ;441
00004e  bf00              NOP                            ;442
000050  e7fa              B        |L15.72|
;;;445    
                          ENDP

000052  0000              DCW      0x0000
                  |L15.84|
                          DCD      m_ticks_elapsed_q_read_ind
                  |L15.88|
                          DCD      m_ticks_elapsed_q_write_ind
                  |L15.92|
                          DCD      m_ticks_elapsed
                  |L15.96|
                          DCD      m_ticks_latest

                          AREA ||i.expired_timers_handler||, CODE, READONLY, ALIGN=2

                  expired_timers_handler PROC
;;;504     */
;;;505    static void expired_timers_handler(uint32_t         ticks_elapsed,
000000  b5f0              PUSH     {r4-r7,lr}
;;;506                                       uint32_t         ticks_previous,
;;;507                                       timer_node_t **  p_restart_list_head)
;;;508    {
000002  4603              MOV      r3,r0
;;;509        uint32_t ticks_expired = 0;
000004  2400              MOVS     r4,#0
;;;510    
;;;511        while (mp_timer_id_head != NULL)
000006  e01f              B        |L16.72|
                  |L16.8|
;;;512        {
;;;513            timer_node_t * p_timer;
;;;514            timer_node_t * p_timer_expired;
;;;515    
;;;516            // Auto variable for current timer node.
;;;517            p_timer = mp_timer_id_head;
000008  4e12              LDR      r6,|L16.84|
00000a  6830              LDR      r0,[r6,#0]  ; mp_timer_id_head
;;;518    
;;;519            // Do nothing if timer did not expire
;;;520            if (ticks_elapsed < p_timer->ticks_to_expire)
00000c  6806              LDR      r6,[r0,#0]
00000e  429e              CMP      r6,r3
000010  d903              BLS      |L16.26|
;;;521            {
;;;522                p_timer->ticks_to_expire -= ticks_elapsed;
000012  6806              LDR      r6,[r0,#0]
000014  1af6              SUBS     r6,r6,r3
000016  6006              STR      r6,[r0,#0]
;;;523                break;
000018  e01a              B        |L16.80|
                  |L16.26|
;;;524            }
;;;525    
;;;526            // Decrement ticks_elapsed and collect expired ticks.
;;;527            ticks_elapsed -= p_timer->ticks_to_expire;
00001a  6806              LDR      r6,[r0,#0]
00001c  1b9b              SUBS     r3,r3,r6
;;;528            ticks_expired += p_timer->ticks_to_expire;
00001e  6806              LDR      r6,[r0,#0]
000020  4434              ADD      r4,r4,r6
;;;529    
;;;530            // Timer expired, set ticks_to_expire zero.
;;;531            p_timer->ticks_to_expire = 0;
000022  2600              MOVS     r6,#0
000024  6006              STR      r6,[r0,#0]
;;;532    
;;;533            // Remove the expired timer from head.
;;;534            p_timer_expired  = mp_timer_id_head;
000026  4e0b              LDR      r6,|L16.84|
000028  6835              LDR      r5,[r6,#0]  ; mp_timer_id_head
;;;535            mp_timer_id_head = p_timer->next;
00002a  4f0a              LDR      r7,|L16.84|
00002c  69c6              LDR      r6,[r0,#0x1c]
00002e  603e              STR      r6,[r7,#0]  ; mp_timer_id_head
;;;536    
;;;537            // Timer will be restarted if periodic.
;;;538            if (p_timer->ticks_periodic_interval != 0)
000030  68c6              LDR      r6,[r0,#0xc]
000032  b146              CBZ      r6,|L16.70|
;;;539            {
;;;540                p_timer->ticks_at_start       = (ticks_previous + ticks_expired) & MAX_RTC_COUNTER_VAL;
000034  190e              ADDS     r6,r1,r4
000036  f026467f          BIC      r6,r6,#0xff000000
00003a  6046              STR      r6,[r0,#4]
;;;541                p_timer->ticks_first_interval = p_timer->ticks_periodic_interval;
00003c  68c6              LDR      r6,[r0,#0xc]
00003e  6086              STR      r6,[r0,#8]
;;;542                p_timer->next                 = *p_restart_list_head;
000040  6816              LDR      r6,[r2,#0]
000042  61c6              STR      r6,[r0,#0x1c]
;;;543                *p_restart_list_head          = p_timer_expired;
000044  6015              STR      r5,[r2,#0]
                  |L16.70|
;;;544            }
;;;545        }
000046  bf00              NOP      
                  |L16.72|
000048  4802              LDR      r0,|L16.84|
00004a  6800              LDR      r0,[r0,#0]            ;511  ; mp_timer_id_head
00004c  2800              CMP      r0,#0                 ;511
00004e  d1db              BNE      |L16.8|
                  |L16.80|
000050  bf00              NOP                            ;523
;;;546    }
000052  bdf0              POP      {r4-r7,pc}
;;;547    
                          ENDP

                  |L16.84|
                          DCD      mp_timer_id_head

                          AREA ||i.list_deletions_handler||, CODE, READONLY, ALIGN=2

                  list_deletions_handler PROC
;;;450     */
;;;451    static bool list_deletions_handler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;452    {
;;;453        timer_node_t * p_timer_old_head;
;;;454        uint8_t        user_ops_first = m_op_queue.first;
000002  481c              LDR      r0,|L17.116|
000004  7804              LDRB     r4,[r0,#0]  ; m_op_queue
;;;455    
;;;456        // Remember the old head, so as to decide if new compare needs to be set.
;;;457        p_timer_old_head = mp_timer_id_head;
000006  481c              LDR      r0,|L17.120|
000008  6806              LDR      r6,[r0,#0]  ; mp_timer_id_head
;;;458    
;;;459        while (user_ops_first != m_op_queue.last)
00000a  e027              B        |L17.92|
                  |L17.12|
;;;460        {
;;;461            timer_user_op_t * p_user_op = &m_op_queue.p_user_op_queue[user_ops_first];
00000c  4819              LDR      r0,|L17.116|
00000e  6840              LDR      r0,[r0,#4]  ; m_op_queue
000010  eb040144          ADD      r1,r4,r4,LSL #1
000014  eb0005c1          ADD      r5,r0,r1,LSL #3
;;;462    
;;;463            // Traverse to next operation in queue.
;;;464            user_ops_first++;
000018  1c60              ADDS     r0,r4,#1
00001a  b2c4              UXTB     r4,r0
;;;465            if (user_ops_first == m_op_queue.size)
00001c  4815              LDR      r0,|L17.116|
00001e  7880              LDRB     r0,[r0,#2]  ; m_op_queue
000020  42a0              CMP      r0,r4
000022  d100              BNE      |L17.38|
;;;466            {
;;;467                user_ops_first = 0;
000024  2400              MOVS     r4,#0
                  |L17.38|
;;;468            }
;;;469    
;;;470            switch (p_user_op->op_type)
000026  7828              LDRB     r0,[r5,#0]
000028  2802              CMP      r0,#2
00002a  d002              BEQ      |L17.50|
00002c  2803              CMP      r0,#3
00002e  d112              BNE      |L17.86|
000030  e003              B        |L17.58|
                  |L17.50|
;;;471            {
;;;472                case TIMER_USER_OP_TYPE_STOP:
;;;473                    // Delete node if timer is running.
;;;474                    timer_list_remove(p_user_op->p_node);
000032  6868              LDR      r0,[r5,#4]
000034  f7fffffe          BL       timer_list_remove
;;;475                    break;
000038  e00e              B        |L17.88|
                  |L17.58|
;;;476    
;;;477                case TIMER_USER_OP_TYPE_STOP_ALL:
;;;478                    // Delete list of running timers, and mark all timers as not running.
;;;479                    while (mp_timer_id_head != NULL)
00003a  e007              B        |L17.76|
                  |L17.60|
;;;480                    {
;;;481                        timer_node_t * p_head = mp_timer_id_head;
00003c  490e              LDR      r1,|L17.120|
00003e  6808              LDR      r0,[r1,#0]  ; mp_timer_id_head
;;;482    
;;;483                        p_head->is_running = false;
000040  2100              MOVS     r1,#0
000042  7401              STRB     r1,[r0,#0x10]
;;;484                        mp_timer_id_head    = p_head->next;
000044  4a0c              LDR      r2,|L17.120|
000046  69c1              LDR      r1,[r0,#0x1c]
000048  6011              STR      r1,[r2,#0]  ; mp_timer_id_head
;;;485                    }
00004a  bf00              NOP      
                  |L17.76|
00004c  480a              LDR      r0,|L17.120|
00004e  6800              LDR      r0,[r0,#0]            ;479  ; mp_timer_id_head
000050  2800              CMP      r0,#0                 ;479
000052  d1f3              BNE      |L17.60|
;;;486                    break;
000054  e000              B        |L17.88|
                  |L17.86|
;;;487    
;;;488                default:
;;;489                    // No implementation needed.
;;;490                    break;
000056  bf00              NOP      
                  |L17.88|
000058  bf00              NOP                            ;475
;;;491            }
;;;492        }
00005a  bf00              NOP      
                  |L17.92|
00005c  4805              LDR      r0,|L17.116|
00005e  7840              LDRB     r0,[r0,#1]            ;459  ; m_op_queue
000060  42a0              CMP      r0,r4                 ;459
000062  d1d3              BNE      |L17.12|
;;;493    
;;;494        // Detect change in head of the list.
;;;495        return (mp_timer_id_head != p_timer_old_head);
000064  4804              LDR      r0,|L17.120|
000066  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
000068  42b0              CMP      r0,r6
00006a  d001              BEQ      |L17.112|
00006c  2001              MOVS     r0,#1
                  |L17.110|
;;;496    }
00006e  bd70              POP      {r4-r6,pc}
                  |L17.112|
000070  2000              MOVS     r0,#0                 ;495
000072  e7fc              B        |L17.110|
;;;497    
                          ENDP

                  |L17.116|
                          DCD      m_op_queue
                  |L17.120|
                          DCD      mp_timer_id_head

                          AREA ||i.list_insertions_handler||, CODE, READONLY, ALIGN=2

                  list_insertions_handler PROC
;;;554     */
;;;555    static bool list_insertions_handler(timer_node_t * p_restart_list_head)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;556    {
000004  4605              MOV      r5,r0
;;;557        timer_node_t * p_timer_id_old_head;
;;;558    
;;;559        // Remember the old head, so as to decide if new compare needs to be set.
;;;560        p_timer_id_old_head = mp_timer_id_head;
000006  4837              LDR      r0,|L18.228|
000008  6807              LDR      r7,[r0,#0]  ; mp_timer_id_head
;;;561    
;;;562        // Handle insertions of timers.
;;;563        while ((p_restart_list_head != NULL) || (m_op_queue.first != m_op_queue.last))
00000a  e05a              B        |L18.194|
                  |L18.12|
;;;564        {
;;;565            timer_node_t * p_timer;
;;;566    
;;;567            if (p_restart_list_head != NULL)
00000c  b115              CBZ      r5,|L18.20|
;;;568            {
;;;569                p_timer           = p_restart_list_head;
00000e  462c              MOV      r4,r5
;;;570                p_restart_list_head = p_timer->next;
000010  69e5              LDR      r5,[r4,#0x1c]
000012  e029              B        |L18.104|
                  |L18.20|
;;;571            }
;;;572            else
;;;573            {
;;;574                timer_user_op_t * p_user_op = &m_op_queue.p_user_op_queue[m_op_queue.first];
000014  4934              LDR      r1,|L18.232|
000016  6849              LDR      r1,[r1,#4]  ; m_op_queue
000018  4a33              LDR      r2,|L18.232|
00001a  7812              LDRB     r2,[r2,#0]  ; m_op_queue
00001c  eb020242          ADD      r2,r2,r2,LSL #1
000020  eb0100c2          ADD      r0,r1,r2,LSL #3
;;;575    
;;;576                m_op_queue.first++;
000024  4930              LDR      r1,|L18.232|
000026  7809              LDRB     r1,[r1,#0]  ; m_op_queue
000028  1c49              ADDS     r1,r1,#1
00002a  4a2f              LDR      r2,|L18.232|
00002c  7011              STRB     r1,[r2,#0]
;;;577                if (m_op_queue.first == m_op_queue.size)
00002e  4611              MOV      r1,r2
000030  7809              LDRB     r1,[r1,#0]  ; m_op_queue
000032  7892              LDRB     r2,[r2,#2]  ; m_op_queue
000034  4291              CMP      r1,r2
000036  d102              BNE      |L18.62|
;;;578                {
;;;579                    m_op_queue.first = 0;
000038  2100              MOVS     r1,#0
00003a  4a2b              LDR      r2,|L18.232|
00003c  7011              STRB     r1,[r2,#0]
                  |L18.62|
;;;580                }
;;;581    
;;;582                p_timer = p_user_op->p_node;
00003e  6844              LDR      r4,[r0,#4]
;;;583    
;;;584                if ((p_user_op->op_type != TIMER_USER_OP_TYPE_START) || p_timer->is_running)
000040  7801              LDRB     r1,[r0,#0]
000042  2901              CMP      r1,#1
000044  d101              BNE      |L18.74|
000046  7c21              LDRB     r1,[r4,#0x10]
000048  b101              CBZ      r1,|L18.76|
                  |L18.74|
;;;585                {
;;;586                    continue;
00004a  e03a              B        |L18.194|
                  |L18.76|
;;;587                }
;;;588    
;;;589                p_timer->ticks_at_start          = p_user_op->params.start.ticks_at_start;
00004c  6881              LDR      r1,[r0,#8]
00004e  6061              STR      r1,[r4,#4]
;;;590                p_timer->ticks_first_interval    = p_user_op->params.start.ticks_first_interval;
000050  68c1              LDR      r1,[r0,#0xc]
000052  60a1              STR      r1,[r4,#8]
;;;591                p_timer->ticks_periodic_interval = p_user_op->params.start.ticks_periodic_interval;
000054  6901              LDR      r1,[r0,#0x10]
000056  60e1              STR      r1,[r4,#0xc]
;;;592                p_timer->p_context               = p_user_op->params.start.p_context;
000058  6941              LDR      r1,[r0,#0x14]
00005a  61a1              STR      r1,[r4,#0x18]
;;;593    
;;;594                if (m_rtc1_reset)
00005c  4923              LDR      r1,|L18.236|
00005e  7809              LDRB     r1,[r1,#0]  ; m_rtc1_reset
000060  b109              CBZ      r1,|L18.102|
;;;595                {
;;;596                    p_timer->ticks_at_start = 0;
000062  2100              MOVS     r1,#0
000064  6061              STR      r1,[r4,#4]
                  |L18.102|
;;;597                }
;;;598            }
000066  bf00              NOP      
                  |L18.104|
;;;599    
;;;600            // Prepare the node to be inserted.
;;;601            if (
000068  4921              LDR      r1,|L18.240|
00006a  6860              LDR      r0,[r4,#4]
00006c  6809              LDR      r1,[r1,#0]  ; m_ticks_latest
00006e  1a40              SUBS     r0,r0,r1
000070  f020407f          BIC      r0,r0,#0xff000000
000074  491f              LDR      r1,|L18.244|
000076  4288              CMP      r0,r1
000078  d208              BCS      |L18.140|
;;;602                 ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
;;;603                 <
;;;604                 (MAX_RTC_COUNTER_VAL / 2)
;;;605                )
;;;606            {
;;;607                p_timer->ticks_to_expire = ticks_diff_get(p_timer->ticks_at_start, m_ticks_latest) +
00007a  491d              LDR      r1,|L18.240|
00007c  6860              LDR      r0,[r4,#4]
00007e  6809              LDR      r1,[r1,#0]  ; m_ticks_latest
000080  f7fffffe          BL       ticks_diff_get
000084  68a1              LDR      r1,[r4,#8]
000086  4408              ADD      r0,r0,r1
000088  6020              STR      r0,[r4,#0]
00008a  e00f              B        |L18.172|
                  |L18.140|
;;;608                                           p_timer->ticks_first_interval;
;;;609            }
;;;610            else
;;;611            {
;;;612                uint32_t delta_current_start;
;;;613    
;;;614                delta_current_start = ticks_diff_get(m_ticks_latest, p_timer->ticks_at_start);
00008c  4818              LDR      r0,|L18.240|
00008e  6861              LDR      r1,[r4,#4]
000090  6800              LDR      r0,[r0,#0]  ; m_ticks_latest
000092  f7fffffe          BL       ticks_diff_get
000096  4606              MOV      r6,r0
;;;615                if (p_timer->ticks_first_interval > delta_current_start)
000098  68a0              LDR      r0,[r4,#8]
00009a  42b0              CMP      r0,r6
00009c  d903              BLS      |L18.166|
;;;616                {
;;;617                    p_timer->ticks_to_expire = p_timer->ticks_first_interval - delta_current_start;
00009e  68a0              LDR      r0,[r4,#8]
0000a0  1b80              SUBS     r0,r0,r6
0000a2  6020              STR      r0,[r4,#0]
0000a4  e001              B        |L18.170|
                  |L18.166|
;;;618                }
;;;619                else
;;;620                {
;;;621                    p_timer->ticks_to_expire = 0;
0000a6  2000              MOVS     r0,#0
0000a8  6020              STR      r0,[r4,#0]
                  |L18.170|
;;;622                }
;;;623            }
0000aa  bf00              NOP      
                  |L18.172|
;;;624    
;;;625            p_timer->ticks_at_start       = 0;
0000ac  2000              MOVS     r0,#0
0000ae  6060              STR      r0,[r4,#4]
;;;626            p_timer->ticks_first_interval = 0;
0000b0  60a0              STR      r0,[r4,#8]
;;;627            p_timer->is_running           = true;
0000b2  2001              MOVS     r0,#1
0000b4  7420              STRB     r0,[r4,#0x10]
;;;628            p_timer->next                 = NULL;
0000b6  2000              MOVS     r0,#0
0000b8  61e0              STR      r0,[r4,#0x1c]
;;;629    
;;;630            // Insert into list
;;;631            timer_list_insert(p_timer);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       timer_list_insert
0000c0  bf00              NOP                            ;586
                  |L18.194|
0000c2  2d00              CMP      r5,#0                 ;563
0000c4  d1a2              BNE      |L18.12|
0000c6  4808              LDR      r0,|L18.232|
0000c8  7800              LDRB     r0,[r0,#0]            ;563  ; m_op_queue
0000ca  4907              LDR      r1,|L18.232|
0000cc  7849              LDRB     r1,[r1,#1]            ;563  ; m_op_queue
0000ce  4288              CMP      r0,r1                 ;563
0000d0  d19c              BNE      |L18.12|
;;;632        }
;;;633    
;;;634        return (mp_timer_id_head != p_timer_id_old_head);
0000d2  4804              LDR      r0,|L18.228|
0000d4  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
0000d6  42b8              CMP      r0,r7
0000d8  d002              BEQ      |L18.224|
0000da  2001              MOVS     r0,#1
                  |L18.220|
;;;635    }
0000dc  e8bd81f0          POP      {r4-r8,pc}
                  |L18.224|
0000e0  2000              MOVS     r0,#0                 ;634
0000e2  e7fb              B        |L18.220|
;;;636    
                          ENDP

                  |L18.228|
                          DCD      mp_timer_id_head
                  |L18.232|
                          DCD      m_op_queue
                  |L18.236|
                          DCD      m_rtc1_reset
                  |L18.240|
                          DCD      m_ticks_latest
                  |L18.244|
                          DCD      0x007fffff

                          AREA ||i.nrf_delay_us||, CODE, READONLY, ALIGN=2

                  nrf_delay_us PROC
;;;39     #if defined ( __CC_ARM   )
;;;40     __STATIC_INLINE void nrf_delay_us(uint32_t number_of_us)
000000  b900              CBNZ     r0,|L19.4|
                  |L19.2|
;;;41     {
;;;42         if(!number_of_us)
;;;43             return;
;;;44     __asm
;;;45         {
;;;46     loop:
;;;47         NOP
;;;48         NOP
;;;49         NOP
;;;50         NOP
;;;51         NOP
;;;52         NOP
;;;53         NOP
;;;54         NOP
;;;55         CMP SystemCoreClock, CLOCK_FREQ_16MHz
;;;56         BEQ cond
;;;57         NOP
;;;58     #ifdef NRF52
;;;59         NOP
;;;60         NOP
;;;61         NOP
;;;62         NOP
;;;63         NOP
;;;64         NOP
;;;65         NOP
;;;66         NOP
;;;67         NOP
;;;68         NOP
;;;69         NOP
;;;70         NOP
;;;71         NOP
;;;72         NOP
;;;73         NOP
;;;74         NOP
;;;75         NOP
;;;76         NOP
;;;77         NOP
;;;78         NOP
;;;79         NOP
;;;80         NOP
;;;81         NOP
;;;82         NOP
;;;83         NOP
;;;84         NOP
;;;85         NOP
;;;86         NOP
;;;87         NOP
;;;88         NOP
;;;89         NOP
;;;90         NOP
;;;91         NOP
;;;92         NOP
;;;93         NOP
;;;94         NOP
;;;95         NOP
;;;96         NOP
;;;97         NOP
;;;98         NOP
;;;99         NOP
;;;100        NOP
;;;101        NOP
;;;102        NOP
;;;103        NOP
;;;104        NOP
;;;105        NOP
;;;106    #endif
;;;107    cond:
;;;108        SUBS number_of_us,number_of_us, #1
;;;109        BNE    loop
;;;110        }
;;;111    }
000002  4770              BX       lr
                  |L19.4|
000004  bf00              NOP                            ;46
                  |L19.6|
000006  bf00              NOP                            ;47
000008  bf00              NOP                            ;48
00000a  bf00              NOP                            ;49
00000c  bf00              NOP                            ;50
00000e  bf00              NOP                            ;51
000010  bf00              NOP                            ;52
000012  bf00              NOP                            ;53
000014  bf00              NOP                            ;54
000016  491e              LDR      r1,|L19.144|
000018  6809              LDR      r1,[r1,#0]            ;55  ; SystemCoreClock
00001a  4a1e              LDR      r2,|L19.148|
00001c  4291              CMP      r1,r2                 ;55
00001e  d100              BNE      |L19.34|
000020  e030              B        |L19.132|
                  |L19.34|
000022  bf00              NOP                            ;57
000024  bf00              NOP                            ;59
000026  bf00              NOP                            ;60
000028  bf00              NOP                            ;61
00002a  bf00              NOP                            ;62
00002c  bf00              NOP                            ;63
00002e  bf00              NOP                            ;64
000030  bf00              NOP                            ;65
000032  bf00              NOP                            ;66
000034  bf00              NOP                            ;67
000036  bf00              NOP                            ;68
000038  bf00              NOP                            ;69
00003a  bf00              NOP                            ;70
00003c  bf00              NOP                            ;71
00003e  bf00              NOP                            ;72
000040  bf00              NOP                            ;73
000042  bf00              NOP                            ;74
000044  bf00              NOP                            ;75
000046  bf00              NOP                            ;76
000048  bf00              NOP                            ;77
00004a  bf00              NOP                            ;78
00004c  bf00              NOP                            ;79
00004e  bf00              NOP                            ;80
000050  bf00              NOP                            ;81
000052  bf00              NOP                            ;82
000054  bf00              NOP                            ;83
000056  bf00              NOP                            ;84
000058  bf00              NOP                            ;85
00005a  bf00              NOP                            ;86
00005c  bf00              NOP                            ;87
00005e  bf00              NOP                            ;88
000060  bf00              NOP                            ;89
000062  bf00              NOP                            ;90
000064  bf00              NOP                            ;91
000066  bf00              NOP                            ;92
000068  bf00              NOP                            ;93
00006a  bf00              NOP                            ;94
00006c  bf00              NOP                            ;95
00006e  bf00              NOP                            ;96
000070  bf00              NOP                            ;97
000072  bf00              NOP                            ;98
000074  bf00              NOP                            ;99
000076  bf00              NOP                            ;100
000078  bf00              NOP                            ;101
00007a  bf00              NOP                            ;102
00007c  bf00              NOP                            ;103
00007e  bf00              NOP                            ;104
000080  bf00              NOP                            ;105
000082  bf00              NOP                            ;107
                  |L19.132|
000084  1e40              SUBS     r0,r0,#1              ;108
000086  d000              BEQ      |L19.138|
000088  e7bd              B        |L19.6|
                  |L19.138|
00008a  bf00              NOP      
00008c  e7b9              B        |L19.2|
;;;112    
                          ENDP

00008e  0000              DCW      0x0000
                  |L19.144|
                          DCD      SystemCoreClock
                  |L19.148|
                          DCD      0x00f42400

                          AREA ||i.rtc1_compare0_set||, CODE, READONLY, ALIGN=2

                  rtc1_compare0_set PROC
;;;193     */
;;;194    static __INLINE void rtc1_compare0_set(uint32_t value)
000000  4901              LDR      r1,|L20.8|
;;;195    {
;;;196        NRF_RTC1->CC[0] = value;
000002  6008              STR      r0,[r1,#0]
;;;197    }
000004  4770              BX       lr
;;;198    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x40011540

                          AREA ||i.rtc1_counter_get||, CODE, READONLY, ALIGN=2

                  rtc1_counter_get PROC
;;;172     */
;;;173    static __INLINE uint32_t rtc1_counter_get(void)
000000  4801              LDR      r0,|L21.8|
;;;174    {
;;;175        return NRF_RTC1->COUNTER;
000002  6800              LDR      r0,[r0,#0]
;;;176    }
000004  4770              BX       lr
;;;177    
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x40011504

                          AREA ||i.rtc1_init||, CODE, READONLY, ALIGN=2

                  rtc1_init PROC
;;;124     */
;;;125    static void rtc1_init(uint32_t prescaler)
000000  b510              PUSH     {r4,lr}
;;;126    {
000002  4604              MOV      r4,r0
;;;127        NRF_RTC1->PRESCALER = prescaler;
000004  4803              LDR      r0,|L22.20|
000006  6004              STR      r4,[r0,#0]
;;;128        NVIC_SetPriority(RTC1_IRQn, RTC1_IRQ_PRI);
000008  2106              MOVS     r1,#6
00000a  2011              MOVS     r0,#0x11
00000c  f7fffffe          BL       NVIC_SetPriority
;;;129    }
000010  bd10              POP      {r4,pc}
;;;130    
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      0x40011508

                          AREA ||i.rtc1_start||, CODE, READONLY, ALIGN=2

                  rtc1_start PROC
;;;133     */
;;;134    static void rtc1_start(void)
000000  b510              PUSH     {r4,lr}
;;;135    {
;;;136        NRF_RTC1->EVTENSET = RTC_EVTEN_COMPARE0_Msk;
000002  f44f3080          MOV      r0,#0x10000
000006  490a              LDR      r1,|L23.48|
000008  6008              STR      r0,[r1,#0]
;;;137        NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;
00000a  490a              LDR      r1,|L23.52|
00000c  f8c10304          STR      r0,[r1,#0x304]
;;;138    
;;;139        NVIC_ClearPendingIRQ(RTC1_IRQn);
000010  2011              MOVS     r0,#0x11
000012  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;140        NVIC_EnableIRQ(RTC1_IRQn);
000016  2011              MOVS     r0,#0x11
000018  f7fffffe          BL       NVIC_EnableIRQ
;;;141    
;;;142        NRF_RTC1->TASKS_START = 1;
00001c  2001              MOVS     r0,#1
00001e  4905              LDR      r1,|L23.52|
000020  6008              STR      r0,[r1,#0]
;;;143        nrf_delay_us(MAX_RTC_TASKS_DELAY);
000022  202f              MOVS     r0,#0x2f
000024  f7fffffe          BL       nrf_delay_us
;;;144    
;;;145        m_rtc1_running = true;
000028  2001              MOVS     r0,#1
00002a  4903              LDR      r1,|L23.56|
00002c  7008              STRB     r0,[r1,#0]
;;;146    }
00002e  bd10              POP      {r4,pc}
;;;147    
                          ENDP

                  |L23.48|
                          DCD      0x40011344
                  |L23.52|
                          DCD      0x40011000
                  |L23.56|
                          DCD      m_rtc1_running

                          AREA ||i.rtc1_stop||, CODE, READONLY, ALIGN=2

                  rtc1_stop PROC
;;;150     */
;;;151    static void rtc1_stop(void)
000000  b510              PUSH     {r4,lr}
;;;152    {
;;;153        NVIC_DisableIRQ(RTC1_IRQn);
000002  2011              MOVS     r0,#0x11
000004  2101              MOVS     r1,#1
000006  4081              LSLS     r1,r1,r0
000008  4a0e              LDR      r2,|L24.68|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
000010  bf00              NOP      
;;;154    
;;;155        NRF_RTC1->EVTENCLR = RTC_EVTEN_COMPARE0_Msk;
000012  f44f3080          MOV      r0,#0x10000
000016  490c              LDR      r1,|L24.72|
000018  6008              STR      r0,[r1,#0]
;;;156        NRF_RTC1->INTENCLR = RTC_INTENSET_COMPARE0_Msk;
00001a  490c              LDR      r1,|L24.76|
00001c  f8c10308          STR      r0,[r1,#0x308]
;;;157    
;;;158        NRF_RTC1->TASKS_STOP = 1;
000020  2001              MOVS     r0,#1
000022  6048              STR      r0,[r1,#4]
;;;159        nrf_delay_us(MAX_RTC_TASKS_DELAY);
000024  202f              MOVS     r0,#0x2f
000026  f7fffffe          BL       nrf_delay_us
;;;160    
;;;161        NRF_RTC1->TASKS_CLEAR = 1;
00002a  2001              MOVS     r0,#1
00002c  4907              LDR      r1,|L24.76|
00002e  6088              STR      r0,[r1,#8]
;;;162        m_ticks_latest        = 0;
000030  2000              MOVS     r0,#0
000032  4907              LDR      r1,|L24.80|
000034  6008              STR      r0,[r1,#0]  ; m_ticks_latest
;;;163        nrf_delay_us(MAX_RTC_TASKS_DELAY);
000036  202f              MOVS     r0,#0x2f
000038  f7fffffe          BL       nrf_delay_us
;;;164    
;;;165        m_rtc1_running = false;
00003c  2000              MOVS     r0,#0
00003e  4905              LDR      r1,|L24.84|
000040  7008              STRB     r0,[r1,#0]
;;;166    }
000042  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  |L24.68|
                          DCD      0xe000e180
                  |L24.72|
                          DCD      0x40011348
                  |L24.76|
                          DCD      0x40011000
                  |L24.80|
                          DCD      m_ticks_latest
                  |L24.84|
                          DCD      m_rtc1_running

                          AREA ||i.ticks_diff_get||, CODE, READONLY, ALIGN=1

                  ticks_diff_get PROC
;;;182     */
;;;183    static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
000000  4602              MOV      r2,r0
;;;184    {
;;;185        return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
000002  1a50              SUBS     r0,r2,r1
000004  f020407f          BIC      r0,r0,#0xff000000
;;;186    }
000008  4770              BX       lr
;;;187    
                          ENDP


                          AREA ||i.timeout_handler_exec||, CODE, READONLY, ALIGN=2

                  timeout_handler_exec PROC
;;;328     */
;;;329    static void timeout_handler_exec(timer_node_t * p_timer)
000000  b570              PUSH     {r4-r6,lr}
;;;330    {
000002  4604              MOV      r4,r0
;;;331        if (m_evt_schedule_func != NULL)
000004  480b              LDR      r0,|L26.52|
000006  6800              LDR      r0,[r0,#0]  ; m_evt_schedule_func
000008  b178              CBZ      r0,|L26.42|
;;;332        {
;;;333            uint32_t err_code = m_evt_schedule_func(p_timer->p_timeout_handler, p_timer->p_context);
00000a  4a0a              LDR      r2,|L26.52|
00000c  e9d40105          LDRD     r0,r1,[r4,#0x14]
000010  6812              LDR      r2,[r2,#0]  ; m_evt_schedule_func
000012  4790              BLX      r2
000014  4605              MOV      r5,r0
;;;334            APP_ERROR_CHECK(err_code);
000016  bf00              NOP      
000018  462e              MOV      r6,r5
00001a  b126              CBZ      r6,|L26.38|
00001c  bf00              NOP      
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       app_error_handler_bare
000024  bf00              NOP      
                  |L26.38|
000026  bf00              NOP      
;;;335        }
000028  e002              B        |L26.48|
                  |L26.42|
;;;336        else
;;;337        {
;;;338            p_timer->p_timeout_handler(p_timer->p_context);
00002a  e9d41005          LDRD     r1,r0,[r4,#0x14]
00002e  4788              BLX      r1
                  |L26.48|
;;;339        }
;;;340    }
000030  bd70              POP      {r4-r6,pc}
;;;341    
                          ENDP

000032  0000              DCW      0x0000
                  |L26.52|
                          DCD      m_evt_schedule_func

                          AREA ||i.timer_list_handler||, CODE, READONLY, ALIGN=2

                  timer_list_handler PROC
;;;690     */
;;;691    static void timer_list_handler(void)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;692    {
;;;693        timer_node_t * p_restart_list_head = NULL;
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
;;;694    
;;;695        uint32_t       ticks_elapsed;
;;;696        uint32_t       ticks_previous;
;;;697        bool           ticks_have_elapsed;
;;;698        bool           compare_update;
;;;699        timer_node_t * p_timer_id_head_old;
;;;700    
;;;701    #if APP_TIMER_WITH_PROFILER
;;;702        {
;;;703            uint8_t size = m_op_queue.size;
;;;704            uint8_t first = m_op_queue.first;
;;;705            uint8_t last = m_op_queue.last;
;;;706            uint8_t utilization = (first <= last) ? (last - first) : (size + 1 - first + last);
;;;707    
;;;708            if (utilization > m_max_user_op_queue_utilization)
;;;709            {
;;;710                m_max_user_op_queue_utilization = utilization;
;;;711            }
;;;712        }
;;;713    #endif
;;;714    
;;;715        // Back up the previous known tick and previous list head
;;;716        ticks_previous    = m_ticks_latest;
000008  480f              LDR      r0,|L27.72|
00000a  6804              LDR      r4,[r0,#0]  ; m_ticks_latest
;;;717        p_timer_id_head_old = mp_timer_id_head;
00000c  480f              LDR      r0,|L27.76|
00000e  6807              LDR      r7,[r0,#0]  ; mp_timer_id_head
;;;718    
;;;719        // Get number of elapsed ticks
;;;720        ticks_have_elapsed = elapsed_ticks_acquire(&ticks_elapsed);
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       elapsed_ticks_acquire
000016  4605              MOV      r5,r0
;;;721    
;;;722        // Handle list deletions
;;;723        compare_update = list_deletions_handler();
000018  f7fffffe          BL       list_deletions_handler
00001c  4606              MOV      r6,r0
;;;724    
;;;725        // Handle expired timers
;;;726        if (ticks_have_elapsed)
00001e  b12d              CBZ      r5,|L27.44|
;;;727        {
;;;728            expired_timers_handler(ticks_elapsed, ticks_previous, &p_restart_list_head);
000020  aa01              ADD      r2,sp,#4
000022  4621              MOV      r1,r4
000024  9800              LDR      r0,[sp,#0]
000026  f7fffffe          BL       expired_timers_handler
;;;729            compare_update = true;
00002a  2601              MOVS     r6,#1
                  |L27.44|
;;;730        }
;;;731    
;;;732        // Handle list insertions
;;;733        if (list_insertions_handler(p_restart_list_head))
00002c  9801              LDR      r0,[sp,#4]
00002e  f7fffffe          BL       list_insertions_handler
000032  b100              CBZ      r0,|L27.54|
;;;734        {
;;;735            compare_update = true;
000034  2601              MOVS     r6,#1
                  |L27.54|
;;;736        }
;;;737    
;;;738        // Update compare register if necessary
;;;739        if (compare_update)
000036  b116              CBZ      r6,|L27.62|
;;;740        {
;;;741            compare_reg_update(p_timer_id_head_old);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       compare_reg_update
                  |L27.62|
;;;742        }
;;;743        m_rtc1_reset = false;
00003e  2000              MOVS     r0,#0
000040  4903              LDR      r1,|L27.80|
000042  7008              STRB     r0,[r1,#0]
;;;744    }
000044  e8bd81fc          POP      {r2-r8,pc}
;;;745    
                          ENDP

                  |L27.72|
                          DCD      m_ticks_latest
                  |L27.76|
                          DCD      mp_timer_id_head
                  |L27.80|
                          DCD      m_rtc1_reset

                          AREA ||i.timer_list_handler_sched||, CODE, READONLY, ALIGN=1

                  timer_list_handler_sched PROC
;;;317     */
;;;318    static void timer_list_handler_sched(void)
000000  b510              PUSH     {r4,lr}
;;;319    {
;;;320        NVIC_SetPendingIRQ(SWI_IRQn);
000002  2014              MOVS     r0,#0x14
000004  f7fffffe          BL       NVIC_SetPendingIRQ
;;;321    }
000008  bd10              POP      {r4,pc}
;;;322    
                          ENDP


                          AREA ||i.timer_list_insert||, CODE, READONLY, ALIGN=2

                  timer_list_insert PROC
;;;203     */
;;;204    static void timer_list_insert(timer_node_t * p_timer)
000000  b510              PUSH     {r4,lr}
;;;205    {
;;;206        if (mp_timer_id_head == NULL)
000002  4918              LDR      r1,|L29.100|
000004  6809              LDR      r1,[r1,#0]  ; mp_timer_id_head
000006  b911              CBNZ     r1,|L29.14|
;;;207        {
;;;208            mp_timer_id_head = p_timer;
000008  4916              LDR      r1,|L29.100|
00000a  6008              STR      r0,[r1,#0]  ; mp_timer_id_head
00000c  e028              B        |L29.96|
                  |L29.14|
;;;209        }
;;;210        else
;;;211        {
;;;212            if (p_timer->ticks_to_expire <= mp_timer_id_head->ticks_to_expire)
00000e  4a15              LDR      r2,|L29.100|
000010  6801              LDR      r1,[r0,#0]
000012  6812              LDR      r2,[r2,#0]  ; mp_timer_id_head
000014  6812              LDR      r2,[r2,#0]
000016  4291              CMP      r1,r2
000018  d80d              BHI      |L29.54|
;;;213            {
;;;214                mp_timer_id_head->ticks_to_expire -= p_timer->ticks_to_expire;
00001a  4912              LDR      r1,|L29.100|
00001c  6809              LDR      r1,[r1,#0]  ; mp_timer_id_head
00001e  6809              LDR      r1,[r1,#0]
000020  6802              LDR      r2,[r0,#0]
000022  1a89              SUBS     r1,r1,r2
000024  4a0f              LDR      r2,|L29.100|
000026  6812              LDR      r2,[r2,#0]  ; mp_timer_id_head
000028  6011              STR      r1,[r2,#0]
;;;215    
;;;216                p_timer->next   = mp_timer_id_head;
00002a  490e              LDR      r1,|L29.100|
00002c  6809              LDR      r1,[r1,#0]  ; mp_timer_id_head
00002e  61c1              STR      r1,[r0,#0x1c]
;;;217                mp_timer_id_head = p_timer;
000030  490c              LDR      r1,|L29.100|
000032  6008              STR      r0,[r1,#0]  ; mp_timer_id_head
000034  e014              B        |L29.96|
                  |L29.54|
;;;218            }
;;;219            else
;;;220            {
;;;221                timer_node_t * p_previous;
;;;222                timer_node_t * p_current;
;;;223                uint32_t       ticks_to_expire;
;;;224    
;;;225                ticks_to_expire   = p_timer->ticks_to_expire;
000036  6802              LDR      r2,[r0,#0]
;;;226                p_previous        = mp_timer_id_head;
000038  4c0a              LDR      r4,|L29.100|
00003a  6823              LDR      r3,[r4,#0]  ; mp_timer_id_head
;;;227                p_current         = mp_timer_id_head;
00003c  6821              LDR      r1,[r4,#0]  ; mp_timer_id_head
;;;228    
;;;229                while ((p_current != NULL) && (ticks_to_expire > p_current->ticks_to_expire))
00003e  e003              B        |L29.72|
                  |L29.64|
;;;230                {
;;;231                    ticks_to_expire   -= p_current->ticks_to_expire;
000040  680c              LDR      r4,[r1,#0]
000042  1b12              SUBS     r2,r2,r4
;;;232                    p_previous         = p_current;
000044  460b              MOV      r3,r1
;;;233                    p_current          = p_current->next;
000046  69c9              LDR      r1,[r1,#0x1c]
                  |L29.72|
000048  b111              CBZ      r1,|L29.80|
00004a  680c              LDR      r4,[r1,#0]            ;229
00004c  4294              CMP      r4,r2                 ;229
00004e  d3f7              BCC      |L29.64|
                  |L29.80|
;;;234                }
;;;235    
;;;236                if (p_current != NULL)
000050  b111              CBZ      r1,|L29.88|
;;;237                {
;;;238                    p_current->ticks_to_expire -= ticks_to_expire;
000052  680c              LDR      r4,[r1,#0]
000054  1aa4              SUBS     r4,r4,r2
000056  600c              STR      r4,[r1,#0]
                  |L29.88|
;;;239                }
;;;240    
;;;241                p_timer->ticks_to_expire = ticks_to_expire;
000058  6002              STR      r2,[r0,#0]
;;;242                p_timer->next            = p_current;
00005a  61c1              STR      r1,[r0,#0x1c]
;;;243                p_previous->next         = p_timer;
00005c  61d8              STR      r0,[r3,#0x1c]
;;;244            }
00005e  bf00              NOP      
                  |L29.96|
;;;245        }
;;;246    }
000060  bd10              POP      {r4,pc}
;;;247    
                          ENDP

000062  0000              DCW      0x0000
                  |L29.100|
                          DCD      mp_timer_id_head

                          AREA ||i.timer_list_remove||, CODE, READONLY, ALIGN=2

                  timer_list_remove PROC
;;;252     */
;;;253    static void timer_list_remove(timer_node_t * p_timer)
000000  b530              PUSH     {r4,r5,lr}
;;;254    {
000002  4602              MOV      r2,r0
;;;255        timer_node_t * p_previous;
;;;256        timer_node_t * p_current;
;;;257        uint32_t       timeout;
;;;258    
;;;259        // Find the timer's position in timer list.
;;;260        p_previous = mp_timer_id_head;
000004  4c15              LDR      r4,|L30.92|
000006  6821              LDR      r1,[r4,#0]  ; mp_timer_id_head
;;;261        p_current  = p_previous;
000008  4608              MOV      r0,r1
;;;262    
;;;263        while (p_current != NULL)
00000a  e004              B        |L30.22|
                  |L30.12|
;;;264        {
;;;265            if (p_current == p_timer)
00000c  4290              CMP      r0,r2
00000e  d100              BNE      |L30.18|
;;;266            {
;;;267                break;
000010  e003              B        |L30.26|
                  |L30.18|
;;;268            }
;;;269            p_previous = p_current;
000012  4601              MOV      r1,r0
;;;270            p_current  = p_current->next;
000014  69c0              LDR      r0,[r0,#0x1c]
                  |L30.22|
000016  2800              CMP      r0,#0                 ;263
000018  d1f8              BNE      |L30.12|
                  |L30.26|
00001a  bf00              NOP                            ;267
;;;271        }
;;;272    
;;;273        // Timer not in active list.
;;;274        if (p_current == NULL)
00001c  b900              CBNZ     r0,|L30.32|
                  |L30.30|
;;;275        {
;;;276            return;
;;;277        }
;;;278    
;;;279        // Timer is the first in the list
;;;280        if (p_previous == p_current)
;;;281        {
;;;282            mp_timer_id_head = mp_timer_id_head->next;
;;;283    
;;;284            // No more timers in the list. Reset RTC1 in case Start timer operations are present in the queue.
;;;285            if (mp_timer_id_head == NULL)
;;;286            {
;;;287                NRF_RTC1->TASKS_CLEAR = 1;
;;;288                m_ticks_latest        = 0;
;;;289                m_rtc1_reset          = true;
;;;290            }
;;;291        }
;;;292    
;;;293        // Remaining timeout between next timeout.
;;;294        timeout = p_current->ticks_to_expire;
;;;295    
;;;296        // Link previous timer with next of this timer, i.e. removing the timer from list.
;;;297        p_previous->next = p_current->next;
;;;298    
;;;299        // If this is not the last timer, increment the next timer by this timer timeout.
;;;300        p_current = p_previous->next;
;;;301        if (p_current != NULL)
;;;302        {
;;;303            p_current->ticks_to_expire += timeout;
;;;304        }
;;;305    }
00001e  bd30              POP      {r4,r5,pc}
                  |L30.32|
000020  4281              CMP      r1,r0                 ;280
000022  d110              BNE      |L30.70|
000024  4c0d              LDR      r4,|L30.92|
000026  6824              LDR      r4,[r4,#0]            ;282  ; mp_timer_id_head
000028  69e4              LDR      r4,[r4,#0x1c]         ;282
00002a  4d0c              LDR      r5,|L30.92|
00002c  602c              STR      r4,[r5,#0]            ;282  ; mp_timer_id_head
00002e  462c              MOV      r4,r5                 ;285
000030  6824              LDR      r4,[r4,#0]            ;285  ; mp_timer_id_head
000032  b944              CBNZ     r4,|L30.70|
000034  2401              MOVS     r4,#1                 ;287
000036  4d0a              LDR      r5,|L30.96|
000038  60ac              STR      r4,[r5,#8]            ;287
00003a  2400              MOVS     r4,#0                 ;288
00003c  4d09              LDR      r5,|L30.100|
00003e  602c              STR      r4,[r5,#0]            ;288  ; m_ticks_latest
000040  2401              MOVS     r4,#1                 ;289
000042  4d09              LDR      r5,|L30.104|
000044  702c              STRB     r4,[r5,#0]            ;289
                  |L30.70|
000046  6803              LDR      r3,[r0,#0]            ;294
000048  69c4              LDR      r4,[r0,#0x1c]         ;297
00004a  61cc              STR      r4,[r1,#0x1c]         ;297
00004c  69c8              LDR      r0,[r1,#0x1c]         ;300
00004e  b110              CBZ      r0,|L30.86|
000050  6804              LDR      r4,[r0,#0]            ;303
000052  441c              ADD      r4,r4,r3              ;303
000054  6004              STR      r4,[r0,#0]            ;303
                  |L30.86|
000056  bf00              NOP      
000058  e7e1              B        |L30.30|
;;;306    
                          ENDP

00005a  0000              DCW      0x0000
                  |L30.92|
                          DCD      mp_timer_id_head
                  |L30.96|
                          DCD      0x40011000
                  |L30.100|
                          DCD      m_ticks_latest
                  |L30.104|
                          DCD      m_rtc1_reset

                          AREA ||i.timer_start_op_schedule||, CODE, READONLY, ALIGN=1

                  timer_start_op_schedule PROC
;;;796    
;;;797    static uint32_t timer_start_op_schedule(timer_node_t * p_node,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;798                                            uint32_t        timeout_initial,
;;;799                                            uint32_t        timeout_periodic,
;;;800                                            void *          p_context)
;;;801    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;802        uint8_t last_index;
;;;803        uint32_t err_code = NRF_SUCCESS;
00000c  f04f0900          MOV      r9,#0
;;;804    
;;;805        CRITICAL_REGION_ENTER();
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       app_util_critical_region_enter
;;;806        timer_user_op_t * p_user_op = user_op_alloc(&last_index);
00001a  a801              ADD      r0,sp,#4
00001c  f7fffffe          BL       user_op_alloc
000020  4604              MOV      r4,r0
;;;807        if (p_user_op == NULL)
000022  b914              CBNZ     r4,|L31.42|
;;;808        {
;;;809            err_code = NRF_ERROR_NO_MEM;
000024  f04f0904          MOV      r9,#4
000028  e00d              B        |L31.70|
                  |L31.42|
;;;810        }
;;;811        else
;;;812        {
;;;813    
;;;814            p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
00002a  2001              MOVS     r0,#1
00002c  7020              STRB     r0,[r4,#0]
;;;815            p_user_op->p_node                               = p_node;
00002e  6065              STR      r5,[r4,#4]
;;;816            p_user_op->params.start.ticks_at_start          = rtc1_counter_get();
000030  f7fffffe          BL       rtc1_counter_get
000034  60a0              STR      r0,[r4,#8]
;;;817            p_user_op->params.start.ticks_first_interval    = timeout_initial;
000036  60e6              STR      r6,[r4,#0xc]
;;;818            p_user_op->params.start.ticks_periodic_interval = timeout_periodic;
000038  6127              STR      r7,[r4,#0x10]
;;;819            p_user_op->params.start.p_context               = p_context;
00003a  f8c48014          STR      r8,[r4,#0x14]
;;;820    
;;;821            user_op_enque(last_index);
00003e  f89d0004          LDRB     r0,[sp,#4]
000042  f7fffffe          BL       user_op_enque
                  |L31.70|
;;;822        }
;;;823        CRITICAL_REGION_EXIT();
000046  f89d0000          LDRB     r0,[sp,#0]
00004a  f7fffffe          BL       app_util_critical_region_exit
;;;824    
;;;825        if (err_code == NRF_SUCCESS)
00004e  f1b90f00          CMP      r9,#0
000052  d101              BNE      |L31.88|
;;;826        {
;;;827            timer_list_handler_sched();
000054  f7fffffe          BL       timer_list_handler_sched
                  |L31.88|
;;;828        }
;;;829    
;;;830        return err_code;
000058  4648              MOV      r0,r9
;;;831    }
00005a  e8bd87fc          POP      {r2-r10,pc}
;;;832    
                          ENDP


                          AREA ||i.timer_stop_op_schedule||, CODE, READONLY, ALIGN=1

                  timer_stop_op_schedule PROC
;;;841     */
;;;842    static uint32_t timer_stop_op_schedule(timer_node_t * p_node,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;843                                           timer_user_op_type_t op_type)
;;;844    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;845        uint8_t last_index;
;;;846        uint32_t err_code = NRF_SUCCESS;
000008  2700              MOVS     r7,#0
;;;847    
;;;848        CRITICAL_REGION_ENTER();
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       app_util_critical_region_enter
;;;849        timer_user_op_t * p_user_op = user_op_alloc(&last_index);
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       user_op_alloc
00001a  4604              MOV      r4,r0
;;;850        if (p_user_op == NULL)
00001c  b90c              CBNZ     r4,|L32.34|
;;;851        {
;;;852            err_code = NRF_ERROR_NO_MEM;
00001e  2704              MOVS     r7,#4
000020  e005              B        |L32.46|
                  |L32.34|
;;;853        }
;;;854        else
;;;855        {
;;;856            p_user_op->op_type  = op_type;
000022  7026              STRB     r6,[r4,#0]
;;;857            p_user_op->p_node = p_node;
000024  6065              STR      r5,[r4,#4]
;;;858    
;;;859            user_op_enque(last_index);
000026  f89d0004          LDRB     r0,[sp,#4]
00002a  f7fffffe          BL       user_op_enque
                  |L32.46|
;;;860        }
;;;861        CRITICAL_REGION_EXIT();
00002e  f89d0000          LDRB     r0,[sp,#0]
000032  f7fffffe          BL       app_util_critical_region_exit
;;;862    
;;;863        if (err_code == NRF_SUCCESS)
000036  b90f              CBNZ     r7,|L32.60|
;;;864        {
;;;865            timer_list_handler_sched();
000038  f7fffffe          BL       timer_list_handler_sched
                  |L32.60|
;;;866        }
;;;867    
;;;868        return err_code;
00003c  4638              MOV      r0,r7
;;;869    }
00003e  e8bd81fc          POP      {r2-r8,pc}
;;;870    
                          ENDP


                          AREA ||i.timer_timeouts_check||, CODE, READONLY, ALIGN=2

                  timer_timeouts_check PROC
;;;344     */
;;;345    static void timer_timeouts_check(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;346    {
;;;347        // Handle expired of timer
;;;348        if (mp_timer_id_head != NULL)
000004  481f              LDR      r0,|L33.132|
000006  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
000008  2800              CMP      r0,#0
00000a  d038              BEQ      |L33.126|
;;;349        {
;;;350            timer_node_t *  p_timer;
;;;351            timer_node_t *  p_previous_timer;
;;;352            uint32_t        ticks_elapsed;
;;;353            uint32_t        ticks_expired;
;;;354    
;;;355            // Initialize actual elapsed ticks being consumed to 0.
;;;356            ticks_expired = 0;
00000c  2700              MOVS     r7,#0
;;;357    
;;;358            // ticks_elapsed is collected here, job will use it.
;;;359            ticks_elapsed = ticks_diff_get(rtc1_counter_get(), m_ticks_latest);
00000e  f7fffffe          BL       rtc1_counter_get
000012  4680              MOV      r8,r0
000014  481c              LDR      r0,|L33.136|
000016  6801              LDR      r1,[r0,#0]  ; m_ticks_latest
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       ticks_diff_get
00001e  4606              MOV      r6,r0
;;;360    
;;;361            // Auto variable containing the head of timers expiring.
;;;362            p_timer = mp_timer_id_head;
000020  4818              LDR      r0,|L33.132|
000022  6805              LDR      r5,[r0,#0]  ; mp_timer_id_head
;;;363    
;;;364            // Expire all timers within ticks_elapsed and collect ticks_expired.
;;;365            while (p_timer != NULL)
000024  e010              B        |L33.72|
                  |L33.38|
;;;366            {
;;;367                // Do nothing if timer did not expire.
;;;368                if (ticks_elapsed < p_timer->ticks_to_expire)
000026  6828              LDR      r0,[r5,#0]
000028  42b0              CMP      r0,r6
00002a  d900              BLS      |L33.46|
;;;369                {
;;;370                    break;
00002c  e00e              B        |L33.76|
                  |L33.46|
;;;371                }
;;;372    
;;;373                // Decrement ticks_elapsed and collect expired ticks.
;;;374                ticks_elapsed -= p_timer->ticks_to_expire;
00002e  6828              LDR      r0,[r5,#0]
000030  1a36              SUBS     r6,r6,r0
;;;375                ticks_expired += p_timer->ticks_to_expire;
000032  6828              LDR      r0,[r5,#0]
000034  4407              ADD      r7,r7,r0
;;;376    
;;;377                // Move to next timer.
;;;378                p_previous_timer = p_timer;
000036  462c              MOV      r4,r5
;;;379                p_timer = p_timer->next;
000038  69ed              LDR      r5,[r5,#0x1c]
;;;380    
;;;381                // Execute Task.
;;;382                if (p_previous_timer->is_running)
00003a  7c20              LDRB     r0,[r4,#0x10]
00003c  b120              CBZ      r0,|L33.72|
;;;383                {
;;;384                    p_previous_timer->is_running = false;
00003e  2000              MOVS     r0,#0
000040  7420              STRB     r0,[r4,#0x10]
;;;385                    timeout_handler_exec(p_previous_timer);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       timeout_handler_exec
                  |L33.72|
000048  2d00              CMP      r5,#0                 ;365
00004a  d1ec              BNE      |L33.38|
                  |L33.76|
00004c  bf00              NOP                            ;370
;;;386                }
;;;387            }
;;;388    
;;;389            // Prepare to queue the ticks expired in the m_ticks_elapsed queue.
;;;390            if (m_ticks_elapsed_q_read_ind == m_ticks_elapsed_q_write_ind)
00004e  480f              LDR      r0,|L33.140|
000050  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
000052  490f              LDR      r1,|L33.144|
000054  7809              LDRB     r1,[r1,#0]  ; m_ticks_elapsed_q_write_ind
000056  4288              CMP      r0,r1
000058  d109              BNE      |L33.110|
;;;391            {
;;;392                // The read index of the queue is equal to the write index. This means the new
;;;393                // value of ticks_expired should be stored at a new location in the m_ticks_elapsed
;;;394                // queue (which is implemented as a double buffer).
;;;395    
;;;396                // Check if there will be a queue overflow.
;;;397                if (++m_ticks_elapsed_q_write_ind == CONTEXT_QUEUE_SIZE_MAX)
00005a  480d              LDR      r0,|L33.144|
00005c  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_write_ind
00005e  1c40              ADDS     r0,r0,#1
000060  b2c0              UXTB     r0,r0
000062  490b              LDR      r1,|L33.144|
000064  7008              STRB     r0,[r1,#0]
000066  2802              CMP      r0,#2
000068  d101              BNE      |L33.110|
;;;398                {
;;;399                    // There will be a queue overflow. Hence the write index should point to the start
;;;400                    // of the queue.
;;;401                    m_ticks_elapsed_q_write_ind = 0;
00006a  2000              MOVS     r0,#0
00006c  7008              STRB     r0,[r1,#0]
                  |L33.110|
;;;402                }
;;;403            }
;;;404    
;;;405            // Queue the ticks expired.
;;;406            m_ticks_elapsed[m_ticks_elapsed_q_write_ind] = ticks_expired;
00006e  4809              LDR      r0,|L33.148|
000070  4907              LDR      r1,|L33.144|
000072  7809              LDRB     r1,[r1,#0]  ; m_ticks_elapsed_q_write_ind
000074  f8407021          STR      r7,[r0,r1,LSL #2]
;;;407    
;;;408            timer_list_handler_sched();
000078  f7fffffe          BL       timer_list_handler_sched
;;;409        }
00007c  bf00              NOP      
                  |L33.126|
;;;410    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;411    
                          ENDP

000082  0000              DCW      0x0000
                  |L33.132|
                          DCD      mp_timer_id_head
                  |L33.136|
                          DCD      m_ticks_latest
                  |L33.140|
                          DCD      m_ticks_elapsed_q_read_ind
                  |L33.144|
                          DCD      m_ticks_elapsed_q_write_ind
                  |L33.148|
                          DCD      m_ticks_elapsed

                          AREA ||i.timer_timeouts_check_sched||, CODE, READONLY, ALIGN=1

                  timer_timeouts_check_sched PROC
;;;309     */
;;;310    static void timer_timeouts_check_sched(void)
000000  b510              PUSH     {r4,lr}
;;;311    {
;;;312        NVIC_SetPendingIRQ(RTC1_IRQn);
000002  2011              MOVS     r0,#0x11
000004  f7fffffe          BL       NVIC_SetPendingIRQ
;;;313    }
000008  bd10              POP      {r4,pc}
;;;314    
                          ENDP


                          AREA ||i.user_op_alloc||, CODE, READONLY, ALIGN=2

                  user_op_alloc PROC
;;;762     */
;;;763    static timer_user_op_t * user_op_alloc( uint8_t * p_last_index)
000000  b510              PUSH     {r4,lr}
;;;764    {
000002  4602              MOV      r2,r0
;;;765        uint8_t           last;
;;;766        timer_user_op_t * p_user_op;
;;;767    
;;;768        last = m_op_queue.last + 1;
000004  480c              LDR      r0,|L35.56|
000006  7840              LDRB     r0,[r0,#1]  ; m_op_queue
000008  1c40              ADDS     r0,r0,#1
00000a  b2c1              UXTB     r1,r0
;;;769        if (last == m_op_queue.size)
00000c  480a              LDR      r0,|L35.56|
00000e  7880              LDRB     r0,[r0,#2]  ; m_op_queue
000010  4288              CMP      r0,r1
000012  d100              BNE      |L35.22|
;;;770        {
;;;771            // Overflow case.
;;;772            last = 0;
000014  2100              MOVS     r1,#0
                  |L35.22|
;;;773        }
;;;774        if (last == m_op_queue.first)
000016  4808              LDR      r0,|L35.56|
000018  7800              LDRB     r0,[r0,#0]  ; m_op_queue
00001a  4288              CMP      r0,r1
00001c  d101              BNE      |L35.34|
;;;775        {
;;;776            // Queue is full.
;;;777            return NULL;
00001e  2000              MOVS     r0,#0
                  |L35.32|
;;;778        }
;;;779    
;;;780        *p_last_index = last;
;;;781        p_user_op     = &m_op_queue.p_user_op_queue[m_op_queue.last];
;;;782    
;;;783        return p_user_op;
;;;784    }
000020  bd10              POP      {r4,pc}
                  |L35.34|
000022  7011              STRB     r1,[r2,#0]            ;780
000024  4804              LDR      r0,|L35.56|
000026  6840              LDR      r0,[r0,#4]            ;781  ; m_op_queue
000028  4c03              LDR      r4,|L35.56|
00002a  7864              LDRB     r4,[r4,#1]            ;781  ; m_op_queue
00002c  eb040444          ADD      r4,r4,r4,LSL #1       ;781
000030  eb0003c4          ADD      r3,r0,r4,LSL #3       ;781
000034  4618              MOV      r0,r3                 ;783
000036  e7f3              B        |L35.32|
;;;785    
                          ENDP

                  |L35.56|
                          DCD      m_op_queue

                          AREA ||i.user_op_enque||, CODE, READONLY, ALIGN=2

                  user_op_enque PROC
;;;750     */
;;;751    static void user_op_enque(uint8_t last_index)
000000  4901              LDR      r1,|L36.8|
;;;752    {
;;;753        m_op_queue.last = last_index;
000002  7048              STRB     r0,[r1,#1]
;;;754    }
000004  4770              BX       lr
;;;755    
                          ENDP

000006  0000              DCW      0x0000
                  |L36.8|
                          DCD      m_op_queue

                          AREA ||.data||, DATA, ALIGN=2

                  m_op_queue
                          %        8
                  mp_timer_id_head
                          DCD      0x00000000
                  m_ticks_latest
                          DCD      0x00000000
                  m_ticks_elapsed
                          %        8
                  m_ticks_elapsed_q_read_ind
000018  00                DCB      0x00
                  m_ticks_elapsed_q_write_ind
000019  000000            DCB      0x00,0x00,0x00
                  m_evt_schedule_func
                          DCD      0x00000000
                  m_rtc1_running
000020  00                DCB      0x00
                  m_rtc1_reset
000021  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\timer\\app_timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_app_timer_c_cd27f9c3____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3____REVSH|
#line 402
|__asm___11_app_timer_c_cd27f9c3____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3____RRX|
#line 587
|__asm___11_app_timer_c_cd27f9c3____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
