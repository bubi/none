; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\nrf_drv_clock.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\nrf_drv_clock.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\nrf_drv_clock.crf ..\..\..\..\..\..\components\drivers_nrf\clock\nrf_drv_clock.c]
                          THUMB

                          AREA ||i.POWER_CLOCK_IRQHandler||, CODE, READONLY, ALIGN=2

                  POWER_CLOCK_IRQHandler PROC
;;;431    
;;;432    void POWER_CLOCK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;433    {
;;;434        if (nrf_clock_event_check(NRF_CLOCK_EVENT_HFCLKSTARTED))
000002  f44f7080          MOV      r0,#0x100
000006  f7fffffe          BL       nrf_clock_event_check
00000a  b160              CBZ      r0,|L1.38|
;;;435        {
;;;436            nrf_clock_event_clear(NRF_CLOCK_EVENT_HFCLKSTARTED);
00000c  f44f7080          MOV      r0,#0x100
000010  f7fffffe          BL       nrf_clock_event_clear
;;;437            nrf_clock_int_disable(NRF_CLOCK_INT_HF_STARTED_MASK);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       nrf_clock_int_disable
;;;438            m_clock_cb.hfclk_on = true;
00001a  2001              MOVS     r0,#1
00001c  490b              LDR      r1,|L1.76|
00001e  7048              STRB     r0,[r1,#1]
;;;439            clock_clk_started_notify(NRF_DRV_CLOCK_EVT_HFCLK_STARTED);
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       clock_clk_started_notify
                  |L1.38|
;;;440        }
;;;441        if (nrf_clock_event_check(NRF_CLOCK_EVENT_LFCLKSTARTED))
000026  f44f7082          MOV      r0,#0x104
00002a  f7fffffe          BL       nrf_clock_event_check
00002e  b158              CBZ      r0,|L1.72|
;;;442        {
;;;443            nrf_clock_event_clear(NRF_CLOCK_EVENT_LFCLKSTARTED);
000030  f44f7082          MOV      r0,#0x104
000034  f7fffffe          BL       nrf_clock_event_clear
;;;444            nrf_clock_int_disable(NRF_CLOCK_INT_LF_STARTED_MASK);
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       nrf_clock_int_disable
;;;445            m_clock_cb.lfclk_on = true;
00003e  2001              MOVS     r0,#1
000040  4902              LDR      r1,|L1.76|
000042  7088              STRB     r0,[r1,#2]
;;;446            clock_clk_started_notify(NRF_DRV_CLOCK_EVT_LFCLK_STARTED);
000044  f7fffffe          BL       clock_clk_started_notify
                  |L1.72|
;;;447        }
;;;448    #if CALIBRATION_SUPPORT
;;;449        if (nrf_clock_event_check(NRF_CLOCK_EVENT_CTTO))
;;;450        {
;;;451            nrf_clock_event_clear(NRF_CLOCK_EVENT_CTTO);
;;;452            nrf_clock_int_disable(NRF_CLOCK_INT_CTTO_MASK);
;;;453            nrf_drv_clock_hfclk_request(&m_clock_cb.cal_hfclk_started_handler_item);
;;;454        }
;;;455    
;;;456        if (nrf_clock_event_check(NRF_CLOCK_EVENT_DONE))
;;;457        {
;;;458            nrf_clock_event_clear(NRF_CLOCK_EVENT_DONE);
;;;459            nrf_clock_int_disable(NRF_CLOCK_INT_DONE_MASK);
;;;460            nrf_drv_clock_hfclk_release();
;;;461            bool aborted = (m_clock_cb.cal_state == CAL_STATE_ABORT);
;;;462            m_clock_cb.cal_state = CAL_STATE_IDLE;
;;;463            if (m_clock_cb.cal_done_handler)
;;;464            {
;;;465                m_clock_cb.cal_done_handler(aborted ?
;;;466                    NRF_DRV_CLOCK_EVT_CAL_ABORTED : NRF_DRV_CLOCK_EVT_CAL_DONE);
;;;467            }
;;;468        }
;;;469    #endif // CALIBRATION_SUPPORT
;;;470    }
000048  bd10              POP      {r4,pc}
;;;471    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      m_clock_cb

                          AREA ||i.clock_clk_started_notify||, CODE, READONLY, ALIGN=2

                  clock_clk_started_notify PROC
;;;407    
;;;408    __STATIC_INLINE void clock_clk_started_notify(nrf_drv_clock_evt_type_t evt_type)
000000  b570              PUSH     {r4-r6,lr}
;;;409    {
000002  4605              MOV      r5,r0
;;;410        nrf_drv_clock_handler_item_t **p_head;
;;;411        if (evt_type == NRF_DRV_CLOCK_EVT_HFCLK_STARTED)
000004  b90d              CBNZ     r5,|L2.10|
;;;412        {
;;;413            p_head = (nrf_drv_clock_handler_item_t **)&m_clock_cb.p_hf_head;
000006  4c09              LDR      r4,|L2.44|
000008  e001              B        |L2.14|
                  |L2.10|
;;;414        }
;;;415        else
;;;416        {
;;;417            p_head = (nrf_drv_clock_handler_item_t **)&m_clock_cb.p_lf_head;
00000a  4c08              LDR      r4,|L2.44|
00000c  3408              ADDS     r4,r4,#8
                  |L2.14|
;;;418        }
;;;419    
;;;420        while (1)
00000e  e009              B        |L2.36|
                  |L2.16|
;;;421        {
;;;422            nrf_drv_clock_handler_item_t * p_item = item_dequeue(p_head);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       item_dequeue
000016  4606              MOV      r6,r0
;;;423            if (!p_item)
000018  b906              CBNZ     r6,|L2.28|
;;;424            {
;;;425                break;
00001a  e004              B        |L2.38|
                  |L2.28|
;;;426            }
;;;427    
;;;428            p_item->event_handler(evt_type);
00001c  4628              MOV      r0,r5
00001e  6871              LDR      r1,[r6,#4]
000020  4788              BLX      r1
;;;429        }
000022  bf00              NOP      
                  |L2.36|
000024  e7f4              B        |L2.16|
                  |L2.38|
000026  bf00              NOP                            ;425
;;;430    }
000028  bd70              POP      {r4-r6,pc}
;;;431    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      m_clock_cb+0x8

                          AREA ||i.hfclk_start||, CODE, READONLY, ALIGN=1

                  hfclk_start PROC
;;;97     
;;;98     static void hfclk_start(void)
000000  b510              PUSH     {r4,lr}
;;;99     {
;;;100    #ifdef SOFTDEVICE_PRESENT
;;;101        if (softdevice_handler_is_enabled())
000002  f7fffffe          BL       softdevice_handler_is_enabled
000006  b108              CBZ      r0,|L3.12|
;;;102        {
;;;103            (void)sd_clock_hfclk_request();
000008  df3f              SVC      #0x3f
                  |L3.10|
;;;104            return;
;;;105        }
;;;106    #endif // SOFTDEVICE_PRESENT
;;;107    
;;;108        nrf_clock_event_clear(NRF_CLOCK_EVENT_HFCLKSTARTED);
;;;109        nrf_clock_int_enable(NRF_CLOCK_INT_HF_STARTED_MASK);
;;;110        nrf_clock_task_trigger(NRF_CLOCK_TASK_HFCLKSTART);
;;;111    }
00000a  bd10              POP      {r4,pc}
                  |L3.12|
00000c  f44f7080          MOV      r0,#0x100             ;108
000010  f7fffffe          BL       nrf_clock_event_clear
000014  2001              MOVS     r0,#1                 ;109
000016  f7fffffe          BL       nrf_clock_int_enable
00001a  2000              MOVS     r0,#0                 ;110
00001c  f7fffffe          BL       nrf_clock_task_trigger
000020  bf00              NOP      
000022  e7f2              B        |L3.10|
;;;112    
                          ENDP


                          AREA ||i.hfclk_stop||, CODE, READONLY, ALIGN=2

                  hfclk_stop PROC
;;;112    
;;;113    static void hfclk_stop(void)
000000  b510              PUSH     {r4,lr}
;;;114    {
;;;115    #ifdef SOFTDEVICE_PRESENT
;;;116        if (softdevice_handler_is_enabled())
000002  f7fffffe          BL       softdevice_handler_is_enabled
000006  b108              CBZ      r0,|L4.12|
;;;117        {
;;;118            (void)sd_clock_hfclk_release();
000008  df40              SVC      #0x40
                  |L4.10|
;;;119            return;
;;;120        }
;;;121    #endif // SOFTDEVICE_PRESENT
;;;122    
;;;123        nrf_clock_task_trigger(NRF_CLOCK_TASK_HFCLKSTOP);
;;;124        while (nrf_clock_hf_is_running(NRF_CLOCK_HFCLK_HIGH_ACCURACY))
;;;125        {}
;;;126        m_clock_cb.hfclk_on = false;
;;;127    }
00000a  bd10              POP      {r4,pc}
                  |L4.12|
00000c  2004              MOVS     r0,#4                 ;123
00000e  f7fffffe          BL       nrf_clock_task_trigger
000012  bf00              NOP                            ;124
                  |L4.20|
000014  2001              MOVS     r0,#1                 ;124
000016  f7fffffe          BL       nrf_clock_hf_is_running
00001a  2800              CMP      r0,#0                 ;124
00001c  d1fa              BNE      |L4.20|
00001e  4902              LDR      r1,|L4.40|
000020  7048              STRB     r0,[r1,#1]            ;126
000022  bf00              NOP      
000024  e7f1              B        |L4.10|
;;;128    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      m_clock_cb

                          AREA ||i.item_dequeue||, CODE, READONLY, ALIGN=1

                  item_dequeue PROC
;;;173    
;;;174    static nrf_drv_clock_handler_item_t * item_dequeue(nrf_drv_clock_handler_item_t ** p_head)
000000  4601              MOV      r1,r0
;;;175    {
;;;176        nrf_drv_clock_handler_item_t * p_item = *p_head;
000002  6808              LDR      r0,[r1,#0]
;;;177        if (p_item)
000004  b108              CBZ      r0,|L5.10|
;;;178        {
;;;179            *p_head = p_item->p_next;
000006  6802              LDR      r2,[r0,#0]
000008  600a              STR      r2,[r1,#0]
                  |L5.10|
;;;180        }
;;;181        return p_item;
;;;182    }
00000a  4770              BX       lr
;;;183    
                          ENDP


                          AREA ||i.item_enqueue||, CODE, READONLY, ALIGN=1

                  item_enqueue PROC
;;;166    
;;;167    static void item_enqueue(nrf_drv_clock_handler_item_t ** p_head,
000000  6802              LDR      r2,[r0,#0]
;;;168                             nrf_drv_clock_handler_item_t * p_item)
;;;169    {
;;;170        p_item->p_next = (*p_head ? *p_head : NULL);
000002  b10a              CBZ      r2,|L6.8|
000004  6802              LDR      r2,[r0,#0]
000006  e000              B        |L6.10|
                  |L6.8|
000008  2200              MOVS     r2,#0
                  |L6.10|
00000a  600a              STR      r2,[r1,#0]
;;;171        *p_head = p_item;
00000c  6001              STR      r1,[r0,#0]
;;;172    }
00000e  4770              BX       lr
;;;173    
                          ENDP


                          AREA ||i.lfclk_start||, CODE, READONLY, ALIGN=1

                  lfclk_start PROC
;;;69      */
;;;70     static void lfclk_start(void)
000000  b510              PUSH     {r4,lr}
;;;71     {
;;;72         nrf_clock_event_clear(NRF_CLOCK_EVENT_LFCLKSTARTED);
000002  f44f7082          MOV      r0,#0x104
000006  f7fffffe          BL       nrf_clock_event_clear
;;;73         nrf_clock_int_enable(NRF_CLOCK_INT_LF_STARTED_MASK);
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       nrf_clock_int_enable
;;;74         nrf_clock_task_trigger(NRF_CLOCK_TASK_LFCLKSTART);
000010  2008              MOVS     r0,#8
000012  f7fffffe          BL       nrf_clock_task_trigger
;;;75     }
000016  bd10              POP      {r4,pc}
;;;76     
                          ENDP


                          AREA ||i.lfclk_stop||, CODE, READONLY, ALIGN=2

                  lfclk_stop PROC
;;;78      */
;;;79     static void lfclk_stop(void)
000000  b510              PUSH     {r4,lr}
;;;80     {
;;;81     #if CALIBRATION_SUPPORT
;;;82         (void)nrf_drv_clock_calibration_abort();
;;;83     #endif
;;;84     
;;;85     #ifdef SOFTDEVICE_PRESENT
;;;86         // If LFCLK is requested to stop while SD is still enabled,
;;;87         // it indicates an error in the application.
;;;88         // Enabling SD should increment the LFCLK request.
;;;89         ASSERT(!softdevice_handler_is_enabled());
;;;90     #endif // SOFTDEVICE_PRESENT
;;;91     
;;;92         nrf_clock_task_trigger(NRF_CLOCK_TASK_LFCLKSTOP);
000002  200c              MOVS     r0,#0xc
000004  f7fffffe          BL       nrf_clock_task_trigger
;;;93         while (nrf_clock_lf_is_running())
000008  bf00              NOP      
                  |L8.10|
00000a  f7fffffe          BL       nrf_clock_lf_is_running
00000e  2800              CMP      r0,#0
000010  d1fb              BNE      |L8.10|
;;;94         {}
;;;95         m_clock_cb.lfclk_on = false;
000012  4901              LDR      r1,|L8.24|
000014  7088              STRB     r0,[r1,#2]
;;;96     }
000016  bd10              POP      {r4,pc}
;;;97     
                          ENDP

                  |L8.24|
                          DCD      m_clock_cb

                          AREA ||i.nrf_clock_event_check||, CODE, READONLY, ALIGN=1

                  nrf_clock_event_check PROC
;;;297    
;;;298    __STATIC_INLINE bool nrf_clock_event_check(nrf_clock_event_t event)
000000  4601              MOV      r1,r0
;;;299    {
;;;300        return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
000002  f04f4080          MOV      r0,#0x40000000
000006  5840              LDR      r0,[r0,r1]
000008  b108              CBZ      r0,|L9.14|
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;301    }
00000c  4770              BX       lr
                  |L9.14|
00000e  2000              MOVS     r0,#0                 ;300
000010  e7fc              B        |L9.12|
;;;302    
                          ENDP


                          AREA ||i.nrf_clock_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_clock_event_clear PROC
;;;288    
;;;289    __STATIC_INLINE void nrf_clock_event_clear(nrf_clock_event_t event)
000000  b508              PUSH     {r3,lr}
;;;290    {
;;;291        *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = NRF_CLOCK_EVENT_CLEAR;
000002  2200              MOVS     r2,#0
000004  f04f4180          MOV      r1,#0x40000000
000008  500a              STR      r2,[r1,r0]
;;;292    #if __CORTEX_M == 0x04
;;;293        volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
00000a  5809              LDR      r1,[r1,r0]
00000c  9100              STR      r1,[sp,#0]
;;;294        (void)dummy;
00000e  bf00              NOP      
;;;295    #endif
;;;296    }
000010  bd08              POP      {r3,pc}
;;;297    
                          ENDP


                          AREA ||i.nrf_clock_hf_is_running||, CODE, READONLY, ALIGN=2

                  nrf_clock_hf_is_running PROC
;;;345    
;;;346    __STATIC_INLINE bool nrf_clock_hf_is_running(nrf_clock_hfclk_t clk_src)
000000  4601              MOV      r1,r0
;;;347    {
;;;348        return (NRF_CLOCK->HFCLKSTAT & (CLOCK_HFCLKSTAT_STATE_Msk | CLOCK_HFCLKSTAT_SRC_Msk)) ==
000002  4806              LDR      r0,|L11.28|
000004  6800              LDR      r0,[r0,#0]
000006  f0001001          AND      r0,r0,#0x10001
00000a  f4413280          ORR      r2,r1,#0x10000
00000e  4290              CMP      r0,r2
000010  d101              BNE      |L11.22|
000012  2001              MOVS     r0,#1
                  |L11.20|
;;;349                (CLOCK_HFCLKSTAT_STATE_Msk | (clk_src << CLOCK_HFCLKSTAT_SRC_Pos));
;;;350    }
000014  4770              BX       lr
                  |L11.22|
000016  2000              MOVS     r0,#0                 ;348
000018  e7fc              B        |L11.20|
;;;351    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x4000040c

                          AREA ||i.nrf_clock_int_disable||, CODE, READONLY, ALIGN=2

                  nrf_clock_int_disable PROC
;;;263    
;;;264    __STATIC_INLINE void nrf_clock_int_disable(uint32_t int_mask)
000000  4901              LDR      r1,|L12.8|
;;;265    {
;;;266        NRF_CLOCK->INTENCLR = int_mask;
000002  6008              STR      r0,[r1,#0]
;;;267    }
000004  4770              BX       lr
;;;268    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40000308

                          AREA ||i.nrf_clock_int_enable||, CODE, READONLY, ALIGN=2

                  nrf_clock_int_enable PROC
;;;258    
;;;259    __STATIC_INLINE void nrf_clock_int_enable(uint32_t int_mask)
000000  4901              LDR      r1,|L13.8|
;;;260    {
;;;261        NRF_CLOCK->INTENSET = int_mask;
000002  6008              STR      r0,[r1,#0]
;;;262    }
000004  4770              BX       lr
;;;263    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40000304

                          AREA ||i.nrf_clock_lf_is_running||, CODE, READONLY, ALIGN=2

                  nrf_clock_lf_is_running PROC
;;;326    
;;;327    __STATIC_INLINE bool nrf_clock_lf_is_running(void)
000000  4802              LDR      r0,|L14.12|
;;;328    {
;;;329        return ((NRF_CLOCK->LFCLKSTAT &
000002  6800              LDR      r0,[r0,#0]
000004  f3c04000          UBFX     r0,r0,#16,#1
;;;330                 CLOCK_LFCLKSTAT_STATE_Msk) >> CLOCK_LFCLKSTAT_STATE_Pos);
;;;331    }
000008  4770              BX       lr
;;;332    
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      0x40000418

                          AREA ||i.nrf_clock_task_trigger||, CODE, READONLY, ALIGN=1

                  nrf_clock_task_trigger PROC
;;;278    
;;;279    __STATIC_INLINE void nrf_clock_task_trigger(nrf_clock_task_t task)
000000  2201              MOVS     r2,#1
;;;280    {
;;;281        *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = NRF_CLOCK_TASK_TRIGGER;
000002  0791              LSLS     r1,r2,#30
000004  500a              STR      r2,[r1,r0]
;;;282    }
000006  4770              BX       lr
;;;283    
                          ENDP


                          AREA ||i.nrf_drv_clock_calibration_abort||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_calibration_abort PROC
;;;366    
;;;367    ret_code_t nrf_drv_clock_calibration_abort(void)
000000  200f              MOVS     r0,#0xf
;;;368    {
;;;369    #if CALIBRATION_SUPPORT
;;;370        CRITICAL_REGION_ENTER();
;;;371        switch (m_clock_cb.cal_state)
;;;372        {
;;;373        case CAL_STATE_CT:
;;;374            nrf_clock_int_disable(NRF_CLOCK_INT_CTTO_MASK);
;;;375            nrf_clock_task_trigger(NRF_CLOCK_TASK_CTSTOP);
;;;376            m_clock_cb.cal_state = CAL_STATE_IDLE;
;;;377            if (m_clock_cb.cal_done_handler)
;;;378            {
;;;379                m_clock_cb.cal_done_handler(NRF_DRV_CLOCK_EVT_CAL_ABORTED);
;;;380            }
;;;381            break;
;;;382        case CAL_STATE_HFCLK_REQ:
;;;383            /* fall through. */
;;;384        case CAL_STATE_CAL:
;;;385            m_clock_cb.cal_state = CAL_STATE_ABORT;
;;;386            break;
;;;387        default:
;;;388            break;
;;;389        }
;;;390        CRITICAL_REGION_EXIT();
;;;391        return NRF_SUCCESS;
;;;392    #else
;;;393        return NRF_ERROR_FORBIDDEN;
;;;394    #endif // CALIBRATION_SUPPORT
;;;395    }
000002  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.nrf_drv_clock_calibration_start||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_calibration_start PROC
;;;329    
;;;330    ret_code_t nrf_drv_clock_calibration_start(uint8_t interval, nrf_drv_clock_event_handler_t handler)
000000  4602              MOV      r2,r0
;;;331    {
;;;332    #if CALIBRATION_SUPPORT
;;;333        ASSERT(m_clock_cb.cal_state == CAL_STATE_IDLE);
;;;334        ret_code_t ret = NRF_SUCCESS;
;;;335        if (m_clock_cb.lfclk_on == false)
;;;336        {
;;;337            ret = NRF_ERROR_INVALID_STATE;
;;;338        }
;;;339        else if (m_clock_cb.cal_state == CAL_STATE_IDLE)
;;;340        {
;;;341            m_clock_cb.cal_done_handler = handler;
;;;342            m_clock_cb.cal_hfclk_started_handler_item.event_handler = clock_calibration_hf_started;
;;;343            if (interval == 0)
;;;344            {
;;;345                m_clock_cb.cal_state = CAL_STATE_HFCLK_REQ;
;;;346                nrf_drv_clock_hfclk_request(&m_clock_cb.cal_hfclk_started_handler_item);
;;;347            }
;;;348            else
;;;349            {
;;;350                m_clock_cb.cal_state = CAL_STATE_CT;
;;;351                nrf_clock_cal_timer_timeout_set(interval);
;;;352                nrf_clock_event_clear(NRF_CLOCK_EVENT_CTTO);
;;;353                nrf_clock_int_enable(NRF_CLOCK_INT_CTTO_MASK);
;;;354                nrf_clock_task_trigger(NRF_CLOCK_TASK_CTSTART);
;;;355            }
;;;356        }
;;;357        else
;;;358        {
;;;359            ret = NRF_ERROR_BUSY;
;;;360        }
;;;361        return ret;
;;;362    #else
;;;363        return NRF_ERROR_FORBIDDEN;
000002  200f              MOVS     r0,#0xf
;;;364    #endif // CALIBRATION_SUPPORT
;;;365    }
000004  4770              BX       lr
;;;366    
                          ENDP


                          AREA ||i.nrf_drv_clock_hfclk_is_running||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_hfclk_is_running PROC
;;;291    
;;;292    bool nrf_drv_clock_hfclk_is_running(void)
000000  b508              PUSH     {r3,lr}
;;;293    {
;;;294        ASSERT(m_clock_cb.module_initialized);
;;;295    
;;;296    #ifdef SOFTDEVICE_PRESENT
;;;297        if (softdevice_handler_is_enabled())
000002  f7fffffe          BL       softdevice_handler_is_enabled
000006  b138              CBZ      r0,|L18.24|
;;;298        {
;;;299            uint32_t is_running;
;;;300            UNUSED_VARIABLE(sd_clock_hfclk_is_running(&is_running));
000008  4668              MOV      r0,sp
00000a  df41              SVC      #0x41
;;;301            return (is_running ? true : false);
00000c  9800              LDR      r0,[sp,#0]
00000e  b108              CBZ      r0,|L18.20|
000010  2001              MOVS     r0,#1
                  |L18.18|
;;;302        }
;;;303    #endif // SOFTDEVICE_PRESENT
;;;304    
;;;305        return nrf_clock_hf_is_running(NRF_CLOCK_HFCLK_HIGH_ACCURACY);
;;;306    }
000012  bd08              POP      {r3,pc}
                  |L18.20|
000014  2000              MOVS     r0,#0                 ;301
000016  e7fc              B        |L18.18|
                  |L18.24|
000018  2001              MOVS     r0,#1                 ;305
00001a  f7fffffe          BL       nrf_clock_hf_is_running
00001e  e7f8              B        |L18.18|
;;;307    
                          ENDP


                          AREA ||i.nrf_drv_clock_hfclk_release||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_hfclk_release PROC
;;;277    
;;;278    void nrf_drv_clock_hfclk_release(void)
000000  b508              PUSH     {r3,lr}
;;;279    {
;;;280        ASSERT(m_clock_cb.module_initialized);
;;;281        ASSERT(m_clock_cb.hfclk_requests > 0);
;;;282    
;;;283        CRITICAL_REGION_ENTER();
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       app_util_critical_region_enter
;;;284        --(m_clock_cb.hfclk_requests);
00000c  4807              LDR      r0,|L19.44|
00000e  6840              LDR      r0,[r0,#4]  ; m_clock_cb
000010  1e40              SUBS     r0,r0,#1
000012  4906              LDR      r1,|L19.44|
000014  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;285        if (m_clock_cb.hfclk_requests == 0)
000016  4608              MOV      r0,r1
000018  6840              LDR      r0,[r0,#4]  ; m_clock_cb
00001a  b908              CBNZ     r0,|L19.32|
;;;286        {
;;;287            hfclk_stop();
00001c  f7fffffe          BL       hfclk_stop
                  |L19.32|
;;;288        }
;;;289        CRITICAL_REGION_EXIT();
000020  f89d0000          LDRB     r0,[sp,#0]
000024  f7fffffe          BL       app_util_critical_region_exit
;;;290    }
000028  bd08              POP      {r3,pc}
;;;291    
                          ENDP

00002a  0000              DCW      0x0000
                  |L19.44|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_hfclk_request||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_hfclk_request PROC
;;;244    
;;;245    void nrf_drv_clock_hfclk_request(nrf_drv_clock_handler_item_t * p_handler_item)
000000  b538              PUSH     {r3-r5,lr}
;;;246    {
000002  4604              MOV      r4,r0
;;;247        ASSERT(m_clock_cb.module_initialized);
;;;248    
;;;249        if (m_clock_cb.hfclk_on)
000004  4818              LDR      r0,|L20.104|
000006  7840              LDRB     r0,[r0,#1]  ; m_clock_cb
000008  b190              CBZ      r0,|L20.48|
;;;250        {
;;;251            if (p_handler_item)
00000a  b114              CBZ      r4,|L20.18|
;;;252            {
;;;253                p_handler_item->event_handler(NRF_DRV_CLOCK_EVT_HFCLK_STARTED);
00000c  2000              MOVS     r0,#0
00000e  6861              LDR      r1,[r4,#4]
000010  4788              BLX      r1
                  |L20.18|
;;;254            }
;;;255            CRITICAL_REGION_ENTER();
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       app_util_critical_region_enter
;;;256            ++(m_clock_cb.hfclk_requests);
00001c  4812              LDR      r0,|L20.104|
00001e  6840              LDR      r0,[r0,#4]  ; m_clock_cb
000020  1c40              ADDS     r0,r0,#1
000022  4911              LDR      r1,|L20.104|
000024  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;257            CRITICAL_REGION_EXIT();
000026  f89d0000          LDRB     r0,[sp,#0]
00002a  f7fffffe          BL       app_util_critical_region_exit
00002e  e019              B        |L20.100|
                  |L20.48|
;;;258        }
;;;259        else
;;;260        {
;;;261            CRITICAL_REGION_ENTER();
000030  2000              MOVS     r0,#0
000032  9000              STR      r0,[sp,#0]
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       app_util_critical_region_enter
;;;262            if (p_handler_item)
00003a  b124              CBZ      r4,|L20.70|
;;;263            {
;;;264                item_enqueue((nrf_drv_clock_handler_item_t **)&m_clock_cb.p_hf_head,
00003c  4621              MOV      r1,r4
00003e  480a              LDR      r0,|L20.104|
000040  3008              ADDS     r0,r0,#8
000042  f7fffffe          BL       item_enqueue
                  |L20.70|
;;;265                    p_handler_item);
;;;266            }
;;;267            if (m_clock_cb.hfclk_requests == 0)
000046  4808              LDR      r0,|L20.104|
000048  6840              LDR      r0,[r0,#4]  ; m_clock_cb
00004a  b908              CBNZ     r0,|L20.80|
;;;268            {
;;;269                hfclk_start();
00004c  f7fffffe          BL       hfclk_start
                  |L20.80|
;;;270            }
;;;271            ++(m_clock_cb.hfclk_requests);
000050  4805              LDR      r0,|L20.104|
000052  6840              LDR      r0,[r0,#4]  ; m_clock_cb
000054  1c40              ADDS     r0,r0,#1
000056  4904              LDR      r1,|L20.104|
000058  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;272            CRITICAL_REGION_EXIT();
00005a  f89d0000          LDRB     r0,[sp,#0]
00005e  f7fffffe          BL       app_util_critical_region_exit
000062  bf00              NOP      
                  |L20.100|
;;;273        }
;;;274    
;;;275        ASSERT(m_clock_cb.hfclk_requests > 0);
;;;276    }
000064  bd38              POP      {r3-r5,pc}
;;;277    
                          ENDP

000066  0000              DCW      0x0000
                  |L20.104|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_init PROC
;;;128    
;;;129    ret_code_t nrf_drv_clock_init(void)
000000  b510              PUSH     {r4,lr}
;;;130    {
;;;131        if (m_clock_cb.module_initialized)
000002  480d              LDR      r0,|L21.56|
000004  7800              LDRB     r0,[r0,#0]  ; m_clock_cb
000006  b108              CBZ      r0,|L21.12|
;;;132        {
;;;133            return MODULE_ALREADY_INITIALIZED;
000008  2085              MOVS     r0,#0x85
                  |L21.10|
;;;134        }
;;;135    
;;;136        m_clock_cb.p_hf_head      = NULL;
;;;137        m_clock_cb.hfclk_requests = 0;
;;;138        m_clock_cb.p_lf_head      = NULL;
;;;139        m_clock_cb.lfclk_requests = 0;
;;;140        nrf_drv_common_irq_enable(POWER_CLOCK_IRQn, CLOCK_CONFIG_IRQ_PRIORITY);
;;;141    #ifdef SOFTDEVICE_PRESENT
;;;142        if (!softdevice_handler_is_enabled())
;;;143    #endif
;;;144        {
;;;145            nrf_clock_lf_src_set((nrf_clock_lfclk_t)CLOCK_CONFIG_LF_SRC);
;;;146        }
;;;147    
;;;148    #if CALIBRATION_SUPPORT
;;;149        m_clock_cb.cal_state = CAL_STATE_IDLE;
;;;150    #endif
;;;151    
;;;152        m_clock_cb.module_initialized = true;
;;;153        return NRF_SUCCESS;
;;;154    }
00000a  bd10              POP      {r4,pc}
                  |L21.12|
00000c  2000              MOVS     r0,#0                 ;136
00000e  490a              LDR      r1,|L21.56|
000010  6088              STR      r0,[r1,#8]            ;136  ; m_clock_cb
000012  6048              STR      r0,[r1,#4]            ;137  ; m_clock_cb
000014  6108              STR      r0,[r1,#0x10]         ;138  ; m_clock_cb
000016  60c8              STR      r0,[r1,#0xc]          ;139  ; m_clock_cb
000018  2106              MOVS     r1,#6                 ;140
00001a  f7fffffe          BL       nrf_drv_common_irq_enable
00001e  f7fffffe          BL       softdevice_handler_is_enabled
000022  b920              CBNZ     r0,|L21.46|
000024  2001              MOVS     r0,#1                 ;145
000026  4905              LDR      r1,|L21.60|
000028  6008              STR      r0,[r1,#0]            ;145
00002a  bf00              NOP                            ;145
00002c  bf00              NOP                            ;145
                  |L21.46|
00002e  2001              MOVS     r0,#1                 ;152
000030  4901              LDR      r1,|L21.56|
000032  7008              STRB     r0,[r1,#0]            ;152
000034  2000              MOVS     r0,#0                 ;153
000036  e7e8              B        |L21.10|
;;;155    
                          ENDP

                  |L21.56|
                          DCD      m_clock_cb
                  |L21.60|
                          DCD      0x40000518

                          AREA ||i.nrf_drv_clock_is_calibrating||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_is_calibrating PROC
;;;396    
;;;397    ret_code_t nrf_drv_clock_is_calibrating(bool * p_is_calibrating)
000000  4601              MOV      r1,r0
;;;398    {
;;;399    #if CALIBRATION_SUPPORT
;;;400        ASSERT(m_clock_cb.module_initialized);
;;;401        *p_is_calibrating = (m_clock_cb.cal_state != CAL_STATE_IDLE);
;;;402        return NRF_SUCCESS;
;;;403    #else
;;;404        return NRF_ERROR_FORBIDDEN;
000002  200f              MOVS     r0,#0xf
;;;405    #endif // CALIBRATION_SUPPORT
;;;406    }
000004  4770              BX       lr
;;;407    
                          ENDP


                          AREA ||i.nrf_drv_clock_lfclk_is_running||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_lfclk_is_running PROC
;;;230    
;;;231    bool nrf_drv_clock_lfclk_is_running(void)
000000  b510              PUSH     {r4,lr}
;;;232    {
;;;233        ASSERT(m_clock_cb.module_initialized);
;;;234    
;;;235    #ifdef SOFTDEVICE_PRESENT
;;;236        if (softdevice_handler_is_enabled())
000002  f7fffffe          BL       softdevice_handler_is_enabled
000006  b108              CBZ      r0,|L23.12|
;;;237        {
;;;238            return true;
000008  2001              MOVS     r0,#1
                  |L23.10|
;;;239        }
;;;240    #endif // SOFTDEVICE_PRESENT
;;;241    
;;;242        return nrf_clock_lf_is_running();
;;;243    }
00000a  bd10              POP      {r4,pc}
                  |L23.12|
00000c  f7fffffe          BL       nrf_clock_lf_is_running
000010  e7fb              B        |L23.10|
;;;244    
                          ENDP


                          AREA ||i.nrf_drv_clock_lfclk_release||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_lfclk_release PROC
;;;216    
;;;217    void nrf_drv_clock_lfclk_release(void)
000000  b508              PUSH     {r3,lr}
;;;218    {
;;;219        ASSERT(m_clock_cb.module_initialized);
;;;220        ASSERT(m_clock_cb.lfclk_requests > 0);
;;;221    
;;;222        CRITICAL_REGION_ENTER();
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       app_util_critical_region_enter
;;;223        --(m_clock_cb.lfclk_requests);
00000c  4807              LDR      r0,|L24.44|
00000e  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
000010  1e40              SUBS     r0,r0,#1
000012  4906              LDR      r1,|L24.44|
000014  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;224        if (m_clock_cb.lfclk_requests == 0)
000016  4608              MOV      r0,r1
000018  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
00001a  b908              CBNZ     r0,|L24.32|
;;;225        {
;;;226            lfclk_stop();
00001c  f7fffffe          BL       lfclk_stop
                  |L24.32|
;;;227        }
;;;228        CRITICAL_REGION_EXIT();
000020  f89d0000          LDRB     r0,[sp,#0]
000024  f7fffffe          BL       app_util_critical_region_exit
;;;229    }
000028  bd08              POP      {r3,pc}
;;;230    
                          ENDP

00002a  0000              DCW      0x0000
                  |L24.44|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_lfclk_request||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_lfclk_request PROC
;;;183    
;;;184    void nrf_drv_clock_lfclk_request(nrf_drv_clock_handler_item_t * p_handler_item)
000000  b538              PUSH     {r3-r5,lr}
;;;185    {
000002  4604              MOV      r4,r0
;;;186        ASSERT(m_clock_cb.module_initialized);
;;;187    
;;;188        if (m_clock_cb.lfclk_on)
000004  4818              LDR      r0,|L25.104|
000006  7880              LDRB     r0,[r0,#2]  ; m_clock_cb
000008  b190              CBZ      r0,|L25.48|
;;;189        {
;;;190            if (p_handler_item)
00000a  b114              CBZ      r4,|L25.18|
;;;191            {
;;;192                p_handler_item->event_handler(NRF_DRV_CLOCK_EVT_LFCLK_STARTED);
00000c  2001              MOVS     r0,#1
00000e  6861              LDR      r1,[r4,#4]
000010  4788              BLX      r1
                  |L25.18|
;;;193            }
;;;194            CRITICAL_REGION_ENTER();
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       app_util_critical_region_enter
;;;195            ++(m_clock_cb.lfclk_requests);
00001c  4812              LDR      r0,|L25.104|
00001e  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
000020  1c40              ADDS     r0,r0,#1
000022  4911              LDR      r1,|L25.104|
000024  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;196            CRITICAL_REGION_EXIT();
000026  f89d0000          LDRB     r0,[sp,#0]
00002a  f7fffffe          BL       app_util_critical_region_exit
00002e  e019              B        |L25.100|
                  |L25.48|
;;;197        }
;;;198        else
;;;199        {
;;;200            CRITICAL_REGION_ENTER();
000030  2000              MOVS     r0,#0
000032  9000              STR      r0,[sp,#0]
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       app_util_critical_region_enter
;;;201            if (p_handler_item)
00003a  b124              CBZ      r4,|L25.70|
;;;202            {
;;;203                item_enqueue((nrf_drv_clock_handler_item_t **)&m_clock_cb.p_lf_head,
00003c  4621              MOV      r1,r4
00003e  480a              LDR      r0,|L25.104|
000040  3010              ADDS     r0,r0,#0x10
000042  f7fffffe          BL       item_enqueue
                  |L25.70|
;;;204                    p_handler_item);
;;;205            }
;;;206            if (m_clock_cb.lfclk_requests == 0)
000046  4808              LDR      r0,|L25.104|
000048  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
00004a  b908              CBNZ     r0,|L25.80|
;;;207            {
;;;208                lfclk_start();
00004c  f7fffffe          BL       lfclk_start
                  |L25.80|
;;;209            }
;;;210            ++(m_clock_cb.lfclk_requests);
000050  4805              LDR      r0,|L25.104|
000052  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
000054  1c40              ADDS     r0,r0,#1
000056  4904              LDR      r1,|L25.104|
000058  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;211            CRITICAL_REGION_EXIT();
00005a  f89d0000          LDRB     r0,[sp,#0]
00005e  f7fffffe          BL       app_util_critical_region_exit
000062  bf00              NOP      
                  |L25.100|
;;;212        }
;;;213    
;;;214        ASSERT(m_clock_cb.lfclk_requests > 0);
;;;215    }
000064  bd38              POP      {r3-r5,pc}
;;;216    
                          ENDP

000066  0000              DCW      0x0000
                  |L25.104|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_on_sd_disable||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_on_sd_disable PROC
;;;495    
;;;496    void nrf_drv_clock_on_sd_disable(void)
000000  b510              PUSH     {r4,lr}
;;;497    {
;;;498        /* Reinit interrupts */
;;;499        ASSERT(m_clock_cb.module_initialized);
;;;500        nrf_drv_common_irq_enable(POWER_CLOCK_IRQn, CLOCK_CONFIG_IRQ_PRIORITY);
000002  2106              MOVS     r1,#6
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       nrf_drv_common_irq_enable
;;;501    
;;;502        /* SD leaves LFCLK enabled - disable it if it is no longer required. */
;;;503        nrf_drv_clock_lfclk_release();
00000a  f7fffffe          BL       nrf_drv_clock_lfclk_release
;;;504    }
00000e  bd10              POP      {r4,pc}
;;;505    
                          ENDP


                          AREA ||i.nrf_drv_clock_on_sd_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_on_sd_enable PROC
;;;481    
;;;482    void nrf_drv_clock_on_sd_enable(void)
000000  b508              PUSH     {r3,lr}
;;;483    {
;;;484        CRITICAL_REGION_ENTER();
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       app_util_critical_region_enter
;;;485        /* Make sure that nrf_drv_clock module is initialized */
;;;486        if (!m_clock_cb.module_initialized)
00000c  4808              LDR      r0,|L27.48|
00000e  7800              LDRB     r0,[r0,#0]  ; m_clock_cb
000010  b908              CBNZ     r0,|L27.22|
;;;487        {
;;;488            (void)nrf_drv_clock_init();
000012  f7fffffe          BL       nrf_drv_clock_init
                  |L27.22|
;;;489        }
;;;490        /* SD is one of the LFCLK requesters, but it will enable it by itself. */
;;;491        ++(m_clock_cb.lfclk_requests);
000016  4806              LDR      r0,|L27.48|
000018  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
00001a  1c40              ADDS     r0,r0,#1
00001c  4904              LDR      r1,|L27.48|
00001e  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;492        m_clock_cb.lfclk_on = true;
000020  2001              MOVS     r0,#1
000022  7088              STRB     r0,[r1,#2]
;;;493        CRITICAL_REGION_EXIT();
000024  f89d0000          LDRB     r0,[sp,#0]
000028  f7fffffe          BL       app_util_critical_region_exit
;;;494    }
00002c  bd08              POP      {r3,pc}
;;;495    
                          ENDP

00002e  0000              DCW      0x0000
                  |L27.48|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_on_soc_event||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_on_soc_event PROC
;;;473    
;;;474    void nrf_drv_clock_on_soc_event(uint32_t evt_id)
000000  b510              PUSH     {r4,lr}
;;;475    {
000002  4604              MOV      r4,r0
;;;476        if (evt_id == NRF_EVT_HFCLKSTARTED)
000004  b914              CBNZ     r4,|L28.12|
;;;477        {
;;;478            clock_clk_started_notify(NRF_DRV_CLOCK_EVT_HFCLK_STARTED);
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       clock_clk_started_notify
                  |L28.12|
;;;479        }
;;;480    }
00000c  bd10              POP      {r4,pc}
;;;481    
                          ENDP


                          AREA ||i.nrf_drv_clock_uninit||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_uninit PROC
;;;155    
;;;156    void nrf_drv_clock_uninit(void)
000000  b510              PUSH     {r4,lr}
;;;157    {
;;;158        ASSERT(m_clock_cb.module_initialized);
;;;159        nrf_drv_common_irq_disable(POWER_CLOCK_IRQn);
000002  2000              MOVS     r0,#0
000004  bf00              NOP      
000006  2101              MOVS     r1,#1
000008  4081              LSLS     r1,r1,r0
00000a  4a08              LDR      r2,|L29.44|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
000014  bf00              NOP      
;;;160        nrf_clock_int_disable(0xFFFFFFFF);
000016  1e40              SUBS     r0,r0,#1
000018  f7fffffe          BL       nrf_clock_int_disable
;;;161    
;;;162        lfclk_stop();
00001c  f7fffffe          BL       lfclk_stop
;;;163        hfclk_stop();
000020  f7fffffe          BL       hfclk_stop
;;;164        m_clock_cb.module_initialized = false;
000024  2000              MOVS     r0,#0
000026  4902              LDR      r1,|L29.48|
000028  7008              STRB     r0,[r1,#0]
;;;165    }
00002a  bd10              POP      {r4,pc}
;;;166    
                          ENDP

                  |L29.44|
                          DCD      0xe000e180
                  |L29.48|
                          DCD      m_clock_cb

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_clock_cb
                          %        20

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\clock\\nrf_drv_clock.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_nrf_drv_clock_c_fa0ef9a0____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_nrf_drv_clock_c_fa0ef9a0____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_nrf_drv_clock_c_fa0ef9a0____REVSH|
#line 402
|__asm___15_nrf_drv_clock_c_fa0ef9a0____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_nrf_drv_clock_c_fa0ef9a0____RRX|
#line 587
|__asm___15_nrf_drv_clock_c_fa0ef9a0____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
