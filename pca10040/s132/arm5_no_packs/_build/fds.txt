; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\fds.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\fds.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\fds.crf ..\..\..\..\..\..\components\libraries\fds\fds.c]
                          THUMB

                          AREA ||i.address_is_valid||, CODE, READONLY, ALIGN=2

                  address_is_valid PROC
;;;157    
;;;158    static bool address_is_valid(uint32_t const * const p_addr)
000000  b510              PUSH     {r4,lr}
;;;159    {
000002  4604              MOV      r4,r0
;;;160        return ((p_addr != NULL) &&
000004  b16c              CBZ      r4,|L1.34|
;;;161                (p_addr >= fs_config.p_start_addr) &&
000006  4808              LDR      r0,|L1.40|
000008  6800              LDR      r0,[r0,#0]  ; fs_config
00000a  42a0              CMP      r0,r4
00000c  d809              BHI      |L1.34|
;;;162                (p_addr <= fs_config.p_end_addr)   &&
00000e  4806              LDR      r0,|L1.40|
000010  6840              LDR      r0,[r0,#4]  ; fs_config
000012  42a0              CMP      r0,r4
000014  d305              BCC      |L1.34|
;;;163                (is_word_aligned(p_addr)));
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       is_word_aligned
00001c  b108              CBZ      r0,|L1.34|
00001e  2001              MOVS     r0,#1
                  |L1.32|
;;;164    }
000020  bd10              POP      {r4,pc}
                  |L1.34|
000022  2000              MOVS     r0,#0                 ;163
000024  e7fc              B        |L1.32|
;;;165    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      fs_config

                          AREA ||i.chunk_is_aligned||, CODE, READONLY, ALIGN=1

                  chunk_is_aligned PROC
;;;166    
;;;167    static bool chunk_is_aligned(fds_record_chunk_t const * const p_chunk, uint32_t num_chunks)
000000  b570              PUSH     {r4-r6,lr}
;;;168    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;169        for (uint32_t i = 0; i < num_chunks; i++)
000006  2400              MOVS     r4,#0
000008  e007              B        |L2.26|
                  |L2.10|
;;;170        {
;;;171            if (!is_word_aligned(p_chunk[i].p_data))
00000a  f8550034          LDR      r0,[r5,r4,LSL #3]
00000e  f7fffffe          BL       is_word_aligned
000012  b908              CBNZ     r0,|L2.24|
;;;172            {
;;;173                return false;
000014  2000              MOVS     r0,#0
                  |L2.22|
;;;174            }
;;;175        }
;;;176        return true;
;;;177    }
000016  bd70              POP      {r4-r6,pc}
                  |L2.24|
000018  1c64              ADDS     r4,r4,#1              ;169
                  |L2.26|
00001a  42b4              CMP      r4,r6                 ;169
00001c  d3f5              BCC      |L2.10|
00001e  2001              MOVS     r0,#1                 ;176
000020  e7f9              B        |L2.22|
;;;178    
                          ENDP


                          AREA ||i.chunk_queue_get_and_advance||, CODE, READONLY, ALIGN=2

                  chunk_queue_get_and_advance PROC
;;;567    // Retrieve the current chunk, and advance the queue.
;;;568    static void chunk_queue_get_and_advance(fds_record_chunk_t ** pp_chunk)
000000  490a              LDR      r1,|L3.44|
;;;569    {
;;;570        if (m_chunk_queue.count != 0)
000002  6c49              LDR      r1,[r1,#0x44]  ; m_chunk_queue
000004  b181              CBZ      r1,|L3.40|
;;;571        {
;;;572            // Point to the current chunk and advance the queue.
;;;573            *pp_chunk = &m_chunk_queue.chunk[m_chunk_queue.rp];
000006  4909              LDR      r1,|L3.44|
000008  6c09              LDR      r1,[r1,#0x40]  ; m_chunk_queue
00000a  4a08              LDR      r2,|L3.44|
00000c  eb0201c1          ADD      r1,r2,r1,LSL #3
000010  6001              STR      r1,[r0,#0]
;;;574    
;;;575            m_chunk_queue.rp = (m_chunk_queue.rp + 1) % FDS_CHUNK_QUEUE_SIZE;
000012  4611              MOV      r1,r2
000014  f8911040          LDRB     r1,[r1,#0x40]  ; m_chunk_queue
000018  1c49              ADDS     r1,r1,#1
00001a  f0010107          AND      r1,r1,#7
00001e  6411              STR      r1,[r2,#0x40]  ; m_chunk_queue
;;;576            m_chunk_queue.count--;
000020  4611              MOV      r1,r2
000022  6c49              LDR      r1,[r1,#0x44]  ; m_chunk_queue
000024  1e49              SUBS     r1,r1,#1
000026  6451              STR      r1,[r2,#0x44]  ; m_chunk_queue
                  |L3.40|
;;;577        }
;;;578    }
000028  4770              BX       lr
;;;579    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      m_chunk_queue

                          AREA ||i.chunk_queue_next||, CODE, READONLY, ALIGN=2

                  chunk_queue_next PROC
;;;554    // the next element in the queue. Handles wrap around.
;;;555    void chunk_queue_next(fds_record_chunk_t ** pp_chunk)
000000  4906              LDR      r1,|L4.28|
;;;556    {
;;;557        if ((*pp_chunk) != &m_chunk_queue.chunk[FDS_CHUNK_QUEUE_SIZE - 1])
000002  6802              LDR      r2,[r0,#0]
000004  428a              CMP      r2,r1
000006  d003              BEQ      |L4.16|
;;;558        {
;;;559            (*pp_chunk)++;
000008  6801              LDR      r1,[r0,#0]
00000a  3108              ADDS     r1,r1,#8
00000c  6001              STR      r1,[r0,#0]
                  |L4.14|
;;;560            return;
;;;561        }
;;;562    
;;;563        *pp_chunk = &m_chunk_queue.chunk[0];
;;;564    }
00000e  4770              BX       lr
                  |L4.16|
000010  4902              LDR      r1,|L4.28|
000012  3938              SUBS     r1,r1,#0x38           ;563
000014  6001              STR      r1,[r0,#0]            ;563
000016  bf00              NOP      
000018  e7f9              B        |L4.14|
;;;565    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      m_chunk_queue+0x38

                          AREA ||i.chunk_queue_skip||, CODE, READONLY, ALIGN=2

                  chunk_queue_skip PROC
;;;580    
;;;581    static void chunk_queue_skip(fds_op_t const * const p_op)
000000  7801              LDRB     r1,[r0,#0]
;;;582    {
;;;583        if ((p_op->op_code == FDS_OP_WRITE) ||
000002  2902              CMP      r1,#2
000004  d002              BEQ      |L5.12|
;;;584            (p_op->op_code == FDS_OP_UPDATE))
000006  7801              LDRB     r1,[r0,#0]
000008  2903              CMP      r1,#3
00000a  d10b              BNE      |L5.36|
                  |L5.12|
;;;585        {
;;;586            m_chunk_queue.rp    += p_op->write.chunk_count;
00000c  4906              LDR      r1,|L5.40|
00000e  6c0a              LDR      r2,[r1,#0x40]  ; m_chunk_queue
000010  7d81              LDRB     r1,[r0,#0x16]
000012  4411              ADD      r1,r1,r2
000014  4a04              LDR      r2,|L5.40|
000016  6411              STR      r1,[r2,#0x40]  ; m_chunk_queue
;;;587            m_chunk_queue.count -= p_op->write.chunk_count;
000018  4611              MOV      r1,r2
00001a  6c4a              LDR      r2,[r1,#0x44]  ; m_chunk_queue
00001c  7d81              LDRB     r1,[r0,#0x16]
00001e  1a51              SUBS     r1,r2,r1
000020  4a01              LDR      r2,|L5.40|
000022  6451              STR      r1,[r2,#0x44]  ; m_chunk_queue
                  |L5.36|
;;;588        }
;;;589    }
000024  4770              BX       lr
;;;590    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      m_chunk_queue

                          AREA ||i.delete_execute||, CODE, READONLY, ALIGN=1

                  delete_execute PROC
;;;1283   
;;;1284   static ret_code_t delete_execute(uint32_t prev_ret, fds_op_t * const p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;1285   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;1286       ret_code_t ret;
;;;1287   
;;;1288       if (prev_ret != FS_SUCCESS)
000006  b10e              CBZ      r6,|L6.12|
;;;1289       {
;;;1290           return FDS_ERR_OPERATION_TIMEOUT;
000008  2001              MOVS     r0,#1
                  |L6.10|
;;;1291       }
;;;1292   
;;;1293       switch (p_op->del.step)
;;;1294       {
;;;1295           case FDS_OP_DEL_RECORD_FLAG_DIRTY:
;;;1296               ret = record_find_and_delete(p_op);
;;;1297               p_op->del.step = FDS_OP_DEL_DONE;
;;;1298               break;
;;;1299   
;;;1300           case FDS_OP_DEL_FILE_FLAG_DIRTY:
;;;1301               ret = file_find_and_delete(p_op);
;;;1302               if (ret == FDS_ERR_NOT_FOUND)
;;;1303               {
;;;1304                   // No more records could be found.
;;;1305                   // There won't be another callback for this operation, so return now.
;;;1306                   ret = FDS_OP_COMPLETED;
;;;1307               }
;;;1308               break;
;;;1309   
;;;1310           case FDS_OP_DEL_DONE:
;;;1311               ret = FDS_OP_COMPLETED;
;;;1312               break;
;;;1313   
;;;1314           default:
;;;1315               ret = FDS_ERR_INTERNAL;
;;;1316               break;
;;;1317       }
;;;1318   
;;;1319       return ret;
;;;1320   }
00000a  bd70              POP      {r4-r6,pc}
                  |L6.12|
00000c  7928              LDRB     r0,[r5,#4]            ;1293
00000e  b120              CBZ      r0,|L6.26|
000010  2801              CMP      r0,#1                 ;1293
000012  d009              BEQ      |L6.40|
000014  2802              CMP      r0,#2                 ;1293
000016  d113              BNE      |L6.64|
000018  e00f              B        |L6.58|
                  |L6.26|
00001a  4628              MOV      r0,r5                 ;1296
00001c  f7fffffe          BL       record_find_and_delete
000020  4604              MOV      r4,r0                 ;1296
000022  2002              MOVS     r0,#2                 ;1297
000024  7128              STRB     r0,[r5,#4]            ;1297
000026  e00d              B        |L6.68|
                  |L6.40|
000028  4628              MOV      r0,r5                 ;1301
00002a  f7fffffe          BL       file_find_and_delete
00002e  4604              MOV      r4,r0                 ;1301
000030  2c0a              CMP      r4,#0xa               ;1302
000032  d101              BNE      |L6.56|
000034  f641541d          MOV      r4,#0x1d1d            ;1306
                  |L6.56|
000038  e004              B        |L6.68|
                  |L6.58|
00003a  f641541d          MOV      r4,#0x1d1d            ;1311
00003e  e001              B        |L6.68|
                  |L6.64|
000040  240f              MOVS     r4,#0xf               ;1315
000042  bf00              NOP                            ;1316
                  |L6.68|
000044  bf00              NOP                            ;1298
000046  4620              MOV      r0,r4                 ;1319
000048  e7df              B        |L6.10|
;;;1321   
                          ENDP


                          AREA ||i.dirty_records_stat||, CODE, READONLY, ALIGN=2

                  dirty_records_stat PROC
;;;509    // Retrieve basic statistics about dirty records on a page.
;;;510    static void dirty_records_stat(uint16_t         page,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;511                                   uint16_t * const p_dirty_records,
;;;512                                   uint16_t * const p_word_count)
;;;513    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;514        fds_header_t const * p_header;
;;;515        uint32_t     const * p_rec;
;;;516    
;;;517        p_rec = m_pages[page].p_addr + FDS_PAGE_TAG_SIZE;
00000a  4814              LDR      r0,|L7.92|
00000c  eb001006          ADD      r0,r0,r6,LSL #4
000010  6840              LDR      r0,[r0,#4]
000012  f1000508          ADD      r5,r0,#8
;;;518    
;;;519        while ((p_rec < (m_pages[page].p_addr + FDS_PAGE_SIZE)) &&
000016  e012              B        |L7.62|
                  |L7.24|
;;;520               (*p_rec != FDS_ERASED_WORD))
;;;521        {
;;;522            p_header = (fds_header_t*)p_rec;
000018  462c              MOV      r4,r5
;;;523    
;;;524            if (!header_is_valid(p_header))
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       header_is_valid
000020  b948              CBNZ     r0,|L7.54|
;;;525            {
;;;526                (*p_dirty_records) += 1;
000022  8838              LDRH     r0,[r7,#0]
000024  1c40              ADDS     r0,r0,#1
000026  8038              STRH     r0,[r7,#0]
;;;527                (*p_word_count)    += FDS_HEADER_SIZE + p_header->tl.length_words;
000028  f8b81000          LDRH     r1,[r8,#0]
00002c  8860              LDRH     r0,[r4,#2]
00002e  1cc0              ADDS     r0,r0,#3
000030  4408              ADD      r0,r0,r1
000032  f8a80000          STRH     r0,[r8,#0]
                  |L7.54|
;;;528            }
;;;529    
;;;530            p_rec += (FDS_HEADER_SIZE + (p_header->tl.length_words));
000036  8860              LDRH     r0,[r4,#2]
000038  1cc0              ADDS     r0,r0,#3
00003a  eb050580          ADD      r5,r5,r0,LSL #2
                  |L7.62|
00003e  4807              LDR      r0,|L7.92|
000040  eb001006          ADD      r0,r0,r6,LSL #4       ;519
000044  6840              LDR      r0,[r0,#4]            ;519
000046  f5005080          ADD      r0,r0,#0x1000         ;519
00004a  42a8              CMP      r0,r5                 ;519
00004c  d903              BLS      |L7.86|
00004e  6828              LDR      r0,[r5,#0]            ;520
000050  1c40              ADDS     r0,r0,#1              ;520
000052  2800              CMP      r0,#0                 ;520
000054  d1e0              BNE      |L7.24|
                  |L7.86|
;;;531        }
;;;532    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;533    
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      m_pages

                          AREA ||i.event_prepare||, CODE, READONLY, ALIGN=1

                  event_prepare PROC
;;;103    
;;;104    static void event_prepare(fds_op_t const * const p_op, fds_evt_t * const p_evt)
000000  7802              LDRB     r2,[r0,#0]
;;;105    {
;;;106        switch (p_op->op_code)
000002  2a07              CMP      r2,#7
000004  d234              BCS      |L8.112|
000006  e8dff002          TBB      [pc,r2]
00000a  3304              DCB      0x33,0x04
00000c  07102029          DCB      0x07,0x10,0x20,0x29
000010  3000              DCB      0x30,0x00
;;;107        {
;;;108            case FDS_OP_INIT:
;;;109                p_evt->id = FDS_EVT_INIT;
000012  2200              MOVS     r2,#0
000014  700a              STRB     r2,[r1,#0]
;;;110                break;
000016  e02c              B        |L8.114|
;;;111    
;;;112            case FDS_OP_WRITE:
;;;113                p_evt->id               = FDS_EVT_WRITE;
000018  2201              MOVS     r2,#1
00001a  700a              STRB     r2,[r1,#0]
;;;114                p_evt->write.file_id    = p_op->write.header.ic.file_id;
00001c  8903              LDRH     r3,[r0,#8]
00001e  818b              STRH     r3,[r1,#0xc]
;;;115                p_evt->write.record_key = p_op->write.header.tl.record_key;
000020  8883              LDRH     r3,[r0,#4]
000022  81cb              STRH     r3,[r1,#0xe]
;;;116                p_evt->write.record_id  = p_op->write.header.record_id;
000024  68c2              LDR      r2,[r0,#0xc]
000026  608a              STR      r2,[r1,#8]
;;;117                break;
000028  e023              B        |L8.114|
;;;118    
;;;119            case FDS_OP_UPDATE:
;;;120                p_evt->id                      = FDS_EVT_UPDATE;
00002a  2202              MOVS     r2,#2
00002c  700a              STRB     r2,[r1,#0]
;;;121                p_evt->write.file_id           = p_op->write.header.ic.file_id;
00002e  8903              LDRH     r3,[r0,#8]
000030  818b              STRH     r3,[r1,#0xc]
;;;122                p_evt->write.record_key        = p_op->write.header.tl.record_key;
000032  8883              LDRH     r3,[r0,#4]
000034  81cb              STRH     r3,[r1,#0xe]
;;;123                p_evt->write.record_id         = p_op->write.header.record_id;
000036  68c2              LDR      r2,[r0,#0xc]
000038  608a              STR      r2,[r1,#8]
;;;124                p_evt->write.is_record_updated = (p_op->write.step == FDS_OP_WRITE_DONE);
00003a  7c02              LDRB     r2,[r0,#0x10]
00003c  2a06              CMP      r2,#6
00003e  d101              BNE      |L8.68|
000040  2301              MOVS     r3,#1
000042  e000              B        |L8.70|
                  |L8.68|
000044  2300              MOVS     r3,#0
                  |L8.70|
000046  740b              STRB     r3,[r1,#0x10]
;;;125                break;
000048  e013              B        |L8.114|
;;;126    
;;;127            case FDS_OP_DEL_RECORD:
;;;128                p_evt->id             = FDS_EVT_DEL_RECORD;
00004a  2203              MOVS     r2,#3
00004c  700a              STRB     r2,[r1,#0]
;;;129                p_evt->del.file_id    = p_op->del.file_id;
00004e  88c3              LDRH     r3,[r0,#6]
000050  818b              STRH     r3,[r1,#0xc]
;;;130                p_evt->del.record_key = p_op->del.record_key;
000052  8903              LDRH     r3,[r0,#8]
000054  81cb              STRH     r3,[r1,#0xe]
;;;131                p_evt->del.record_id  = p_op->del.record_to_delete;
000056  68c2              LDR      r2,[r0,#0xc]
000058  608a              STR      r2,[r1,#8]
;;;132                break;
00005a  e00a              B        |L8.114|
;;;133    
;;;134            case FDS_OP_DEL_FILE:
;;;135                p_evt->id             = FDS_EVT_DEL_FILE;
00005c  2204              MOVS     r2,#4
00005e  700a              STRB     r2,[r1,#0]
;;;136                p_evt->del.file_id    = p_op->del.file_id;
000060  88c3              LDRH     r3,[r0,#6]
000062  818b              STRH     r3,[r1,#0xc]
;;;137                p_evt->del.record_key = FDS_RECORD_KEY_DIRTY;
000064  2300              MOVS     r3,#0
000066  81cb              STRH     r3,[r1,#0xe]
;;;138                break;
000068  e003              B        |L8.114|
;;;139    
;;;140            case FDS_OP_GC:
;;;141                p_evt->id = FDS_EVT_GC;
00006a  2205              MOVS     r2,#5
00006c  700a              STRB     r2,[r1,#0]
;;;142                break;
00006e  e000              B        |L8.114|
                  |L8.112|
;;;143    
;;;144            default:
;;;145                // Should not happen.
;;;146                break;
000070  bf00              NOP      
                  |L8.114|
000072  bf00              NOP                            ;110
;;;147        }
;;;148    }
000074  4770              BX       lr
;;;149    
                          ENDP


                          AREA ||i.event_send||, CODE, READONLY, ALIGN=2

                  event_send PROC
;;;91     
;;;92     static void event_send(fds_evt_t const * const p_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;93     {
000002  4605              MOV      r5,r0
;;;94         for (uint32_t user = 0; user < FDS_MAX_USERS; user++)
000004  2400              MOVS     r4,#0
000006  e009              B        |L9.28|
                  |L9.8|
;;;95         {
;;;96             if (m_cb_table[user] != NULL)
000008  4806              LDR      r0,|L9.36|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  b120              CBZ      r0,|L9.26|
;;;97             {
;;;98                 m_cb_table[user](p_evt);
000010  4804              LDR      r0,|L9.36|
000012  f8501024          LDR      r1,[r0,r4,LSL #2]
000016  4628              MOV      r0,r5
000018  4788              BLX      r1
                  |L9.26|
00001a  1c64              ADDS     r4,r4,#1              ;94
                  |L9.28|
00001c  2c08              CMP      r4,#8                 ;94
00001e  d3f3              BCC      |L9.8|
;;;99             }
;;;100        }
;;;101    }
000020  bd70              POP      {r4-r6,pc}
;;;102    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      m_cb_table

                          AREA ||i.fds_descriptor_from_rec_id||, CODE, READONLY, ALIGN=1

                  fds_descriptor_from_rec_id PROC
;;;1980   
;;;1981   ret_code_t fds_descriptor_from_rec_id(fds_record_desc_t * const p_desc,
000000  4602              MOV      r2,r0
;;;1982                                         uint32_t                  record_id)
;;;1983   {
;;;1984       if (p_desc == NULL)
000002  b90a              CBNZ     r2,|L10.8|
;;;1985       {
;;;1986           return FDS_ERR_NULL_ARG;
000004  2005              MOVS     r0,#5
                  |L10.6|
;;;1987       }
;;;1988   
;;;1989       // Zero the descriptor and set the record_id field.
;;;1990       memset(p_desc, 0x00, sizeof(fds_record_desc_t));
;;;1991       p_desc->record_id = record_id;
;;;1992   
;;;1993       return FDS_SUCCESS;
;;;1994   }
000006  4770              BX       lr
                  |L10.8|
000008  2000              MOVS     r0,#0                 ;1990
00000a  6010              STR      r0,[r2,#0]            ;1990
00000c  6050              STR      r0,[r2,#4]            ;1990
00000e  6090              STR      r0,[r2,#8]            ;1990
000010  6011              STR      r1,[r2,#0]            ;1991
000012  bf00              NOP                            ;1993
000014  e7f7              B        |L10.6|
;;;1995   
                          ENDP


                          AREA ||i.fds_file_delete||, CODE, READONLY, ALIGN=1

                  fds_file_delete PROC
;;;1893   
;;;1894   ret_code_t fds_file_delete(uint16_t file_id)
000000  b510              PUSH     {r4,lr}
;;;1895   {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;1896       fds_op_t op;
;;;1897   
;;;1898       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       flag_is_set
00000c  b910              CBNZ     r0,|L11.20|
;;;1899       {
;;;1900           return FDS_ERR_NOT_INITIALIZED;
00000e  2002              MOVS     r0,#2
                  |L11.16|
;;;1901       }
;;;1902   
;;;1903       if (file_id == FDS_FILE_ID_INVALID)
;;;1904       {
;;;1905           return FDS_ERR_INVALID_ARG;
;;;1906       }
;;;1907   
;;;1908       op.op_code      = FDS_OP_DEL_FILE;
;;;1909       op.del.step     = FDS_OP_DEL_FILE_FLAG_DIRTY;
;;;1910       op.del.file_id  = file_id;
;;;1911   
;;;1912       if (op_enqueue(&op, 0, NULL))
;;;1913       {
;;;1914           queue_start();
;;;1915           return FDS_SUCCESS;
;;;1916       }
;;;1917   
;;;1918       return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1919   }
000010  b008              ADD      sp,sp,#0x20
000012  bd10              POP      {r4,pc}
                  |L11.20|
000014  f64f70ff          MOV      r0,#0xffff            ;1903
000018  4284              CMP      r4,r0                 ;1903
00001a  d101              BNE      |L11.32|
00001c  2004              MOVS     r0,#4                 ;1905
00001e  e7f7              B        |L11.16|
                  |L11.32|
000020  2005              MOVS     r0,#5                 ;1908
000022  f88d0004          STRB     r0,[sp,#4]            ;1908
000026  2001              MOVS     r0,#1                 ;1909
000028  f88d0008          STRB     r0,[sp,#8]            ;1909
00002c  f8ad400a          STRH     r4,[sp,#0xa]          ;1910
000030  2200              MOVS     r2,#0                 ;1912
000032  4611              MOV      r1,r2                 ;1912
000034  a801              ADD      r0,sp,#4              ;1912
000036  f7fffffe          BL       op_enqueue
00003a  b118              CBZ      r0,|L11.68|
00003c  f7fffffe          BL       queue_start
000040  2000              MOVS     r0,#0                 ;1915
000042  e7e5              B        |L11.16|
                  |L11.68|
000044  2008              MOVS     r0,#8                 ;1918
000046  e7e3              B        |L11.16|
;;;1920   
                          ENDP


                          AREA ||i.fds_gc||, CODE, READONLY, ALIGN=2

                  fds_gc PROC
;;;1921   
;;;1922   ret_code_t fds_gc(void)
000000  b500              PUSH     {lr}
;;;1923   {
000002  b087              SUB      sp,sp,#0x1c
;;;1924       fds_op_t op;
;;;1925   
;;;1926       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       flag_is_set
00000a  b910              CBNZ     r0,|L12.18|
;;;1927       {
;;;1928           return FDS_ERR_NOT_INITIALIZED;
00000c  2002              MOVS     r0,#2
                  |L12.14|
;;;1929       }
;;;1930   
;;;1931       op.op_code = FDS_OP_GC;
;;;1932   
;;;1933       if (op_enqueue(&op, 0, NULL))
;;;1934       {
;;;1935           if (m_gc.state != GC_BEGIN)
;;;1936           {
;;;1937               // Resume GC by retrying the last step.
;;;1938               m_gc.resume = true;
;;;1939           }
;;;1940   
;;;1941           queue_start();
;;;1942           return FDS_SUCCESS;
;;;1943       }
;;;1944   
;;;1945       return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1946   }
00000e  b007              ADD      sp,sp,#0x1c
000010  bd00              POP      {pc}
                  |L12.18|
000012  2006              MOVS     r0,#6                 ;1931
000014  f88d0000          STRB     r0,[sp,#0]            ;1931
000018  2200              MOVS     r2,#0                 ;1933
00001a  4611              MOV      r1,r2                 ;1933
00001c  4668              MOV      r0,sp                 ;1933
00001e  f7fffffe          BL       op_enqueue
000022  b148              CBZ      r0,|L12.56|
000024  4805              LDR      r0,|L12.60|
000026  7800              LDRB     r0,[r0,#0]            ;1935  ; m_gc
000028  b110              CBZ      r0,|L12.48|
00002a  2001              MOVS     r0,#1                 ;1938
00002c  4903              LDR      r1,|L12.60|
00002e  7308              STRB     r0,[r1,#0xc]          ;1938
                  |L12.48|
000030  f7fffffe          BL       queue_start
000034  2000              MOVS     r0,#0                 ;1942
000036  e7ea              B        |L12.14|
                  |L12.56|
000038  2008              MOVS     r0,#8                 ;1945
00003a  e7e8              B        |L12.14|
;;;1947   
                          ENDP

                  |L12.60|
                          DCD      m_gc

                          AREA ||i.fds_init||, CODE, READONLY, ALIGN=1

                  fds_init PROC
;;;1602   
;;;1603   ret_code_t fds_init(void)
000000  b510              PUSH     {r4,lr}
;;;1604   {
000002  b08c              SUB      sp,sp,#0x30
;;;1605       fds_evt_t const evt_success = { .id = FDS_EVT_INIT, .result = FDS_SUCCESS };
000004  2114              MOVS     r1,#0x14
000006  a807              ADD      r0,sp,#0x1c
000008  f7fffffe          BL       __aeabi_memclr4
;;;1606   
;;;1607       // No initialization is necessary. Notify the application immediately.
;;;1608       if (flag_is_set(FDS_FLAG_INITIALIZED))
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       flag_is_set
000012  b128              CBZ      r0,|L13.32|
;;;1609       {
;;;1610           event_send(&evt_success);
000014  a807              ADD      r0,sp,#0x1c
000016  f7fffffe          BL       event_send
;;;1611           return FDS_SUCCESS;
00001a  2000              MOVS     r0,#0
                  |L13.28|
;;;1612       }
;;;1613   
;;;1614       if (flag_is_set(FDS_FLAG_INITIALIZING))
;;;1615       {
;;;1616           return FDS_SUCCESS;
;;;1617       }
;;;1618   
;;;1619       flag_set(FDS_FLAG_INITIALIZING);
;;;1620   
;;;1621       (void)fs_init();
;;;1622   
;;;1623       // Initialize the page structure (m_pages), and determine which
;;;1624       // initialization steps are required given the current state of the filesystem.
;;;1625       fds_init_opts_t init_opts = pages_init();
;;;1626   
;;;1627       if (init_opts == NO_PAGES)
;;;1628       {
;;;1629           return FDS_ERR_NO_PAGES;
;;;1630       }
;;;1631   
;;;1632       if (init_opts == ALREADY_INSTALLED)
;;;1633       {
;;;1634           // No initialization is necessary. Notify the application immediately.
;;;1635           flag_set(FDS_FLAG_INITIALIZED);
;;;1636           flag_clear(FDS_FLAG_INITIALIZING);
;;;1637   
;;;1638           event_send(&evt_success);
;;;1639           return FDS_SUCCESS;
;;;1640       }
;;;1641   
;;;1642       fds_op_t op;
;;;1643       op.op_code = FDS_OP_INIT;
;;;1644   
;;;1645       switch (init_opts)
;;;1646       {
;;;1647           case FRESH_INSTALL:
;;;1648           case TAG_SWAP:
;;;1649               op.init.step = FDS_OP_INIT_TAG_SWAP;
;;;1650               break;
;;;1651   
;;;1652           case PROMOTE_SWAP:
;;;1653           case PROMOTE_SWAP_INST:
;;;1654               op.init.step = FDS_OP_INIT_PROMOTE_SWAP;
;;;1655               break;
;;;1656   
;;;1657           case DISCARD_SWAP:
;;;1658               op.init.step = FDS_OP_INIT_ERASE_SWAP;
;;;1659               break;
;;;1660   
;;;1661           case TAG_DATA:
;;;1662           case TAG_DATA_INST:
;;;1663               op.init.step = FDS_OP_INIT_TAG_DATA;
;;;1664               break;
;;;1665   
;;;1666           default:
;;;1667               // Should not happen.
;;;1668               break;
;;;1669       }
;;;1670   
;;;1671       // This cannot fail since it will be the first operation in the queue.
;;;1672       (void)op_enqueue(&op, 0, NULL);
;;;1673   
;;;1674       queue_start();
;;;1675   
;;;1676       return FDS_SUCCESS;
;;;1677   }
00001c  b00c              ADD      sp,sp,#0x30
00001e  bd10              POP      {r4,pc}
                  |L13.32|
000020  2001              MOVS     r0,#1                 ;1614
000022  f7fffffe          BL       flag_is_set
000026  b108              CBZ      r0,|L13.44|
000028  2000              MOVS     r0,#0                 ;1616
00002a  e7f7              B        |L13.28|
                  |L13.44|
00002c  2001              MOVS     r0,#1                 ;1619
00002e  f7fffffe          BL       flag_set
000032  f7fffffe          BL       fs_init
000036  f7fffffe          BL       pages_init
00003a  4604              MOV      r4,r0                 ;1625
00003c  b90c              CBNZ     r4,|L13.66|
00003e  200b              MOVS     r0,#0xb               ;1629
000040  e7ec              B        |L13.28|
                  |L13.66|
000042  2c06              CMP      r4,#6                 ;1632
000044  d10a              BNE      |L13.92|
000046  2002              MOVS     r0,#2                 ;1635
000048  f7fffffe          BL       flag_set
00004c  2001              MOVS     r0,#1                 ;1636
00004e  f7fffffe          BL       flag_clear
000052  a807              ADD      r0,sp,#0x1c           ;1638
000054  f7fffffe          BL       event_send
000058  2000              MOVS     r0,#0                 ;1639
00005a  e7df              B        |L13.28|
                  |L13.92|
00005c  2001              MOVS     r0,#1                 ;1643
00005e  f88d0000          STRB     r0,[sp,#0]            ;1643
000062  2c0c              CMP      r4,#0xc               ;1645
000064  d21a              BCS      |L13.156|
000066  e8dff004          TBB      [pc,r4]               ;1645
00006a  1906              DCB      0x19,0x06
00006c  19071914          DCB      0x19,0x07,0x19,0x14
000070  1915190b          DCB      0x19,0x15,0x19,0x0b
000074  100c              DCB      0x10,0x0c
000076  bf00              NOP                            ;1648
000078  2000              MOVS     r0,#0                 ;1649
00007a  f88d0004          STRB     r0,[sp,#4]            ;1649
00007e  e00e              B        |L13.158|
000080  bf00              NOP                            ;1653
000082  2003              MOVS     r0,#3                 ;1654
000084  f88d0004          STRB     r0,[sp,#4]            ;1654
000088  e009              B        |L13.158|
00008a  2002              MOVS     r0,#2                 ;1658
00008c  f88d0004          STRB     r0,[sp,#4]            ;1658
000090  e005              B        |L13.158|
000092  bf00              NOP                            ;1662
000094  2001              MOVS     r0,#1                 ;1663
000096  f88d0004          STRB     r0,[sp,#4]            ;1663
00009a  e000              B        |L13.158|
                  |L13.156|
00009c  bf00              NOP                            ;1668
                  |L13.158|
00009e  bf00              NOP                            ;1650
0000a0  2200              MOVS     r2,#0                 ;1672
0000a2  4611              MOV      r1,r2                 ;1672
0000a4  4668              MOV      r0,sp                 ;1672
0000a6  f7fffffe          BL       op_enqueue
0000aa  f7fffffe          BL       queue_start
0000ae  2000              MOVS     r0,#0                 ;1676
0000b0  e7b4              B        |L13.28|
;;;1678   
                          ENDP


                          AREA ||i.fds_record_close||, CODE, READONLY, ALIGN=2

                  fds_record_close PROC
;;;1723   
;;;1724   ret_code_t fds_record_close(fds_record_desc_t * const p_desc)
000000  b538              PUSH     {r3-r5,lr}
;;;1725   {
000002  4604              MOV      r4,r0
;;;1726       ret_code_t ret;
;;;1727       uint16_t   page;
;;;1728   
;;;1729       if (p_desc == NULL)
000004  b90c              CBNZ     r4,|L14.10|
;;;1730       {
;;;1731           return FDS_ERR_NULL_ARG;
000006  2005              MOVS     r0,#5
                  |L14.8|
;;;1732       }
;;;1733   
;;;1734       if (record_find_by_desc((fds_record_desc_t*)p_desc, &page))
;;;1735       {
;;;1736           CRITICAL_SECTION_ENTER();
;;;1737           if ((m_pages[page].records_open > 0) && (p_desc->record_is_open))
;;;1738           {
;;;1739   
;;;1740               m_pages[page].records_open--;
;;;1741               p_desc->record_is_open = false;
;;;1742   
;;;1743               ret = FDS_SUCCESS;
;;;1744           }
;;;1745           else
;;;1746           {
;;;1747               ret = FDS_ERR_NO_OPEN_RECORDS;
;;;1748           }
;;;1749           CRITICAL_SECTION_EXIT();
;;;1750       }
;;;1751       else
;;;1752       {
;;;1753           ret = FDS_ERR_NOT_FOUND;
;;;1754       }
;;;1755   
;;;1756       return ret;
;;;1757   }
000008  bd38              POP      {r3-r5,pc}
                  |L14.10|
00000a  4669              MOV      r1,sp                 ;1734
00000c  4620              MOV      r0,r4                 ;1734
00000e  f7fffffe          BL       record_find_by_desc
000012  b1e0              CBZ      r0,|L14.78|
000014  480f              LDR      r0,|L14.84|
000016  f8bd1000          LDRH     r1,[sp,#0]            ;1737
00001a  eb001001          ADD      r0,r0,r1,LSL #4       ;1737
00001e  8980              LDRH     r0,[r0,#0xc]          ;1737
000020  2800              CMP      r0,#0                 ;1737
000022  dd12              BLE      |L14.74|
000024  7aa0              LDRB     r0,[r4,#0xa]          ;1737
000026  b180              CBZ      r0,|L14.74|
000028  480a              LDR      r0,|L14.84|
00002a  f8bd1000          LDRH     r1,[sp,#0]            ;1740
00002e  eb001001          ADD      r0,r0,r1,LSL #4       ;1740
000032  8980              LDRH     r0,[r0,#0xc]          ;1740
000034  1e40              SUBS     r0,r0,#1              ;1740
000036  4907              LDR      r1,|L14.84|
000038  f8bd2000          LDRH     r2,[sp,#0]            ;1740
00003c  eb011102          ADD      r1,r1,r2,LSL #4       ;1740
000040  8188              STRH     r0,[r1,#0xc]          ;1740
000042  2000              MOVS     r0,#0                 ;1741
000044  72a0              STRB     r0,[r4,#0xa]          ;1741
000046  2500              MOVS     r5,#0                 ;1743
000048  e002              B        |L14.80|
                  |L14.74|
00004a  2506              MOVS     r5,#6                 ;1747
00004c  e000              B        |L14.80|
                  |L14.78|
00004e  250a              MOVS     r5,#0xa               ;1753
                  |L14.80|
000050  4628              MOV      r0,r5                 ;1756
000052  e7d9              B        |L14.8|
;;;1758   
                          ENDP

                  |L14.84|
                          DCD      m_pages

                          AREA ||i.fds_record_delete||, CODE, READONLY, ALIGN=1

                  fds_record_delete PROC
;;;1865   
;;;1866   ret_code_t fds_record_delete(fds_record_desc_t * const p_desc)
000000  b510              PUSH     {r4,lr}
;;;1867   {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;1868       fds_op_t op;
;;;1869   
;;;1870       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       flag_is_set
00000c  b910              CBNZ     r0,|L15.20|
;;;1871       {
;;;1872           return FDS_ERR_NOT_INITIALIZED;
00000e  2002              MOVS     r0,#2
                  |L15.16|
;;;1873       }
;;;1874   
;;;1875       if (p_desc == NULL)
;;;1876       {
;;;1877           return FDS_ERR_NULL_ARG;
;;;1878       }
;;;1879   
;;;1880       op.op_code              = FDS_OP_DEL_RECORD;
;;;1881       op.del.step             = FDS_OP_DEL_RECORD_FLAG_DIRTY;
;;;1882       op.del.record_to_delete = p_desc->record_id;
;;;1883   
;;;1884       if (op_enqueue(&op, 0, NULL))
;;;1885       {
;;;1886           queue_start();
;;;1887           return FDS_SUCCESS;
;;;1888       }
;;;1889   
;;;1890      return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1891   }
000010  b008              ADD      sp,sp,#0x20
000012  bd10              POP      {r4,pc}
                  |L15.20|
000014  b90c              CBNZ     r4,|L15.26|
000016  2005              MOVS     r0,#5                 ;1877
000018  e7fa              B        |L15.16|
                  |L15.26|
00001a  2004              MOVS     r0,#4                 ;1880
00001c  f88d0004          STRB     r0,[sp,#4]            ;1880
000020  2000              MOVS     r0,#0                 ;1881
000022  f88d0008          STRB     r0,[sp,#8]            ;1881
000026  6821              LDR      r1,[r4,#0]            ;1882
000028  9104              STR      r1,[sp,#0x10]         ;1882
00002a  2200              MOVS     r2,#0                 ;1884
00002c  4611              MOV      r1,r2                 ;1884
00002e  a801              ADD      r0,sp,#4              ;1884
000030  f7fffffe          BL       op_enqueue
000034  b118              CBZ      r0,|L15.62|
000036  f7fffffe          BL       queue_start
00003a  2000              MOVS     r0,#0                 ;1887
00003c  e7e8              B        |L15.16|
                  |L15.62|
00003e  2008              MOVS     r0,#8                 ;1890
000040  e7e6              B        |L15.16|
;;;1892   
                          ENDP


                          AREA ||i.fds_record_find||, CODE, READONLY, ALIGN=1

                  fds_record_find PROC
;;;1955   
;;;1956   ret_code_t fds_record_find(uint16_t                  file_id,
000000  b57f              PUSH     {r0-r6,lr}
;;;1957                              uint16_t                  record_key,
;;;1958                              fds_record_desc_t * const p_desc,
;;;1959                              fds_find_token_t  * const p_token)
;;;1960   {
000002  4614              MOV      r4,r2
000004  461d              MOV      r5,r3
;;;1961       return record_find(&file_id, &record_key, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  a901              ADD      r1,sp,#4
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       record_find
;;;1962   }
000012  b004              ADD      sp,sp,#0x10
000014  bd70              POP      {r4-r6,pc}
;;;1963   
                          ENDP


                          AREA ||i.fds_record_find_by_key||, CODE, READONLY, ALIGN=1

                  fds_record_find_by_key PROC
;;;1964   
;;;1965   ret_code_t fds_record_find_by_key(uint16_t                  record_key,
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;1966                                     fds_record_desc_t * const p_desc,
;;;1967                                     fds_find_token_t  * const p_token)
;;;1968   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;1969       return record_find(NULL, &record_key, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  4669              MOV      r1,sp
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       record_find
;;;1970   }
000012  bd3e              POP      {r1-r5,pc}
;;;1971   
                          ENDP


                          AREA ||i.fds_record_find_in_file||, CODE, READONLY, ALIGN=1

                  fds_record_find_in_file PROC
;;;1972   
;;;1973   ret_code_t fds_record_find_in_file(uint16_t                  file_id,
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;1974                                      fds_record_desc_t * const p_desc,
;;;1975                                      fds_find_token_t  * const p_token)
;;;1976   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;1977       return record_find(&file_id, NULL, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  2100              MOVS     r1,#0
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       record_find
;;;1978   }
000012  bd3e              POP      {r1-r5,pc}
;;;1979   
                          ENDP


                          AREA ||i.fds_record_id_from_desc||, CODE, READONLY, ALIGN=1

                  fds_record_id_from_desc PROC
;;;1996   
;;;1997   ret_code_t fds_record_id_from_desc(fds_record_desc_t const * const p_desc,
000000  4602              MOV      r2,r0
;;;1998                                      uint32_t                * const p_record_id)
;;;1999   {
;;;2000       if ((p_desc == NULL) || (p_record_id == NULL))
000002  b102              CBZ      r2,|L19.6|
000004  b909              CBNZ     r1,|L19.10|
                  |L19.6|
;;;2001       {
;;;2002           return FDS_ERR_NULL_ARG;
000006  2005              MOVS     r0,#5
                  |L19.8|
;;;2003       }
;;;2004   
;;;2005       *p_record_id = p_desc->record_id;
;;;2006   
;;;2007       return FDS_SUCCESS;
;;;2008   }
000008  4770              BX       lr
                  |L19.10|
00000a  6810              LDR      r0,[r2,#0]            ;2005
00000c  6008              STR      r0,[r1,#0]            ;2005
00000e  2000              MOVS     r0,#0                 ;2007
000010  e7fa              B        |L19.8|
;;;2009   
                          ENDP


                          AREA ||i.fds_record_iterate||, CODE, READONLY, ALIGN=1

                  fds_record_iterate PROC
;;;1948   
;;;1949   ret_code_t fds_record_iterate(fds_record_desc_t * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1950                                 fds_find_token_t  * const p_token)
;;;1951   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1952       return record_find(NULL, NULL, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  2100              MOVS     r1,#0
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       record_find
;;;1953   }
000012  bd70              POP      {r4-r6,pc}
;;;1954   
                          ENDP


                          AREA ||i.fds_record_open||, CODE, READONLY, ALIGN=2

                  fds_record_open PROC
;;;1679   
;;;1680   ret_code_t fds_record_open(fds_record_desc_t  * const p_desc,
000000  b538              PUSH     {r3-r5,lr}
;;;1681                              fds_flash_record_t * const p_flash_rec)
;;;1682   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1683       uint16_t page;
;;;1684   
;;;1685       if ((p_desc == NULL) || (p_flash_rec == NULL))
000006  b104              CBZ      r4,|L21.10|
000008  b90d              CBNZ     r5,|L21.14|
                  |L21.10|
;;;1686       {
;;;1687           return FDS_ERR_NULL_ARG;
00000a  2005              MOVS     r0,#5
                  |L21.12|
;;;1688       }
;;;1689   
;;;1690       // Find the record if necessary.
;;;1691       if (record_find_by_desc(p_desc, &page))
;;;1692       {
;;;1693           fds_header_t const * const p_header = (fds_header_t*)p_desc->p_record;
;;;1694   
;;;1695   #if defined(FDS_CRC_ENABLED)
;;;1696           if (!crc_verify_success(p_header->ic.crc16,
;;;1697                                   p_header->tl.length_words,
;;;1698                                   p_desc->p_record))
;;;1699           {
;;;1700               return FDS_ERR_CRC_CHECK_FAILED;
;;;1701           }
;;;1702   #endif
;;;1703   
;;;1704           CRITICAL_SECTION_ENTER();
;;;1705           m_pages[page].records_open++;
;;;1706           CRITICAL_SECTION_EXIT();
;;;1707   
;;;1708           // Initialize p_flash_rec.
;;;1709           p_flash_rec->p_header = p_header;
;;;1710           p_flash_rec->p_data   = (p_desc->p_record + FDS_HEADER_SIZE);
;;;1711   
;;;1712           // Set the record as open in the descriptor.
;;;1713           p_desc->record_is_open = true;
;;;1714   
;;;1715           return FDS_SUCCESS;
;;;1716       }
;;;1717   
;;;1718       // The record could not be found.
;;;1719       // It either never existed or it has been deleted.
;;;1720       return FDS_ERR_NOT_FOUND;
;;;1721   }
00000c  bd38              POP      {r3-r5,pc}
                  |L21.14|
00000e  4669              MOV      r1,sp                 ;1691
000010  4620              MOV      r0,r4                 ;1691
000012  f7fffffe          BL       record_find_by_desc
000016  b1a8              CBZ      r0,|L21.68|
000018  6861              LDR      r1,[r4,#4]            ;1693
00001a  480b              LDR      r0,|L21.72|
00001c  f8bd2000          LDRH     r2,[sp,#0]            ;1705
000020  eb001002          ADD      r0,r0,r2,LSL #4       ;1705
000024  8980              LDRH     r0,[r0,#0xc]          ;1705
000026  1c40              ADDS     r0,r0,#1              ;1705
000028  4a07              LDR      r2,|L21.72|
00002a  f8bd3000          LDRH     r3,[sp,#0]            ;1705
00002e  eb021203          ADD      r2,r2,r3,LSL #4       ;1705
000032  8190              STRH     r0,[r2,#0xc]          ;1705
000034  6029              STR      r1,[r5,#0]            ;1709
000036  6860              LDR      r0,[r4,#4]            ;1710
000038  300c              ADDS     r0,r0,#0xc            ;1710
00003a  6068              STR      r0,[r5,#4]            ;1710
00003c  2001              MOVS     r0,#1                 ;1713
00003e  72a0              STRB     r0,[r4,#0xa]          ;1713
000040  2000              MOVS     r0,#0                 ;1715
000042  e7e3              B        |L21.12|
                  |L21.68|
000044  200a              MOVS     r0,#0xa               ;1720
000046  e7e1              B        |L21.12|
;;;1722   
                          ENDP

                  |L21.72|
                          DCD      m_pages

                          AREA ||i.fds_record_update||, CODE, READONLY, ALIGN=1

                  fds_record_update PROC
;;;1852   
;;;1853   ret_code_t fds_record_update(fds_record_desc_t       * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1854                                fds_record_t      const * const p_record)
;;;1855   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1856       // A NULL descriptor is not allowed when updating a record.
;;;1857       if (p_desc == NULL)
000006  b90c              CBNZ     r4,|L22.12|
;;;1858       {
;;;1859           return FDS_ERR_NULL_ARG;
000008  2005              MOVS     r0,#5
                  |L22.10|
;;;1860       }
;;;1861   
;;;1862       return write_enqueue(p_desc, p_record, NULL, FDS_OP_UPDATE);
;;;1863   }
00000a  bd70              POP      {r4-r6,pc}
                  |L22.12|
00000c  2303              MOVS     r3,#3                 ;1862
00000e  2200              MOVS     r2,#0                 ;1862
000010  4629              MOV      r1,r5                 ;1862
000012  4620              MOV      r0,r4                 ;1862
000014  f7fffffe          BL       write_enqueue
000018  e7f7              B        |L22.10|
;;;1864   
                          ENDP


                          AREA ||i.fds_record_write||, CODE, READONLY, ALIGN=1

                  fds_record_write PROC
;;;1831   
;;;1832   ret_code_t fds_record_write(fds_record_desc_t       * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1833                               fds_record_t      const * const p_record)
;;;1834   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1835       return write_enqueue(p_desc, p_record, NULL, FDS_OP_WRITE);
000006  2302              MOVS     r3,#2
000008  2200              MOVS     r2,#0
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       write_enqueue
;;;1836   }
000012  bd70              POP      {r4-r6,pc}
;;;1837   
                          ENDP


                          AREA ||i.fds_record_write_reserved||, CODE, READONLY, ALIGN=1

                  fds_record_write_reserved PROC
;;;1838   
;;;1839   ret_code_t fds_record_write_reserved(fds_record_desc_t         * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1840                                        fds_record_t        const * const p_record,
;;;1841                                        fds_reserve_token_t const * const p_tok)
;;;1842   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1843       // A NULL token is not allowed when writing to a reserved space.
;;;1844       if (p_tok == NULL)
000008  b90c              CBNZ     r4,|L24.14|
;;;1845       {
;;;1846           return FDS_ERR_NULL_ARG;
00000a  2005              MOVS     r0,#5
                  |L24.12|
;;;1847       }
;;;1848   
;;;1849       return write_enqueue(p_desc, p_record, p_tok, FDS_OP_WRITE);
;;;1850   }
00000c  bd70              POP      {r4-r6,pc}
                  |L24.14|
00000e  2302              MOVS     r3,#2                 ;1849
000010  4622              MOV      r2,r4                 ;1849
000012  4631              MOV      r1,r6                 ;1849
000014  4628              MOV      r0,r5                 ;1849
000016  f7fffffe          BL       write_enqueue
00001a  e7f7              B        |L24.12|
;;;1851   
                          ENDP


                          AREA ||i.fds_register||, CODE, READONLY, ALIGN=2

                  fds_register PROC
;;;1580   
;;;1581   ret_code_t fds_register(fds_cb_t cb)
000000  4601              MOV      r1,r0
;;;1582   {
;;;1583       ret_code_t ret;
;;;1584   
;;;1585       CRITICAL_SECTION_ENTER();
;;;1586       if (m_users == FDS_MAX_USERS)
000002  4a09              LDR      r2,|L25.40|
000004  7812              LDRB     r2,[r2,#0]  ; m_users
000006  2a08              CMP      r2,#8
000008  d101              BNE      |L25.14|
;;;1587       {
;;;1588           ret = FDS_ERR_USER_LIMIT_REACHED;
00000a  200c              MOVS     r0,#0xc
00000c  e00a              B        |L25.36|
                  |L25.14|
;;;1589       }
;;;1590       else
;;;1591       {
;;;1592           m_cb_table[m_users] = cb;
00000e  4a07              LDR      r2,|L25.44|
000010  4b05              LDR      r3,|L25.40|
000012  781b              LDRB     r3,[r3,#0]  ; m_users
000014  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1593           m_users++;
000018  4a03              LDR      r2,|L25.40|
00001a  7812              LDRB     r2,[r2,#0]  ; m_users
00001c  1c52              ADDS     r2,r2,#1
00001e  4b02              LDR      r3,|L25.40|
000020  701a              STRB     r2,[r3,#0]
;;;1594   
;;;1595           ret = FDS_SUCCESS;
000022  2000              MOVS     r0,#0
                  |L25.36|
;;;1596       }
;;;1597       CRITICAL_SECTION_EXIT();
;;;1598   
;;;1599       return ret;
;;;1600   }
000024  4770              BX       lr
;;;1601   
                          ENDP

000026  0000              DCW      0x0000
                  |L25.40|
                          DCD      m_users
                  |L25.44|
                          DCD      m_cb_table

                          AREA ||i.fds_reserve||, CODE, READONLY, ALIGN=1

                  fds_reserve PROC
;;;1759   
;;;1760   ret_code_t fds_reserve(fds_reserve_token_t * const p_tok, uint16_t length_words)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1761   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1762       ret_code_t ret;
;;;1763       uint16_t   page;
;;;1764   
;;;1765       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       flag_is_set
00000c  b908              CBNZ     r0,|L26.18|
;;;1766       {
;;;1767           return FDS_ERR_NOT_INITIALIZED;
00000e  2002              MOVS     r0,#2
                  |L26.16|
;;;1768       }
;;;1769   
;;;1770       if (p_tok == NULL)
;;;1771       {
;;;1772           return FDS_ERR_NULL_ARG;
;;;1773       }
;;;1774   
;;;1775       ret = write_space_reserve(length_words, &page);
;;;1776   
;;;1777       if (ret == FDS_SUCCESS)
;;;1778       {
;;;1779           p_tok->page         = page;
;;;1780           p_tok->length_words = length_words;
;;;1781       }
;;;1782   
;;;1783       return ret;
;;;1784   }
000010  bdf8              POP      {r3-r7,pc}
                  |L26.18|
000012  b90c              CBNZ     r4,|L26.24|
000014  2005              MOVS     r0,#5                 ;1772
000016  e7fb              B        |L26.16|
                  |L26.24|
000018  4669              MOV      r1,sp                 ;1775
00001a  4628              MOV      r0,r5                 ;1775
00001c  f7fffffe          BL       write_space_reserve
000020  4606              MOV      r6,r0                 ;1775
000022  b91e              CBNZ     r6,|L26.44|
000024  f8bd0000          LDRH     r0,[sp,#0]            ;1779
000028  8020              STRH     r0,[r4,#0]            ;1779
00002a  8065              STRH     r5,[r4,#2]            ;1780
                  |L26.44|
00002c  4630              MOV      r0,r6                 ;1783
00002e  e7ef              B        |L26.16|
;;;1785   
                          ENDP


                          AREA ||i.fds_reserve_cancel||, CODE, READONLY, ALIGN=2

                  fds_reserve_cancel PROC
;;;1786   
;;;1787   ret_code_t fds_reserve_cancel(fds_reserve_token_t * const p_tok)
000000  b570              PUSH     {r4-r6,lr}
;;;1788   {
000002  4604              MOV      r4,r0
;;;1789       ret_code_t ret;
;;;1790   
;;;1791       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       flag_is_set
00000a  b908              CBNZ     r0,|L27.16|
;;;1792       {
;;;1793           return FDS_ERR_NOT_INITIALIZED;
00000c  2002              MOVS     r0,#2
                  |L27.14|
;;;1794       }
;;;1795   
;;;1796       if (p_tok == NULL)
;;;1797       {
;;;1798           return FDS_ERR_NULL_ARG;
;;;1799       }
;;;1800   
;;;1801       if (p_tok->page > FDS_MAX_PAGES)
;;;1802       {
;;;1803           // The page does not exist. This shouldn't happen.
;;;1804           return FDS_ERR_INVALID_ARG;
;;;1805       }
;;;1806   
;;;1807       fds_page_t const * const p_page = &m_pages[p_tok->page];
;;;1808   
;;;1809       CRITICAL_SECTION_ENTER();
;;;1810       if (p_page->words_reserved - (FDS_HEADER_SIZE + p_tok->length_words) >= 0)
;;;1811       {
;;;1812           // Free reserved space.
;;;1813           write_space_free(p_tok->length_words, p_tok->page);
;;;1814   
;;;1815           // Clean the token.
;;;1816           p_tok->page         = 0;
;;;1817           p_tok->length_words = 0;
;;;1818           ret = FDS_SUCCESS;
;;;1819       }
;;;1820       else
;;;1821       {
;;;1822           // We are trying to cancel a reservation of more words than how many are
;;;1823           // currently reserved on the page. Clearly, this shouldn't happen.
;;;1824           ret = FDS_ERR_INVALID_ARG;
;;;1825       }
;;;1826       CRITICAL_SECTION_EXIT();
;;;1827   
;;;1828       return ret;
;;;1829   }
00000e  bd70              POP      {r4-r6,pc}
                  |L27.16|
000010  b90c              CBNZ     r4,|L27.22|
000012  2005              MOVS     r0,#5                 ;1798
000014  e7fb              B        |L27.14|
                  |L27.22|
000016  8820              LDRH     r0,[r4,#0]            ;1801
000018  2802              CMP      r0,#2                 ;1801
00001a  dd01              BLE      |L27.32|
00001c  2004              MOVS     r0,#4                 ;1804
00001e  e7f6              B        |L27.14|
                  |L27.32|
000020  8820              LDRH     r0,[r4,#0]            ;1807
000022  490a              LDR      r1,|L27.76|
000024  eb011600          ADD      r6,r1,r0,LSL #4       ;1807
000028  8971              LDRH     r1,[r6,#0xa]          ;1810
00002a  8860              LDRH     r0,[r4,#2]            ;1810
00002c  1cc0              ADDS     r0,r0,#3              ;1810
00002e  1a08              SUBS     r0,r1,r0              ;1810
000030  d408              BMI      |L27.68|
000032  8821              LDRH     r1,[r4,#0]            ;1813
000034  8860              LDRH     r0,[r4,#2]            ;1813
000036  f7fffffe          BL       write_space_free
00003a  2000              MOVS     r0,#0                 ;1816
00003c  8020              STRH     r0,[r4,#0]            ;1816
00003e  8060              STRH     r0,[r4,#2]            ;1817
000040  2500              MOVS     r5,#0                 ;1818
000042  e000              B        |L27.70|
                  |L27.68|
000044  2504              MOVS     r5,#4                 ;1824
                  |L27.70|
000046  4628              MOV      r0,r5                 ;1828
000048  e7e1              B        |L27.14|
;;;1830   
                          ENDP

00004a  0000              DCW      0x0000
                  |L27.76|
                          DCD      m_pages

                          AREA ||i.fds_stat||, CODE, READONLY, ALIGN=2

                  fds_stat PROC
;;;2010   
;;;2011   ret_code_t fds_stat(fds_stat_t * const p_stat)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2012   {
000004  4604              MOV      r4,r0
;;;2013       uint16_t const words_in_page = FDS_PAGE_SIZE;
000006  f44f6880          MOV      r8,#0x400
;;;2014       // The largest number of free contiguous words on any page.
;;;2015       uint16_t       contig_words  = 0;
00000a  2600              MOVS     r6,#0
;;;2016   
;;;2017       if (!flag_is_set(FDS_FLAG_INITIALIZED))
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       flag_is_set
000012  b910              CBNZ     r0,|L28.26|
;;;2018       {
;;;2019           return FDS_ERR_NOT_INITIALIZED;
000014  2002              MOVS     r0,#2
                  |L28.22|
;;;2020       }
;;;2021   
;;;2022       if (p_stat == NULL)
;;;2023       {
;;;2024           return FDS_ERR_NULL_ARG;
;;;2025       }
;;;2026   
;;;2027       memset(p_stat, 0x00, sizeof(fds_stat_t));
;;;2028   
;;;2029       for (uint16_t i = 0; i < FDS_MAX_PAGES; i++)
;;;2030       {
;;;2031           uint32_t const * p_record   = NULL;
;;;2032           uint16_t const   words_used = m_pages[i].write_offset + m_pages[i].words_reserved;
;;;2033   
;;;2034           p_stat->open_records   += m_pages[i].records_open;
;;;2035           p_stat->words_reserved += m_pages[i].words_reserved;
;;;2036           p_stat->words_used     += words_used;
;;;2037           contig_words           =  (words_in_page - words_used);
;;;2038   
;;;2039           if (contig_words > p_stat->largest_contig)
;;;2040           {
;;;2041               p_stat->largest_contig = contig_words;
;;;2042           }
;;;2043   
;;;2044           while (record_find_next(i, &p_record))
;;;2045           {
;;;2046               p_stat->valid_records++;
;;;2047           }
;;;2048   
;;;2049           dirty_records_stat(i, &p_stat->dirty_records, &p_stat->freeable_words);
;;;2050       }
;;;2051   
;;;2052       return FDS_SUCCESS;
;;;2053   }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L28.26|
00001a  b90c              CBNZ     r4,|L28.32|
00001c  2005              MOVS     r0,#5                 ;2024
00001e  e7fa              B        |L28.22|
                  |L28.32|
000020  210e              MOVS     r1,#0xe               ;2027
000022  4620              MOV      r0,r4                 ;2027
000024  f7fffffe          BL       __aeabi_memclr
000028  2500              MOVS     r5,#0                 ;2029
00002a  e035              B        |L28.152|
                  |L28.44|
00002c  2000              MOVS     r0,#0                 ;2031
00002e  9000              STR      r0,[sp,#0]            ;2031
000030  481b              LDR      r0,|L28.160|
000032  eb001005          ADD      r0,r0,r5,LSL #4       ;2032
000036  8900              LDRH     r0,[r0,#8]            ;2032
000038  4919              LDR      r1,|L28.160|
00003a  eb011105          ADD      r1,r1,r5,LSL #4       ;2032
00003e  8949              LDRH     r1,[r1,#0xa]          ;2032
000040  4408              ADD      r0,r0,r1              ;2032
000042  b287              UXTH     r7,r0                 ;2032
000044  8820              LDRH     r0,[r4,#0]            ;2034
000046  4916              LDR      r1,|L28.160|
000048  eb011105          ADD      r1,r1,r5,LSL #4       ;2034
00004c  8989              LDRH     r1,[r1,#0xc]          ;2034
00004e  4408              ADD      r0,r0,r1              ;2034
000050  8020              STRH     r0,[r4,#0]            ;2034
000052  88e0              LDRH     r0,[r4,#6]            ;2035
000054  4912              LDR      r1,|L28.160|
000056  eb011105          ADD      r1,r1,r5,LSL #4       ;2035
00005a  8949              LDRH     r1,[r1,#0xa]          ;2035
00005c  4408              ADD      r0,r0,r1              ;2035
00005e  80e0              STRH     r0,[r4,#6]            ;2035
000060  8920              LDRH     r0,[r4,#8]            ;2036
000062  4438              ADD      r0,r0,r7              ;2036
000064  8120              STRH     r0,[r4,#8]            ;2036
000066  f5c76080          RSB      r0,r7,#0x400          ;2037
00006a  b286              UXTH     r6,r0                 ;2037
00006c  8960              LDRH     r0,[r4,#0xa]          ;2039
00006e  42b0              CMP      r0,r6                 ;2039
000070  da00              BGE      |L28.116|
000072  8166              STRH     r6,[r4,#0xa]          ;2041
                  |L28.116|
000074  e002              B        |L28.124|
                  |L28.118|
000076  8860              LDRH     r0,[r4,#2]            ;2046
000078  1c40              ADDS     r0,r0,#1              ;2046
00007a  8060              STRH     r0,[r4,#2]            ;2046
                  |L28.124|
00007c  4669              MOV      r1,sp                 ;2044
00007e  4628              MOV      r0,r5                 ;2044
000080  f7fffffe          BL       record_find_next
000084  2800              CMP      r0,#0                 ;2044
000086  d1f6              BNE      |L28.118|
000088  f104020c          ADD      r2,r4,#0xc            ;2049
00008c  1d21              ADDS     r1,r4,#4              ;2049
00008e  4628              MOV      r0,r5                 ;2049
000090  f7fffffe          BL       dirty_records_stat
000094  1c68              ADDS     r0,r5,#1              ;2029
000096  b285              UXTH     r5,r0                 ;2029
                  |L28.152|
000098  2d02              CMP      r5,#2                 ;2029
00009a  dbc7              BLT      |L28.44|
00009c  2000              MOVS     r0,#0                 ;2052
00009e  e7ba              B        |L28.22|
;;;2054   
                          ENDP

                  |L28.160|
                          DCD      m_pages

                          AREA ||i.file_find_and_delete||, CODE, READONLY, ALIGN=2

                  file_find_and_delete PROC
;;;813    // Finds a record within a file and flags it as dirty.
;;;814    static ret_code_t file_find_and_delete(fds_op_t * const p_op)
000000  b53e              PUSH     {r1-r5,lr}
;;;815    {
000002  4604              MOV      r4,r0
;;;816        ret_code_t        ret;
;;;817        fds_record_desc_t desc;
;;;818    
;;;819        // This token must persist across calls.
;;;820        static fds_find_token_t tok = {0};
;;;821    
;;;822        // Pass NULL to ignore the record key.
;;;823        ret = record_find(&p_op->del.file_id, NULL, &desc, &tok);
000004  4b0c              LDR      r3,|L29.56|
000006  466a              MOV      r2,sp
000008  2100              MOVS     r1,#0
00000a  1da0              ADDS     r0,r4,#6
00000c  f7fffffe          BL       record_find
000010  4605              MOV      r5,r0
;;;824    
;;;825        if (ret == FDS_SUCCESS)
000012  b95d              CBNZ     r5,|L29.44|
;;;826        {
;;;827             // A record was found: flag it as dirty.
;;;828            ret = record_header_flag_dirty((uint32_t*)desc.p_record);
000014  9801              LDR      r0,[sp,#4]
000016  f7fffffe          BL       record_header_flag_dirty
00001a  4605              MOV      r5,r0
;;;829    
;;;830            // This page can now be garbage collected.
;;;831            m_pages[tok.page].can_gc = true;
00001c  2001              MOVS     r0,#1
00001e  4906              LDR      r1,|L29.56|
000020  8889              LDRH     r1,[r1,#4]  ; tok
000022  4a06              LDR      r2,|L29.60|
000024  eb021101          ADD      r1,r2,r1,LSL #4
000028  7388              STRB     r0,[r1,#0xe]
00002a  e003              B        |L29.52|
                  |L29.44|
;;;832        }
;;;833        else // FDS_ERR_NOT_FOUND
;;;834        {
;;;835            // No more records were found. Zero the token, so that it can be reused.
;;;836            memset(&tok, 0x00, sizeof(fds_find_token_t));
00002c  4802              LDR      r0,|L29.56|
00002e  2100              MOVS     r1,#0
000030  6001              STR      r1,[r0,#0]  ; tok
000032  6041              STR      r1,[r0,#4]  ; tok
                  |L29.52|
;;;837        }
;;;838    
;;;839        return ret;
000034  4628              MOV      r0,r5
;;;840    }
000036  bd3e              POP      {r1-r5,pc}
;;;841    
                          ENDP

                  |L29.56|
                          DCD      tok
                  |L29.60|
                          DCD      m_pages

                          AREA ||i.flag_clear||, CODE, READONLY, ALIGN=2

                  flag_clear PROC
;;;77     
;;;78     static void flag_clear(fds_flags_t flag)
000000  4902              LDR      r1,|L30.12|
;;;79     {
;;;80         CRITICAL_SECTION_ENTER();
;;;81         m_flags &= ~(flag);
000002  7809              LDRB     r1,[r1,#0]  ; m_flags
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L30.12|
000008  7011              STRB     r1,[r2,#0]
;;;82         CRITICAL_SECTION_EXIT();
;;;83     }
00000a  4770              BX       lr
;;;84     
                          ENDP

                  |L30.12|
                          DCD      m_flags

                          AREA ||i.flag_is_set||, CODE, READONLY, ALIGN=2

                  flag_is_set PROC
;;;85     
;;;86     static bool flag_is_set(fds_flags_t flag)
000000  4601              MOV      r1,r0
;;;87     {
;;;88         return (m_flags & flag);
000002  4804              LDR      r0,|L31.20|
000004  7800              LDRB     r0,[r0,#0]  ; m_flags
000006  4008              ANDS     r0,r0,r1
000008  b108              CBZ      r0,|L31.14|
00000a  2001              MOVS     r0,#1
                  |L31.12|
;;;89     }
00000c  4770              BX       lr
                  |L31.14|
00000e  2000              MOVS     r0,#0                 ;88
000010  e7fc              B        |L31.12|
;;;90     
                          ENDP

000012  0000              DCW      0x0000
                  |L31.20|
                          DCD      m_flags

                          AREA ||i.flag_set||, CODE, READONLY, ALIGN=2

                  flag_set PROC
;;;69     
;;;70     static void flag_set(fds_flags_t flag)
000000  4902              LDR      r1,|L32.12|
;;;71     {
;;;72         CRITICAL_SECTION_ENTER();
;;;73         m_flags |= flag;
000002  7809              LDRB     r1,[r1,#0]  ; m_flags
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L32.12|
000008  7011              STRB     r1,[r2,#0]
;;;74         CRITICAL_SECTION_EXIT();
;;;75     }
00000a  4770              BX       lr
;;;76     
                          ENDP

                  |L32.12|
                          DCD      m_flags

                          AREA ||i.fs_event_handler||, CODE, READONLY, ALIGN=1

                  fs_event_handler PROC
;;;1453   
;;;1454   static void fs_event_handler(fs_evt_t const * const p_evt, fs_ret_t result)
000000  b570              PUSH     {r4-r6,lr}
;;;1455   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1456       queue_process(result);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       queue_process
;;;1457   }
00000c  bd70              POP      {r4-r6,pc}
;;;1458   
                          ENDP


                          AREA ||i.gc_execute||, CODE, READONLY, ALIGN=2

                  gc_execute PROC
;;;1322   
;;;1323   static ret_code_t gc_execute(uint32_t prev_ret)
000000  b570              PUSH     {r4-r6,lr}
;;;1324   {
000002  4605              MOV      r5,r0
;;;1325       ret_code_t ret;
;;;1326   
;;;1327       if (prev_ret != FS_SUCCESS)
000004  b10d              CBZ      r5,|L34.10|
;;;1328       {
;;;1329           return FDS_ERR_OPERATION_TIMEOUT;
000006  2001              MOVS     r0,#1
                  |L34.8|
;;;1330       }
;;;1331   
;;;1332       if (m_gc.resume)
;;;1333       {
;;;1334           m_gc.resume = false;
;;;1335       }
;;;1336       else
;;;1337       {
;;;1338           gc_state_advance();
;;;1339       }
;;;1340   
;;;1341       switch (m_gc.state)
;;;1342       {
;;;1343           case GC_NEXT_PAGE:
;;;1344               ret = gc_next_page();
;;;1345               break;
;;;1346   
;;;1347           case GC_FIND_NEXT_RECORD:
;;;1348               ret = gc_record_find_next();
;;;1349               break;
;;;1350   
;;;1351           case GC_COPY_RECORD:
;;;1352               ret = gc_record_copy();
;;;1353               break;
;;;1354   
;;;1355           case GC_ERASE_PAGE:
;;;1356               ret = gc_page_erase();
;;;1357               break;
;;;1358   
;;;1359           case GC_PROMOTE_SWAP:
;;;1360               ret = gc_swap_promote();
;;;1361               break;
;;;1362   
;;;1363           case GC_TAG_NEW_SWAP:
;;;1364               ret = gc_tag_new_swap();
;;;1365               break;
;;;1366   
;;;1367           default:
;;;1368               // Should not happen.
;;;1369               ret = FDS_ERR_INTERNAL;
;;;1370               break;
;;;1371       }
;;;1372   
;;;1373       // Either FDS_OP_EXECUTING, FDS_OP_COMPLETED, FDS_ERR_BUSY or FDS_ERR_INTERNAL.
;;;1374       return ret;
;;;1375   }
000008  bd70              POP      {r4-r6,pc}
                  |L34.10|
00000a  4818              LDR      r0,|L34.108|
00000c  7b00              LDRB     r0,[r0,#0xc]          ;1332  ; m_gc
00000e  b118              CBZ      r0,|L34.24|
000010  2000              MOVS     r0,#0                 ;1334
000012  4916              LDR      r1,|L34.108|
000014  7308              STRB     r0,[r1,#0xc]          ;1334
000016  e001              B        |L34.28|
                  |L34.24|
000018  f7fffffe          BL       gc_state_advance
                  |L34.28|
00001c  4813              LDR      r0,|L34.108|
00001e  7800              LDRB     r0,[r0,#0]            ;1341  ; m_gc
000020  2808              CMP      r0,#8                 ;1341
000022  d21d              BCS      |L34.96|
000024  e8dff000          TBB      [pc,r0]               ;1341
000028  1c04080c          DCB      0x1c,0x04,0x08,0x0c
00002c  101c1418          DCB      0x10,0x1c,0x14,0x18
000030  f7fffffe          BL       gc_next_page
000034  4604              MOV      r4,r0                 ;1344
000036  e015              B        |L34.100|
000038  f7fffffe          BL       gc_record_find_next
00003c  4604              MOV      r4,r0                 ;1348
00003e  e011              B        |L34.100|
000040  f7fffffe          BL       gc_record_copy
000044  4604              MOV      r4,r0                 ;1352
000046  e00d              B        |L34.100|
000048  f7fffffe          BL       gc_page_erase
00004c  4604              MOV      r4,r0                 ;1356
00004e  e009              B        |L34.100|
000050  f7fffffe          BL       gc_swap_promote
000054  4604              MOV      r4,r0                 ;1360
000056  e005              B        |L34.100|
000058  f7fffffe          BL       gc_tag_new_swap
00005c  4604              MOV      r4,r0                 ;1364
00005e  e001              B        |L34.100|
                  |L34.96|
000060  240f              MOVS     r4,#0xf               ;1369
000062  bf00              NOP                            ;1370
                  |L34.100|
000064  bf00              NOP                            ;1345
000066  4620              MOV      r0,r4                 ;1374
000068  e7ce              B        |L34.8|
;;;1376   
                          ENDP

00006a  0000              DCW      0x0000
                  |L34.108|
                          DCD      m_gc

                          AREA ||i.gc_init||, CODE, READONLY, ALIGN=2

                  gc_init PROC
;;;895    
;;;896    static void gc_init(void)
000000  480c              LDR      r0,|L35.52|
;;;897    {
;;;898        m_gc.run_count++;
000002  8900              LDRH     r0,[r0,#8]  ; m_gc
000004  1c40              ADDS     r0,r0,#1
000006  490b              LDR      r1,|L35.52|
000008  8108              STRH     r0,[r1,#8]
;;;899        m_gc.cur_page = 0;
00000a  2000              MOVS     r0,#0
00000c  8048              STRH     r0,[r1,#2]
;;;900        m_gc.resume   = false;
00000e  7308              STRB     r0,[r1,#0xc]
;;;901    
;;;902        // Setup which pages to GC. Defer checking for open records and the can_gc flag,
;;;903        // as other operations might change those while GC is running.
;;;904        for (uint16_t i = 0; i < FDS_MAX_PAGES; i++)
000010  bf00              NOP      
000012  e00c              B        |L35.46|
                  |L35.20|
;;;905        {
;;;906            m_gc.do_gc_page[i] = (m_pages[i].page_type == FDS_PAGE_DATA);
000014  4908              LDR      r1,|L35.56|
000016  eb011100          ADD      r1,r1,r0,LSL #4
00001a  7809              LDRB     r1,[r1,#0]
00001c  b909              CBNZ     r1,|L35.34|
00001e  2201              MOVS     r2,#1
000020  e000              B        |L35.36|
                  |L35.34|
000022  2200              MOVS     r2,#0
                  |L35.36|
000024  4903              LDR      r1,|L35.52|
000026  310a              ADDS     r1,r1,#0xa
000028  540a              STRB     r2,[r1,r0]
00002a  1c41              ADDS     r1,r0,#1              ;904
00002c  b288              UXTH     r0,r1                 ;904
                  |L35.46|
00002e  2802              CMP      r0,#2                 ;904
000030  dbf0              BLT      |L35.20|
;;;907        }
;;;908    }
000032  4770              BX       lr
;;;909    
                          ENDP

                  |L35.52|
                          DCD      m_gc
                  |L35.56|
                          DCD      m_pages

                          AREA ||i.gc_next_page||, CODE, READONLY, ALIGN=2

                  gc_next_page PROC
;;;1020   
;;;1021   static ret_code_t gc_next_page(void)
000000  b510              PUSH     {r4,lr}
;;;1022   {
;;;1023       if (!gc_page_next(&m_gc.cur_page))
000002  4808              LDR      r0,|L36.36|
000004  f7fffffe          BL       gc_page_next
000008  b940              CBNZ     r0,|L36.28|
;;;1024       {
;;;1025           // No pages left to GC; GC has terminated. Reset the state.
;;;1026           m_gc.state        = GC_BEGIN;
00000a  2000              MOVS     r0,#0
00000c  4905              LDR      r1,|L36.36|
00000e  1e89              SUBS     r1,r1,#2
000010  7008              STRB     r0,[r1,#0]
;;;1027           m_gc.cur_page     = 0;
000012  8048              STRH     r0,[r1,#2]
;;;1028           m_gc.p_record_src = NULL;
000014  6048              STR      r0,[r1,#4]  ; m_gc
;;;1029   
;;;1030           return FDS_OP_COMPLETED;
000016  f641501d          MOV      r0,#0x1d1d
                  |L36.26|
;;;1031       }
;;;1032   
;;;1033       return gc_record_find_next();
;;;1034   }
00001a  bd10              POP      {r4,pc}
                  |L36.28|
00001c  f7fffffe          BL       gc_record_find_next
000020  e7fb              B        |L36.26|
;;;1035   
                          ENDP

000022  0000              DCW      0x0000
                  |L36.36|
                          DCD      m_gc+0x2

                          AREA ||i.gc_page_erase||, CODE, READONLY, ALIGN=2

                  gc_page_erase PROC
;;;948    // records on the page being garbage collected.
;;;949    static ret_code_t gc_page_erase(void)
000000  b570              PUSH     {r4-r6,lr}
;;;950    {
;;;951        uint32_t       ret;
;;;952        uint16_t const gc = m_gc.cur_page;
000002  480d              LDR      r0,|L37.56|
000004  8845              LDRH     r5,[r0,#2]  ; m_gc
;;;953    
;;;954        if (m_pages[gc].records_open == 0)
000006  480d              LDR      r0,|L37.60|
000008  eb001005          ADD      r0,r0,r5,LSL #4
00000c  8980              LDRH     r0,[r0,#0xc]
00000e  b968              CBNZ     r0,|L37.44|
;;;955        {
;;;956            ret = fs_erase(&fs_config, m_pages[gc].p_addr, FDS_PHY_PAGES_IN_VPAGE, NULL);
000010  480a              LDR      r0,|L37.60|
000012  eb001005          ADD      r0,r0,r5,LSL #4
000016  2300              MOVS     r3,#0
000018  2201              MOVS     r2,#1
00001a  6841              LDR      r1,[r0,#4]
00001c  4808              LDR      r0,|L37.64|
00001e  f7fffffe          BL       fs_erase
000022  4604              MOV      r4,r0
;;;957            m_gc.state = GC_ERASE_PAGE;
000024  2004              MOVS     r0,#4
000026  4904              LDR      r1,|L37.56|
000028  7008              STRB     r0,[r1,#0]
00002a  e002              B        |L37.50|
                  |L37.44|
;;;958        }
;;;959        else
;;;960        {
;;;961            // If there are open records, stop garbage collection on this page.
;;;962            // Discard the swap and try to garbage collect another page.
;;;963            ret = gc_swap_erase();
00002c  f7fffffe          BL       gc_swap_erase
000030  4604              MOV      r4,r0
                  |L37.50|
;;;964        }
;;;965    
;;;966        return ret;
000032  4620              MOV      r0,r4
;;;967    }
000034  bd70              POP      {r4-r6,pc}
;;;968    
                          ENDP

000036  0000              DCW      0x0000
                  |L37.56|
                          DCD      m_gc
                  |L37.60|
                          DCD      m_pages
                  |L37.64|
                          DCD      fs_config

                          AREA ||i.gc_page_next||, CODE, READONLY, ALIGN=2

                  gc_page_next PROC
;;;912    // Returns true if there are pages left to garbage collect, returns false otherwise.
;;;913    static bool gc_page_next(uint16_t * const p_next_page)
000000  b510              PUSH     {r4,lr}
;;;914    {
000002  4601              MOV      r1,r0
;;;915        bool ret = false;
000004  2200              MOVS     r2,#0
;;;916    
;;;917        for (uint16_t i = 0; i < FDS_MAX_PAGES; i++)
000006  2000              MOVS     r0,#0
000008  e015              B        |L38.54|
                  |L38.10|
;;;918        {
;;;919            if (m_gc.do_gc_page[i])
00000a  4b0d              LDR      r3,|L38.64|
00000c  5c1b              LDRB     r3,[r3,r0]
00000e  b183              CBZ      r3,|L38.50|
;;;920            {
;;;921                // Do not attempt to GC this page again.
;;;922                m_gc.do_gc_page[i] = false;
000010  2400              MOVS     r4,#0
000012  4b0b              LDR      r3,|L38.64|
000014  541c              STRB     r4,[r3,r0]
;;;923    
;;;924                // Only GC pages with no open records and with some records which have been deleted.
;;;925                if ((m_pages[i].records_open == 0) && (m_pages[i].can_gc == true))
000016  4b0b              LDR      r3,|L38.68|
000018  eb031300          ADD      r3,r3,r0,LSL #4
00001c  899b              LDRH     r3,[r3,#0xc]
00001e  b943              CBNZ     r3,|L38.50|
000020  4b08              LDR      r3,|L38.68|
000022  eb031300          ADD      r3,r3,r0,LSL #4
000026  7b9b              LDRB     r3,[r3,#0xe]
000028  2b01              CMP      r3,#1
00002a  d102              BNE      |L38.50|
;;;926                {
;;;927                    *p_next_page = i;
00002c  8008              STRH     r0,[r1,#0]
;;;928                    ret = true;
00002e  2201              MOVS     r2,#1
;;;929                    break;
000030  e003              B        |L38.58|
                  |L38.50|
000032  1c43              ADDS     r3,r0,#1              ;917
000034  b298              UXTH     r0,r3                 ;917
                  |L38.54|
000036  2802              CMP      r0,#2                 ;917
000038  dbe7              BLT      |L38.10|
                  |L38.58|
00003a  bf00              NOP      
;;;930                }
;;;931            }
;;;932        }
;;;933    
;;;934        return ret;
00003c  4610              MOV      r0,r2
;;;935    }
00003e  bd10              POP      {r4,pc}
;;;936    
                          ENDP

                  |L38.64|
                          DCD      m_gc+0xa
                  |L38.68|
                          DCD      m_pages

                          AREA ||i.gc_record_copy||, CODE, READONLY, ALIGN=2

                  gc_record_copy PROC
;;;970    // Copy the current record to swap.
;;;971    static ret_code_t gc_record_copy(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;972    {
;;;973        fds_header_t const * const p_header   = (fds_header_t*)m_gc.p_record_src;
000002  480c              LDR      r0,|L39.52|
000004  6844              LDR      r4,[r0,#4]  ; m_gc
;;;974        uint32_t     const * const p_dest     = m_swap_page.p_addr + m_swap_page.write_offset;
000006  480c              LDR      r0,|L39.56|
000008  6800              LDR      r0,[r0,#0]  ; m_swap_page
00000a  490b              LDR      r1,|L39.56|
00000c  8889              LDRH     r1,[r1,#4]  ; m_swap_page
00000e  eb000581          ADD      r5,r0,r1,LSL #2
;;;975        uint16_t     const         record_len = FDS_HEADER_SIZE + p_header->tl.length_words;
000012  8860              LDRH     r0,[r4,#2]
000014  1cc0              ADDS     r0,r0,#3
000016  b286              UXTH     r6,r0
;;;976    
;;;977        m_gc.state = GC_COPY_RECORD;
000018  2003              MOVS     r0,#3
00001a  4906              LDR      r1,|L39.52|
00001c  7008              STRB     r0,[r1,#0]
;;;978    
;;;979        // Copy the record to swap; it is guaranteed to fit in the destination page,
;;;980        // so there is no need to check its size. This will either succeed or timeout.
;;;981        return fs_store(&fs_config, p_dest, m_gc.p_record_src, record_len, NULL);
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
000022  4608              MOV      r0,r1
000024  4633              MOV      r3,r6
000026  4629              MOV      r1,r5
000028  6842              LDR      r2,[r0,#4]  ; m_gc
00002a  4804              LDR      r0,|L39.60|
00002c  f7fffffe          BL       fs_store
;;;982    }
000030  bdf8              POP      {r3-r7,pc}
;;;983    
                          ENDP

000032  0000              DCW      0x0000
                  |L39.52|
                          DCD      m_gc
                  |L39.56|
                          DCD      m_swap_page
                  |L39.60|
                          DCD      fs_config

                          AREA ||i.gc_record_find_next||, CODE, READONLY, ALIGN=2

                  gc_record_find_next PROC
;;;984    
;;;985    static ret_code_t gc_record_find_next(void)
000000  b510              PUSH     {r4,lr}
;;;986    {
;;;987        ret_code_t ret;
;;;988    
;;;989        // Find the next valid record to copy.
;;;990        if (record_find_next(m_gc.cur_page, &m_gc.p_record_src))
000002  4907              LDR      r1,|L40.32|
000004  8848              LDRH     r0,[r1,#2]  ; m_gc
000006  1d09              ADDS     r1,r1,#4
000008  f7fffffe          BL       record_find_next
00000c  b118              CBZ      r0,|L40.22|
;;;991        {
;;;992            ret = gc_record_copy();
00000e  f7fffffe          BL       gc_record_copy
000012  4604              MOV      r4,r0
000014  e002              B        |L40.28|
                  |L40.22|
;;;993        }
;;;994        else
;;;995        {
;;;996            // No more records left to copy on this page; swap pages.
;;;997            ret = gc_page_erase();
000016  f7fffffe          BL       gc_page_erase
00001a  4604              MOV      r4,r0
                  |L40.28|
;;;998        }
;;;999    
;;;1000       return ret;
00001c  4620              MOV      r0,r4
;;;1001   }
00001e  bd10              POP      {r4,pc}
;;;1002   
                          ENDP

                  |L40.32|
                          DCD      m_gc

                          AREA ||i.gc_state_advance||, CODE, READONLY, ALIGN=2

                  gc_state_advance PROC
;;;1061   
;;;1062   static void gc_state_advance(void)
000000  b510              PUSH     {r4,lr}
;;;1063   {
;;;1064       switch (m_gc.state)
000002  4814              LDR      r0,|L41.84|
000004  7800              LDRB     r0,[r0,#0]  ; m_gc
000006  2808              CMP      r0,#8
000008  d220              BCS      |L41.76|
00000a  e8dff000          TBB      [pc,r0]
00000e  041f              DCB      0x04,0x1f
000010  1f0a1016          DCB      0x1f,0x0a,0x10,0x16
000014  171b              DCB      0x17,0x1b
;;;1065       {
;;;1066           case GC_BEGIN:
;;;1067               gc_init();
000016  f7fffffe          BL       gc_init
;;;1068               m_gc.state = GC_NEXT_PAGE;
00001a  2001              MOVS     r0,#1
00001c  490d              LDR      r1,|L41.84|
00001e  7008              STRB     r0,[r1,#0]
;;;1069               break;
000020  e015              B        |L41.78|
;;;1070   
;;;1071           // A record was successfully copied.
;;;1072           case GC_COPY_RECORD:
;;;1073               gc_update_swap_offset();
000022  f7fffffe          BL       gc_update_swap_offset
;;;1074               m_gc.state = GC_FIND_NEXT_RECORD;
000026  2002              MOVS     r0,#2
000028  490a              LDR      r1,|L41.84|
00002a  7008              STRB     r0,[r1,#0]
;;;1075               break;
00002c  e00f              B        |L41.78|
;;;1076   
;;;1077           // A page was successfully erased. Prepare to promote the swap.
;;;1078           case GC_ERASE_PAGE:
;;;1079               gc_swap_pages();
00002e  f7fffffe          BL       gc_swap_pages
;;;1080               m_gc.state = GC_PROMOTE_SWAP;
000032  2006              MOVS     r0,#6
000034  4907              LDR      r1,|L41.84|
000036  7008              STRB     r0,[r1,#0]
;;;1081               break;
000038  e009              B        |L41.78|
;;;1082   
;;;1083           // Swap was discarded because the page being GC'ed had open records.
;;;1084           case GC_DISCARD_SWAP:
;;;1085           // Swap was sucessfully promoted.
;;;1086           case GC_PROMOTE_SWAP:
00003a  bf00              NOP      
;;;1087               // Prepare to tag the page just GC'ed as swap.
;;;1088               m_gc.state = GC_TAG_NEW_SWAP;
00003c  2007              MOVS     r0,#7
00003e  4905              LDR      r1,|L41.84|
000040  7008              STRB     r0,[r1,#0]
;;;1089               break;
000042  e004              B        |L41.78|
;;;1090   
;;;1091           case GC_TAG_NEW_SWAP:
;;;1092               m_gc.state = GC_NEXT_PAGE;
000044  2001              MOVS     r0,#1
000046  4903              LDR      r1,|L41.84|
000048  7008              STRB     r0,[r1,#0]
;;;1093               break;
00004a  e000              B        |L41.78|
                  |L41.76|
;;;1094   
;;;1095           default:
;;;1096               // Should not happen.
;;;1097               break;
00004c  bf00              NOP      
                  |L41.78|
00004e  bf00              NOP                            ;1069
;;;1098       }
;;;1099   }
000050  bd10              POP      {r4,pc}
;;;1100   
                          ENDP

000052  0000              DCW      0x0000
                  |L41.84|
                          DCD      m_gc

                          AREA ||i.gc_swap_erase||, CODE, READONLY, ALIGN=2

                  gc_swap_erase PROC
;;;937    
;;;938    static ret_code_t gc_swap_erase(void)
000000  b510              PUSH     {r4,lr}
;;;939    {
;;;940        m_gc.state               = GC_DISCARD_SWAP;
000002  2005              MOVS     r0,#5
000004  4906              LDR      r1,|L42.32|
000006  7008              STRB     r0,[r1,#0]
;;;941        m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
000008  2002              MOVS     r0,#2
00000a  4906              LDR      r1,|L42.36|
00000c  8088              STRH     r0,[r1,#4]
;;;942    
;;;943        return fs_erase(&fs_config, m_swap_page.p_addr, FDS_PHY_PAGES_IN_VPAGE, NULL);
00000e  4608              MOV      r0,r1
000010  2300              MOVS     r3,#0
000012  2201              MOVS     r2,#1
000014  6801              LDR      r1,[r0,#0]  ; m_swap_page
000016  4804              LDR      r0,|L42.40|
000018  f7fffffe          BL       fs_erase
;;;944    }
00001c  bd10              POP      {r4,pc}
;;;945    
                          ENDP

00001e  0000              DCW      0x0000
                  |L42.32|
                          DCD      m_gc
                  |L42.36|
                          DCD      m_swap_page
                  |L42.40|
                          DCD      fs_config

                          AREA ||i.gc_swap_pages||, CODE, READONLY, ALIGN=2

                  gc_swap_pages PROC
;;;1046   
;;;1047   static void gc_swap_pages(void)
000000  490d              LDR      r1,|L43.56|
;;;1048   {
;;;1049       // The page being garbage collected will be the new swap page,
;;;1050       // and the current swap will be used as a data page (promoted).
;;;1051       uint32_t const * const p_addr = m_swap_page.p_addr;
000002  6808              LDR      r0,[r1,#0]  ; m_swap_page
;;;1052   
;;;1053       m_swap_page.p_addr            = m_pages[m_gc.cur_page].p_addr;
000004  490d              LDR      r1,|L43.60|
000006  8849              LDRH     r1,[r1,#2]  ; m_gc
000008  4a0d              LDR      r2,|L43.64|
00000a  eb021101          ADD      r1,r2,r1,LSL #4
00000e  6849              LDR      r1,[r1,#4]
000010  4a09              LDR      r2,|L43.56|
000012  6011              STR      r1,[r2,#0]  ; m_swap_page
;;;1054       m_pages[m_gc.cur_page].p_addr = p_addr;
000014  4909              LDR      r1,|L43.60|
000016  8849              LDRH     r1,[r1,#2]  ; m_gc
000018  4a09              LDR      r2,|L43.64|
00001a  eb021101          ADD      r1,r2,r1,LSL #4
00001e  6048              STR      r0,[r1,#4]
;;;1055   
;;;1056       // Keep the offset for this page, but reset it for the swap.
;;;1057       m_pages[m_gc.cur_page].write_offset = m_swap_page.write_offset;
000020  4905              LDR      r1,|L43.56|
000022  8889              LDRH     r1,[r1,#4]  ; m_swap_page
000024  4a05              LDR      r2,|L43.60|
000026  8852              LDRH     r2,[r2,#2]  ; m_gc
000028  4b05              LDR      r3,|L43.64|
00002a  eb031202          ADD      r2,r3,r2,LSL #4
00002e  8111              STRH     r1,[r2,#8]
;;;1058       m_swap_page.write_offset            = FDS_PAGE_TAG_SIZE;
000030  2102              MOVS     r1,#2
000032  4a01              LDR      r2,|L43.56|
000034  8091              STRH     r1,[r2,#4]
;;;1059   }
000036  4770              BX       lr
;;;1060   
                          ENDP

                  |L43.56|
                          DCD      m_swap_page
                  |L43.60|
                          DCD      m_gc
                  |L43.64|
                          DCD      m_pages

                          AREA ||i.gc_swap_promote||, CODE, READONLY, ALIGN=2

                  gc_swap_promote PROC
;;;1004   // Promote the swap by tagging it as a data page.
;;;1005   static ret_code_t gc_swap_promote(void)
000000  b510              PUSH     {r4,lr}
;;;1006   {
;;;1007       m_gc.state = GC_PROMOTE_SWAP;
000002  2006              MOVS     r0,#6
000004  4904              LDR      r1,|L44.24|
000006  7008              STRB     r0,[r1,#0]
;;;1008       return page_tag_write_data(m_pages[m_gc.cur_page].p_addr);
000008  8849              LDRH     r1,[r1,#2]  ; m_gc
00000a  4a04              LDR      r2,|L44.28|
00000c  eb021101          ADD      r1,r2,r1,LSL #4
000010  6848              LDR      r0,[r1,#4]
000012  f7fffffe          BL       page_tag_write_data
;;;1009   }
000016  bd10              POP      {r4,pc}
;;;1010   
                          ENDP

                  |L44.24|
                          DCD      m_gc
                  |L44.28|
                          DCD      m_pages

                          AREA ||i.gc_tag_new_swap||, CODE, READONLY, ALIGN=2

                  gc_tag_new_swap PROC
;;;1012   // Tag the page just garbage collected as swap.
;;;1013   static ret_code_t gc_tag_new_swap(void)
000000  b510              PUSH     {r4,lr}
;;;1014   {
;;;1015       m_gc.state        = GC_TAG_NEW_SWAP;
000002  2007              MOVS     r0,#7
000004  4903              LDR      r1,|L45.20|
000006  7008              STRB     r0,[r1,#0]
;;;1016       m_gc.p_record_src = NULL;
000008  2000              MOVS     r0,#0
00000a  6048              STR      r0,[r1,#4]  ; m_gc
;;;1017       return page_tag_write_swap();
00000c  f7fffffe          BL       page_tag_write_swap
;;;1018   }
000010  bd10              POP      {r4,pc}
;;;1019   
                          ENDP

000012  0000              DCW      0x0000
                  |L45.20|
                          DCD      m_gc

                          AREA ||i.gc_update_swap_offset||, CODE, READONLY, ALIGN=2

                  gc_update_swap_offset PROC
;;;1037   // Update the swap page offeset after a record has been successfully copied to it.
;;;1038   static void gc_update_swap_offset(void)
000000  4a05              LDR      r2,|L46.24|
;;;1039   {
;;;1040       fds_header_t const * const p_header   = (fds_header_t*)m_gc.p_record_src;
000002  6850              LDR      r0,[r2,#4]  ; m_gc
;;;1041       uint16_t     const         record_len = FDS_HEADER_SIZE + p_header->tl.length_words;
000004  8842              LDRH     r2,[r0,#2]
000006  1cd2              ADDS     r2,r2,#3
000008  b291              UXTH     r1,r2
;;;1042   
;;;1043       m_swap_page.write_offset += record_len;
00000a  4a04              LDR      r2,|L46.28|
00000c  8892              LDRH     r2,[r2,#4]  ; m_swap_page
00000e  440a              ADD      r2,r2,r1
000010  4b02              LDR      r3,|L46.28|
000012  809a              STRH     r2,[r3,#4]
;;;1044   }
000014  4770              BX       lr
;;;1045   
                          ENDP

000016  0000              DCW      0x0000
                  |L46.24|
                          DCD      m_gc
                  |L46.28|
                          DCD      m_swap_page

                          AREA ||i.header_is_valid||, CODE, READONLY, ALIGN=1

                  header_is_valid PROC
;;;150    
;;;151    static bool header_is_valid(fds_header_t const * const p_header)
000000  4601              MOV      r1,r0
;;;152    {
;;;153        return ((p_header->ic.file_id    != FDS_FILE_ID_INVALID) &&
000002  8888              LDRH     r0,[r1,#4]
000004  f64f72ff          MOV      r2,#0xffff
000008  4290              CMP      r0,r2
00000a  d003              BEQ      |L47.20|
;;;154                (p_header->tl.record_key != FDS_RECORD_KEY_DIRTY));
00000c  8808              LDRH     r0,[r1,#0]
00000e  b108              CBZ      r0,|L47.20|
000010  2001              MOVS     r0,#1
                  |L47.18|
;;;155    }
000012  4770              BX       lr
                  |L47.20|
000014  2000              MOVS     r0,#0                 ;154
000016  e7fc              B        |L47.18|
;;;156    
                          ENDP


                          AREA ||i.init_execute||, CODE, READONLY, ALIGN=2

                  init_execute PROC
;;;1102   // Initialize the filesystem.
;;;1103   static ret_code_t init_execute(uint32_t prev_ret, fds_op_t * const p_op)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1104   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;1105       ret_code_t ret = FDS_ERR_INTERNAL;
000008  270f              MOVS     r7,#0xf
;;;1106   
;;;1107       if (prev_ret != FS_SUCCESS)
00000a  b12e              CBZ      r6,|L48.24|
;;;1108       {
;;;1109           // A previous operation has timed out.
;;;1110           flag_clear(FDS_FLAG_INITIALIZING);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       flag_clear
;;;1111           return FDS_ERR_OPERATION_TIMEOUT;
000012  2001              MOVS     r0,#1
                  |L48.20|
;;;1112       }
;;;1113   
;;;1114       switch (p_op->init.step)
;;;1115       {
;;;1116           case FDS_OP_INIT_TAG_SWAP:
;;;1117               // The page write offset was determined previously by pages_init().
;;;1118               ret             = page_tag_write_swap();
;;;1119               p_op->init.step = FDS_OP_INIT_TAG_DATA;
;;;1120               break;
;;;1121   
;;;1122           case FDS_OP_INIT_TAG_DATA:
;;;1123           {
;;;1124               // Tag remaining erased pages as data.
;;;1125               bool write_reqd = false;
;;;1126               for (uint16_t i = 0; i < FDS_MAX_PAGES; i++)
;;;1127               {
;;;1128                   if (m_pages[i].page_type == FDS_PAGE_ERASED)
;;;1129                   {
;;;1130                       ret = page_tag_write_data(m_pages[i].p_addr);
;;;1131                       m_pages[i].page_type = FDS_PAGE_DATA;
;;;1132                       write_reqd           = true;
;;;1133                       break;
;;;1134                   }
;;;1135               }
;;;1136               if (!write_reqd)
;;;1137               {
;;;1138                   flag_set(FDS_FLAG_INITIALIZED);
;;;1139                   flag_clear(FDS_FLAG_INITIALIZING);
;;;1140                   return FDS_OP_COMPLETED;
;;;1141               }
;;;1142           }
;;;1143           break;
;;;1144   
;;;1145           case FDS_OP_INIT_ERASE_SWAP:
;;;1146               ret = fs_erase(&fs_config, m_swap_page.p_addr, FDS_PHY_PAGES_IN_VPAGE, NULL);
;;;1147               // If the swap is going to be discarded then reset its write_offset.
;;;1148               m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
;;;1149               p_op->init.step          = FDS_OP_INIT_TAG_SWAP;
;;;1150               break;
;;;1151   
;;;1152           case FDS_OP_INIT_PROMOTE_SWAP:
;;;1153           {
;;;1154               // When promoting the swap, keep the write_offset set by pages_init().
;;;1155               ret = page_tag_write_data(m_swap_page.p_addr);
;;;1156   
;;;1157               uint16_t const         gc         = m_gc.cur_page;
;;;1158               uint32_t const * const p_old_swap = m_swap_page.p_addr;
;;;1159   
;;;1160               // Execute the swap.
;;;1161               m_swap_page.p_addr = m_pages[gc].p_addr;
;;;1162               m_pages[gc].p_addr = p_old_swap;
;;;1163   
;;;1164               // Copy the offset from the swap to the new page.
;;;1165               m_pages[gc].write_offset = m_swap_page.write_offset;
;;;1166               m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
;;;1167   
;;;1168               m_pages[gc].page_type = FDS_PAGE_DATA;
;;;1169               p_op->init.step       = FDS_OP_INIT_TAG_SWAP;
;;;1170           }
;;;1171           break;
;;;1172   
;;;1173           default:
;;;1174               // Should not happen.
;;;1175               break;
;;;1176       }
;;;1177   
;;;1178       if (ret != FDS_SUCCESS)
;;;1179       {
;;;1180           // fstorage queue was full.
;;;1181           flag_clear(FDS_FLAG_INITIALIZING);
;;;1182           return FDS_ERR_BUSY;
;;;1183       }
;;;1184   
;;;1185       return FDS_OP_EXECUTING;
;;;1186   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L48.24|
000018  7920              LDRB     r0,[r4,#4]            ;1114
00001a  b130              CBZ      r0,|L48.42|
00001c  2801              CMP      r0,#1                 ;1114
00001e  d00a              BEQ      |L48.54|
000020  2802              CMP      r0,#2                 ;1114
000022  d033              BEQ      |L48.140|
000024  2803              CMP      r0,#3                 ;1114
000026  d164              BNE      |L48.242|
000028  e03e              B        |L48.168|
                  |L48.42|
00002a  f7fffffe          BL       page_tag_write_swap
00002e  4607              MOV      r7,r0                 ;1118
000030  2001              MOVS     r0,#1                 ;1119
000032  7120              STRB     r0,[r4,#4]            ;1119
000034  e05e              B        |L48.244|
                  |L48.54|
000036  f04f0800          MOV      r8,#0                 ;1125
00003a  2500              MOVS     r5,#0                 ;1126
00003c  e016              B        |L48.108|
                  |L48.62|
00003e  4832              LDR      r0,|L48.264|
000040  eb001005          ADD      r0,r0,r5,LSL #4       ;1128
000044  7800              LDRB     r0,[r0,#0]            ;1128
000046  2802              CMP      r0,#2                 ;1128
000048  d10e              BNE      |L48.104|
00004a  492f              LDR      r1,|L48.264|
00004c  eb011105          ADD      r1,r1,r5,LSL #4       ;1130
000050  6848              LDR      r0,[r1,#4]            ;1130
000052  f7fffffe          BL       page_tag_write_data
000056  4607              MOV      r7,r0                 ;1130
000058  2000              MOVS     r0,#0                 ;1131
00005a  492b              LDR      r1,|L48.264|
00005c  eb011105          ADD      r1,r1,r5,LSL #4       ;1131
000060  7008              STRB     r0,[r1,#0]            ;1131
000062  f04f0801          MOV      r8,#1                 ;1132
000066  e003              B        |L48.112|
                  |L48.104|
000068  1c68              ADDS     r0,r5,#1              ;1126
00006a  b285              UXTH     r5,r0                 ;1126
                  |L48.108|
00006c  2d02              CMP      r5,#2                 ;1126
00006e  dbe6              BLT      |L48.62|
                  |L48.112|
000070  bf00              NOP                            ;1133
000072  f1b80f00          CMP      r8,#0                 ;1136
000076  d108              BNE      |L48.138|
000078  2002              MOVS     r0,#2                 ;1138
00007a  f7fffffe          BL       flag_set
00007e  2001              MOVS     r0,#1                 ;1139
000080  f7fffffe          BL       flag_clear
000084  f641501d          MOV      r0,#0x1d1d            ;1140
000088  e7c4              B        |L48.20|
                  |L48.138|
00008a  e033              B        |L48.244|
                  |L48.140|
00008c  481f              LDR      r0,|L48.268|
00008e  2300              MOVS     r3,#0                 ;1146
000090  2201              MOVS     r2,#1                 ;1146
000092  6801              LDR      r1,[r0,#0]            ;1146  ; m_swap_page
000094  481e              LDR      r0,|L48.272|
000096  f7fffffe          BL       fs_erase
00009a  4607              MOV      r7,r0                 ;1146
00009c  2002              MOVS     r0,#2                 ;1148
00009e  491b              LDR      r1,|L48.268|
0000a0  8088              STRH     r0,[r1,#4]            ;1148
0000a2  2000              MOVS     r0,#0                 ;1149
0000a4  7120              STRB     r0,[r4,#4]            ;1149
0000a6  e025              B        |L48.244|
                  |L48.168|
0000a8  4918              LDR      r1,|L48.268|
0000aa  6808              LDR      r0,[r1,#0]            ;1155  ; m_swap_page
0000ac  f7fffffe          BL       page_tag_write_data
0000b0  4607              MOV      r7,r0                 ;1155
0000b2  4818              LDR      r0,|L48.276|
0000b4  8845              LDRH     r5,[r0,#2]            ;1157  ; m_gc
0000b6  4815              LDR      r0,|L48.268|
0000b8  f8d08000          LDR      r8,[r0,#0]            ;1158  ; m_swap_page
0000bc  4812              LDR      r0,|L48.264|
0000be  eb001005          ADD      r0,r0,r5,LSL #4       ;1161
0000c2  6840              LDR      r0,[r0,#4]            ;1161
0000c4  4911              LDR      r1,|L48.268|
0000c6  6008              STR      r0,[r1,#0]            ;1161  ; m_swap_page
0000c8  480f              LDR      r0,|L48.264|
0000ca  eb001005          ADD      r0,r0,r5,LSL #4       ;1162
0000ce  f8c08004          STR      r8,[r0,#4]            ;1162
0000d2  4608              MOV      r0,r1                 ;1165
0000d4  8880              LDRH     r0,[r0,#4]            ;1165  ; m_swap_page
0000d6  490c              LDR      r1,|L48.264|
0000d8  eb011105          ADD      r1,r1,r5,LSL #4       ;1165
0000dc  8108              STRH     r0,[r1,#8]            ;1165
0000de  2002              MOVS     r0,#2                 ;1166
0000e0  490a              LDR      r1,|L48.268|
0000e2  8088              STRH     r0,[r1,#4]            ;1166
0000e4  2000              MOVS     r0,#0                 ;1168
0000e6  4908              LDR      r1,|L48.264|
0000e8  eb011105          ADD      r1,r1,r5,LSL #4       ;1168
0000ec  7008              STRB     r0,[r1,#0]            ;1168
0000ee  7120              STRB     r0,[r4,#4]            ;1169
0000f0  e000              B        |L48.244|
                  |L48.242|
0000f2  bf00              NOP                            ;1175
                  |L48.244|
0000f4  bf00              NOP                            ;1120
0000f6  b127              CBZ      r7,|L48.258|
0000f8  2001              MOVS     r0,#1                 ;1181
0000fa  f7fffffe          BL       flag_clear
0000fe  200e              MOVS     r0,#0xe               ;1182
000100  e788              B        |L48.20|
                  |L48.258|
000102  2000              MOVS     r0,#0                 ;1185
000104  e786              B        |L48.20|
;;;1187   
                          ENDP

000106  0000              DCW      0x0000
                  |L48.264|
                          DCD      m_pages
                  |L48.268|
                          DCD      m_swap_page
                  |L48.272|
                          DCD      fs_config
                  |L48.276|
                          DCD      m_gc

                          AREA ||i.is_word_aligned||, CODE, READONLY, ALIGN=1

                  is_word_aligned PROC
;;;501     */
;;;502    static __INLINE bool is_word_aligned(void const* p)
000000  4601              MOV      r1,r0
;;;503    {
;;;504        return (((uintptr_t)p & 0x03) == 0);
000002  f0010003          AND      r0,r1,#3
000006  b908              CBNZ     r0,|L49.12|
000008  2001              MOVS     r0,#1
                  |L49.10|
;;;505    }
00000a  4770              BX       lr
                  |L49.12|
00000c  2000              MOVS     r0,#0                 ;504
00000e  e7fc              B        |L49.10|
;;;506    
                          ENDP


                          AREA ||i.op_enqueue||, CODE, READONLY, ALIGN=2

                  op_enqueue PROC
;;;592    // Enqueue an operation.
;;;593    static bool op_enqueue(fds_op_t           const * const p_op,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;594                           uint32_t                         num_chunks,
;;;595                           fds_record_chunk_t const * const p_chunk)
;;;596    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;597        uint32_t idx;
;;;598        bool     ret = false;
00000a  f04f0800          MOV      r8,#0
;;;599    
;;;600        CRITICAL_SECTION_ENTER();
;;;601        if  ((m_op_queue.count    <= FDS_OP_QUEUE_SIZE - 1) &&
00000e  4823              LDR      r0,|L50.156|
000010  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000012  2803              CMP      r0,#3
000014  d83f              BHI      |L50.150|
;;;602             (m_chunk_queue.count <= FDS_CHUNK_QUEUE_SIZE - num_chunks))
000016  4822              LDR      r0,|L50.160|
000018  6c40              LDR      r0,[r0,#0x44]  ; m_chunk_queue
00001a  f1c40108          RSB      r1,r4,#8
00001e  4288              CMP      r0,r1
000020  d839              BHI      |L50.150|
;;;603        {
;;;604            idx = (m_op_queue.count + m_op_queue.rp) % FDS_OP_QUEUE_SIZE;
000022  481e              LDR      r0,|L50.156|
000024  f8900074          LDRB     r0,[r0,#0x74]  ; m_op_queue
000028  491c              LDR      r1,|L50.156|
00002a  f8911070          LDRB     r1,[r1,#0x70]  ; m_op_queue
00002e  4408              ADD      r0,r0,r1
000030  f0000503          AND      r5,r0,#3
;;;605    
;;;606            m_op_queue.op[idx] = *p_op;
000034  ebc501c5          RSB      r1,r5,r5,LSL #3
000038  4a18              LDR      r2,|L50.156|
00003a  eb020081          ADD      r0,r2,r1,LSL #2
00003e  221c              MOVS     r2,#0x1c
000040  4631              MOV      r1,r6
000042  f7fffffe          BL       __aeabi_memcpy4
;;;607            m_op_queue.count++;
000046  4815              LDR      r0,|L50.156|
000048  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
00004a  1c40              ADDS     r0,r0,#1
00004c  4913              LDR      r1,|L50.156|
00004e  6748              STR      r0,[r1,#0x74]  ; m_op_queue
;;;608    
;;;609            if (num_chunks != 0)
000050  b1fc              CBZ      r4,|L50.146|
;;;610            {
;;;611                idx = (m_chunk_queue.count + m_chunk_queue.rp) % FDS_CHUNK_QUEUE_SIZE;
000052  4813              LDR      r0,|L50.160|
000054  f8900044          LDRB     r0,[r0,#0x44]  ; m_chunk_queue
000058  4911              LDR      r1,|L50.160|
00005a  f8911040          LDRB     r1,[r1,#0x40]  ; m_chunk_queue
00005e  4408              ADD      r0,r0,r1
000060  f0000507          AND      r5,r0,#7
;;;612    
;;;613                fds_record_chunk_t * p_chunk_dst;
;;;614                p_chunk_dst = &m_chunk_queue.chunk[idx];
000064  480e              LDR      r0,|L50.160|
000066  eb0000c5          ADD      r0,r0,r5,LSL #3
00006a  9000              STR      r0,[sp,#0]
;;;615    
;;;616                for (uint32_t i = 0; i < num_chunks; i++)
00006c  2300              MOVS     r3,#0
00006e  e008              B        |L50.130|
                  |L50.112|
;;;617                {
;;;618                    *p_chunk_dst = p_chunk[i];
000070  eb0702c3          ADD      r2,r7,r3,LSL #3
000074  9800              LDR      r0,[sp,#0]
000076  ca06              LDM      r2,{r1,r2}
000078  c006              STM      r0!,{r1,r2}
;;;619                    chunk_queue_next(&p_chunk_dst);
00007a  4668              MOV      r0,sp
00007c  f7fffffe          BL       chunk_queue_next
000080  1c5b              ADDS     r3,r3,#1              ;616
                  |L50.130|
000082  42a3              CMP      r3,r4                 ;616
000084  d3f4              BCC      |L50.112|
;;;620                }
;;;621    
;;;622                m_chunk_queue.count += num_chunks;
000086  4806              LDR      r0,|L50.160|
000088  6c40              LDR      r0,[r0,#0x44]  ; m_chunk_queue
00008a  4420              ADD      r0,r0,r4
00008c  4904              LDR      r1,|L50.160|
00008e  6448              STR      r0,[r1,#0x44]  ; m_chunk_queue
;;;623            }
000090  bf00              NOP      
                  |L50.146|
;;;624    
;;;625            ret = true;
000092  f04f0801          MOV      r8,#1
                  |L50.150|
;;;626        }
;;;627        CRITICAL_SECTION_EXIT();
;;;628    
;;;629        return ret;
000096  4640              MOV      r0,r8
;;;630    }
000098  e8bd83f8          POP      {r3-r9,pc}
;;;631    
                          ENDP

                  |L50.156|
                          DCD      m_op_queue
                  |L50.160|
                          DCD      m_chunk_queue

                          AREA ||i.page_from_record||, CODE, READONLY, ALIGN=2

                  page_from_record PROC
;;;226    // Returns FDS_SUCCESS if the page is found, FDS_ERR_NOT_FOUND otherwise.
;;;227    static ret_code_t page_from_record(uint16_t * const p_page, uint32_t const * const p_rec)
000000  b510              PUSH     {r4,lr}
;;;228    {
000002  4602              MOV      r2,r0
;;;229        ret_code_t ret = FDS_ERR_NOT_FOUND;
000004  230a              MOVS     r3,#0xa
;;;230    
;;;231        CRITICAL_SECTION_ENTER();
;;;232        for (uint16_t i = 0; i < FDS_MAX_PAGES; i++)
000006  2000              MOVS     r0,#0
000008  e012              B        |L51.48|
                  |L51.10|
;;;233        {
;;;234            if ((p_rec > m_pages[i].p_addr) &&
00000a  4c0c              LDR      r4,|L51.60|
00000c  eb041400          ADD      r4,r4,r0,LSL #4
000010  6864              LDR      r4,[r4,#4]
000012  428c              CMP      r4,r1
000014  d20a              BCS      |L51.44|
;;;235                (p_rec < m_pages[i].p_addr + FDS_PAGE_SIZE))
000016  4c09              LDR      r4,|L51.60|
000018  eb041400          ADD      r4,r4,r0,LSL #4
00001c  6864              LDR      r4,[r4,#4]
00001e  f5045480          ADD      r4,r4,#0x1000
000022  428c              CMP      r4,r1
000024  d902              BLS      |L51.44|
;;;236            {
;;;237                ret     = FDS_SUCCESS;
000026  2300              MOVS     r3,#0
;;;238                *p_page = i;
000028  8010              STRH     r0,[r2,#0]
;;;239                break;
00002a  e003              B        |L51.52|
                  |L51.44|
00002c  1c44              ADDS     r4,r0,#1              ;232
00002e  b2a0              UXTH     r0,r4                 ;232
                  |L51.48|
000030  2802              CMP      r0,#2                 ;232
000032  dbea              BLT      |L51.10|
                  |L51.52|
000034  bf00              NOP      
;;;240            }
;;;241        }
;;;242        CRITICAL_SECTION_EXIT();
;;;243    
;;;244        return ret;
000036  4618              MOV      r0,r3
;;;245    }
000038  bd10              POP      {r4,pc}
;;;246    
                          ENDP

00003a  0000              DCW      0x0000
                  |L51.60|
                          DCD      m_pages

                          AREA ||i.page_has_space||, CODE, READONLY, ALIGN=2

                  page_has_space PROC
;;;216    // NOTE: Must be called from within a critical section.
;;;217    static bool page_has_space(uint16_t page, uint16_t length_words)
000000  4602              MOV      r2,r0
;;;218    {
;;;219        length_words += m_pages[page].write_offset;
000002  4809              LDR      r0,|L52.40|
000004  eb001002          ADD      r0,r0,r2,LSL #4
000008  8900              LDRH     r0,[r0,#8]
00000a  4408              ADD      r0,r0,r1
00000c  b281              UXTH     r1,r0
;;;220        length_words += m_pages[page].words_reserved;
00000e  4806              LDR      r0,|L52.40|
000010  eb001002          ADD      r0,r0,r2,LSL #4
000014  8940              LDRH     r0,[r0,#0xa]
000016  4408              ADD      r0,r0,r1
000018  b281              UXTH     r1,r0
;;;221        return (length_words < FDS_PAGE_SIZE);
00001a  f5b16f80          CMP      r1,#0x400
00001e  da01              BGE      |L52.36|
000020  2001              MOVS     r0,#1
                  |L52.34|
;;;222    }
000022  4770              BX       lr
                  |L52.36|
000024  2000              MOVS     r0,#0                 ;221
000026  e7fc              B        |L52.34|
;;;223    
                          ENDP

                  |L52.40|
                          DCD      m_pages

                          AREA ||i.page_identify||, CODE, READONLY, ALIGN=2

                  page_identify PROC
;;;180    // Reads a page tag, and determines if the page is used to store data or as swap.
;;;181    static fds_page_type_t page_identify(uint32_t const * const p_page_addr)
000000  4601              MOV      r1,r0
;;;182    {
;;;183        if (p_page_addr[FDS_PAGE_TAG_WORD_0] != FDS_PAGE_TAG_MAGIC)
000002  4a08              LDR      r2,|L53.36|
000004  6808              LDR      r0,[r1,#0]
000006  4290              CMP      r0,r2
000008  d001              BEQ      |L53.14|
;;;184        {
;;;185            return FDS_PAGE_UNDEFINED;
00000a  2003              MOVS     r0,#3
                  |L53.12|
;;;186        }
;;;187    
;;;188        switch (p_page_addr[FDS_PAGE_TAG_WORD_1])
;;;189        {
;;;190            case FDS_PAGE_TAG_SWAP:
;;;191                return FDS_PAGE_SWAP;
;;;192    
;;;193            case FDS_PAGE_TAG_DATA:
;;;194                return FDS_PAGE_DATA;
;;;195    
;;;196            default:
;;;197                return FDS_PAGE_UNDEFINED;
;;;198        }
;;;199    }
00000c  4770              BX       lr
                  |L53.14|
00000e  4a06              LDR      r2,|L53.40|
000010  6848              LDR      r0,[r1,#4]            ;188
000012  4410              ADD      r0,r0,r2              ;188
000014  b110              CBZ      r0,|L53.28|
000016  2801              CMP      r0,#1                 ;188
000018  d102              BNE      |L53.32|
00001a  e7f7              B        |L53.12|
                  |L53.28|
00001c  2000              MOVS     r0,#0                 ;194
00001e  e7f5              B        |L53.12|
                  |L53.32|
000020  2003              MOVS     r0,#3                 ;197
000022  e7f3              B        |L53.12|
;;;200    
                          ENDP

                  |L53.36|
                          DCD      0xdeadc0de
                  |L53.40|
                          DCD      0x0ee1fe02

                          AREA ||i.page_is_erased||, CODE, READONLY, ALIGN=1

                  page_is_erased PROC
;;;201    
;;;202    static bool page_is_erased(uint32_t const * const p_page_addr)
000000  4602              MOV      r2,r0
;;;203    {
;;;204        for (uint32_t i = 0; i < FDS_PAGE_SIZE; i++)
000002  2100              MOVS     r1,#0
000004  e006              B        |L54.20|
                  |L54.6|
;;;205        {
;;;206            if (*(p_page_addr + i) != FDS_ERASED_WORD)
000006  f8520021          LDR      r0,[r2,r1,LSL #2]
00000a  1c40              ADDS     r0,r0,#1
00000c  b108              CBZ      r0,|L54.18|
;;;207            {
;;;208                return false;
00000e  2000              MOVS     r0,#0
                  |L54.16|
;;;209            }
;;;210        }
;;;211    
;;;212        return true;
;;;213    }
000010  4770              BX       lr
                  |L54.18|
000012  1c49              ADDS     r1,r1,#1              ;204
                  |L54.20|
000014  f5b16f80          CMP      r1,#0x400             ;204
000018  d3f5              BCC      |L54.6|
00001a  2001              MOVS     r0,#1                 ;212
00001c  e7f8              B        |L54.16|
;;;214    
                          ENDP


                          AREA ||i.page_offsets_update||, CODE, READONLY, ALIGN=1

                  page_offsets_update PROC
;;;291    
;;;292    static void page_offsets_update(fds_page_t * const p_page, uint16_t length_words)
000000  8903              LDRH     r3,[r0,#8]
;;;293    {
;;;294        p_page->write_offset   += (FDS_HEADER_SIZE + length_words);
000002  1cca              ADDS     r2,r1,#3
000004  441a              ADD      r2,r2,r3
000006  8102              STRH     r2,[r0,#8]
;;;295        p_page->words_reserved -= (FDS_HEADER_SIZE + length_words);
000008  8943              LDRH     r3,[r0,#0xa]
00000a  1cca              ADDS     r2,r1,#3
00000c  1a9a              SUBS     r2,r3,r2
00000e  8142              STRH     r2,[r0,#0xa]
;;;296    }
000010  4770              BX       lr
;;;297    
                          ENDP


                          AREA ||i.page_scan||, CODE, READONLY, ALIGN=2

                  page_scan PROC
;;;251    // If an invalid record header is found, the can_gc argument is set to true.
;;;252    static void page_scan(uint32_t const *       p_addr,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;253                          uint16_t       * const words_written,
;;;254                          bool           * const can_gc)
;;;255    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;256        uint32_t const * const p_end_addr          = p_addr + FDS_PAGE_SIZE;
00000a  f5045880          ADD      r8,r4,#0x1000
;;;257        bool                   dirty_record_found  = false;
00000e  f04f0900          MOV      r9,#0
;;;258    
;;;259        p_addr         += FDS_PAGE_TAG_SIZE;
000012  3408              ADDS     r4,r4,#8
;;;260        *words_written  = FDS_PAGE_TAG_SIZE;
000014  2002              MOVS     r0,#2
000016  8030              STRH     r0,[r6,#0]
;;;261    
;;;262        while ((p_addr < p_end_addr) && (*p_addr != FDS_ERASED_WORD))
000018  e019              B        |L56.78|
                  |L56.26|
;;;263        {
;;;264            // NOTE: Skip records with a dirty key or with a missing file ID.
;;;265            fds_header_t const * const p_header = (fds_header_t*)p_addr;
00001a  4625              MOV      r5,r4
;;;266    
;;;267            if (!header_is_valid(p_header))
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       header_is_valid
000022  b910              CBNZ     r0,|L56.42|
;;;268            {
;;;269                dirty_record_found = true;
000024  f04f0901          MOV      r9,#1
000028  e007              B        |L56.58|
                  |L56.42|
;;;270            }
;;;271            else
;;;272            {
;;;273                // Update the latest (largest) record ID.
;;;274                if (p_header->record_id > m_latest_rec_id)
00002a  490e              LDR      r1,|L56.100|
00002c  68a8              LDR      r0,[r5,#8]
00002e  6809              LDR      r1,[r1,#0]  ; m_latest_rec_id
000030  4288              CMP      r0,r1
000032  d902              BLS      |L56.58|
;;;275                {
;;;276                   m_latest_rec_id = p_header->record_id;
000034  490b              LDR      r1,|L56.100|
000036  68a8              LDR      r0,[r5,#8]
000038  6008              STR      r0,[r1,#0]  ; m_latest_rec_id
                  |L56.58|
;;;277                }
;;;278            }
;;;279    
;;;280            // Jump to the next record.
;;;281            p_addr         += (FDS_HEADER_SIZE + p_header->tl.length_words);
00003a  8868              LDRH     r0,[r5,#2]
00003c  1cc0              ADDS     r0,r0,#3
00003e  eb040480          ADD      r4,r4,r0,LSL #2
;;;282            *words_written += (FDS_HEADER_SIZE + p_header->tl.length_words);
000042  8831              LDRH     r1,[r6,#0]
000044  8868              LDRH     r0,[r5,#2]
000046  1cc0              ADDS     r0,r0,#3
000048  4408              ADD      r0,r0,r1
00004a  8030              STRH     r0,[r6,#0]
;;;283        }
00004c  bf00              NOP      
                  |L56.78|
00004e  4544              CMP      r4,r8                 ;262
000050  d203              BCS      |L56.90|
000052  6820              LDR      r0,[r4,#0]            ;262
000054  1c40              ADDS     r0,r0,#1              ;262
000056  2800              CMP      r0,#0                 ;262
000058  d1df              BNE      |L56.26|
                  |L56.90|
;;;284    
;;;285        if (can_gc != NULL)
00005a  b10f              CBZ      r7,|L56.96|
;;;286        {
;;;287            *can_gc = dirty_record_found;
00005c  f8879000          STRB     r9,[r7,#0]
                  |L56.96|
;;;288        }
;;;289    }
000060  e8bd87f0          POP      {r4-r10,pc}
;;;290    
                          ENDP

                  |L56.100|
                          DCD      m_latest_rec_id

                          AREA ||i.page_tag_write_data||, CODE, READONLY, ALIGN=2

                  page_tag_write_data PROC
;;;308    // Tags a page as data, i.e, ready for storage.
;;;309    static ret_code_t page_tag_write_data(uint32_t const * const p_page_addr)
000000  b538              PUSH     {r3-r5,lr}
;;;310    {
000002  4604              MOV      r4,r0
;;;311        // Needs to be statically allocated since it will be written to flash.
;;;312        static uint32_t const page_tag_data[] = {FDS_PAGE_TAG_MAGIC, FDS_PAGE_TAG_DATA};
;;;313        return fs_store(&fs_config, p_page_addr, page_tag_data, FDS_PAGE_TAG_SIZE, NULL);
000004  2000              MOVS     r0,#0
000006  2302              MOVS     r3,#2
000008  4a03              LDR      r2,|L57.24|
00000a  4621              MOV      r1,r4
00000c  9000              STR      r0,[sp,#0]
00000e  4803              LDR      r0,|L57.28|
000010  f7fffffe          BL       fs_store
;;;314    }
000014  bd38              POP      {r3-r5,pc}
;;;315    
                          ENDP

000016  0000              DCW      0x0000
                  |L57.24|
                          DCD      page_tag_data
                  |L57.28|
                          DCD      fs_config

                          AREA ||i.page_tag_write_swap||, CODE, READONLY, ALIGN=2

                  page_tag_write_swap PROC
;;;299    // Tags a page as swap, i.e., reserved for GC.
;;;300    static ret_code_t page_tag_write_swap()
000000  b508              PUSH     {r3,lr}
;;;301    {
;;;302        // Needs to be statically allocated since it will be written to flash.
;;;303        static uint32_t const page_tag_swap[] = {FDS_PAGE_TAG_MAGIC, FDS_PAGE_TAG_SWAP};
;;;304        return fs_store(&fs_config, m_swap_page.p_addr, page_tag_swap, FDS_PAGE_TAG_SIZE, NULL);
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4804              LDR      r0,|L58.24|
000008  2302              MOVS     r3,#2
00000a  4a04              LDR      r2,|L58.28|
00000c  6801              LDR      r1,[r0,#0]  ; m_swap_page
00000e  4804              LDR      r0,|L58.32|
000010  f7fffffe          BL       fs_store
;;;305    }
000014  bd08              POP      {r3,pc}
;;;306    
                          ENDP

000016  0000              DCW      0x0000
                  |L58.24|
                          DCD      m_swap_page
                  |L58.28|
                          DCD      page_tag_swap
                  |L58.32|
                          DCD      fs_config

                          AREA ||i.pages_init||, CODE, READONLY, ALIGN=2

                  pages_init PROC
;;;634    // provide additional information regarding eventual further initialization steps.
;;;635    static fds_init_opts_t pages_init()
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;636    {
;;;637        uint32_t ret = NO_PAGES;
000004  2600              MOVS     r6,#0
;;;638        // The index of the page being initialized in m_pages[].
;;;639        uint16_t page = 0;
000006  2400              MOVS     r4,#0
;;;640        bool     swap_set_but_not_found  = false;
000008  46a0              MOV      r8,r4
;;;641    
;;;642        for (uint16_t i = 0; i < FDS_VIRTUAL_PAGES; i++)
00000a  2700              MOVS     r7,#0
00000c  e081              B        |L59.274|
                  |L59.14|
;;;643        {
;;;644            uint32_t        const * const p_page_addr = fs_config.p_start_addr + (i * FDS_PAGE_SIZE);
00000e  4844              LDR      r0,|L59.288|
000010  6800              LDR      r0,[r0,#0]  ; fs_config
000012  eb003507          ADD      r5,r0,r7,LSL #12
;;;645            fds_page_type_t const         page_type   = page_identify(p_page_addr);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       page_identify
00001c  4681              MOV      r9,r0
;;;646    
;;;647            switch (page_type)
00001e  f1b90f00          CMP      r9,#0
000022  d032              BEQ      |L59.138|
000024  f1b90f01          CMP      r9,#1
000028  d04a              BEQ      |L59.192|
00002a  f1b90f03          CMP      r9,#3
00002e  d16c              BNE      |L59.266|
;;;648            {
;;;649                case FDS_PAGE_UNDEFINED:
;;;650                    if (page_is_erased(p_page_addr))
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       page_is_erased
000036  b1f8              CBZ      r0,|L59.120|
;;;651                    {
;;;652                        if (m_swap_page.p_addr != NULL)
000038  483a              LDR      r0,|L59.292|
00003a  6800              LDR      r0,[r0,#0]  ; m_swap_page
00003c  b190              CBZ      r0,|L59.100|
;;;653                        {
;;;654                            // If a swap page is already set, flag the page as erased (in m_pages)
;;;655                            // and try to tag it as data (in flash) later on during initialization.
;;;656                            m_pages[page].page_type    = FDS_PAGE_ERASED;
00003e  2002              MOVS     r0,#2
000040  4939              LDR      r1,|L59.296|
000042  eb011104          ADD      r1,r1,r4,LSL #4
000046  7008              STRB     r0,[r1,#0]
;;;657                            m_pages[page].p_addr       = p_page_addr;
000048  4837              LDR      r0,|L59.296|
00004a  eb001004          ADD      r0,r0,r4,LSL #4
00004e  6045              STR      r5,[r0,#4]
;;;658                            m_pages[page].write_offset = FDS_PAGE_TAG_SIZE;
000050  2002              MOVS     r0,#2
000052  4935              LDR      r1,|L59.296|
000054  eb011104          ADD      r1,r1,r4,LSL #4
000058  8108              STRH     r0,[r1,#8]
;;;659    
;;;660                            // This is a candidate for a potential new swap page, in case the
;;;661                            // current swap is going to be promoted to complete a GC instance.
;;;662                            m_gc.cur_page = page;
00005a  4834              LDR      r0,|L59.300|
00005c  8044              STRH     r4,[r0,#2]
;;;663                            page++;
00005e  1c60              ADDS     r0,r4,#1
000060  b284              UXTH     r4,r0
000062  e006              B        |L59.114|
                  |L59.100|
;;;664                        }
;;;665                        else
;;;666                        {
;;;667                            // If there is no swap page yet, use this one.
;;;668                            m_swap_page.p_addr       = p_page_addr;
000064  482f              LDR      r0,|L59.292|
000066  6005              STR      r5,[r0,#0]  ; m_swap_page
;;;669                            m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
000068  2002              MOVS     r0,#2
00006a  492e              LDR      r1,|L59.292|
00006c  8088              STRH     r0,[r1,#4]
;;;670                            swap_set_but_not_found   = true;
00006e  f04f0801          MOV      r8,#1
                  |L59.114|
;;;671                        }
;;;672    
;;;673                        ret |= PAGE_ERASED;
000072  f0460601          ORR      r6,r6,#1
000076  e007              B        |L59.136|
                  |L59.120|
;;;674                    }
;;;675                    else
;;;676                    {
;;;677                        // Do not initialize or use this page.
;;;678                        m_pages[page++].page_type = FDS_PAGE_UNDEFINED;
000078  2203              MOVS     r2,#3
00007a  4620              MOV      r0,r4
00007c  1c61              ADDS     r1,r4,#1
00007e  b28c              UXTH     r4,r1
000080  4929              LDR      r1,|L59.296|
000082  eb011000          ADD      r0,r1,r0,LSL #4
000086  7002              STRB     r2,[r0,#0]
                  |L59.136|
;;;679                    }
;;;680                    break;
000088  e040              B        |L59.268|
                  |L59.138|
;;;681    
;;;682                case FDS_PAGE_DATA:
;;;683                    m_pages[page].page_type = FDS_PAGE_DATA;
00008a  2000              MOVS     r0,#0
00008c  4926              LDR      r1,|L59.296|
00008e  eb011104          ADD      r1,r1,r4,LSL #4
000092  7008              STRB     r0,[r1,#0]
;;;684                    m_pages[page].p_addr    = p_page_addr;
000094  4824              LDR      r0,|L59.296|
000096  eb001004          ADD      r0,r0,r4,LSL #4
00009a  6045              STR      r5,[r0,#4]
;;;685                    // Scan the page to compute its write offset and determine whether or not the page
;;;686                    // can be garbage collected. Additionally, update the latest kwown record ID.
;;;687                    page_scan(p_page_addr, &m_pages[page].write_offset, &m_pages[page].can_gc);
00009c  4822              LDR      r0,|L59.296|
00009e  eb001004          ADD      r0,r0,r4,LSL #4
0000a2  f100020e          ADD      r2,r0,#0xe
0000a6  4820              LDR      r0,|L59.296|
0000a8  eb001004          ADD      r0,r0,r4,LSL #4
0000ac  f1000108          ADD      r1,r0,#8
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       page_scan
;;;688    
;;;689                    ret |= PAGE_DATA;
0000b6  f0460602          ORR      r6,r6,#2
;;;690                    page++;
0000ba  1c60              ADDS     r0,r4,#1
0000bc  b284              UXTH     r4,r0
;;;691    
;;;692                    break;
0000be  e025              B        |L59.268|
                  |L59.192|
;;;693    
;;;694                case FDS_PAGE_SWAP:
;;;695                    if (swap_set_but_not_found)
0000c0  f1b80f00          CMP      r8,#0
0000c4  d011              BEQ      |L59.234|
;;;696                    {
;;;697                        m_pages[page].page_type    = FDS_PAGE_ERASED;
0000c6  2002              MOVS     r0,#2
0000c8  4917              LDR      r1,|L59.296|
0000ca  eb011104          ADD      r1,r1,r4,LSL #4
0000ce  7008              STRB     r0,[r1,#0]
;;;698                        m_pages[page].p_addr       = m_swap_page.p_addr;
0000d0  4814              LDR      r0,|L59.292|
0000d2  6800              LDR      r0,[r0,#0]  ; m_swap_page
0000d4  4914              LDR      r1,|L59.296|
0000d6  eb011104          ADD      r1,r1,r4,LSL #4
0000da  6048              STR      r0,[r1,#4]
;;;699                        m_pages[page].write_offset = FDS_PAGE_TAG_SIZE;
0000dc  2002              MOVS     r0,#2
0000de  4912              LDR      r1,|L59.296|
0000e0  eb011104          ADD      r1,r1,r4,LSL #4
0000e4  8108              STRH     r0,[r1,#8]
;;;700    
;;;701                        page++;
0000e6  1c60              ADDS     r0,r4,#1
0000e8  b284              UXTH     r4,r0
                  |L59.234|
;;;702                    }
;;;703    
;;;704                    m_swap_page.p_addr = p_page_addr;
0000ea  480e              LDR      r0,|L59.292|
0000ec  6005              STR      r5,[r0,#0]  ; m_swap_page
;;;705                    // If the swap is promoted, this offset should be kept, otherwise,
;;;706                    // it should be set to FDS_PAGE_TAG_SIZE.
;;;707                    page_scan(p_page_addr, &m_swap_page.write_offset, NULL);
0000ee  2200              MOVS     r2,#0
0000f0  1d01              ADDS     r1,r0,#4
0000f2  4628              MOV      r0,r5
0000f4  f7fffffe          BL       page_scan
;;;708    
;;;709                    ret |= (m_swap_page.write_offset == FDS_PAGE_TAG_SIZE) ?
0000f8  480a              LDR      r0,|L59.292|
0000fa  8880              LDRH     r0,[r0,#4]  ; m_swap_page
0000fc  2802              CMP      r0,#2
0000fe  d101              BNE      |L59.260|
;;;710                            SWAP_EMPTY : SWAP_DIRTY;
000100  2004              MOVS     r0,#4
000102  e000              B        |L59.262|
                  |L59.260|
000104  2008              MOVS     r0,#8
                  |L59.262|
000106  4306              ORRS     r6,r6,r0
;;;711                    break;
000108  e000              B        |L59.268|
                  |L59.266|
;;;712    
;;;713                default:
;;;714                    // Shouldn't happen.
;;;715                    break;
00010a  bf00              NOP      
                  |L59.268|
00010c  bf00              NOP                            ;680
00010e  1c78              ADDS     r0,r7,#1              ;642
000110  b287              UXTH     r7,r0                 ;642
                  |L59.274|
000112  2f03              CMP      r7,#3                 ;642
000114  f6ffaf7b          BLT      |L59.14|
;;;716            }
;;;717        }
;;;718    
;;;719        return (fds_init_opts_t)ret;
000118  b2f0              UXTB     r0,r6
;;;720    }
00011a  e8bd87f0          POP      {r4-r10,pc}
;;;721    
                          ENDP

00011e  0000              DCW      0x0000
                  |L59.288|
                          DCD      fs_config
                  |L59.292|
                          DCD      m_swap_page
                  |L59.296|
                          DCD      m_pages
                  |L59.300|
                          DCD      m_gc

                          AREA ||i.queue_advance||, CODE, READONLY, ALIGN=2

                  queue_advance PROC
;;;536    // Returns true if the queue is not empty.
;;;537    static bool queue_advance(void)
000000  b510              PUSH     {r4,lr}
;;;538    {
;;;539        // Reset the current element.
;;;540        memset(&m_op_queue.op[m_op_queue.rp], 0x00, sizeof(fds_op_t));
000002  4910              LDR      r1,|L60.68|
000004  6f09              LDR      r1,[r1,#0x70]  ; m_op_queue
000006  ebc101c1          RSB      r1,r1,r1,LSL #3
00000a  4a0e              LDR      r2,|L60.68|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  211c              MOVS     r1,#0x1c
000012  f7fffffe          BL       __aeabi_memclr4
;;;541    
;;;542        if (m_op_queue.count != 0)
000016  480b              LDR      r0,|L60.68|
000018  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
00001a  b158              CBZ      r0,|L60.52|
;;;543        {
;;;544            // Advance in the queue, wrapping around if necessary.
;;;545            m_op_queue.rp = (m_op_queue.rp + 1) % FDS_OP_QUEUE_SIZE;
00001c  4809              LDR      r0,|L60.68|
00001e  f8900070          LDRB     r0,[r0,#0x70]  ; m_op_queue
000022  1c40              ADDS     r0,r0,#1
000024  f0000003          AND      r0,r0,#3
000028  4906              LDR      r1,|L60.68|
00002a  6708              STR      r0,[r1,#0x70]  ; m_op_queue
;;;546            m_op_queue.count--;
00002c  4608              MOV      r0,r1
00002e  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000030  1e40              SUBS     r0,r0,#1
000032  6748              STR      r0,[r1,#0x74]  ; m_op_queue
                  |L60.52|
;;;547        }
;;;548    
;;;549        return (m_op_queue.count != 0);
000034  4803              LDR      r0,|L60.68|
000036  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000038  b108              CBZ      r0,|L60.62|
00003a  2001              MOVS     r0,#1
                  |L60.60|
;;;550    }
00003c  bd10              POP      {r4,pc}
                  |L60.62|
00003e  2000              MOVS     r0,#0                 ;549
000040  e7fc              B        |L60.60|
;;;551    
                          ENDP

000042  0000              DCW      0x0000
                  |L60.68|
                          DCD      m_op_queue

                          AREA ||i.queue_process||, CODE, READONLY, ALIGN=2

                  queue_process PROC
;;;1377   
;;;1378   static void queue_process(fs_ret_t result)
000000  b570              PUSH     {r4-r6,lr}
;;;1379   {
000002  b086              SUB      sp,sp,#0x18
000004  4606              MOV      r6,r0
;;;1380       ret_code_t         ret;
;;;1381       fds_op_t   * const p_op = &m_op_queue.op[m_op_queue.rp];
000006  4826              LDR      r0,|L61.160|
000008  6f00              LDR      r0,[r0,#0x70]  ; m_op_queue
00000a  ebc000c0          RSB      r0,r0,r0,LSL #3
00000e  4924              LDR      r1,|L61.160|
000010  eb010580          ADD      r5,r1,r0,LSL #2
;;;1382   
;;;1383       switch (p_op->op_code)
000014  7828              LDRB     r0,[r5,#0]
000016  2807              CMP      r0,#7
000018  d21e              BCS      |L61.88|
00001a  e8dff000          TBB      [pc,r0]
00001e  1d04              DCB      0x1d,0x04
000020  0a0b1112          DCB      0x0a,0x0b,0x11,0x12
000024  1800              DCB      0x18,0x00
;;;1384       {
;;;1385           case FDS_OP_INIT:
;;;1386               ret = init_execute(result, p_op);
000026  4629              MOV      r1,r5
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       init_execute
00002e  4604              MOV      r4,r0
;;;1387               break;
000030  e014              B        |L61.92|
;;;1388   
;;;1389           case FDS_OP_WRITE:
;;;1390           case FDS_OP_UPDATE:
000032  bf00              NOP      
;;;1391               ret = write_execute(result, p_op);
000034  4629              MOV      r1,r5
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       write_execute
00003c  4604              MOV      r4,r0
;;;1392               break;
00003e  e00d              B        |L61.92|
;;;1393   
;;;1394           case FDS_OP_DEL_RECORD:
;;;1395           case FDS_OP_DEL_FILE:
000040  bf00              NOP      
;;;1396               ret = delete_execute(result, p_op);
000042  4629              MOV      r1,r5
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       delete_execute
00004a  4604              MOV      r4,r0
;;;1397               break;
00004c  e006              B        |L61.92|
;;;1398   
;;;1399           case FDS_OP_GC:
;;;1400               ret = gc_execute(result);
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       gc_execute
000054  4604              MOV      r4,r0
;;;1401               break;
000056  e001              B        |L61.92|
                  |L61.88|
;;;1402   
;;;1403           default:
;;;1404               ret = FDS_ERR_INTERNAL;
000058  240f              MOVS     r4,#0xf
;;;1405               break;
00005a  bf00              NOP      
                  |L61.92|
00005c  bf00              NOP                            ;1387
;;;1406       }
;;;1407   
;;;1408       if (ret != FDS_OP_EXECUTING)
00005e  b1e4              CBZ      r4,|L61.154|
;;;1409       {
;;;1410           fds_evt_t evt;
;;;1411   
;;;1412           if (ret == FDS_OP_COMPLETED)
000060  f641501d          MOV      r0,#0x1d1d
000064  4284              CMP      r4,r0
000066  d102              BNE      |L61.110|
;;;1413           {
;;;1414               evt.result = FDS_SUCCESS;
000068  2000              MOVS     r0,#0
00006a  9002              STR      r0,[sp,#8]
00006c  e003              B        |L61.118|
                  |L61.110|
;;;1415           }
;;;1416           else
;;;1417           {
;;;1418               // Either FDS_ERR_BUSY, FDS_ERR_OPERATION_TIMEOUT,
;;;1419               // FDS_ERR_CRC_CHECK_FAILED or FDS_ERR_NOT_FOUND.
;;;1420               evt.result = ret;
00006e  9402              STR      r4,[sp,#8]
;;;1421   
;;;1422               // If this operation had any chunks in the queue, skip them.
;;;1423               chunk_queue_skip(p_op);
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       chunk_queue_skip
                  |L61.118|
;;;1424           }
;;;1425   
;;;1426           event_prepare(p_op, &evt);
000076  a901              ADD      r1,sp,#4
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       event_prepare
;;;1427           event_send(&evt);
00007e  a801              ADD      r0,sp,#4
000080  f7fffffe          BL       event_send
;;;1428   
;;;1429           // Advance the queue, and if there are any queued operations, process them.
;;;1430           if (queue_advance())
000084  f7fffffe          BL       queue_advance
000088  b118              CBZ      r0,|L61.146|
;;;1431           {
;;;1432               queue_process(FS_SUCCESS);
00008a  2000              MOVS     r0,#0
00008c  f7fffffe          BL       queue_process
000090  e002              B        |L61.152|
                  |L61.146|
;;;1433           }
;;;1434           else
;;;1435           {
;;;1436               // No more elements in the queue. Clear the FDS_FLAG_PROCESSING flag,
;;;1437               // so that new operation can start processing the queue.
;;;1438               flag_clear(FDS_FLAG_PROCESSING);
000092  2004              MOVS     r0,#4
000094  f7fffffe          BL       flag_clear
                  |L61.152|
;;;1439           }
;;;1440       }
000098  bf00              NOP      
                  |L61.154|
;;;1441   }
00009a  b006              ADD      sp,sp,#0x18
00009c  bd70              POP      {r4-r6,pc}
;;;1442   
                          ENDP

00009e  0000              DCW      0x0000
                  |L61.160|
                          DCD      m_op_queue

                          AREA ||i.queue_start||, CODE, READONLY, ALIGN=1

                  queue_start PROC
;;;1443   
;;;1444   static void queue_start(void)
000000  b510              PUSH     {r4,lr}
;;;1445   {
;;;1446       if (!flag_is_set(FDS_FLAG_PROCESSING))
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       flag_is_set
000008  b928              CBNZ     r0,|L62.22|
;;;1447       {
;;;1448           flag_set(FDS_FLAG_PROCESSING);
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       flag_set
;;;1449           queue_process(FS_SUCCESS);
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       queue_process
                  |L62.22|
;;;1450       }
;;;1451   }
000016  bd10              POP      {r4,pc}
;;;1452   
                          ENDP


                          AREA ||i.record_find||, CODE, READONLY, ALIGN=2

                  record_find PROC
;;;450    // If both are NULL, it will iterate through all records.
;;;451    static ret_code_t record_find(uint16_t          const * const p_file_id,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;452                                  uint16_t          const * const p_record_key,
;;;453                                  fds_record_desc_t       * const p_desc,
;;;454                                  fds_find_token_t        * const p_token)
;;;455    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
;;;456        if (!flag_is_set(FDS_FLAG_INITIALIZED))
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       flag_is_set
000012  b910              CBNZ     r0,|L63.26|
;;;457        {
;;;458            return FDS_ERR_NOT_INITIALIZED;
000014  2002              MOVS     r0,#2
                  |L63.22|
;;;459        }
;;;460    
;;;461        if (p_desc == NULL || p_token == NULL)
;;;462        {
;;;463            return FDS_ERR_NULL_ARG;
;;;464        }
;;;465    
;;;466        // Begin (or resume) searching for a record.
;;;467        for (; p_token->page < FDS_MAX_PAGES; p_token->page++)
;;;468        {
;;;469            if (m_pages[p_token->page].page_type != FDS_PAGE_DATA)
;;;470            {
;;;471                // Skip this page.
;;;472                continue;
;;;473            }
;;;474    
;;;475            while (record_find_next(p_token->page, &p_token->p_addr))
;;;476            {
;;;477                fds_header_t const * const p_header = (fds_header_t*)p_token->p_addr;
;;;478    
;;;479                // A valid record was found, check its header for a match.
;;;480                if ((p_file_id != NULL) &&
;;;481                    (p_header->ic.file_id != *p_file_id))
;;;482                {
;;;483                    continue;
;;;484                }
;;;485    
;;;486                if ((p_record_key != NULL) &&
;;;487                    (p_header->tl.record_key != *p_record_key))
;;;488                {
;;;489                    continue;
;;;490                }
;;;491    
;;;492                // Record found; update the descriptor.
;;;493                p_desc->record_id    = p_header->record_id;
;;;494                p_desc->p_record     = p_token->p_addr;
;;;495                p_desc->gc_run_count = m_gc.run_count;
;;;496    
;;;497                return FDS_SUCCESS;
;;;498            }
;;;499    
;;;500            // We have scanned an entire page. Set the address in the token to NULL
;;;501            // so that it will be updated in the next iteration.
;;;502            p_token->p_addr = NULL;
;;;503        }
;;;504    
;;;505        return FDS_ERR_NOT_FOUND;
;;;506    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L63.26|
00001a  b105              CBZ      r5,|L63.30|
00001c  b90c              CBNZ     r4,|L63.34|
                  |L63.30|
00001e  2005              MOVS     r0,#5                 ;463
000020  e7f9              B        |L63.22|
                  |L63.34|
000022  e028              B        |L63.118|
                  |L63.36|
000024  88a0              LDRH     r0,[r4,#4]            ;469
000026  4916              LDR      r1,|L63.128|
000028  eb011000          ADD      r0,r1,r0,LSL #4       ;469
00002c  7800              LDRB     r0,[r0,#0]            ;469
00002e  b100              CBZ      r0,|L63.50|
000030  e01e              B        |L63.112|
                  |L63.50|
000032  e015              B        |L63.96|
                  |L63.52|
000034  6821              LDR      r1,[r4,#0]            ;477
000036  b126              CBZ      r6,|L63.66|
000038  8888              LDRH     r0,[r1,#4]            ;481
00003a  8832              LDRH     r2,[r6,#0]            ;481
00003c  4290              CMP      r0,r2                 ;481
00003e  d000              BEQ      |L63.66|
000040  e00e              B        |L63.96|
                  |L63.66|
000042  b127              CBZ      r7,|L63.78|
000044  8808              LDRH     r0,[r1,#0]            ;487
000046  883a              LDRH     r2,[r7,#0]            ;487
000048  4290              CMP      r0,r2                 ;487
00004a  d000              BEQ      |L63.78|
00004c  e008              B        |L63.96|
                  |L63.78|
00004e  6888              LDR      r0,[r1,#8]            ;493
000050  6028              STR      r0,[r5,#0]            ;493
000052  6820              LDR      r0,[r4,#0]            ;494
000054  6068              STR      r0,[r5,#4]            ;494
000056  480b              LDR      r0,|L63.132|
000058  8900              LDRH     r0,[r0,#8]            ;495  ; m_gc
00005a  8128              STRH     r0,[r5,#8]            ;495
00005c  2000              MOVS     r0,#0                 ;497
00005e  e7da              B        |L63.22|
                  |L63.96|
000060  88a0              LDRH     r0,[r4,#4]            ;475
000062  4621              MOV      r1,r4                 ;475
000064  f7fffffe          BL       record_find_next
000068  2800              CMP      r0,#0                 ;475
00006a  d1e3              BNE      |L63.52|
00006c  6020              STR      r0,[r4,#0]            ;502
00006e  bf00              NOP                            ;472
                  |L63.112|
000070  88a0              LDRH     r0,[r4,#4]            ;467
000072  1c40              ADDS     r0,r0,#1              ;467
000074  80a0              STRH     r0,[r4,#4]            ;467
                  |L63.118|
000076  88a0              LDRH     r0,[r4,#4]            ;467
000078  2802              CMP      r0,#2                 ;467
00007a  dbd3              BLT      |L63.36|
00007c  200a              MOVS     r0,#0xa               ;505
00007e  e7ca              B        |L63.22|
;;;507    
                          ENDP

                  |L63.128|
                          DCD      m_pages
                  |L63.132|
                          DCD      m_gc

                          AREA ||i.record_find_and_delete||, CODE, READONLY, ALIGN=2

                  record_find_and_delete PROC
;;;776    
;;;777    static ret_code_t record_find_and_delete(fds_op_t * const p_op)
000000  b57f              PUSH     {r0-r6,lr}
;;;778    {
000002  4604              MOV      r4,r0
;;;779        ret_code_t        ret;
;;;780        uint16_t          page;
;;;781        fds_record_desc_t desc = {0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
;;;782    
;;;783        desc.record_id = p_op->del.record_to_delete;
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  9000              STR      r0,[sp,#0]
;;;784    
;;;785        if (record_find_by_desc(&desc, &page))
000010  a903              ADD      r1,sp,#0xc
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       record_find_by_desc
000018  b180              CBZ      r0,|L64.60|
;;;786        {
;;;787            fds_header_t const * const p_header = (fds_header_t const *)desc.p_record;
00001a  9e01              LDR      r6,[sp,#4]
;;;788    
;;;789            // Copy the record key and file ID, so that they can be returned in the event.
;;;790            // In case this function is run as part of an update, there is no need to copy
;;;791            // the file ID and record key since they are present in the header stored
;;;792            // in the queue element.
;;;793    
;;;794            p_op->del.file_id    = p_header->ic.file_id;
00001c  88b1              LDRH     r1,[r6,#4]
00001e  80e1              STRH     r1,[r4,#6]
;;;795            p_op->del.record_key = p_header->tl.record_key;
000020  8831              LDRH     r1,[r6,#0]
000022  8121              STRH     r1,[r4,#8]
;;;796    
;;;797            // Flag the record as dirty.
;;;798            ret = record_header_flag_dirty((uint32_t*)desc.p_record);
000024  9801              LDR      r0,[sp,#4]
000026  f7fffffe          BL       record_header_flag_dirty
00002a  4605              MOV      r5,r0
;;;799    
;;;800            // This page can now be garbage collected.
;;;801            m_pages[page].can_gc = true;
00002c  2001              MOVS     r0,#1
00002e  4905              LDR      r1,|L64.68|
000030  f8bd200c          LDRH     r2,[sp,#0xc]
000034  eb011102          ADD      r1,r1,r2,LSL #4
000038  7388              STRB     r0,[r1,#0xe]
;;;802        }
00003a  e000              B        |L64.62|
                  |L64.60|
;;;803        else
;;;804        {
;;;805            // The record never existed, or it has already been deleted.
;;;806            ret = FDS_ERR_NOT_FOUND;
00003c  250a              MOVS     r5,#0xa
                  |L64.62|
;;;807        }
;;;808    
;;;809        return ret;
00003e  4628              MOV      r0,r5
;;;810    }
000040  b004              ADD      sp,sp,#0x10
000042  bd70              POP      {r4-r6,pc}
;;;811    
                          ENDP

                  |L64.68|
                          DCD      m_pages

                          AREA ||i.record_find_by_desc||, CODE, READONLY, ALIGN=2

                  record_find_by_desc PROC
;;;411    // NOTE: Do not pass NULL as an argument for p_page.
;;;412    static bool record_find_by_desc(fds_record_desc_t * const p_desc, uint16_t * const p_page)
000000  b538              PUSH     {r3-r5,lr}
;;;413    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;414        // If the gc_run_count field in the descriptor matches our counter, then the record has
;;;415        // not been moved. If the address is valid, and the record ID matches, there is no need
;;;416        // to find the record again. Only lookup the page in which the record is stored.
;;;417    
;;;418        if ((address_is_valid(p_desc->p_record))     &&
000006  6860              LDR      r0,[r4,#4]
000008  f7fffffe          BL       address_is_valid
00000c  b190              CBZ      r0,|L65.52|
;;;419            (p_desc->gc_run_count == m_gc.run_count) &&
00000e  8920              LDRH     r0,[r4,#8]
000010  4919              LDR      r1,|L65.120|
000012  8909              LDRH     r1,[r1,#8]  ; m_gc
000014  4288              CMP      r0,r1
000016  d10d              BNE      |L65.52|
;;;420            (p_desc->record_id    == ((fds_header_t*)p_desc->p_record)->record_id))
000018  e9d40100          LDRD     r0,r1,[r4,#0]
00001c  6889              LDR      r1,[r1,#8]
00001e  4288              CMP      r0,r1
000020  d108              BNE      |L65.52|
;;;421        {
;;;422            return (page_from_record(p_page, p_desc->p_record) == FDS_SUCCESS);
000022  4628              MOV      r0,r5
000024  6861              LDR      r1,[r4,#4]
000026  f7fffffe          BL       page_from_record
00002a  b908              CBNZ     r0,|L65.48|
00002c  2001              MOVS     r0,#1
                  |L65.46|
;;;423        }
;;;424    
;;;425        // Otherwise, find the record in flash.
;;;426        for (*p_page = 0; *p_page < FDS_MAX_PAGES; (*p_page)++)
;;;427        {
;;;428            // Set p_record to NULL to make record_find_next() search from the beginning of the page.
;;;429            uint32_t const * p_record = NULL;
;;;430    
;;;431            while (record_find_next(*p_page, &p_record))
;;;432            {
;;;433                fds_header_t const * const p_header = (fds_header_t*)p_record;
;;;434                if (p_header->record_id == p_desc->record_id)
;;;435                {
;;;436                    p_desc->p_record     = p_record;
;;;437                    p_desc->gc_run_count = m_gc.run_count;
;;;438                    return true;
;;;439                }
;;;440            }
;;;441        }
;;;442    
;;;443        return false;
;;;444    }
00002e  bd38              POP      {r3-r5,pc}
                  |L65.48|
000030  2000              MOVS     r0,#0                 ;422
000032  e7fc              B        |L65.46|
                  |L65.52|
000034  2000              MOVS     r0,#0                 ;426
000036  8028              STRH     r0,[r5,#0]            ;426
000038  e018              B        |L65.108|
                  |L65.58|
00003a  2000              MOVS     r0,#0                 ;429
00003c  9000              STR      r0,[sp,#0]            ;429
00003e  e00c              B        |L65.90|
                  |L65.64|
000040  9900              LDR      r1,[sp,#0]            ;433
000042  6888              LDR      r0,[r1,#8]            ;434
000044  6822              LDR      r2,[r4,#0]            ;434
000046  4290              CMP      r0,r2                 ;434
000048  d106              BNE      |L65.88|
00004a  9800              LDR      r0,[sp,#0]            ;436
00004c  6060              STR      r0,[r4,#4]            ;436
00004e  480a              LDR      r0,|L65.120|
000050  8900              LDRH     r0,[r0,#8]            ;437  ; m_gc
000052  8120              STRH     r0,[r4,#8]            ;437
000054  2001              MOVS     r0,#1                 ;438
000056  e7ea              B        |L65.46|
                  |L65.88|
000058  bf00              NOP                            ;440
                  |L65.90|
00005a  8828              LDRH     r0,[r5,#0]            ;431
00005c  4669              MOV      r1,sp                 ;431
00005e  f7fffffe          BL       record_find_next
000062  2800              CMP      r0,#0                 ;431
000064  d1ec              BNE      |L65.64|
000066  8828              LDRH     r0,[r5,#0]            ;426
000068  1c40              ADDS     r0,r0,#1              ;426
00006a  8028              STRH     r0,[r5,#0]            ;426
                  |L65.108|
00006c  8828              LDRH     r0,[r5,#0]            ;426
00006e  2802              CMP      r0,#2                 ;426
000070  dbe3              BLT      |L65.58|
000072  2000              MOVS     r0,#0                 ;443
000074  e7db              B        |L65.46|
;;;445    
                          ENDP

000076  0000              DCW      0x0000
                  |L65.120|
                          DCD      m_gc

                          AREA ||i.record_find_next||, CODE, READONLY, ALIGN=2

                  record_find_next PROC
;;;368    // If no record is found, p_record is unchanged.
;;;369    static bool record_find_next(uint16_t page, uint32_t const ** p_record)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;370    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;371        fds_header_t const * p_header;
;;;372        uint32_t     const * p_next_rec = (*p_record);
000008  683c              LDR      r4,[r7,#0]
;;;373    
;;;374        // If this is not the first invocation on this page, then jump to the next record.
;;;375        // Otherwise, start searching from the beginning of the page.
;;;376        if (p_next_rec != NULL)
00000a  b12c              CBZ      r4,|L66.24|
;;;377        {
;;;378            p_header    = ((fds_header_t*)p_next_rec);
00000c  4625              MOV      r5,r4
;;;379            p_next_rec += (FDS_HEADER_SIZE + p_header->tl.length_words);
00000e  8868              LDRH     r0,[r5,#2]
000010  1cc0              ADDS     r0,r0,#3
000012  eb040480          ADD      r4,r4,r0,LSL #2
000016  e005              B        |L66.36|
                  |L66.24|
;;;380        }
;;;381        else
;;;382        {
;;;383            p_next_rec = m_pages[page].p_addr + FDS_PAGE_TAG_SIZE;
000018  4810              LDR      r0,|L66.92|
00001a  eb001006          ADD      r0,r0,r6,LSL #4
00001e  6840              LDR      r0,[r0,#4]
000020  f1000408          ADD      r4,r0,#8
                  |L66.36|
;;;384        }
;;;385    
;;;386        // Read records from the page, until a valid record is found or the end of the page is
;;;387        // reached. The argument p_record is only updated if a valid record is found.
;;;388        while ((p_next_rec < (m_pages[page].p_addr + FDS_PAGE_SIZE) &&
000024  e00c              B        |L66.64|
                  |L66.38|
;;;389               *p_next_rec != FDS_ERASED_WORD))
;;;390        {
;;;391            p_header = (fds_header_t*)p_next_rec;
000026  4625              MOV      r5,r4
;;;392    
;;;393            if (header_is_valid(p_header))
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       header_is_valid
00002e  b118              CBZ      r0,|L66.56|
;;;394            {
;;;395                *p_record = p_next_rec;
000030  603c              STR      r4,[r7,#0]
;;;396                return true;
000032  2001              MOVS     r0,#1
                  |L66.52|
;;;397            }
;;;398            else
;;;399            {
;;;400                // The record is not valid, jump to the next.
;;;401                p_next_rec += (FDS_HEADER_SIZE + (p_header->tl.length_words));
;;;402            }
;;;403        }
;;;404    
;;;405        // No more valid records on this page.
;;;406        return false;
;;;407    }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L66.56|
000038  8868              LDRH     r0,[r5,#2]            ;401
00003a  1cc0              ADDS     r0,r0,#3              ;401
00003c  eb040480          ADD      r4,r4,r0,LSL #2       ;401
                  |L66.64|
000040  4806              LDR      r0,|L66.92|
000042  eb001006          ADD      r0,r0,r6,LSL #4       ;388
000046  6840              LDR      r0,[r0,#4]            ;388
000048  f5005080          ADD      r0,r0,#0x1000         ;388
00004c  42a0              CMP      r0,r4                 ;388
00004e  d903              BLS      |L66.88|
000050  6820              LDR      r0,[r4,#0]            ;389
000052  1c40              ADDS     r0,r0,#1              ;389
000054  2800              CMP      r0,#0                 ;389
000056  d1e6              BNE      |L66.38|
                  |L66.88|
000058  2000              MOVS     r0,#0                 ;406
00005a  e7eb              B        |L66.52|
;;;408    
                          ENDP

                  |L66.92|
                          DCD      m_pages

                          AREA ||i.record_header_flag_dirty||, CODE, READONLY, ALIGN=2

                  record_header_flag_dirty PROC
;;;766    
;;;767    static ret_code_t record_header_flag_dirty(uint32_t * const p_record)
000000  b538              PUSH     {r3-r5,lr}
;;;768    {
000002  4604              MOV      r4,r0
;;;769        // Flag the record as dirty.
;;;770        fs_ret_t ret = fs_store(&fs_config, p_record,
000004  2000              MOVS     r0,#0
000006  2301              MOVS     r3,#1
000008  4a05              LDR      r2,|L67.32|
00000a  4621              MOV      r1,r4
00000c  9000              STR      r0,[sp,#0]
00000e  4805              LDR      r0,|L67.36|
000010  f7fffffe          BL       fs_store
000014  4605              MOV      r5,r0
;;;771                                (uint32_t*)&m_fds_tl_dirty, FDS_HEADER_SIZE_TL, NULL);
;;;772    
;;;773        return (ret == FS_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
000016  b90d              CBNZ     r5,|L67.28|
000018  2000              MOVS     r0,#0
                  |L67.26|
;;;774    }
00001a  bd38              POP      {r3-r5,pc}
                  |L67.28|
00001c  200e              MOVS     r0,#0xe               ;773
00001e  e7fc              B        |L67.26|
;;;775    
                          ENDP

                  |L67.32|
                          DCD      m_fds_tl_dirty
                  |L67.36|
                          DCD      fs_config

                          AREA ||i.record_header_write_begin||, CODE, READONLY, ALIGN=2

                  record_header_write_begin PROC
;;;723    // Write the first part of a record header (the key and length).
;;;724    static ret_code_t record_header_write_begin(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;725    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;726        ret_code_t ret;
;;;727        ret = fs_store(&fs_config, p_addr + FDS_OFFSET_TL,
000006  2000              MOVS     r0,#0
000008  2301              MOVS     r3,#1
00000a  1d22              ADDS     r2,r4,#4
00000c  4629              MOV      r1,r5
00000e  9000              STR      r0,[sp,#0]
000010  4805              LDR      r0,|L68.40|
000012  f7fffffe          BL       fs_store
000016  4606              MOV      r6,r0
;;;728                      (uint32_t*)&p_op->write.header.tl, FDS_HEADER_SIZE_TL, NULL);
;;;729    
;;;730        // Write the record ID next.
;;;731        p_op->write.step = FDS_OP_WRITE_RECORD_ID;
000018  2102              MOVS     r1,#2
00001a  7421              STRB     r1,[r4,#0x10]
;;;732    
;;;733        return (ret == FS_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
00001c  b90e              CBNZ     r6,|L68.34|
00001e  2000              MOVS     r0,#0
                  |L68.32|
;;;734    }
000020  bdf8              POP      {r3-r7,pc}
                  |L68.34|
000022  200e              MOVS     r0,#0xe               ;733
000024  e7fc              B        |L68.32|
;;;735    
                          ENDP

000026  0000              DCW      0x0000
                  |L68.40|
                          DCD      fs_config

                          AREA ||i.record_header_write_finalize||, CODE, READONLY, ALIGN=2

                  record_header_write_finalize PROC
;;;751    
;;;752    static ret_code_t record_header_write_finalize(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;753    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;754        ret_code_t ret;
;;;755        ret = fs_store(&fs_config, p_addr + FDS_OFFSET_IC,
000006  2000              MOVS     r0,#0
000008  2301              MOVS     r3,#1
00000a  f1040208          ADD      r2,r4,#8
00000e  1d29              ADDS     r1,r5,#4
000010  9000              STR      r0,[sp,#0]
000012  4808              LDR      r0,|L69.52|
000014  f7fffffe          BL       fs_store
000018  4606              MOV      r6,r0
;;;756                       (uint32_t*)&p_op->write.header.ic, FDS_HEADER_SIZE_IC, NULL);
;;;757    
;;;758        // If this is a simple write operation, then this is the last step.
;;;759        // If this is an update instead, delete the old record next.
;;;760        p_op->write.step = (p_op->op_code == FDS_OP_UPDATE) ? FDS_OP_WRITE_FLAG_DIRTY :
00001a  7820              LDRB     r0,[r4,#0]
00001c  2803              CMP      r0,#3
00001e  d101              BNE      |L69.36|
000020  2105              MOVS     r1,#5
000022  e000              B        |L69.38|
                  |L69.36|
;;;761                                                              FDS_OP_WRITE_DONE;
000024  2106              MOVS     r1,#6
                  |L69.38|
000026  7421              STRB     r1,[r4,#0x10]
;;;762    
;;;763        return (ret == FS_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
000028  b90e              CBNZ     r6,|L69.46|
00002a  2000              MOVS     r0,#0
                  |L69.44|
;;;764    }
00002c  bdf8              POP      {r3-r7,pc}
                  |L69.46|
00002e  200e              MOVS     r0,#0xe               ;763
000030  e7fc              B        |L69.44|
;;;765    
                          ENDP

000032  0000              DCW      0x0000
                  |L69.52|
                          DCD      fs_config

                          AREA ||i.record_header_write_id||, CODE, READONLY, ALIGN=2

                  record_header_write_id PROC
;;;736    
;;;737    static ret_code_t record_header_write_id(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;738    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;739        ret_code_t ret;
;;;740        ret = fs_store(&fs_config, p_addr + FDS_OFFSET_ID,
000006  2000              MOVS     r0,#0
000008  2301              MOVS     r3,#1
00000a  f104020c          ADD      r2,r4,#0xc
00000e  f1050108          ADD      r1,r5,#8
000012  9000              STR      r0,[sp,#0]
000014  4807              LDR      r0,|L70.52|
000016  f7fffffe          BL       fs_store
00001a  4606              MOV      r6,r0
;;;741                       (uint32_t*)&p_op->write.header.record_id, FDS_HEADER_SIZE_ID, NULL);
;;;742    
;;;743        // If this record has zero chunk, write the last part of the header directly.
;;;744        // Otherwise, write the record chunks next.
;;;745        p_op->write.step = (p_op->write.chunk_count != 0) ? FDS_OP_WRITE_CHUNKS :
00001c  7da0              LDRB     r0,[r4,#0x16]
00001e  b108              CBZ      r0,|L70.36|
000020  2103              MOVS     r1,#3
000022  e000              B        |L70.38|
                  |L70.36|
;;;746                                                            FDS_OP_WRITE_HEADER_FINALIZE;
000024  2101              MOVS     r1,#1
                  |L70.38|
000026  7421              STRB     r1,[r4,#0x10]
;;;747    
;;;748        return (ret == FS_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
000028  b90e              CBNZ     r6,|L70.46|
00002a  2000              MOVS     r0,#0
                  |L70.44|
;;;749    }
00002c  bdf8              POP      {r3-r7,pc}
                  |L70.46|
00002e  200e              MOVS     r0,#0xe               ;748
000030  e7fc              B        |L70.44|
;;;750    
                          ENDP

000032  0000              DCW      0x0000
                  |L70.52|
                          DCD      fs_config

                          AREA ||i.record_id_new||, CODE, READONLY, ALIGN=2

                  record_id_new PROC
;;;355    
;;;356    static uint32_t record_id_new(void)
000000  4803              LDR      r0,|L71.16|
;;;357    {
;;;358        CRITICAL_SECTION_ENTER();
;;;359        m_latest_rec_id++;
000002  6800              LDR      r0,[r0,#0]  ; m_latest_rec_id
000004  1c40              ADDS     r0,r0,#1
000006  4902              LDR      r1,|L71.16|
000008  6008              STR      r0,[r1,#0]  ; m_latest_rec_id
;;;360        CRITICAL_SECTION_EXIT();
;;;361        return m_latest_rec_id;
00000a  4608              MOV      r0,r1
00000c  6800              LDR      r0,[r0,#0]  ; m_latest_rec_id
;;;362    }
00000e  4770              BX       lr
;;;363    
                          ENDP

                  |L71.16|
                          DCD      m_latest_rec_id

                          AREA ||i.record_write_chunk||, CODE, READONLY, ALIGN=2

                  record_write_chunk PROC
;;;844    // the number of chunks left to write for this operation and accumulates the offset.
;;;845    static ret_code_t record_write_chunk(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b57c              PUSH     {r2-r6,lr}
;;;846    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;847        ret_code_t           ret;
;;;848        fds_record_chunk_t * p_chunk = NULL;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;849    
;;;850        // Retrieve the next chunk to be written.
;;;851        chunk_queue_get_and_advance(&p_chunk);
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       chunk_queue_get_and_advance
;;;852    
;;;853        ret = fs_store(&fs_config, p_addr + p_op->write.chunk_offset,
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
000014  9801              LDR      r0,[sp,#4]
000016  8883              LDRH     r3,[r0,#4]
000018  6802              LDR      r2,[r0,#0]
00001a  8aa0              LDRH     r0,[r4,#0x14]
00001c  eb050180          ADD      r1,r5,r0,LSL #2
000020  480a              LDR      r0,|L72.76|
000022  f7fffffe          BL       fs_store
000026  4606              MOV      r6,r0
;;;854                       p_chunk->p_data, p_chunk->length_words, NULL);
;;;855    
;;;856        // Accumulate the offset.
;;;857        p_op->write.chunk_offset += p_chunk->length_words;
000028  8aa0              LDRH     r0,[r4,#0x14]
00002a  9901              LDR      r1,[sp,#4]
00002c  8889              LDRH     r1,[r1,#4]
00002e  4408              ADD      r0,r0,r1
000030  82a0              STRH     r0,[r4,#0x14]
;;;858    
;;;859        // Decrement the number of chunks left to write.
;;;860        // NOTE: If chunk_count is initially zero, this function is not called
;;;861        // because this step is skipped entirely. See record_header_write_id().
;;;862        p_op->write.chunk_count--;
000032  7da0              LDRB     r0,[r4,#0x16]
000034  1e40              SUBS     r0,r0,#1
000036  75a0              STRB     r0,[r4,#0x16]
;;;863    
;;;864        if (p_op->write.chunk_count == 0)
000038  7da0              LDRB     r0,[r4,#0x16]
00003a  b908              CBNZ     r0,|L72.64|
;;;865        {
;;;866            // All record chunks have been written; write the last part of
;;;867            // the record header to finalize the write operation.
;;;868            p_op->write.step = FDS_OP_WRITE_HEADER_FINALIZE;
00003c  2101              MOVS     r1,#1
00003e  7421              STRB     r1,[r4,#0x10]
                  |L72.64|
;;;869        }
;;;870    
;;;871        return (ret == NRF_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
000040  b90e              CBNZ     r6,|L72.70|
000042  2000              MOVS     r0,#0
                  |L72.68|
;;;872    }
000044  bd7c              POP      {r2-r6,pc}
                  |L72.70|
000046  200e              MOVS     r0,#0xe               ;871
000048  e7fc              B        |L72.68|
;;;873    
                          ENDP

00004a  0000              DCW      0x0000
                  |L72.76|
                          DCD      fs_config

                          AREA ||i.write_enqueue||, CODE, READONLY, ALIGN=2

                  write_enqueue PROC
;;;1460   // Enqueues write and update operations.
;;;1461   static ret_code_t write_enqueue(fds_record_desc_t         * const p_desc,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1462                                   fds_record_t        const * const p_record,
;;;1463                                   fds_reserve_token_t const * const p_tok,
;;;1464                                   fds_op_code_t                     op_code)
;;;1465   {
000004  b088              SUB      sp,sp,#0x20
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;1466       ret_code_t ret;
;;;1467       fds_op_t   op;
;;;1468       uint16_t   page;
;;;1469       uint16_t   crc          = 0;
00000e  f04f0a00          MOV      r10,#0
;;;1470       uint16_t   length_words = 0;
000012  46d1              MOV      r9,r10
;;;1471   
;;;1472       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       flag_is_set
00001a  b918              CBNZ     r0,|L73.36|
;;;1473       {
;;;1474           return FDS_ERR_NOT_INITIALIZED;
00001c  2002              MOVS     r0,#2
                  |L73.30|
;;;1475       }
;;;1476   
;;;1477       if (p_record == NULL)
;;;1478       {
;;;1479           return FDS_ERR_NULL_ARG;
;;;1480       }
;;;1481   
;;;1482       if ((p_record->file_id == FDS_FILE_ID_INVALID) ||
;;;1483           (p_record->key     == FDS_RECORD_KEY_DIRTY))
;;;1484       {
;;;1485           return FDS_ERR_INVALID_ARG;
;;;1486       }
;;;1487   
;;;1488       if (!chunk_is_aligned(p_record->data.p_chunks,
;;;1489                             p_record->data.num_chunks))
;;;1490       {
;;;1491           return FDS_ERR_UNALIGNED_ADDR;
;;;1492       }
;;;1493   
;;;1494       // No space was previously reserved for this operation.
;;;1495       if (p_tok == NULL)
;;;1496       {
;;;1497           // Compute the total length of the record.
;;;1498           for (uint32_t i = 0; i < p_record->data.num_chunks; i++)
;;;1499           {
;;;1500               length_words += p_record->data.p_chunks[i].length_words;
;;;1501           }
;;;1502   
;;;1503           // Find a page where to write data.
;;;1504           ret = write_space_reserve(length_words, &page);
;;;1505   
;;;1506           if (ret != FDS_SUCCESS)
;;;1507           {
;;;1508               // There is either not enough flash space available (FDS_ERR_NO_SPACE_IN_FLASH) or
;;;1509               // the record exceeds the virtual page size (FDS_ERR_RECORD_TOO_LARGE).
;;;1510               return ret;
;;;1511           }
;;;1512       }
;;;1513       else
;;;1514       {
;;;1515           page         = p_tok->page;
;;;1516           length_words = p_tok->length_words;
;;;1517       }
;;;1518   
;;;1519       // Initialize the operation.
;;;1520       op.op_code                      = op_code;
;;;1521       op.write.step                   = FDS_OP_WRITE_HEADER_BEGIN;
;;;1522       op.write.page                   = page;
;;;1523       op.write.chunk_count            = p_record->data.num_chunks;
;;;1524       op.write.chunk_offset           = FDS_OFFSET_DATA;
;;;1525       op.write.header.record_id       = record_id_new();
;;;1526       op.write.header.ic.file_id      = p_record->file_id;
;;;1527       op.write.header.tl.record_key   = p_record->key;
;;;1528       op.write.header.tl.length_words = length_words;
;;;1529   
;;;1530       if (op_code == FDS_OP_UPDATE)
;;;1531       {
;;;1532           op.write.step             = FDS_OP_WRITE_FIND_RECORD;
;;;1533           // Save the record ID of the record to be updated.
;;;1534           op.write.record_to_delete = p_desc->record_id;
;;;1535       }
;;;1536   
;;;1537   #if defined (FDS_CRC_ENABLED)
;;;1538       // First, compute the CRC for the first 6 bytes of the header which contain the
;;;1539       // record key, length and file ID, then, compute the CRC of the record ID (4 bytes).
;;;1540       crc = crc16_compute((uint8_t*)&op.write.header,           6, NULL);
;;;1541       crc = crc16_compute((uint8_t*)&op.write.header.record_id, 4, &crc);
;;;1542   
;;;1543       for (uint32_t i = 0; i < p_record->data.num_chunks; i++)
;;;1544       {
;;;1545           // Compute the CRC for the record data.
;;;1546           crc = crc16_compute((uint8_t*)p_record->data.p_chunks[i].p_data,
;;;1547                               p_record->data.p_chunks[i].length_words * sizeof(uint32_t), &crc);
;;;1548       }
;;;1549   #endif
;;;1550   
;;;1551       op.write.header.ic.crc16 = crc;
;;;1552   
;;;1553       // Attempt to enqueue the operation.
;;;1554       if (!op_enqueue(&op, p_record->data.num_chunks, p_record->data.p_chunks))
;;;1555       {
;;;1556           // No space availble in the queues. Cancel the reservation of flash space.
;;;1557           CRITICAL_SECTION_ENTER();
;;;1558           write_space_free(length_words, page);
;;;1559           CRITICAL_SECTION_EXIT();
;;;1560   
;;;1561           return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1562       }
;;;1563   
;;;1564        // Initialize the record descriptor, if provided.
;;;1565       if (p_desc != NULL)
;;;1566       {
;;;1567           p_desc->p_record       = NULL;
;;;1568           // Don't invoke record_id_new() again !
;;;1569           p_desc->record_id      = op.write.header.record_id;
;;;1570           p_desc->record_is_open = false;
;;;1571           p_desc->gc_run_count   = m_gc.run_count;
;;;1572       }
;;;1573   
;;;1574       // Start processing the queue, if necessary.
;;;1575       queue_start();
;;;1576   
;;;1577       return FDS_SUCCESS;
;;;1578   }
00001e  b008              ADD      sp,sp,#0x20
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L73.36|
000024  b90c              CBNZ     r4,|L73.42|
000026  2005              MOVS     r0,#5                 ;1479
000028  e7f9              B        |L73.30|
                  |L73.42|
00002a  8820              LDRH     r0,[r4,#0]            ;1482
00002c  f64f71ff          MOV      r1,#0xffff            ;1482
000030  4288              CMP      r0,r1                 ;1482
000032  d001              BEQ      |L73.56|
000034  8860              LDRH     r0,[r4,#2]            ;1483
000036  b908              CBNZ     r0,|L73.60|
                  |L73.56|
000038  2004              MOVS     r0,#4                 ;1485
00003a  e7f0              B        |L73.30|
                  |L73.60|
00003c  8921              LDRH     r1,[r4,#8]            ;1488
00003e  6860              LDR      r0,[r4,#4]            ;1488
000040  f7fffffe          BL       chunk_is_aligned
000044  b908              CBNZ     r0,|L73.74|
000046  2003              MOVS     r0,#3                 ;1491
000048  e7e9              B        |L73.30|
                  |L73.74|
00004a  b9b6              CBNZ     r6,|L73.122|
00004c  2000              MOVS     r0,#0                 ;1498
00004e  e007              B        |L73.96|
                  |L73.80|
000050  6861              LDR      r1,[r4,#4]            ;1500
000052  eb0101c0          ADD      r1,r1,r0,LSL #3       ;1500
000056  8889              LDRH     r1,[r1,#4]            ;1500
000058  4449              ADD      r1,r1,r9              ;1500
00005a  fa1ff981          UXTH     r9,r1                 ;1500
00005e  1c40              ADDS     r0,r0,#1              ;1498
                  |L73.96|
000060  8921              LDRH     r1,[r4,#8]            ;1498
000062  4281              CMP      r1,r0                 ;1498
000064  d8f4              BHI      |L73.80|
000066  4669              MOV      r1,sp                 ;1504
000068  4648              MOV      r0,r9                 ;1504
00006a  f7fffffe          BL       write_space_reserve
00006e  4680              MOV      r8,r0                 ;1504
000070  f1b80f00          CMP      r8,#0                 ;1506
000074  d005              BEQ      |L73.130|
000076  4640              MOV      r0,r8                 ;1510
000078  e7d1              B        |L73.30|
                  |L73.122|
00007a  8830              LDRH     r0,[r6,#0]            ;1515
00007c  9000              STR      r0,[sp,#0]            ;1515
00007e  f8b69002          LDRH     r9,[r6,#2]            ;1516
                  |L73.130|
000082  f88d7004          STRB     r7,[sp,#4]            ;1520
000086  2100              MOVS     r1,#0                 ;1521
000088  f88d1014          STRB     r1,[sp,#0x14]         ;1521
00008c  f8bd1000          LDRH     r1,[sp,#0]            ;1522
000090  f8ad1016          STRH     r1,[sp,#0x16]         ;1522
000094  7a21              LDRB     r1,[r4,#8]            ;1523
000096  f88d101a          STRB     r1,[sp,#0x1a]         ;1523
00009a  2103              MOVS     r1,#3                 ;1524
00009c  f8ad1018          STRH     r1,[sp,#0x18]         ;1524
0000a0  f7fffffe          BL       record_id_new
0000a4  9004              STR      r0,[sp,#0x10]         ;1525
0000a6  8821              LDRH     r1,[r4,#0]            ;1526
0000a8  f8ad100c          STRH     r1,[sp,#0xc]          ;1526
0000ac  8860              LDRH     r0,[r4,#2]            ;1527
0000ae  f8ad0008          STRH     r0,[sp,#8]            ;1527
0000b2  f8ad900a          STRH     r9,[sp,#0xa]          ;1528
0000b6  2f03              CMP      r7,#3                 ;1530
0000b8  d104              BNE      |L73.196|
0000ba  2104              MOVS     r1,#4                 ;1532
0000bc  f88d1014          STRB     r1,[sp,#0x14]         ;1532
0000c0  6829              LDR      r1,[r5,#0]            ;1534
0000c2  9107              STR      r1,[sp,#0x1c]         ;1534
                  |L73.196|
0000c4  f8ada00e          STRH     r10,[sp,#0xe]         ;1551
0000c8  8921              LDRH     r1,[r4,#8]            ;1554
0000ca  a801              ADD      r0,sp,#4              ;1554
0000cc  6862              LDR      r2,[r4,#4]            ;1554
0000ce  f7fffffe          BL       op_enqueue
0000d2  b930              CBNZ     r0,|L73.226|
0000d4  f8bd1000          LDRH     r1,[sp,#0]            ;1558
0000d8  4648              MOV      r0,r9                 ;1558
0000da  f7fffffe          BL       write_space_free
0000de  2008              MOVS     r0,#8                 ;1561
0000e0  e79d              B        |L73.30|
                  |L73.226|
0000e2  b145              CBZ      r5,|L73.246|
0000e4  2000              MOVS     r0,#0                 ;1567
0000e6  6068              STR      r0,[r5,#4]            ;1567
0000e8  9804              LDR      r0,[sp,#0x10]         ;1569
0000ea  6028              STR      r0,[r5,#0]            ;1569
0000ec  2000              MOVS     r0,#0                 ;1570
0000ee  72a8              STRB     r0,[r5,#0xa]          ;1570
0000f0  4803              LDR      r0,|L73.256|
0000f2  8900              LDRH     r0,[r0,#8]            ;1571  ; m_gc
0000f4  8128              STRH     r0,[r5,#8]            ;1571
                  |L73.246|
0000f6  f7fffffe          BL       queue_start
0000fa  2000              MOVS     r0,#0                 ;1577
0000fc  e78f              B        |L73.30|
;;;1579   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L73.256|
                          DCD      m_gc

                          AREA ||i.write_execute||, CODE, READONLY, ALIGN=2

                  write_execute PROC
;;;1189   // Executes write and update operations.
;;;1190   static ret_code_t write_execute(uint32_t prev_ret, fds_op_t * const p_op)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1191   {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;1192       ret_code_t         ret;
;;;1193       uint32_t   *       p_write_addr;
;;;1194       fds_page_t * const p_page = &m_pages[p_op->write.page];
000008  8a68              LDRH     r0,[r5,#0x12]
00000a  4929              LDR      r1,|L74.176|
00000c  eb011600          ADD      r6,r1,r0,LSL #4
;;;1195   
;;;1196       // This must persist across calls.
;;;1197       static fds_record_desc_t desc = {0};
;;;1198   
;;;1199       if (prev_ret != FS_SUCCESS)
000010  b137              CBZ      r7,|L74.32|
;;;1200       {
;;;1201           // The previous operation has timed out, update offsets.
;;;1202           page_offsets_update(p_page, p_op->write.header.tl.length_words);
000012  88e9              LDRH     r1,[r5,#6]
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       page_offsets_update
;;;1203           return FDS_ERR_OPERATION_TIMEOUT;
00001a  2001              MOVS     r0,#1
                  |L74.28|
;;;1204       }
;;;1205   
;;;1206       // Compute the address where to write data.
;;;1207       p_write_addr = (uint32_t*)(p_page->p_addr + p_page->write_offset);
;;;1208   
;;;1209       // Execute the current step of the operation, and set one to be executed next.
;;;1210       switch (p_op->write.step)
;;;1211       {
;;;1212           case FDS_OP_WRITE_FIND_RECORD:
;;;1213           {
;;;1214               // The first step of updating a record constists of locating the copy to be deleted.
;;;1215               // If the old copy couldn't be found for any reason then the update should fail.
;;;1216               // This prevents duplicates when queuing multiple updates of the same record.
;;;1217   
;;;1218               uint16_t page;
;;;1219               desc.p_record  = NULL;
;;;1220               desc.record_id = p_op->write.record_to_delete;
;;;1221   
;;;1222               if (!record_find_by_desc(&desc, &page))
;;;1223               {
;;;1224                   return FDS_ERR_NOT_FOUND;
;;;1225               }
;;;1226               // Setting the step is redundant since we are falling through.
;;;1227           }
;;;1228           // Fallthrough to FDS_OP_WRITE_HEADER_BEGIN.
;;;1229   
;;;1230           case FDS_OP_WRITE_HEADER_BEGIN:
;;;1231               ret = record_header_write_begin(p_op, p_write_addr);
;;;1232               break;
;;;1233   
;;;1234           case FDS_OP_WRITE_RECORD_ID:
;;;1235               ret = record_header_write_id(p_op, p_write_addr);
;;;1236               break;
;;;1237   
;;;1238           case FDS_OP_WRITE_CHUNKS:
;;;1239               ret = record_write_chunk(p_op, p_write_addr);
;;;1240               break;
;;;1241   
;;;1242           case FDS_OP_WRITE_HEADER_FINALIZE:
;;;1243               ret = record_header_write_finalize(p_op, p_write_addr);
;;;1244               break;
;;;1245   
;;;1246           case FDS_OP_WRITE_FLAG_DIRTY:
;;;1247               ret = record_header_flag_dirty((uint32_t*)desc.p_record);
;;;1248               p_op->write.step = FDS_OP_WRITE_DONE;
;;;1249               break;
;;;1250   
;;;1251           case FDS_OP_WRITE_DONE:
;;;1252               ret = FDS_OP_COMPLETED;
;;;1253   
;;;1254   #if defined(FDS_CRC_ENABLED)
;;;1255               if (flag_is_set(FDS_FLAG_VERIFY_CRC))
;;;1256               {
;;;1257                   if (!crc_verify_success(p_op->write.header.ic.crc16,
;;;1258                                           p_op->write.header.tl.length_words,
;;;1259                                           p_write_addr))
;;;1260                   {
;;;1261                       ret = FDS_ERR_CRC_CHECK_FAILED;
;;;1262                   }
;;;1263               }
;;;1264   #endif
;;;1265               break;
;;;1266   
;;;1267           default:
;;;1268               ret = FDS_ERR_INTERNAL;
;;;1269               break;
;;;1270       }
;;;1271   
;;;1272       // An operation has either completed or failed. It may have failed because fstorage
;;;1273       // ran out of memory, or because the user tried to delete a record which did not exist.
;;;1274       if (ret != FDS_OP_EXECUTING)
;;;1275       {
;;;1276           // There won't be another callback for this operation, so update the page offset now.
;;;1277           page_offsets_update(p_page, p_op->write.header.tl.length_words);
;;;1278       }
;;;1279   
;;;1280       return ret;
;;;1281   }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L74.32|
000020  8931              LDRH     r1,[r6,#8]            ;1207
000022  6870              LDR      r0,[r6,#4]            ;1207
000024  eb000881          ADD      r8,r0,r1,LSL #2       ;1207
000028  7c28              LDRB     r0,[r5,#0x10]         ;1210
00002a  2807              CMP      r0,#7                 ;1210
00002c  d235              BCS      |L74.154|
00002e  e8dff000          TBB      [pc,r0]               ;1210
000032  1123              DCB      0x11,0x23
000034  171d0429          DCB      0x17,0x1d,0x04,0x29
000038  3100              DCB      0x31,0x00
00003a  2000              MOVS     r0,#0                 ;1219
00003c  491d              LDR      r1,|L74.180|
00003e  6048              STR      r0,[r1,#4]            ;1219  ; desc
000040  69a8              LDR      r0,[r5,#0x18]         ;1220
000042  6008              STR      r0,[r1,#0]            ;1220  ; desc
000044  4669              MOV      r1,sp                 ;1222
000046  481b              LDR      r0,|L74.180|
000048  f7fffffe          BL       record_find_by_desc
00004c  b908              CBNZ     r0,|L74.82|
00004e  200a              MOVS     r0,#0xa               ;1224
000050  e7e4              B        |L74.28|
                  |L74.82|
000052  bf00              NOP                            ;1230
000054  4641              MOV      r1,r8                 ;1231
000056  4628              MOV      r0,r5                 ;1231
000058  f7fffffe          BL       record_header_write_begin
00005c  4604              MOV      r4,r0                 ;1231
00005e  e01e              B        |L74.158|
000060  4641              MOV      r1,r8                 ;1235
000062  4628              MOV      r0,r5                 ;1235
000064  f7fffffe          BL       record_header_write_id
000068  4604              MOV      r4,r0                 ;1235
00006a  e018              B        |L74.158|
00006c  4641              MOV      r1,r8                 ;1239
00006e  4628              MOV      r0,r5                 ;1239
000070  f7fffffe          BL       record_write_chunk
000074  4604              MOV      r4,r0                 ;1239
000076  e012              B        |L74.158|
000078  4641              MOV      r1,r8                 ;1243
00007a  4628              MOV      r0,r5                 ;1243
00007c  f7fffffe          BL       record_header_write_finalize
000080  4604              MOV      r4,r0                 ;1243
000082  e00c              B        |L74.158|
000084  490b              LDR      r1,|L74.180|
000086  6848              LDR      r0,[r1,#4]            ;1247  ; desc
000088  f7fffffe          BL       record_header_flag_dirty
00008c  4604              MOV      r4,r0                 ;1247
00008e  2106              MOVS     r1,#6                 ;1248
000090  7429              STRB     r1,[r5,#0x10]         ;1248
000092  e004              B        |L74.158|
000094  f641541d          MOV      r4,#0x1d1d            ;1252
000098  e001              B        |L74.158|
                  |L74.154|
00009a  240f              MOVS     r4,#0xf               ;1268
00009c  bf00              NOP                            ;1269
                  |L74.158|
00009e  bf00              NOP                            ;1232
0000a0  b11c              CBZ      r4,|L74.170|
0000a2  88e9              LDRH     r1,[r5,#6]            ;1277
0000a4  4630              MOV      r0,r6                 ;1277
0000a6  f7fffffe          BL       page_offsets_update
                  |L74.170|
0000aa  4620              MOV      r0,r4                 ;1280
0000ac  e7b6              B        |L74.28|
;;;1282   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L74.176|
                          DCD      m_pages
                  |L74.180|
                          DCD      desc

                          AREA ||i.write_space_free||, CODE, READONLY, ALIGN=2

                  write_space_free PROC
;;;349    // NOTE: Must be called within a critical section.
;;;350    static void write_space_free(uint16_t length_words, uint16_t page)
000000  4a05              LDR      r2,|L75.24|
;;;351    {
;;;352        m_pages[page].words_reserved -= (length_words + FDS_HEADER_SIZE);
000002  eb021201          ADD      r2,r2,r1,LSL #4
000006  8953              LDRH     r3,[r2,#0xa]
000008  1cc2              ADDS     r2,r0,#3
00000a  1a9a              SUBS     r2,r3,r2
00000c  4b02              LDR      r3,|L75.24|
00000e  eb031301          ADD      r3,r3,r1,LSL #4
000012  815a              STRH     r2,[r3,#0xa]
;;;353    }
000014  4770              BX       lr
;;;354    
                          ENDP

000016  0000              DCW      0x0000
                  |L75.24|
                          DCD      m_pages

                          AREA ||i.write_space_reserve||, CODE, READONLY, ALIGN=2

                  write_space_reserve PROC
;;;318    // NOTE: this function takes into the account the space required for the record header.
;;;319    static ret_code_t write_space_reserve(uint16_t length_words, uint16_t * p_page)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;320    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;321        bool           space_reserved  = false;
000008  f04f0800          MOV      r8,#0
;;;322        uint16_t const total_len_words = length_words + FDS_HEADER_SIZE;
00000c  1cf8              ADDS     r0,r7,#3
00000e  b285              UXTH     r5,r0
;;;323    
;;;324        if (total_len_words >= FDS_PAGE_SIZE - FDS_PAGE_TAG_SIZE)
000010  f24030fe          MOV      r0,#0x3fe
000014  4285              CMP      r5,r0
000016  db02              BLT      |L76.30|
;;;325        {
;;;326            return FDS_ERR_RECORD_TOO_LARGE;
000018  2009              MOVS     r0,#9
                  |L76.26|
;;;327        }
;;;328    
;;;329        CRITICAL_SECTION_ENTER();
;;;330        for (uint16_t page = 0; page < FDS_MAX_PAGES; page++)
;;;331        {
;;;332            if ((m_pages[page].page_type == FDS_PAGE_DATA) &&
;;;333                (page_has_space(page, total_len_words)))
;;;334            {
;;;335                space_reserved = true;
;;;336                *p_page        = page;
;;;337    
;;;338                m_pages[page].words_reserved += total_len_words;
;;;339                break;
;;;340            }
;;;341        }
;;;342        CRITICAL_SECTION_EXIT();
;;;343    
;;;344        return (space_reserved) ? FDS_SUCCESS : FDS_ERR_NO_SPACE_IN_FLASH;
;;;345    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L76.30|
00001e  2400              MOVS     r4,#0                 ;330
000020  e018              B        |L76.84|
                  |L76.34|
000022  4811              LDR      r0,|L76.104|
000024  eb001004          ADD      r0,r0,r4,LSL #4       ;332
000028  7800              LDRB     r0,[r0,#0]            ;332
00002a  b988              CBNZ     r0,|L76.80|
00002c  4629              MOV      r1,r5                 ;333
00002e  4620              MOV      r0,r4                 ;333
000030  f7fffffe          BL       page_has_space
000034  b160              CBZ      r0,|L76.80|
000036  f04f0801          MOV      r8,#1                 ;335
00003a  8034              STRH     r4,[r6,#0]            ;336
00003c  480a              LDR      r0,|L76.104|
00003e  eb001004          ADD      r0,r0,r4,LSL #4       ;338
000042  8940              LDRH     r0,[r0,#0xa]          ;338
000044  4428              ADD      r0,r0,r5              ;338
000046  4908              LDR      r1,|L76.104|
000048  eb011104          ADD      r1,r1,r4,LSL #4       ;338
00004c  8148              STRH     r0,[r1,#0xa]          ;338
00004e  e003              B        |L76.88|
                  |L76.80|
000050  1c60              ADDS     r0,r4,#1              ;330
000052  b284              UXTH     r4,r0                 ;330
                  |L76.84|
000054  2c02              CMP      r4,#2                 ;330
000056  dbe4              BLT      |L76.34|
                  |L76.88|
000058  bf00              NOP                            ;339
00005a  f1b80f00          CMP      r8,#0                 ;344
00005e  d001              BEQ      |L76.100|
000060  2000              MOVS     r0,#0                 ;344
000062  e7da              B        |L76.26|
                  |L76.100|
000064  2007              MOVS     r0,#7                 ;344
000066  e7d8              B        |L76.26|
;;;346    
                          ENDP

                  |L76.104|
                          DCD      m_pages

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_cb_table
                          %        32
                  m_op_queue
                          %        120
                  m_chunk_queue
                          %        72
                  m_pages
                          %        32
                  m_gc
                          %        16
                  desc
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  m_fds_tl_dirty
000000  0000ffff          DCW      0x0000,0xffff
                  page_tag_swap
                          DCD      0xdeadc0de
                          DCD      0xf11e01ff
                  page_tag_data
                          DCD      0xdeadc0de
                          DCD      0xf11e01fe

                          AREA ||.data||, DATA, ALIGN=2

                  m_flags
000000  00                DCB      0x00
                  m_users
000001  000000            DCB      0x00,0x00,0x00
                  m_latest_rec_id
                          DCD      0x00000000
                  m_swap_page
                          %        8
                  tok
                          DCD      0x00000000
000014  0000              DCW      0x0000
000016  0000              DCB      0x00,0x00

                          AREA fs_data, DATA, ALIGN=2

                  fs_config
                  ||__tagsym$$used||
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      fs_event_handler
00000c  03ff0000          DCB      0x03,0xff,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\fds\\fds.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_fds_c_1b2f21da____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_fds_c_1b2f21da____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_fds_c_1b2f21da____REVSH|
#line 402
|__asm___5_fds_c_1b2f21da____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_fds_c_1b2f21da____RRX|
#line 587
|__asm___5_fds_c_1b2f21da____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
