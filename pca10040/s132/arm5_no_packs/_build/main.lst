L 1 "..\..\..\main.c"
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_sdk_bluetooth_template_main main.c
N * @{
N * @ingroup bluetooth_template
N * @brief bluetooth_template main file.
N *
N * This file contains a template for creating a new application using Bluetooth Developper Studio generated code.
N * It has the code necessary to wakeup from button, advertise, get a connection restart advertising on disconnect and if no new
N * connection created go back to system-off mode.
N * It can easily be used as a starting point for creating a new application, the comments identified
N * with 'YOUR_JOB' indicates where and how you can customize.
N */
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060016
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 28 "..\..\..\main.c" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060016
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 29 "..\..\..\main.c" 2
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060016
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 30 "..\..\..\main.c" 2
N
N#include "nordic_common.h"
L 1 "..\..\..\..\..\..\components\libraries\util\nordic_common.h" 1
N/* Copyright (c) 2008 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N */
N
N/** @file
N * @brief Common defines and macros for firmware developed by Nordic Semiconductor.
N */
N
N#ifndef NORDIC_COMMON_H__
N#define NORDIC_COMMON_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** The upper 8 bits of a 32 bit value */
N//lint -emacro(572,MSB) // Suppress warning 572 "Excessive shift value"
N#define MSB_32(a) (((a) & 0xFF000000) >> 24)
N/** The lower 8 bits (of a 32 bit value) */
N#define LSB_32(a) ((a) & 0x000000FF)
N
N/** The upper 8 bits of a 16 bit value */
N//lint -emacro(572,MSB_16) // Suppress warning 572 "Excessive shift value"
N#define MSB_16(a) (((a) & 0xFF00) >> 8)
N/** The lower 8 bits (of a 16 bit value) */
N#define LSB_16(a) ((a) & 0x00FF)
N
N/** Leaves the minimum of the two 32-bit arguments */
N/*lint -emacro(506, MIN) */ /* Suppress "Constant value Boolean */
N#define MIN(a, b) ((a) < (b) ? (a) : (b))
N/** Leaves the maximum of the two 32-bit arguments */
N/*lint -emacro(506, MAX) */ /* Suppress "Constant value Boolean */
N#define MAX(a, b) ((a) < (b) ? (b) : (a))
N
N/**@brief Concatenates two parameters.
N *
N * It realizes two level expansion to make it sure that all the parameters
N * are actually expanded before gluing them together.
N *
N * @param p1 First parameter to concatenating
N * @param p2 Second parameter to concatenating
N *
N * @return Two parameters glued together.
N *         They have to create correct C mnemonic in other case
N *         preprocessor error would be generated.
N *
N * @sa CONCAT_3
N */
N#define CONCAT_2(p1, p2)      CONCAT_2_(p1, p2)
N/** Auxiliary macro used by @ref CONCAT_2 */
N#define CONCAT_2_(p1, p2)     p1##p2
N
N/**@brief Concatenates three parameters.
N *
N * It realizes two level expansion to make it sure that all the parameters
N * are actually expanded before gluing them together.
N *
N * @param p1 First parameter to concatenating
N * @param p2 Second parameter to concatenating
N * @param p3 Third parameter to concatenating
N *
N * @return Three parameters glued together.
N *         They have to create correct C mnemonic in other case
N *         preprocessor error would be generated.
N *
N * @sa CONCAT_2
N */
N#define CONCAT_3(p1, p2, p3)  CONCAT_3_(p1, p2, p3)
N/** Auxiliary macro used by @ref CONCAT_3 */
N#define CONCAT_3_(p1, p2, p3) p1##p2##p3
N
N#define NUM_TO_STR_INTERNAL(val) #val
N/** Converts numeric value to string.
N */
N#define NUM_TO_STR(val) NUM_TO_STR_INTERNAL(val)
N
N/** Counts number of elements inside the array
N */
N#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
N
N/**@brief Set a bit in the uint32 word.
N *
N * @param[in] W  Word whose bit is being set.
N * @param[in] B  Bit number in the word to be set.
N */
N#define SET_BIT(W,B)  ((W) |= (uint32_t)(1U << (B)))
N
N
N/**@brief Clears a bit in the uint32 word.
N *
N * @param[in] W   Word whose bit is to be cleared.
N * @param[in] B   Bit number in the word to be cleared.
N */
N#define CLR_BIT(W, B) ((W) &= (~((uint32_t)1 << (B))))
N
N
N/**@brief Checks if a bit is set.
N *
N * @param[in] W   Word whose bit is to be checked.
N * @param[in] B   Bit number in the word to be checked.
N *
N * @retval 1 if bit is set.
N * @retval 0 if bit is not set.
N */
N#define IS_SET(W,B) (((W) >> (B)) & 1)
N
N#define BIT_0 0x01 /**< The value of bit 0 */
N#define BIT_1 0x02 /**< The value of bit 1 */
N#define BIT_2 0x04 /**< The value of bit 2 */
N#define BIT_3 0x08 /**< The value of bit 3 */
N#define BIT_4 0x10 /**< The value of bit 4 */
N#define BIT_5 0x20 /**< The value of bit 5 */
N#define BIT_6 0x40 /**< The value of bit 6 */
N#define BIT_7 0x80 /**< The value of bit 7 */
N#define BIT_8 0x0100 /**< The value of bit 8 */
N#define BIT_9 0x0200 /**< The value of bit 9 */
N#define BIT_10 0x0400 /**< The value of bit 10 */
N#define BIT_11 0x0800 /**< The value of bit 11 */
N#define BIT_12 0x1000 /**< The value of bit 12 */
N#define BIT_13 0x2000 /**< The value of bit 13 */
N#define BIT_14 0x4000 /**< The value of bit 14 */
N#define BIT_15 0x8000 /**< The value of bit 15 */
N#define BIT_16 0x00010000 /**< The value of bit 16 */
N#define BIT_17 0x00020000 /**< The value of bit 17 */
N#define BIT_18 0x00040000 /**< The value of bit 18 */
N#define BIT_19 0x00080000 /**< The value of bit 19 */
N#define BIT_20 0x00100000 /**< The value of bit 20 */
N#define BIT_21 0x00200000 /**< The value of bit 21 */
N#define BIT_22 0x00400000 /**< The value of bit 22 */
N#define BIT_23 0x00800000 /**< The value of bit 23 */
N#define BIT_24 0x01000000 /**< The value of bit 24 */
N#define BIT_25 0x02000000 /**< The value of bit 25 */
N#define BIT_26 0x04000000 /**< The value of bit 26 */
N#define BIT_27 0x08000000 /**< The value of bit 27 */
N#define BIT_28 0x10000000 /**< The value of bit 28 */
N#define BIT_29 0x20000000 /**< The value of bit 29 */
N#define BIT_30 0x40000000 /**< The value of bit 30 */
N#define BIT_31 0x80000000 /**< The value of bit 31 */
N
N#define UNUSED_VARIABLE(X)  ((void)(X))
N#define UNUSED_PARAMETER(X) UNUSED_VARIABLE(X)
N#define UNUSED_RETURN_VALUE(X) UNUSED_VARIABLE(X)
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // NORDIC_COMMON_H__
L 32 "..\..\..\main.c" 2
N#include "nrf.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef NRF_H
N#define NRF_H
N
N/* MDK version */
N#define MDK_MAJOR_VERSION   8
N#define MDK_MINOR_VERSION   9
N#define MDK_MICRO_VERSION   0
N
N#if defined(_WIN32)
X#if 0L
S    /* Do not include nrf51 specific files when building for PC host */
S#elif defined(__unix)
X#elif 0L
S    /* Do not include nrf51 specific files when building for PC host */
S#elif defined(__APPLE__)
X#elif 0L
S    /* Do not include nrf51 specific files when building for PC host */
N#else
N
N    /* Family selection for family includes. */
N    #if defined (NRF51)
X    #if 0L
S        #include "nrf51.h"
S        #include "nrf51_bitfields.h"
S        #include "nrf51_deprecated.h"
N    #elif defined (NRF52)
X    #elif 1L
N        #include "nrf52.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf52.h" 1
N
N/****************************************************************************************************//**
N * @file     nrf52.h
N *
N * @brief    CMSIS Cortex-M4 Peripheral Access Layer Header File for
N *           nrf52 from Nordic Semiconductor.
N *
N * @version  V1
N * @date     30. September 2016
N *
N * @note     Generated with SVDConv V2.81d 
N *           from CMSIS SVD File 'nrf52.svd' Version 1,
N *
N * @par      Copyright (c) 2016, Nordic Semiconductor ASA
N *           All rights reserved.
N *           
N *           Redistribution and use in source and binary forms, with or without
N *           modification, are permitted provided that the following conditions are met:
N *           
N *           * Redistributions of source code must retain the above copyright notice, this
N *           list of conditions and the following disclaimer.
N *           
N *           * Redistributions in binary form must reproduce the above copyright notice,
N *           this list of conditions and the following disclaimer in the documentation
N *           and/or other materials provided with the distribution.
N *           
N *           * Neither the name of Nordic Semiconductor ASA nor the names of its
N *           contributors may be used to endorse or promote products derived from
N *           this software without specific prior written permission.
N *           
N *           THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N *           AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N *           IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N *           DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N *           FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N *           DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N *           SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N *           CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N *           OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N *           OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *           
N *
N *******************************************************************************************************/
N
N
N
N/** @addtogroup Nordic Semiconductor
N  * @{
N  */
N
N/** @addtogroup nrf52
N  * @{
N  */
N
N#ifndef NRF52_H
N#define NRF52_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum {
N/* -------------------  Cortex-M4 Processor Exceptions Numbers  ------------------- */
N  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N  MemoryManagement_IRQn         = -12,              /*!<   4  Memory Management, MPU mismatch, including Access Violation
N                                                         and No Match                                                          */
N  BusFault_IRQn                 = -11,              /*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
N                                                         related Fault                                                         */
N  UsageFault_IRQn               = -10,              /*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition    */
N  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* ----------------------  nrf52 Specific Interrupt Numbers  ---------------------- */
N  POWER_CLOCK_IRQn              =   0,              /*!<   0  POWER_CLOCK                                                      */
N  RADIO_IRQn                    =   1,              /*!<   1  RADIO                                                            */
N  UARTE0_UART0_IRQn             =   2,              /*!<   2  UARTE0_UART0                                                     */
N  SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQn=   3,      /*!<   3  SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0                                */
N  SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQn=   4,      /*!<   4  SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1                                */
N  NFCT_IRQn                     =   5,              /*!<   5  NFCT                                                             */
N  GPIOTE_IRQn                   =   6,              /*!<   6  GPIOTE                                                           */
N  SAADC_IRQn                    =   7,              /*!<   7  SAADC                                                            */
N  TIMER0_IRQn                   =   8,              /*!<   8  TIMER0                                                           */
N  TIMER1_IRQn                   =   9,              /*!<   9  TIMER1                                                           */
N  TIMER2_IRQn                   =  10,              /*!<  10  TIMER2                                                           */
N  RTC0_IRQn                     =  11,              /*!<  11  RTC0                                                             */
N  TEMP_IRQn                     =  12,              /*!<  12  TEMP                                                             */
N  RNG_IRQn                      =  13,              /*!<  13  RNG                                                              */
N  ECB_IRQn                      =  14,              /*!<  14  ECB                                                              */
N  CCM_AAR_IRQn                  =  15,              /*!<  15  CCM_AAR                                                          */
N  WDT_IRQn                      =  16,              /*!<  16  WDT                                                              */
N  RTC1_IRQn                     =  17,              /*!<  17  RTC1                                                             */
N  QDEC_IRQn                     =  18,              /*!<  18  QDEC                                                             */
N  COMP_LPCOMP_IRQn              =  19,              /*!<  19  COMP_LPCOMP                                                      */
N  SWI0_EGU0_IRQn                =  20,              /*!<  20  SWI0_EGU0                                                        */
N  SWI1_EGU1_IRQn                =  21,              /*!<  21  SWI1_EGU1                                                        */
N  SWI2_EGU2_IRQn                =  22,              /*!<  22  SWI2_EGU2                                                        */
N  SWI3_EGU3_IRQn                =  23,              /*!<  23  SWI3_EGU3                                                        */
N  SWI4_EGU4_IRQn                =  24,              /*!<  24  SWI4_EGU4                                                        */
N  SWI5_EGU5_IRQn                =  25,              /*!<  25  SWI5_EGU5                                                        */
N  TIMER3_IRQn                   =  26,              /*!<  26  TIMER3                                                           */
N  TIMER4_IRQn                   =  27,              /*!<  27  TIMER4                                                           */
N  PWM0_IRQn                     =  28,              /*!<  28  PWM0                                                             */
N  PDM_IRQn                      =  29,              /*!<  29  PDM                                                              */
N  MWU_IRQn                      =  32,              /*!<  32  MWU                                                              */
N  PWM1_IRQn                     =  33,              /*!<  33  PWM1                                                             */
N  PWM2_IRQn                     =  34,              /*!<  34  PWM2                                                             */
N  SPIM2_SPIS2_SPI2_IRQn         =  35,              /*!<  35  SPIM2_SPIS2_SPI2                                                 */
N  RTC2_IRQn                     =  36,              /*!<  36  RTC2                                                             */
N  I2S_IRQn                      =  37,              /*!<  37  I2S                                                              */
N  FPU_IRQn                      =  38               /*!<  38  FPU                                                              */
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* ----------------Configuration of the Cortex-M4 Processor and Core Peripherals---------------- */
N#define __CM4_REV                 0x0001            /*!< Cortex-M4 Core Revision                                               */
N#define __MPU_PRESENT                  1            /*!< MPU present or not                                                    */
N#define __NVIC_PRIO_BITS               3            /*!< Number of Bits used for Priority Levels                               */
N#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
N#define __FPU_PRESENT                  1            /*!< FPU present or not                                                    */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include "core_cm4.h"                               /*!< Cortex-M4 processor and core peripherals                              */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060300 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM4_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM4_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) |                                     __CM4_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x04U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1U)
X    #if (1 == 1U)
N      #define __FPU_USED       1U
N    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
N    #endif
N  #else
S    #define __FPU_USED         0U
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060300 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060300 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x04U) == 0x04U) || ((0x04U) == 0x07U)
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1 == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1 == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060300 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060300 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060300 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060300 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060300 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060300 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x04U) >= 0x04U)   
N
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
N
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 211 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cm4.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060300 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 212 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cm4.h" 2
N#include "core_cmSimd.h"                 /* Compiler specific SIMD Intrinsics */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cmSimd.h" 1
N/**************************************************************************//**
N * @file     core_cmSimd.h
N * @brief    CMSIS Cortex-M SIMD Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060300 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMSIMD_H
N#define __CORE_CMSIMD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CMSIMD_H */
L 213 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cm4.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000U
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1U)
X#if (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1U)
X#if (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N  \brief    Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
X  volatile uint32_t FPCCR;                   
N  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
X  volatile uint32_t FPCAR;                   
N  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
X  volatile uint32_t FPDSCR;                  
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N} FPU_Type;
N
N/* Floating-Point Context Control Register Definitions */
N#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register Definitions */
N#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register Definitions */
N#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 Definitions */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 Definitions */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if (__MPU_PRESENT == 1U)
X#if (1 == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N#if (__FPU_PRESENT == 1U)
X#if (1 == 1U)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in NVIC and returns the active bit.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3)));
N  }
N  else
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 3)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 3) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != 0x5AA55AA5U)
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5U;        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == 0x5AA55AA5U)
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 138 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf52.h" 2
N#include "system_nrf52.h"                           /*!< nrf52 System                                                          */
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\system_nrf52.h" 1
N/* Copyright (c) 2012 ARM LIMITED
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of ARM nor the names of its contributors may be used to
N *     endorse or promote products derived from this software without specific
N *     prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef SYSTEM_NRF52_H
N#define SYSTEM_NRF52_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_NRF52_H */
L 139 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf52.h" 2
N
N
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N/* -------------------  Start of section using anonymous unions  ------------------ */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined(__ICCARM__)
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S/* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning 586
S#else
S  #warning Not supported compiler type
N#endif
N
N
Ntypedef struct {
N  __I  uint32_t  PART;                              /*!< Part code                                                             */
X  volatile const  uint32_t  PART;                               
N  __I  uint32_t  VARIANT;                           /*!< Part Variant, Hardware version and Production configuration           */
X  volatile const  uint32_t  VARIANT;                            
N  __I  uint32_t  PACKAGE;                           /*!< Package option                                                        */
X  volatile const  uint32_t  PACKAGE;                            
N  __I  uint32_t  RAM;                               /*!< RAM variant                                                           */
X  volatile const  uint32_t  RAM;                                
N  __I  uint32_t  FLASH;                             /*!< Flash variant                                                         */
X  volatile const  uint32_t  FLASH;                              
N  __IO uint32_t  UNUSED0[3];                        /*!< Description collection[0]: Unspecified                                */
X  volatile uint32_t  UNUSED0[3];                         
N} FICR_INFO_Type;
N
Ntypedef struct {
N  __I  uint32_t  A0;                                /*!< Slope definition A0.                                                  */
X  volatile const  uint32_t  A0;                                 
N  __I  uint32_t  A1;                                /*!< Slope definition A1.                                                  */
X  volatile const  uint32_t  A1;                                 
N  __I  uint32_t  A2;                                /*!< Slope definition A2.                                                  */
X  volatile const  uint32_t  A2;                                 
N  __I  uint32_t  A3;                                /*!< Slope definition A3.                                                  */
X  volatile const  uint32_t  A3;                                 
N  __I  uint32_t  A4;                                /*!< Slope definition A4.                                                  */
X  volatile const  uint32_t  A4;                                 
N  __I  uint32_t  A5;                                /*!< Slope definition A5.                                                  */
X  volatile const  uint32_t  A5;                                 
N  __I  uint32_t  B0;                                /*!< y-intercept B0.                                                       */
X  volatile const  uint32_t  B0;                                 
N  __I  uint32_t  B1;                                /*!< y-intercept B1.                                                       */
X  volatile const  uint32_t  B1;                                 
N  __I  uint32_t  B2;                                /*!< y-intercept B2.                                                       */
X  volatile const  uint32_t  B2;                                 
N  __I  uint32_t  B3;                                /*!< y-intercept B3.                                                       */
X  volatile const  uint32_t  B3;                                 
N  __I  uint32_t  B4;                                /*!< y-intercept B4.                                                       */
X  volatile const  uint32_t  B4;                                 
N  __I  uint32_t  B5;                                /*!< y-intercept B5.                                                       */
X  volatile const  uint32_t  B5;                                 
N  __I  uint32_t  T0;                                /*!< Segment end T0.                                                       */
X  volatile const  uint32_t  T0;                                 
N  __I  uint32_t  T1;                                /*!< Segment end T1.                                                       */
X  volatile const  uint32_t  T1;                                 
N  __I  uint32_t  T2;                                /*!< Segment end T2.                                                       */
X  volatile const  uint32_t  T2;                                 
N  __I  uint32_t  T3;                                /*!< Segment end T3.                                                       */
X  volatile const  uint32_t  T3;                                 
N  __I  uint32_t  T4;                                /*!< Segment end T4.                                                       */
X  volatile const  uint32_t  T4;                                 
N} FICR_TEMP_Type;
N
Ntypedef struct {
N  __I  uint32_t  TAGHEADER0;                        /*!< Default header for NFC Tag. Software can read these values to
X  volatile const  uint32_t  TAGHEADER0;                        
N                                                         populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.            */
N  __I  uint32_t  TAGHEADER1;                        /*!< Default header for NFC Tag. Software can read these values to
X  volatile const  uint32_t  TAGHEADER1;                        
N                                                         populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.            */
N  __I  uint32_t  TAGHEADER2;                        /*!< Default header for NFC Tag. Software can read these values to
X  volatile const  uint32_t  TAGHEADER2;                        
N                                                         populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.            */
N  __I  uint32_t  TAGHEADER3;                        /*!< Default header for NFC Tag. Software can read these values to
X  volatile const  uint32_t  TAGHEADER3;                        
N                                                         populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.            */
N} FICR_NFC_Type;
N
Ntypedef struct {
N  __IO uint32_t  POWER;                             /*!< Description cluster[0]: RAM0 power control register                   */
X  volatile uint32_t  POWER;                              
N  __O  uint32_t  POWERSET;                          /*!< Description cluster[0]: RAM0 power control set register               */
X  volatile  uint32_t  POWERSET;                           
N  __O  uint32_t  POWERCLR;                          /*!< Description cluster[0]: RAM0 power control clear register             */
X  volatile  uint32_t  POWERCLR;                           
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N} POWER_RAM_Type;
N
Ntypedef struct {
N  __IO uint32_t  RTS;                               /*!< Pin select for RTS signal                                             */
X  volatile uint32_t  RTS;                                
N  __IO uint32_t  TXD;                               /*!< Pin select for TXD signal                                             */
X  volatile uint32_t  TXD;                                
N  __IO uint32_t  CTS;                               /*!< Pin select for CTS signal                                             */
X  volatile uint32_t  CTS;                                
N  __IO uint32_t  RXD;                               /*!< Pin select for RXD signal                                             */
X  volatile uint32_t  RXD;                                
N} UARTE_PSEL_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< Data pointer                                                          */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of bytes in receive buffer                             */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of bytes transferred in the last transaction                   */
X  volatile const  uint32_t  AMOUNT;                             
N} UARTE_RXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< Data pointer                                                          */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of bytes in transmit buffer                            */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of bytes transferred in the last transaction                   */
X  volatile const  uint32_t  AMOUNT;                             
N} UARTE_TXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  SCK;                               /*!< Pin select for SCK                                                    */
X  volatile uint32_t  SCK;                                
N  __IO uint32_t  MOSI;                              /*!< Pin select for MOSI signal                                            */
X  volatile uint32_t  MOSI;                               
N  __IO uint32_t  MISO;                              /*!< Pin select for MISO signal                                            */
X  volatile uint32_t  MISO;                               
N} SPIM_PSEL_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< Data pointer                                                          */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of bytes in receive buffer                             */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of bytes transferred in the last transaction                   */
X  volatile const  uint32_t  AMOUNT;                             
N  __IO uint32_t  LIST;                              /*!< EasyDMA list type                                                     */
X  volatile uint32_t  LIST;                               
N} SPIM_RXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< Data pointer                                                          */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of bytes in transmit buffer                            */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of bytes transferred in the last transaction                   */
X  volatile const  uint32_t  AMOUNT;                             
N  __IO uint32_t  LIST;                              /*!< EasyDMA list type                                                     */
X  volatile uint32_t  LIST;                               
N} SPIM_TXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  SCK;                               /*!< Pin select for SCK                                                    */
X  volatile uint32_t  SCK;                                
N  __IO uint32_t  MISO;                              /*!< Pin select for MISO signal                                            */
X  volatile uint32_t  MISO;                               
N  __IO uint32_t  MOSI;                              /*!< Pin select for MOSI signal                                            */
X  volatile uint32_t  MOSI;                               
N  __IO uint32_t  CSN;                               /*!< Pin select for CSN signal                                             */
X  volatile uint32_t  CSN;                                
N} SPIS_PSEL_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< RXD data pointer                                                      */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of bytes in receive buffer                             */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of bytes received in last granted transaction                  */
X  volatile const  uint32_t  AMOUNT;                             
N} SPIS_RXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< TXD data pointer                                                      */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of bytes in transmit buffer                            */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of bytes transmitted in last granted transaction               */
X  volatile const  uint32_t  AMOUNT;                             
N} SPIS_TXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  SCL;                               /*!< Pin select for SCL signal                                             */
X  volatile uint32_t  SCL;                                
N  __IO uint32_t  SDA;                               /*!< Pin select for SDA signal                                             */
X  volatile uint32_t  SDA;                                
N} TWIM_PSEL_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< Data pointer                                                          */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of bytes in receive buffer                             */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of bytes transferred in the last transaction                   */
X  volatile const  uint32_t  AMOUNT;                             
N  __IO uint32_t  LIST;                              /*!< EasyDMA list type                                                     */
X  volatile uint32_t  LIST;                               
N} TWIM_RXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< Data pointer                                                          */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of bytes in transmit buffer                            */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of bytes transferred in the last transaction                   */
X  volatile const  uint32_t  AMOUNT;                             
N  __IO uint32_t  LIST;                              /*!< EasyDMA list type                                                     */
X  volatile uint32_t  LIST;                               
N} TWIM_TXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  SCL;                               /*!< Pin select for SCL signal                                             */
X  volatile uint32_t  SCL;                                
N  __IO uint32_t  SDA;                               /*!< Pin select for SDA signal                                             */
X  volatile uint32_t  SDA;                                
N} TWIS_PSEL_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< RXD Data pointer                                                      */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of bytes in RXD buffer                                 */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of bytes transferred in the last RXD transaction               */
X  volatile const  uint32_t  AMOUNT;                             
N} TWIS_RXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< TXD Data pointer                                                      */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of bytes in TXD buffer                                 */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of bytes transferred in the last TXD transaction               */
X  volatile const  uint32_t  AMOUNT;                             
N} TWIS_TXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  SCK;                               /*!< Pin select for SCK                                                    */
X  volatile uint32_t  SCK;                                
N  __IO uint32_t  MOSI;                              /*!< Pin select for MOSI                                                   */
X  volatile uint32_t  MOSI;                               
N  __IO uint32_t  MISO;                              /*!< Pin select for MISO                                                   */
X  volatile uint32_t  MISO;                               
N} SPI_PSEL_Type;
N
Ntypedef struct {
N  __IO uint32_t  RX;                                /*!< Result of last incoming frames                                        */
X  volatile uint32_t  RX;                                 
N} NFCT_FRAMESTATUS_Type;
N
Ntypedef struct {
N  __IO uint32_t  FRAMECONFIG;                       /*!< Configuration of outgoing frames                                      */
X  volatile uint32_t  FRAMECONFIG;                        
N  __IO uint32_t  AMOUNT;                            /*!< Size of outgoing frame                                                */
X  volatile uint32_t  AMOUNT;                             
N} NFCT_TXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  FRAMECONFIG;                       /*!< Configuration of incoming frames                                      */
X  volatile uint32_t  FRAMECONFIG;                        
N  __I  uint32_t  AMOUNT;                            /*!< Size of last incoming frame                                           */
X  volatile const  uint32_t  AMOUNT;                             
N} NFCT_RXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  LIMITH;                            /*!< Description cluster[0]: Last results is equal or above CH[0].LIMIT.HIGH */
X  volatile uint32_t  LIMITH;                             
N  __IO uint32_t  LIMITL;                            /*!< Description cluster[0]: Last results is equal or below CH[0].LIMIT.LOW */
X  volatile uint32_t  LIMITL;                             
N} SAADC_EVENTS_CH_Type;
N
Ntypedef struct {
N  __IO uint32_t  PSELP;                             /*!< Description cluster[0]: Input positive pin selection for CH[0]        */
X  volatile uint32_t  PSELP;                              
N  __IO uint32_t  PSELN;                             /*!< Description cluster[0]: Input negative pin selection for CH[0]        */
X  volatile uint32_t  PSELN;                              
N  __IO uint32_t  CONFIG;                            /*!< Description cluster[0]: Input configuration for CH[0]                 */
X  volatile uint32_t  CONFIG;                             
N  __IO uint32_t  LIMIT;                             /*!< Description cluster[0]: High/low limits for event monitoring
X  volatile uint32_t  LIMIT;                             
N                                                         a channel                                                             */
N} SAADC_CH_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< Data pointer                                                          */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Maximum number of buffer words to transfer                            */
X  volatile uint32_t  MAXCNT;                             
N  __I  uint32_t  AMOUNT;                            /*!< Number of buffer words transferred since last START                   */
X  volatile const  uint32_t  AMOUNT;                             
N} SAADC_RESULT_Type;
N
Ntypedef struct {
N  __IO uint32_t  LED;                               /*!< Pin select for LED signal                                             */
X  volatile uint32_t  LED;                                
N  __IO uint32_t  A;                                 /*!< Pin select for A signal                                               */
X  volatile uint32_t  A;                                  
N  __IO uint32_t  B;                                 /*!< Pin select for B signal                                               */
X  volatile uint32_t  B;                                  
N} QDEC_PSEL_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< Description cluster[0]: Beginning address in Data RAM of this
X  volatile uint32_t  PTR;                               
N                                                         sequence                                                              */
N  __IO uint32_t  CNT;                               /*!< Description cluster[0]: Amount of values (duty cycles) in this
X  volatile uint32_t  CNT;                               
N                                                         sequence                                                              */
N  __IO uint32_t  REFRESH;                           /*!< Description cluster[0]: Amount of additional PWM periods between
X  volatile uint32_t  REFRESH;                           
N                                                         samples loaded into compare register                                  */
N  __IO uint32_t  ENDDELAY;                          /*!< Description cluster[0]: Time added after the sequence                 */
X  volatile uint32_t  ENDDELAY;                           
N  __I  uint32_t  RESERVED1[4];
X  volatile const  uint32_t  RESERVED1[4];
N} PWM_SEQ_Type;
N
Ntypedef struct {
N  __IO uint32_t  OUT[4];                            /*!< Description collection[0]: Output pin select for PWM channel
X  volatile uint32_t  OUT[4];                            
N                                                         0                                                                     */
N} PWM_PSEL_Type;
N
Ntypedef struct {
N  __IO uint32_t  CLK;                               /*!< Pin number configuration for PDM CLK signal                           */
X  volatile uint32_t  CLK;                                
N  __IO uint32_t  DIN;                               /*!< Pin number configuration for PDM DIN signal                           */
X  volatile uint32_t  DIN;                                
N} PDM_PSEL_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< RAM address pointer to write samples to with EasyDMA                  */
X  volatile uint32_t  PTR;                                
N  __IO uint32_t  MAXCNT;                            /*!< Number of samples to allocate memory for in EasyDMA mode              */
X  volatile uint32_t  MAXCNT;                             
N} PDM_SAMPLE_Type;
N
Ntypedef struct {
N  __O  uint32_t  EN;                                /*!< Description cluster[0]: Enable channel group 0                        */
X  volatile  uint32_t  EN;                                 
N  __O  uint32_t  DIS;                               /*!< Description cluster[0]: Disable channel group 0                       */
X  volatile  uint32_t  DIS;                                
N} PPI_TASKS_CHG_Type;
N
Ntypedef struct {
N  __IO uint32_t  EEP;                               /*!< Description cluster[0]: Channel 0 event end-point                     */
X  volatile uint32_t  EEP;                                
N  __IO uint32_t  TEP;                               /*!< Description cluster[0]: Channel 0 task end-point                      */
X  volatile uint32_t  TEP;                                
N} PPI_CH_Type;
N
Ntypedef struct {
N  __IO uint32_t  TEP;                               /*!< Description cluster[0]: Channel 0 task end-point                      */
X  volatile uint32_t  TEP;                                
N} PPI_FORK_Type;
N
Ntypedef struct {
N  __IO uint32_t  WA;                                /*!< Description cluster[0]: Write access to region 0 detected             */
X  volatile uint32_t  WA;                                 
N  __IO uint32_t  RA;                                /*!< Description cluster[0]: Read access to region 0 detected              */
X  volatile uint32_t  RA;                                 
N} MWU_EVENTS_REGION_Type;
N
Ntypedef struct {
N  __IO uint32_t  WA;                                /*!< Description cluster[0]: Write access to peripheral region 0
X  volatile uint32_t  WA;                                
N                                                         detected                                                              */
N  __IO uint32_t  RA;                                /*!< Description cluster[0]: Read access to peripheral region 0 detected   */
X  volatile uint32_t  RA;                                 
N} MWU_EVENTS_PREGION_Type;
N
Ntypedef struct {
N  __IO uint32_t  SUBSTATWA;                         /*!< Description cluster[0]: Source of event/interrupt in region
X  volatile uint32_t  SUBSTATWA;                         
N                                                         0, write access detected while corresponding subregion was enabled
N                                                          for watching                                                         */
N  __IO uint32_t  SUBSTATRA;                         /*!< Description cluster[0]: Source of event/interrupt in region
X  volatile uint32_t  SUBSTATRA;                         
N                                                         0, read access detected while corresponding subregion was enabled
N                                                          for watching                                                         */
N} MWU_PERREGION_Type;
N
Ntypedef struct {
N  __IO uint32_t  START;                             /*!< Description cluster[0]: Start address for region 0                    */
X  volatile uint32_t  START;                              
N  __IO uint32_t  END;                               /*!< Description cluster[0]: End address of region 0                       */
X  volatile uint32_t  END;                                
N  __I  uint32_t  RESERVED2[2];
X  volatile const  uint32_t  RESERVED2[2];
N} MWU_REGION_Type;
N
Ntypedef struct {
N  __I  uint32_t  START;                             /*!< Description cluster[0]: Reserved for future use                       */
X  volatile const  uint32_t  START;                              
N  __I  uint32_t  END;                               /*!< Description cluster[0]: Reserved for future use                       */
X  volatile const  uint32_t  END;                                
N  __IO uint32_t  SUBS;                              /*!< Description cluster[0]: Subregions of region 0                        */
X  volatile uint32_t  SUBS;                               
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N} MWU_PREGION_Type;
N
Ntypedef struct {
N  __IO uint32_t  MODE;                              /*!< I2S mode.                                                             */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  RXEN;                              /*!< Reception (RX) enable.                                                */
X  volatile uint32_t  RXEN;                               
N  __IO uint32_t  TXEN;                              /*!< Transmission (TX) enable.                                             */
X  volatile uint32_t  TXEN;                               
N  __IO uint32_t  MCKEN;                             /*!< Master clock generator enable.                                        */
X  volatile uint32_t  MCKEN;                              
N  __IO uint32_t  MCKFREQ;                           /*!< Master clock generator frequency.                                     */
X  volatile uint32_t  MCKFREQ;                            
N  __IO uint32_t  RATIO;                             /*!< MCK / LRCK ratio.                                                     */
X  volatile uint32_t  RATIO;                              
N  __IO uint32_t  SWIDTH;                            /*!< Sample width.                                                         */
X  volatile uint32_t  SWIDTH;                             
N  __IO uint32_t  ALIGN;                             /*!< Alignment of sample within a frame.                                   */
X  volatile uint32_t  ALIGN;                              
N  __IO uint32_t  FORMAT;                            /*!< Frame format.                                                         */
X  volatile uint32_t  FORMAT;                             
N  __IO uint32_t  CHANNELS;                          /*!< Enable channels.                                                      */
X  volatile uint32_t  CHANNELS;                           
N} I2S_CONFIG_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< Receive buffer RAM start address.                                     */
X  volatile uint32_t  PTR;                                
N} I2S_RXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  PTR;                               /*!< Transmit buffer RAM start address.                                    */
X  volatile uint32_t  PTR;                                
N} I2S_TXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  MAXCNT;                            /*!< Size of RXD and TXD buffers.                                          */
X  volatile uint32_t  MAXCNT;                             
N} I2S_RXTXD_Type;
N
Ntypedef struct {
N  __IO uint32_t  MCK;                               /*!< Pin select for MCK signal.                                            */
X  volatile uint32_t  MCK;                                
N  __IO uint32_t  SCK;                               /*!< Pin select for SCK signal.                                            */
X  volatile uint32_t  SCK;                                
N  __IO uint32_t  LRCK;                              /*!< Pin select for LRCK signal.                                           */
X  volatile uint32_t  LRCK;                               
N  __IO uint32_t  SDIN;                              /*!< Pin select for SDIN signal.                                           */
X  volatile uint32_t  SDIN;                               
N  __IO uint32_t  SDOUT;                             /*!< Pin select for SDOUT signal.                                          */
X  volatile uint32_t  SDOUT;                              
N} I2S_PSEL_Type;
N
N
N/* ================================================================================ */
N/* ================                      FICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Factory Information Configuration Registers (FICR)
N  */
N
Ntypedef struct {                                    /*!< FICR Structure                                                        */
N  __I  uint32_t  RESERVED0[4];
X  volatile const  uint32_t  RESERVED0[4];
N  __I  uint32_t  CODEPAGESIZE;                      /*!< Code memory page size                                                 */
X  volatile const  uint32_t  CODEPAGESIZE;                       
N  __I  uint32_t  CODESIZE;                          /*!< Code memory size                                                      */
X  volatile const  uint32_t  CODESIZE;                           
N  __I  uint32_t  RESERVED1[18];
X  volatile const  uint32_t  RESERVED1[18];
N  __I  uint32_t  DEVICEID[2];                       /*!< Description collection[0]: Device identifier                          */
X  volatile const  uint32_t  DEVICEID[2];                        
N  __I  uint32_t  RESERVED2[6];
X  volatile const  uint32_t  RESERVED2[6];
N  __I  uint32_t  ER[4];                             /*!< Description collection[0]: Encryption Root, word 0                    */
X  volatile const  uint32_t  ER[4];                              
N  __I  uint32_t  IR[4];                             /*!< Description collection[0]: Identity Root, word 0                      */
X  volatile const  uint32_t  IR[4];                              
N  __I  uint32_t  DEVICEADDRTYPE;                    /*!< Device address type                                                   */
X  volatile const  uint32_t  DEVICEADDRTYPE;                     
N  __I  uint32_t  DEVICEADDR[2];                     /*!< Description collection[0]: Device address 0                           */
X  volatile const  uint32_t  DEVICEADDR[2];                      
N  __I  uint32_t  RESERVED3[21];
X  volatile const  uint32_t  RESERVED3[21];
N  FICR_INFO_Type INFO;                              /*!< Device info                                                           */
N  __I  uint32_t  RESERVED4[185];
X  volatile const  uint32_t  RESERVED4[185];
N  FICR_TEMP_Type TEMP;                              /*!< Registers storing factory TEMP module linearization coefficients      */
N  __I  uint32_t  RESERVED5[2];
X  volatile const  uint32_t  RESERVED5[2];
N  FICR_NFC_Type NFC;                                /*!< Unspecified                                                           */
N} NRF_FICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      UICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief User Information Configuration Registers (UICR)
N  */
N
Ntypedef struct {                                    /*!< UICR Structure                                                        */
N  __IO uint32_t  UNUSED0;                           /*!< Unspecified                                                           */
X  volatile uint32_t  UNUSED0;                            
N  __IO uint32_t  UNUSED1;                           /*!< Unspecified                                                           */
X  volatile uint32_t  UNUSED1;                            
N  __IO uint32_t  UNUSED2;                           /*!< Unspecified                                                           */
X  volatile uint32_t  UNUSED2;                            
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __IO uint32_t  UNUSED3;                           /*!< Unspecified                                                           */
X  volatile uint32_t  UNUSED3;                            
N  __IO uint32_t  NRFFW[15];                         /*!< Description collection[0]: Reserved for Nordic firmware design        */
X  volatile uint32_t  NRFFW[15];                          
N  __IO uint32_t  NRFHW[12];                         /*!< Description collection[0]: Reserved for Nordic hardware design        */
X  volatile uint32_t  NRFHW[12];                          
N  __IO uint32_t  CUSTOMER[32];                      /*!< Description collection[0]: Reserved for customer                      */
X  volatile uint32_t  CUSTOMER[32];                       
N  __I  uint32_t  RESERVED1[64];
X  volatile const  uint32_t  RESERVED1[64];
N  __IO uint32_t  PSELRESET[2];                      /*!< Description collection[0]: Mapping of the nRESET function (see
X  volatile uint32_t  PSELRESET[2];                      
N                                                         POWER chapter for details)                                            */
N  __IO uint32_t  APPROTECT;                         /*!< Access Port protection                                                */
X  volatile uint32_t  APPROTECT;                          
N  __IO uint32_t  NFCPINS;                           /*!< Setting of pins dedicated to NFC functionality: NFC antenna
X  volatile uint32_t  NFCPINS;                           
N                                                         or GPIO                                                               */
N} NRF_UICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      BPROT                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Block Protect (BPROT)
N  */
N
Ntypedef struct {                                    /*!< BPROT Structure                                                       */
N  __I  uint32_t  RESERVED0[384];
X  volatile const  uint32_t  RESERVED0[384];
N  __IO uint32_t  CONFIG0;                           /*!< Block protect configuration register 0                                */
X  volatile uint32_t  CONFIG0;                            
N  __IO uint32_t  CONFIG1;                           /*!< Block protect configuration register 1                                */
X  volatile uint32_t  CONFIG1;                            
N  __IO uint32_t  DISABLEINDEBUG;                    /*!< Disable protection mechanism in debug interface mode                  */
X  volatile uint32_t  DISABLEINDEBUG;                     
N  __IO uint32_t  UNUSED0;                           /*!< Unspecified                                                           */
X  volatile uint32_t  UNUSED0;                            
N  __IO uint32_t  CONFIG2;                           /*!< Block protect configuration register 2                                */
X  volatile uint32_t  CONFIG2;                            
N  __IO uint32_t  CONFIG3;                           /*!< Block protect configuration register 3                                */
X  volatile uint32_t  CONFIG3;                            
N} NRF_BPROT_Type;
N
N
N/* ================================================================================ */
N/* ================                      POWER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Power control (POWER)
N  */
N
Ntypedef struct {                                    /*!< POWER Structure                                                       */
N  __I  uint32_t  RESERVED0[30];
X  volatile const  uint32_t  RESERVED0[30];
N  __O  uint32_t  TASKS_CONSTLAT;                    /*!< Enable constant latency mode                                          */
X  volatile  uint32_t  TASKS_CONSTLAT;                     
N  __O  uint32_t  TASKS_LOWPWR;                      /*!< Enable low power mode (variable latency)                              */
X  volatile  uint32_t  TASKS_LOWPWR;                       
N  __I  uint32_t  RESERVED1[34];
X  volatile const  uint32_t  RESERVED1[34];
N  __IO uint32_t  EVENTS_POFWARN;                    /*!< Power failure warning                                                 */
X  volatile uint32_t  EVENTS_POFWARN;                     
N  __I  uint32_t  RESERVED2[2];
X  volatile const  uint32_t  RESERVED2[2];
N  __IO uint32_t  EVENTS_SLEEPENTER;                 /*!< CPU entered WFI/WFE sleep                                             */
X  volatile uint32_t  EVENTS_SLEEPENTER;                  
N  __IO uint32_t  EVENTS_SLEEPEXIT;                  /*!< CPU exited WFI/WFE sleep                                              */
X  volatile uint32_t  EVENTS_SLEEPEXIT;                   
N  __I  uint32_t  RESERVED3[122];
X  volatile const  uint32_t  RESERVED3[122];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[61];
X  volatile const  uint32_t  RESERVED4[61];
N  __IO uint32_t  RESETREAS;                         /*!< Reset reason                                                          */
X  volatile uint32_t  RESETREAS;                          
N  __I  uint32_t  RESERVED5[9];
X  volatile const  uint32_t  RESERVED5[9];
N  __I  uint32_t  RAMSTATUS;                         /*!< Deprecated register - RAM status register                             */
X  volatile const  uint32_t  RAMSTATUS;                          
N  __I  uint32_t  RESERVED6[53];
X  volatile const  uint32_t  RESERVED6[53];
N  __O  uint32_t  SYSTEMOFF;                         /*!< System OFF register                                                   */
X  volatile  uint32_t  SYSTEMOFF;                          
N  __I  uint32_t  RESERVED7[3];
X  volatile const  uint32_t  RESERVED7[3];
N  __IO uint32_t  POFCON;                            /*!< Power failure comparator configuration                                */
X  volatile uint32_t  POFCON;                             
N  __I  uint32_t  RESERVED8[2];
X  volatile const  uint32_t  RESERVED8[2];
N  __IO uint32_t  GPREGRET;                          /*!< General purpose retention register                                    */
X  volatile uint32_t  GPREGRET;                           
N  __IO uint32_t  GPREGRET2;                         /*!< General purpose retention register                                    */
X  volatile uint32_t  GPREGRET2;                          
N  __IO uint32_t  RAMON;                             /*!< Deprecated register - RAM on/off register (this register is
X  volatile uint32_t  RAMON;                             
N                                                         retained)                                                             */
N  __I  uint32_t  RESERVED9[11];
X  volatile const  uint32_t  RESERVED9[11];
N  __IO uint32_t  RAMONB;                            /*!< Deprecated register - RAM on/off register (this register is
X  volatile uint32_t  RAMONB;                            
N                                                         retained)                                                             */
N  __I  uint32_t  RESERVED10[8];
X  volatile const  uint32_t  RESERVED10[8];
N  __IO uint32_t  DCDCEN;                            /*!< DC/DC enable register                                                 */
X  volatile uint32_t  DCDCEN;                             
N  __I  uint32_t  RESERVED11[225];
X  volatile const  uint32_t  RESERVED11[225];
N  POWER_RAM_Type RAM[8];                            /*!< Unspecified                                                           */
N} NRF_POWER_Type;
N
N
N/* ================================================================================ */
N/* ================                      CLOCK                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Clock control (CLOCK)
N  */
N
Ntypedef struct {                                    /*!< CLOCK Structure                                                       */
N  __O  uint32_t  TASKS_HFCLKSTART;                  /*!< Start HFCLK crystal oscillator                                        */
X  volatile  uint32_t  TASKS_HFCLKSTART;                   
N  __O  uint32_t  TASKS_HFCLKSTOP;                   /*!< Stop HFCLK crystal oscillator                                         */
X  volatile  uint32_t  TASKS_HFCLKSTOP;                    
N  __O  uint32_t  TASKS_LFCLKSTART;                  /*!< Start LFCLK source                                                    */
X  volatile  uint32_t  TASKS_LFCLKSTART;                   
N  __O  uint32_t  TASKS_LFCLKSTOP;                   /*!< Stop LFCLK source                                                     */
X  volatile  uint32_t  TASKS_LFCLKSTOP;                    
N  __O  uint32_t  TASKS_CAL;                         /*!< Start calibration of LFRC oscillator                                  */
X  volatile  uint32_t  TASKS_CAL;                          
N  __O  uint32_t  TASKS_CTSTART;                     /*!< Start calibration timer                                               */
X  volatile  uint32_t  TASKS_CTSTART;                      
N  __O  uint32_t  TASKS_CTSTOP;                      /*!< Stop calibration timer                                                */
X  volatile  uint32_t  TASKS_CTSTOP;                       
N  __I  uint32_t  RESERVED0[57];
X  volatile const  uint32_t  RESERVED0[57];
N  __IO uint32_t  EVENTS_HFCLKSTARTED;               /*!< HFCLK oscillator started                                              */
X  volatile uint32_t  EVENTS_HFCLKSTARTED;                
N  __IO uint32_t  EVENTS_LFCLKSTARTED;               /*!< LFCLK started                                                         */
X  volatile uint32_t  EVENTS_LFCLKSTARTED;                
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  __IO uint32_t  EVENTS_DONE;                       /*!< Calibration of LFCLK RC oscillator complete event                     */
X  volatile uint32_t  EVENTS_DONE;                        
N  __IO uint32_t  EVENTS_CTTO;                       /*!< Calibration timer timeout                                             */
X  volatile uint32_t  EVENTS_CTTO;                        
N  __I  uint32_t  RESERVED2[124];
X  volatile const  uint32_t  RESERVED2[124];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __I  uint32_t  HFCLKRUN;                          /*!< Status indicating that HFCLKSTART task has been triggered             */
X  volatile const  uint32_t  HFCLKRUN;                           
N  __I  uint32_t  HFCLKSTAT;                         /*!< HFCLK status                                                          */
X  volatile const  uint32_t  HFCLKSTAT;                          
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __I  uint32_t  LFCLKRUN;                          /*!< Status indicating that LFCLKSTART task has been triggered             */
X  volatile const  uint32_t  LFCLKRUN;                           
N  __I  uint32_t  LFCLKSTAT;                         /*!< LFCLK status                                                          */
X  volatile const  uint32_t  LFCLKSTAT;                          
N  __I  uint32_t  LFCLKSRCCOPY;                      /*!< Copy of LFCLKSRC register, set when LFCLKSTART task was triggered     */
X  volatile const  uint32_t  LFCLKSRCCOPY;                       
N  __I  uint32_t  RESERVED5[62];
X  volatile const  uint32_t  RESERVED5[62];
N  __IO uint32_t  LFCLKSRC;                          /*!< Clock source for the LFCLK                                            */
X  volatile uint32_t  LFCLKSRC;                           
N  __I  uint32_t  RESERVED6[7];
X  volatile const  uint32_t  RESERVED6[7];
N  __IO uint32_t  CTIV;                              /*!< Calibration timer interval                                            */
X  volatile uint32_t  CTIV;                               
N  __I  uint32_t  RESERVED7[8];
X  volatile const  uint32_t  RESERVED7[8];
N  __IO uint32_t  TRACECONFIG;                       /*!< Clocking options for the Trace Port debug interface                   */
X  volatile uint32_t  TRACECONFIG;                        
N} NRF_CLOCK_Type;
N
N
N/* ================================================================================ */
N/* ================                      RADIO                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief 2.4 GHz Radio (RADIO)
N  */
N
Ntypedef struct {                                    /*!< RADIO Structure                                                       */
N  __O  uint32_t  TASKS_TXEN;                        /*!< Enable RADIO in TX mode                                               */
X  volatile  uint32_t  TASKS_TXEN;                         
N  __O  uint32_t  TASKS_RXEN;                        /*!< Enable RADIO in RX mode                                               */
X  volatile  uint32_t  TASKS_RXEN;                         
N  __O  uint32_t  TASKS_START;                       /*!< Start RADIO                                                           */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop RADIO                                                            */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_DISABLE;                     /*!< Disable RADIO                                                         */
X  volatile  uint32_t  TASKS_DISABLE;                      
N  __O  uint32_t  TASKS_RSSISTART;                   /*!< Start the RSSI and take one single sample of the receive signal
X  volatile  uint32_t  TASKS_RSSISTART;                   
N                                                         strength.                                                             */
N  __O  uint32_t  TASKS_RSSISTOP;                    /*!< Stop the RSSI measurement                                             */
X  volatile  uint32_t  TASKS_RSSISTOP;                     
N  __O  uint32_t  TASKS_BCSTART;                     /*!< Start the bit counter                                                 */
X  volatile  uint32_t  TASKS_BCSTART;                      
N  __O  uint32_t  TASKS_BCSTOP;                      /*!< Stop the bit counter                                                  */
X  volatile  uint32_t  TASKS_BCSTOP;                       
N  __I  uint32_t  RESERVED0[55];
X  volatile const  uint32_t  RESERVED0[55];
N  __IO uint32_t  EVENTS_READY;                      /*!< RADIO has ramped up and is ready to be started                        */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_ADDRESS;                    /*!< Address sent or received                                              */
X  volatile uint32_t  EVENTS_ADDRESS;                     
N  __IO uint32_t  EVENTS_PAYLOAD;                    /*!< Packet payload sent or received                                       */
X  volatile uint32_t  EVENTS_PAYLOAD;                     
N  __IO uint32_t  EVENTS_END;                        /*!< Packet sent or received                                               */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_DISABLED;                   /*!< RADIO has been disabled                                               */
X  volatile uint32_t  EVENTS_DISABLED;                    
N  __IO uint32_t  EVENTS_DEVMATCH;                   /*!< A device address match occurred on the last received packet           */
X  volatile uint32_t  EVENTS_DEVMATCH;                    
N  __IO uint32_t  EVENTS_DEVMISS;                    /*!< No device address match occurred on the last received packet          */
X  volatile uint32_t  EVENTS_DEVMISS;                     
N  __IO uint32_t  EVENTS_RSSIEND;                    /*!< Sampling of receive signal strength complete.                         */
X  volatile uint32_t  EVENTS_RSSIEND;                     
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __IO uint32_t  EVENTS_BCMATCH;                    /*!< Bit counter reached bit count value.                                  */
X  volatile uint32_t  EVENTS_BCMATCH;                     
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __IO uint32_t  EVENTS_CRCOK;                      /*!< Packet received with CRC ok                                           */
X  volatile uint32_t  EVENTS_CRCOK;                       
N  __IO uint32_t  EVENTS_CRCERROR;                   /*!< Packet received with CRC error                                        */
X  volatile uint32_t  EVENTS_CRCERROR;                    
N  __I  uint32_t  RESERVED3[50];
X  volatile const  uint32_t  RESERVED3[50];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED4[64];
X  volatile const  uint32_t  RESERVED4[64];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED5[61];
X  volatile const  uint32_t  RESERVED5[61];
N  __I  uint32_t  CRCSTATUS;                         /*!< CRC status                                                            */
X  volatile const  uint32_t  CRCSTATUS;                          
N  __I  uint32_t  RESERVED6;
X  volatile const  uint32_t  RESERVED6;
N  __I  uint32_t  RXMATCH;                           /*!< Received address                                                      */
X  volatile const  uint32_t  RXMATCH;                            
N  __I  uint32_t  RXCRC;                             /*!< CRC field of previously received packet                               */
X  volatile const  uint32_t  RXCRC;                              
N  __I  uint32_t  DAI;                               /*!< Device address match index                                            */
X  volatile const  uint32_t  DAI;                                
N  __I  uint32_t  RESERVED7[60];
X  volatile const  uint32_t  RESERVED7[60];
N  __IO uint32_t  PACKETPTR;                         /*!< Packet pointer                                                        */
X  volatile uint32_t  PACKETPTR;                          
N  __IO uint32_t  FREQUENCY;                         /*!< Frequency                                                             */
X  volatile uint32_t  FREQUENCY;                          
N  __IO uint32_t  TXPOWER;                           /*!< Output power                                                          */
X  volatile uint32_t  TXPOWER;                            
N  __IO uint32_t  MODE;                              /*!< Data rate and modulation                                              */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  PCNF0;                             /*!< Packet configuration register 0                                       */
X  volatile uint32_t  PCNF0;                              
N  __IO uint32_t  PCNF1;                             /*!< Packet configuration register 1                                       */
X  volatile uint32_t  PCNF1;                              
N  __IO uint32_t  BASE0;                             /*!< Base address 0                                                        */
X  volatile uint32_t  BASE0;                              
N  __IO uint32_t  BASE1;                             /*!< Base address 1                                                        */
X  volatile uint32_t  BASE1;                              
N  __IO uint32_t  PREFIX0;                           /*!< Prefixes bytes for logical addresses 0-3                              */
X  volatile uint32_t  PREFIX0;                            
N  __IO uint32_t  PREFIX1;                           /*!< Prefixes bytes for logical addresses 4-7                              */
X  volatile uint32_t  PREFIX1;                            
N  __IO uint32_t  TXADDRESS;                         /*!< Transmit address select                                               */
X  volatile uint32_t  TXADDRESS;                          
N  __IO uint32_t  RXADDRESSES;                       /*!< Receive address select                                                */
X  volatile uint32_t  RXADDRESSES;                        
N  __IO uint32_t  CRCCNF;                            /*!< CRC configuration                                                     */
X  volatile uint32_t  CRCCNF;                             
N  __IO uint32_t  CRCPOLY;                           /*!< CRC polynomial                                                        */
X  volatile uint32_t  CRCPOLY;                            
N  __IO uint32_t  CRCINIT;                           /*!< CRC initial value                                                     */
X  volatile uint32_t  CRCINIT;                            
N  __IO uint32_t  UNUSED0;                           /*!< Unspecified                                                           */
X  volatile uint32_t  UNUSED0;                            
N  __IO uint32_t  TIFS;                              /*!< Inter Frame Spacing in us                                             */
X  volatile uint32_t  TIFS;                               
N  __I  uint32_t  RSSISAMPLE;                        /*!< RSSI sample                                                           */
X  volatile const  uint32_t  RSSISAMPLE;                         
N  __I  uint32_t  RESERVED8;
X  volatile const  uint32_t  RESERVED8;
N  __I  uint32_t  STATE;                             /*!< Current radio state                                                   */
X  volatile const  uint32_t  STATE;                              
N  __IO uint32_t  DATAWHITEIV;                       /*!< Data whitening initial value                                          */
X  volatile uint32_t  DATAWHITEIV;                        
N  __I  uint32_t  RESERVED9[2];
X  volatile const  uint32_t  RESERVED9[2];
N  __IO uint32_t  BCC;                               /*!< Bit counter compare                                                   */
X  volatile uint32_t  BCC;                                
N  __I  uint32_t  RESERVED10[39];
X  volatile const  uint32_t  RESERVED10[39];
N  __IO uint32_t  DAB[8];                            /*!< Description collection[0]: Device address base segment 0              */
X  volatile uint32_t  DAB[8];                             
N  __IO uint32_t  DAP[8];                            /*!< Description collection[0]: Device address prefix 0                    */
X  volatile uint32_t  DAP[8];                             
N  __IO uint32_t  DACNF;                             /*!< Device address match configuration                                    */
X  volatile uint32_t  DACNF;                              
N  __I  uint32_t  RESERVED11[3];
X  volatile const  uint32_t  RESERVED11[3];
N  __IO uint32_t  MODECNF0;                          /*!< Radio mode configuration register 0                                   */
X  volatile uint32_t  MODECNF0;                           
N  __I  uint32_t  RESERVED12[618];
X  volatile const  uint32_t  RESERVED12[618];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control                                              */
X  volatile uint32_t  POWER;                              
N} NRF_RADIO_Type;
N
N
N/* ================================================================================ */
N/* ================                      UARTE                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief UART with EasyDMA (UARTE)
N  */
N
Ntypedef struct {                                    /*!< UARTE Structure                                                       */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start UART receiver                                                   */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __O  uint32_t  TASKS_STOPRX;                      /*!< Stop UART receiver                                                    */
X  volatile  uint32_t  TASKS_STOPRX;                       
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start UART transmitter                                                */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __O  uint32_t  TASKS_STOPTX;                      /*!< Stop UART transmitter                                                 */
X  volatile  uint32_t  TASKS_STOPTX;                       
N  __I  uint32_t  RESERVED0[7];
X  volatile const  uint32_t  RESERVED0[7];
N  __O  uint32_t  TASKS_FLUSHRX;                     /*!< Flush RX FIFO into RX buffer                                          */
X  volatile  uint32_t  TASKS_FLUSHRX;                      
N  __I  uint32_t  RESERVED1[52];
X  volatile const  uint32_t  RESERVED1[52];
N  __IO uint32_t  EVENTS_CTS;                        /*!< CTS is activated (set low). Clear To Send.                            */
X  volatile uint32_t  EVENTS_CTS;                         
N  __IO uint32_t  EVENTS_NCTS;                       /*!< CTS is deactivated (set high). Not Clear To Send.                     */
X  volatile uint32_t  EVENTS_NCTS;                        
N  __IO uint32_t  EVENTS_RXDRDY;                     /*!< Data received in RXD (but potentially not yet transferred to
X  volatile uint32_t  EVENTS_RXDRDY;                     
N                                                         Data RAM)                                                             */
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __IO uint32_t  EVENTS_ENDRX;                      /*!< Receive buffer is filled up                                           */
X  volatile uint32_t  EVENTS_ENDRX;                       
N  __I  uint32_t  RESERVED3[2];
X  volatile const  uint32_t  RESERVED3[2];
N  __IO uint32_t  EVENTS_TXDRDY;                     /*!< Data sent from TXD                                                    */
X  volatile uint32_t  EVENTS_TXDRDY;                      
N  __IO uint32_t  EVENTS_ENDTX;                      /*!< Last TX byte transmitted                                              */
X  volatile uint32_t  EVENTS_ENDTX;                       
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error detected                                                        */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED4[7];
X  volatile const  uint32_t  RESERVED4[7];
N  __IO uint32_t  EVENTS_RXTO;                       /*!< Receiver timeout                                                      */
X  volatile uint32_t  EVENTS_RXTO;                        
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  EVENTS_RXSTARTED;                  /*!< UART receiver has started                                             */
X  volatile uint32_t  EVENTS_RXSTARTED;                   
N  __IO uint32_t  EVENTS_TXSTARTED;                  /*!< UART transmitter has started                                          */
X  volatile uint32_t  EVENTS_TXSTARTED;                   
N  __I  uint32_t  RESERVED6;
X  volatile const  uint32_t  RESERVED6;
N  __IO uint32_t  EVENTS_TXSTOPPED;                  /*!< Transmitter stopped                                                   */
X  volatile uint32_t  EVENTS_TXSTOPPED;                   
N  __I  uint32_t  RESERVED7[41];
X  volatile const  uint32_t  RESERVED7[41];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED8[63];
X  volatile const  uint32_t  RESERVED8[63];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED9[93];
X  volatile const  uint32_t  RESERVED9[93];
N  __IO uint32_t  ERRORSRC;                          /*!< Error source                                                          */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED10[31];
X  volatile const  uint32_t  RESERVED10[31];
N  __IO uint32_t  ENABLE;                            /*!< Enable UART                                                           */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  UARTE_PSEL_Type PSEL;                             /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED12[3];
X  volatile const  uint32_t  RESERVED12[3];
N  __IO uint32_t  BAUDRATE;                          /*!< Baud rate. Accuracy depends on the HFCLK source selected.             */
X  volatile uint32_t  BAUDRATE;                           
N  __I  uint32_t  RESERVED13[3];
X  volatile const  uint32_t  RESERVED13[3];
N  UARTE_RXD_Type RXD;                               /*!< RXD EasyDMA channel                                                   */
N  __I  uint32_t  RESERVED14;
X  volatile const  uint32_t  RESERVED14;
N  UARTE_TXD_Type TXD;                               /*!< TXD EasyDMA channel                                                   */
N  __I  uint32_t  RESERVED15[7];
X  volatile const  uint32_t  RESERVED15[7];
N  __IO uint32_t  CONFIG;                            /*!< Configuration of parity and hardware flow control                     */
X  volatile uint32_t  CONFIG;                             
N} NRF_UARTE_Type;
N
N
N/* ================================================================================ */
N/* ================                      UART                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Universal Asynchronous Receiver/Transmitter (UART)
N  */
N
Ntypedef struct {                                    /*!< UART Structure                                                        */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start UART receiver                                                   */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __O  uint32_t  TASKS_STOPRX;                      /*!< Stop UART receiver                                                    */
X  volatile  uint32_t  TASKS_STOPRX;                       
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start UART transmitter                                                */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __O  uint32_t  TASKS_STOPTX;                      /*!< Stop UART transmitter                                                 */
X  volatile  uint32_t  TASKS_STOPTX;                       
N  __I  uint32_t  RESERVED0[3];
X  volatile const  uint32_t  RESERVED0[3];
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend UART                                                          */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __I  uint32_t  RESERVED1[56];
X  volatile const  uint32_t  RESERVED1[56];
N  __IO uint32_t  EVENTS_CTS;                        /*!< CTS is activated (set low). Clear To Send.                            */
X  volatile uint32_t  EVENTS_CTS;                         
N  __IO uint32_t  EVENTS_NCTS;                       /*!< CTS is deactivated (set high). Not Clear To Send.                     */
X  volatile uint32_t  EVENTS_NCTS;                        
N  __IO uint32_t  EVENTS_RXDRDY;                     /*!< Data received in RXD                                                  */
X  volatile uint32_t  EVENTS_RXDRDY;                      
N  __I  uint32_t  RESERVED2[4];
X  volatile const  uint32_t  RESERVED2[4];
N  __IO uint32_t  EVENTS_TXDRDY;                     /*!< Data sent from TXD                                                    */
X  volatile uint32_t  EVENTS_TXDRDY;                      
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error detected                                                        */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED4[7];
X  volatile const  uint32_t  RESERVED4[7];
N  __IO uint32_t  EVENTS_RXTO;                       /*!< Receiver timeout                                                      */
X  volatile uint32_t  EVENTS_RXTO;                        
N  __I  uint32_t  RESERVED5[46];
X  volatile const  uint32_t  RESERVED5[46];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED6[64];
X  volatile const  uint32_t  RESERVED6[64];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED7[93];
X  volatile const  uint32_t  RESERVED7[93];
N  __IO uint32_t  ERRORSRC;                          /*!< Error source                                                          */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED8[31];
X  volatile const  uint32_t  RESERVED8[31];
N  __IO uint32_t  ENABLE;                            /*!< Enable UART                                                           */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED9;
X  volatile const  uint32_t  RESERVED9;
N  __IO uint32_t  PSELRTS;                           /*!< Pin select for RTS                                                    */
X  volatile uint32_t  PSELRTS;                            
N  __IO uint32_t  PSELTXD;                           /*!< Pin select for TXD                                                    */
X  volatile uint32_t  PSELTXD;                            
N  __IO uint32_t  PSELCTS;                           /*!< Pin select for CTS                                                    */
X  volatile uint32_t  PSELCTS;                            
N  __IO uint32_t  PSELRXD;                           /*!< Pin select for RXD                                                    */
X  volatile uint32_t  PSELRXD;                            
N  __I  uint32_t  RXD;                               /*!< RXD register                                                          */
X  volatile const  uint32_t  RXD;                                
N  __O  uint32_t  TXD;                               /*!< TXD register                                                          */
X  volatile  uint32_t  TXD;                                
N  __I  uint32_t  RESERVED10;
X  volatile const  uint32_t  RESERVED10;
N  __IO uint32_t  BAUDRATE;                          /*!< Baud rate                                                             */
X  volatile uint32_t  BAUDRATE;                           
N  __I  uint32_t  RESERVED11[17];
X  volatile const  uint32_t  RESERVED11[17];
N  __IO uint32_t  CONFIG;                            /*!< Configuration of parity and hardware flow control                     */
X  volatile uint32_t  CONFIG;                             
N} NRF_UART_Type;
N
N
N/* ================================================================================ */
N/* ================                      SPIM                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Serial Peripheral Interface Master with EasyDMA 0 (SPIM)
N  */
N
Ntypedef struct {                                    /*!< SPIM Structure                                                        */
N  __I  uint32_t  RESERVED0[4];
X  volatile const  uint32_t  RESERVED0[4];
N  __O  uint32_t  TASKS_START;                       /*!< Start SPI transaction                                                 */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop SPI transaction                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend SPI transaction                                               */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __O  uint32_t  TASKS_RESUME;                      /*!< Resume SPI transaction                                                */
X  volatile  uint32_t  TASKS_RESUME;                       
N  __I  uint32_t  RESERVED2[56];
X  volatile const  uint32_t  RESERVED2[56];
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< SPI transaction has stopped                                           */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __I  uint32_t  RESERVED3[2];
X  volatile const  uint32_t  RESERVED3[2];
N  __IO uint32_t  EVENTS_ENDRX;                      /*!< End of RXD buffer reached                                             */
X  volatile uint32_t  EVENTS_ENDRX;                       
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __IO uint32_t  EVENTS_END;                        /*!< End of RXD buffer and TXD buffer reached                              */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  EVENTS_ENDTX;                      /*!< End of TXD buffer reached                                             */
X  volatile uint32_t  EVENTS_ENDTX;                       
N  __I  uint32_t  RESERVED6[10];
X  volatile const  uint32_t  RESERVED6[10];
N  __IO uint32_t  EVENTS_STARTED;                    /*!< Transaction started                                                   */
X  volatile uint32_t  EVENTS_STARTED;                     
N  __I  uint32_t  RESERVED7[44];
X  volatile const  uint32_t  RESERVED7[44];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED8[64];
X  volatile const  uint32_t  RESERVED8[64];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED9[125];
X  volatile const  uint32_t  RESERVED9[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPIM                                                           */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED10;
X  volatile const  uint32_t  RESERVED10;
N  SPIM_PSEL_Type PSEL;                              /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED11[4];
X  volatile const  uint32_t  RESERVED11[4];
N  __IO uint32_t  FREQUENCY;                         /*!< SPI frequency                                                         */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED12[3];
X  volatile const  uint32_t  RESERVED12[3];
N  SPIM_RXD_Type RXD;                                /*!< RXD EasyDMA channel                                                   */
N  SPIM_TXD_Type TXD;                                /*!< TXD EasyDMA channel                                                   */
N  __IO uint32_t  CONFIG;                            /*!< Configuration register                                                */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED13[26];
X  volatile const  uint32_t  RESERVED13[26];
N  __IO uint32_t  ORC;                               /*!< Over-read character. Character clocked out in case and over-read
X  volatile uint32_t  ORC;                               
N                                                         of the TXD buffer.                                                    */
N} NRF_SPIM_Type;
N
N
N/* ================================================================================ */
N/* ================                      SPIS                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI Slave 0 (SPIS)
N  */
N
Ntypedef struct {                                    /*!< SPIS Structure                                                        */
N  __I  uint32_t  RESERVED0[9];
X  volatile const  uint32_t  RESERVED0[9];
N  __O  uint32_t  TASKS_ACQUIRE;                     /*!< Acquire SPI semaphore                                                 */
X  volatile  uint32_t  TASKS_ACQUIRE;                      
N  __O  uint32_t  TASKS_RELEASE;                     /*!< Release SPI semaphore, enabling the SPI slave to acquire it           */
X  volatile  uint32_t  TASKS_RELEASE;                      
N  __I  uint32_t  RESERVED1[54];
X  volatile const  uint32_t  RESERVED1[54];
N  __IO uint32_t  EVENTS_END;                        /*!< Granted transaction completed                                         */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED2[2];
X  volatile const  uint32_t  RESERVED2[2];
N  __IO uint32_t  EVENTS_ENDRX;                      /*!< End of RXD buffer reached                                             */
X  volatile uint32_t  EVENTS_ENDRX;                       
N  __I  uint32_t  RESERVED3[5];
X  volatile const  uint32_t  RESERVED3[5];
N  __IO uint32_t  EVENTS_ACQUIRED;                   /*!< Semaphore acquired                                                    */
X  volatile uint32_t  EVENTS_ACQUIRED;                    
N  __I  uint32_t  RESERVED4[53];
X  volatile const  uint32_t  RESERVED4[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED5[64];
X  volatile const  uint32_t  RESERVED5[64];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED6[61];
X  volatile const  uint32_t  RESERVED6[61];
N  __I  uint32_t  SEMSTAT;                           /*!< Semaphore status register                                             */
X  volatile const  uint32_t  SEMSTAT;                            
N  __I  uint32_t  RESERVED7[15];
X  volatile const  uint32_t  RESERVED7[15];
N  __IO uint32_t  STATUS;                            /*!< Status from last transaction                                          */
X  volatile uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED8[47];
X  volatile const  uint32_t  RESERVED8[47];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPI slave                                                      */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED9;
X  volatile const  uint32_t  RESERVED9;
N  SPIS_PSEL_Type PSEL;                              /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED10[7];
X  volatile const  uint32_t  RESERVED10[7];
N  SPIS_RXD_Type RXD;                                /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  SPIS_TXD_Type TXD;                                /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED12;
X  volatile const  uint32_t  RESERVED12;
N  __IO uint32_t  CONFIG;                            /*!< Configuration register                                                */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED13;
X  volatile const  uint32_t  RESERVED13;
N  __IO uint32_t  DEF;                               /*!< Default character. Character clocked out in case of an ignored
X  volatile uint32_t  DEF;                               
N                                                         transaction.                                                          */
N  __I  uint32_t  RESERVED14[24];
X  volatile const  uint32_t  RESERVED14[24];
N  __IO uint32_t  ORC;                               /*!< Over-read character                                                   */
X  volatile uint32_t  ORC;                                
N} NRF_SPIS_Type;
N
N
N/* ================================================================================ */
N/* ================                      TWIM                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief I2C compatible Two-Wire Master Interface with EasyDMA 0 (TWIM)
N  */
N
Ntypedef struct {                                    /*!< TWIM Structure                                                        */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start TWI receive sequence                                            */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start TWI transmit sequence                                           */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop TWI transaction. Must be issued while the TWI master is
X  volatile  uint32_t  TASKS_STOP;                        
N                                                         not suspended.                                                        */
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend TWI transaction                                               */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __O  uint32_t  TASKS_RESUME;                      /*!< Resume TWI transaction                                                */
X  volatile  uint32_t  TASKS_RESUME;                       
N  __I  uint32_t  RESERVED3[56];
X  volatile const  uint32_t  RESERVED3[56];
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< TWI stopped                                                           */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __I  uint32_t  RESERVED4[7];
X  volatile const  uint32_t  RESERVED4[7];
N  __IO uint32_t  EVENTS_ERROR;                      /*!< TWI error                                                             */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED5[8];
X  volatile const  uint32_t  RESERVED5[8];
N  __IO uint32_t  EVENTS_SUSPENDED;                  /*!< Last byte has been sent out after the SUSPEND task has been
X  volatile uint32_t  EVENTS_SUSPENDED;                  
N                                                         issued, TWI traffic is now suspended.                                 */
N  __IO uint32_t  EVENTS_RXSTARTED;                  /*!< Receive sequence started                                              */
X  volatile uint32_t  EVENTS_RXSTARTED;                   
N  __IO uint32_t  EVENTS_TXSTARTED;                  /*!< Transmit sequence started                                             */
X  volatile uint32_t  EVENTS_TXSTARTED;                   
N  __I  uint32_t  RESERVED6[2];
X  volatile const  uint32_t  RESERVED6[2];
N  __IO uint32_t  EVENTS_LASTRX;                     /*!< Byte boundary, starting to receive the last byte                      */
X  volatile uint32_t  EVENTS_LASTRX;                      
N  __IO uint32_t  EVENTS_LASTTX;                     /*!< Byte boundary, starting to transmit the last byte                     */
X  volatile uint32_t  EVENTS_LASTTX;                      
N  __I  uint32_t  RESERVED7[39];
X  volatile const  uint32_t  RESERVED7[39];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED8[63];
X  volatile const  uint32_t  RESERVED8[63];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED9[110];
X  volatile const  uint32_t  RESERVED9[110];
N  __IO uint32_t  ERRORSRC;                          /*!< Error source                                                          */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED10[14];
X  volatile const  uint32_t  RESERVED10[14];
N  __IO uint32_t  ENABLE;                            /*!< Enable TWIM                                                           */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  TWIM_PSEL_Type PSEL;                              /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED12[5];
X  volatile const  uint32_t  RESERVED12[5];
N  __IO uint32_t  FREQUENCY;                         /*!< TWI frequency                                                         */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED13[3];
X  volatile const  uint32_t  RESERVED13[3];
N  TWIM_RXD_Type RXD;                                /*!< RXD EasyDMA channel                                                   */
N  TWIM_TXD_Type TXD;                                /*!< TXD EasyDMA channel                                                   */
N  __I  uint32_t  RESERVED14[13];
X  volatile const  uint32_t  RESERVED14[13];
N  __IO uint32_t  ADDRESS;                           /*!< Address used in the TWI transfer                                      */
X  volatile uint32_t  ADDRESS;                            
N} NRF_TWIM_Type;
N
N
N/* ================================================================================ */
N/* ================                      TWIS                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief I2C compatible Two-Wire Slave Interface with EasyDMA 0 (TWIS)
N  */
N
Ntypedef struct {                                    /*!< TWIS Structure                                                        */
N  __I  uint32_t  RESERVED0[5];
X  volatile const  uint32_t  RESERVED0[5];
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop TWI transaction                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend TWI transaction                                               */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __O  uint32_t  TASKS_RESUME;                      /*!< Resume TWI transaction                                                */
X  volatile  uint32_t  TASKS_RESUME;                       
N  __I  uint32_t  RESERVED2[3];
X  volatile const  uint32_t  RESERVED2[3];
N  __O  uint32_t  TASKS_PREPARERX;                   /*!< Prepare the TWI slave to respond to a write command                   */
X  volatile  uint32_t  TASKS_PREPARERX;                    
N  __O  uint32_t  TASKS_PREPARETX;                   /*!< Prepare the TWI slave to respond to a read command                    */
X  volatile  uint32_t  TASKS_PREPARETX;                    
N  __I  uint32_t  RESERVED3[51];
X  volatile const  uint32_t  RESERVED3[51];
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< TWI stopped                                                           */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __I  uint32_t  RESERVED4[7];
X  volatile const  uint32_t  RESERVED4[7];
N  __IO uint32_t  EVENTS_ERROR;                      /*!< TWI error                                                             */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED5[9];
X  volatile const  uint32_t  RESERVED5[9];
N  __IO uint32_t  EVENTS_RXSTARTED;                  /*!< Receive sequence started                                              */
X  volatile uint32_t  EVENTS_RXSTARTED;                   
N  __IO uint32_t  EVENTS_TXSTARTED;                  /*!< Transmit sequence started                                             */
X  volatile uint32_t  EVENTS_TXSTARTED;                   
N  __I  uint32_t  RESERVED6[4];
X  volatile const  uint32_t  RESERVED6[4];
N  __IO uint32_t  EVENTS_WRITE;                      /*!< Write command received                                                */
X  volatile uint32_t  EVENTS_WRITE;                       
N  __IO uint32_t  EVENTS_READ;                       /*!< Read command received                                                 */
X  volatile uint32_t  EVENTS_READ;                        
N  __I  uint32_t  RESERVED7[37];
X  volatile const  uint32_t  RESERVED7[37];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED8[63];
X  volatile const  uint32_t  RESERVED8[63];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED9[113];
X  volatile const  uint32_t  RESERVED9[113];
N  __IO uint32_t  ERRORSRC;                          /*!< Error source                                                          */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  MATCH;                             /*!< Status register indicating which address had a match                  */
X  volatile const  uint32_t  MATCH;                              
N  __I  uint32_t  RESERVED10[10];
X  volatile const  uint32_t  RESERVED10[10];
N  __IO uint32_t  ENABLE;                            /*!< Enable TWIS                                                           */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  TWIS_PSEL_Type PSEL;                              /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED12[9];
X  volatile const  uint32_t  RESERVED12[9];
N  TWIS_RXD_Type RXD;                                /*!< RXD EasyDMA channel                                                   */
N  __I  uint32_t  RESERVED13;
X  volatile const  uint32_t  RESERVED13;
N  TWIS_TXD_Type TXD;                                /*!< TXD EasyDMA channel                                                   */
N  __I  uint32_t  RESERVED14[14];
X  volatile const  uint32_t  RESERVED14[14];
N  __IO uint32_t  ADDRESS[2];                        /*!< Description collection[0]: TWI slave address 0                        */
X  volatile uint32_t  ADDRESS[2];                         
N  __I  uint32_t  RESERVED15;
X  volatile const  uint32_t  RESERVED15;
N  __IO uint32_t  CONFIG;                            /*!< Configuration register for the address match mechanism                */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED16[10];
X  volatile const  uint32_t  RESERVED16[10];
N  __IO uint32_t  ORC;                               /*!< Over-read character. Character sent out in case of an over-read
X  volatile uint32_t  ORC;                               
N                                                         of the transmit buffer.                                               */
N} NRF_TWIS_Type;
N
N
N/* ================================================================================ */
N/* ================                       SPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Serial Peripheral Interface 0 (SPI)
N  */
N
Ntypedef struct {                                    /*!< SPI Structure                                                         */
N  __I  uint32_t  RESERVED0[66];
X  volatile const  uint32_t  RESERVED0[66];
N  __IO uint32_t  EVENTS_READY;                      /*!< TXD byte sent and RXD byte received                                   */
X  volatile uint32_t  EVENTS_READY;                       
N  __I  uint32_t  RESERVED1[126];
X  volatile const  uint32_t  RESERVED1[126];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[125];
X  volatile const  uint32_t  RESERVED2[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPI                                                            */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  SPI_PSEL_Type PSEL;                               /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __I  uint32_t  RXD;                               /*!< RXD register                                                          */
X  volatile const  uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TXD register                                                          */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  FREQUENCY;                         /*!< SPI frequency                                                         */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register                                                */
X  volatile uint32_t  CONFIG;                             
N} NRF_SPI_Type;
N
N
N/* ================================================================================ */
N/* ================                       TWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief I2C compatible Two-Wire Interface 0 (TWI)
N  */
N
Ntypedef struct {                                    /*!< TWI Structure                                                         */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start TWI receive sequence                                            */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start TWI transmit sequence                                           */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop TWI transaction                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend TWI transaction                                               */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __O  uint32_t  TASKS_RESUME;                      /*!< Resume TWI transaction                                                */
X  volatile  uint32_t  TASKS_RESUME;                       
N  __I  uint32_t  RESERVED3[56];
X  volatile const  uint32_t  RESERVED3[56];
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< TWI stopped                                                           */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __IO uint32_t  EVENTS_RXDREADY;                   /*!< TWI RXD byte received                                                 */
X  volatile uint32_t  EVENTS_RXDREADY;                    
N  __I  uint32_t  RESERVED4[4];
X  volatile const  uint32_t  RESERVED4[4];
N  __IO uint32_t  EVENTS_TXDSENT;                    /*!< TWI TXD byte sent                                                     */
X  volatile uint32_t  EVENTS_TXDSENT;                     
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< TWI error                                                             */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED6[4];
X  volatile const  uint32_t  RESERVED6[4];
N  __IO uint32_t  EVENTS_BB;                         /*!< TWI byte boundary, generated before each byte that is sent or
X  volatile uint32_t  EVENTS_BB;                         
N                                                         received                                                              */
N  __I  uint32_t  RESERVED7[3];
X  volatile const  uint32_t  RESERVED7[3];
N  __IO uint32_t  EVENTS_SUSPENDED;                  /*!< TWI entered the suspended state                                       */
X  volatile uint32_t  EVENTS_SUSPENDED;                   
N  __I  uint32_t  RESERVED8[45];
X  volatile const  uint32_t  RESERVED8[45];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED9[64];
X  volatile const  uint32_t  RESERVED9[64];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED10[110];
X  volatile const  uint32_t  RESERVED10[110];
N  __IO uint32_t  ERRORSRC;                          /*!< Error source                                                          */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED11[14];
X  volatile const  uint32_t  RESERVED11[14];
N  __IO uint32_t  ENABLE;                            /*!< Enable TWI                                                            */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED12;
X  volatile const  uint32_t  RESERVED12;
N  __IO uint32_t  PSELSCL;                           /*!< Pin select for SCL                                                    */
X  volatile uint32_t  PSELSCL;                            
N  __IO uint32_t  PSELSDA;                           /*!< Pin select for SDA                                                    */
X  volatile uint32_t  PSELSDA;                            
N  __I  uint32_t  RESERVED13[2];
X  volatile const  uint32_t  RESERVED13[2];
N  __I  uint32_t  RXD;                               /*!< RXD register                                                          */
X  volatile const  uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TXD register                                                          */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED14;
X  volatile const  uint32_t  RESERVED14;
N  __IO uint32_t  FREQUENCY;                         /*!< TWI frequency                                                         */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED15[24];
X  volatile const  uint32_t  RESERVED15[24];
N  __IO uint32_t  ADDRESS;                           /*!< Address used in the TWI transfer                                      */
X  volatile uint32_t  ADDRESS;                            
N} NRF_TWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      NFCT                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief NFC-A compatible radio (NFCT)
N  */
N
Ntypedef struct {                                    /*!< NFCT Structure                                                        */
N  __O  uint32_t  TASKS_ACTIVATE;                    /*!< Activate NFC peripheral for incoming and outgoing frames, change
X  volatile  uint32_t  TASKS_ACTIVATE;                    
N                                                         state to activated                                                    */
N  __O  uint32_t  TASKS_DISABLE;                     /*!< Disable NFC peripheral                                                */
X  volatile  uint32_t  TASKS_DISABLE;                      
N  __O  uint32_t  TASKS_SENSE;                       /*!< Enable NFC sense field mode, change state to sense mode               */
X  volatile  uint32_t  TASKS_SENSE;                        
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start transmission of a outgoing frame, change state to transmit      */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __I  uint32_t  RESERVED0[3];
X  volatile const  uint32_t  RESERVED0[3];
N  __O  uint32_t  TASKS_ENABLERXDATA;                /*!< Initializes the EasyDMA for receive.                                  */
X  volatile  uint32_t  TASKS_ENABLERXDATA;                 
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  __O  uint32_t  TASKS_GOIDLE;                      /*!< Force state machine to IDLE state                                     */
X  volatile  uint32_t  TASKS_GOIDLE;                       
N  __O  uint32_t  TASKS_GOSLEEP;                     /*!< Force state machine to SLEEP_A state                                  */
X  volatile  uint32_t  TASKS_GOSLEEP;                      
N  __I  uint32_t  RESERVED2[53];
X  volatile const  uint32_t  RESERVED2[53];
N  __IO uint32_t  EVENTS_READY;                      /*!< The NFC peripheral is ready to receive and send frames                */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_FIELDDETECTED;              /*!< Remote NFC field detected                                             */
X  volatile uint32_t  EVENTS_FIELDDETECTED;               
N  __IO uint32_t  EVENTS_FIELDLOST;                  /*!< Remote NFC field lost                                                 */
X  volatile uint32_t  EVENTS_FIELDLOST;                   
N  __IO uint32_t  EVENTS_TXFRAMESTART;               /*!< Marks the start of the first symbol of a transmitted frame            */
X  volatile uint32_t  EVENTS_TXFRAMESTART;                
N  __IO uint32_t  EVENTS_TXFRAMEEND;                 /*!< Marks the end of the last transmitted on-air symbol of a frame        */
X  volatile uint32_t  EVENTS_TXFRAMEEND;                  
N  __IO uint32_t  EVENTS_RXFRAMESTART;               /*!< Marks the end of the first symbol of a received frame                 */
X  volatile uint32_t  EVENTS_RXFRAMESTART;                
N  __IO uint32_t  EVENTS_RXFRAMEEND;                 /*!< Received data have been checked (CRC, parity) and transferred
X  volatile uint32_t  EVENTS_RXFRAMEEND;                 
N                                                         to RAM, and EasyDMA has ended accessing the RX buffer                 */
N  __IO uint32_t  EVENTS_ERROR;                      /*!< NFC error reported. The ERRORSTATUS register contains details
X  volatile uint32_t  EVENTS_ERROR;                      
N                                                         on the source of the error.                                           */
N  __I  uint32_t  RESERVED3[2];
X  volatile const  uint32_t  RESERVED3[2];
N  __IO uint32_t  EVENTS_RXERROR;                    /*!< NFC RX frame error reported. The FRAMESTATUS.RX register contains
X  volatile uint32_t  EVENTS_RXERROR;                    
N                                                         details on the source of the error.                                   */
N  __IO uint32_t  EVENTS_ENDRX;                      /*!< RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.      */
X  volatile uint32_t  EVENTS_ENDRX;                       
N  __IO uint32_t  EVENTS_ENDTX;                      /*!< Transmission of data in RAM has ended, and EasyDMA has ended
X  volatile uint32_t  EVENTS_ENDTX;                      
N                                                         accessing the TX buffer                                               */
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __IO uint32_t  EVENTS_AUTOCOLRESSTARTED;          /*!< Auto collision resolution process has started                         */
X  volatile uint32_t  EVENTS_AUTOCOLRESSTARTED;           
N  __I  uint32_t  RESERVED5[3];
X  volatile const  uint32_t  RESERVED5[3];
N  __IO uint32_t  EVENTS_COLLISION;                  /*!< NFC Auto collision resolution error reported.                         */
X  volatile uint32_t  EVENTS_COLLISION;                   
N  __IO uint32_t  EVENTS_SELECTED;                   /*!< NFC Auto collision resolution successfully completed                  */
X  volatile uint32_t  EVENTS_SELECTED;                    
N  __IO uint32_t  EVENTS_STARTED;                    /*!< EasyDMA is ready to receive or send frames.                           */
X  volatile uint32_t  EVENTS_STARTED;                     
N  __I  uint32_t  RESERVED6[43];
X  volatile const  uint32_t  RESERVED6[43];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED7[63];
X  volatile const  uint32_t  RESERVED7[63];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED8[62];
X  volatile const  uint32_t  RESERVED8[62];
N  __IO uint32_t  ERRORSTATUS;                       /*!< NFC Error Status register                                             */
X  volatile uint32_t  ERRORSTATUS;                        
N  __I  uint32_t  RESERVED9;
X  volatile const  uint32_t  RESERVED9;
N  NFCT_FRAMESTATUS_Type FRAMESTATUS;                /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED10[8];
X  volatile const  uint32_t  RESERVED10[8];
N  __I  uint32_t  CURRENTLOADCTRL;                   /*!< Current value driven to the NFC Load Control                          */
X  volatile const  uint32_t  CURRENTLOADCTRL;                    
N  __I  uint32_t  RESERVED11[2];
X  volatile const  uint32_t  RESERVED11[2];
N  __I  uint32_t  FIELDPRESENT;                      /*!< Indicates the presence or not of a valid field                        */
X  volatile const  uint32_t  FIELDPRESENT;                       
N  __I  uint32_t  RESERVED12[49];
X  volatile const  uint32_t  RESERVED12[49];
N  __IO uint32_t  FRAMEDELAYMIN;                     /*!< Minimum frame delay                                                   */
X  volatile uint32_t  FRAMEDELAYMIN;                      
N  __IO uint32_t  FRAMEDELAYMAX;                     /*!< Maximum frame delay                                                   */
X  volatile uint32_t  FRAMEDELAYMAX;                      
N  __IO uint32_t  FRAMEDELAYMODE;                    /*!< Configuration register for the Frame Delay Timer                      */
X  volatile uint32_t  FRAMEDELAYMODE;                     
N  __IO uint32_t  PACKETPTR;                         /*!< Packet pointer for TXD and RXD data storage in Data RAM               */
X  volatile uint32_t  PACKETPTR;                          
N  __IO uint32_t  MAXLEN;                            /*!< Size of allocated for TXD and RXD data storage buffer in Data
X  volatile uint32_t  MAXLEN;                            
N                                                         RAM                                                                   */
N  NFCT_TXD_Type TXD;                                /*!< Unspecified                                                           */
N  NFCT_RXD_Type RXD;                                /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED13[26];
X  volatile const  uint32_t  RESERVED13[26];
N  __IO uint32_t  NFCID1_LAST;                       /*!< Last NFCID1 part (4, 7 or 10 bytes ID)                                */
X  volatile uint32_t  NFCID1_LAST;                        
N  __IO uint32_t  NFCID1_2ND_LAST;                   /*!< Second last NFCID1 part (7 or 10 bytes ID)                            */
X  volatile uint32_t  NFCID1_2ND_LAST;                    
N  __IO uint32_t  NFCID1_3RD_LAST;                   /*!< Third last NFCID1 part (10 bytes ID)                                  */
X  volatile uint32_t  NFCID1_3RD_LAST;                    
N  __I  uint32_t  RESERVED14;
X  volatile const  uint32_t  RESERVED14;
N  __IO uint32_t  SENSRES;                           /*!< NFC-A SENS_RES auto-response settings                                 */
X  volatile uint32_t  SENSRES;                            
N  __IO uint32_t  SELRES;                            /*!< NFC-A SEL_RES auto-response settings                                  */
X  volatile uint32_t  SELRES;                             
N} NRF_NFCT_Type;
N
N
N/* ================================================================================ */
N/* ================                     GPIOTE                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief GPIO Tasks and Events (GPIOTE)
N  */
N
Ntypedef struct {                                    /*!< GPIOTE Structure                                                      */
N  __O  uint32_t  TASKS_OUT[8];                      /*!< Description collection[0]: Task for writing to pin specified
X  volatile  uint32_t  TASKS_OUT[8];                      
N                                                         in CONFIG[0].PSEL. Action on pin is configured in CONFIG[0].POLARITY. */
N  __I  uint32_t  RESERVED0[4];
X  volatile const  uint32_t  RESERVED0[4];
N  __O  uint32_t  TASKS_SET[8];                      /*!< Description collection[0]: Task for writing to pin specified
X  volatile  uint32_t  TASKS_SET[8];                      
N                                                         in CONFIG[0].PSEL. Action on pin is to set it high.                   */
N  __I  uint32_t  RESERVED1[4];
X  volatile const  uint32_t  RESERVED1[4];
N  __O  uint32_t  TASKS_CLR[8];                      /*!< Description collection[0]: Task for writing to pin specified
X  volatile  uint32_t  TASKS_CLR[8];                      
N                                                         in CONFIG[0].PSEL. Action on pin is to set it low.                    */
N  __I  uint32_t  RESERVED2[32];
X  volatile const  uint32_t  RESERVED2[32];
N  __IO uint32_t  EVENTS_IN[8];                      /*!< Description collection[0]: Event generated from pin specified
X  volatile uint32_t  EVENTS_IN[8];                      
N                                                         in CONFIG[0].PSEL                                                     */
N  __I  uint32_t  RESERVED3[23];
X  volatile const  uint32_t  RESERVED3[23];
N  __IO uint32_t  EVENTS_PORT;                       /*!< Event generated from multiple input GPIO pins with SENSE mechanism
X  volatile uint32_t  EVENTS_PORT;                       
N                                                         enabled                                                               */
N  __I  uint32_t  RESERVED4[97];
X  volatile const  uint32_t  RESERVED4[97];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED5[129];
X  volatile const  uint32_t  RESERVED5[129];
N  __IO uint32_t  CONFIG[8];                         /*!< Description collection[0]: Configuration for OUT[n], SET[n]
X  volatile uint32_t  CONFIG[8];                         
N                                                         and CLR[n] tasks and IN[n] event                                      */
N} NRF_GPIOTE_Type;
N
N
N/* ================================================================================ */
N/* ================                      SAADC                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Analog to Digital Converter (SAADC)
N  */
N
Ntypedef struct {                                    /*!< SAADC Structure                                                       */
N  __O  uint32_t  TASKS_START;                       /*!< Start the ADC and prepare the result buffer in RAM                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Take one ADC sample, if scan is enabled all channels are sampled      */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the ADC and terminate any on-going conversion                    */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_CALIBRATEOFFSET;             /*!< Starts offset auto-calibration                                        */
X  volatile  uint32_t  TASKS_CALIBRATEOFFSET;              
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_STARTED;                    /*!< The ADC has started                                                   */
X  volatile uint32_t  EVENTS_STARTED;                     
N  __IO uint32_t  EVENTS_END;                        /*!< The ADC has filled up the Result buffer                               */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_DONE;                       /*!< A conversion task has been completed. Depending on the mode,
X  volatile uint32_t  EVENTS_DONE;                       
N                                                         multiple conversions might be needed for a result to be transferred
N                                                          to RAM.                                                              */
N  __IO uint32_t  EVENTS_RESULTDONE;                 /*!< A result is ready to get transferred to RAM.                          */
X  volatile uint32_t  EVENTS_RESULTDONE;                  
N  __IO uint32_t  EVENTS_CALIBRATEDONE;              /*!< Calibration is complete                                               */
X  volatile uint32_t  EVENTS_CALIBRATEDONE;               
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< The ADC has stopped                                                   */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  SAADC_EVENTS_CH_Type EVENTS_CH[8];                /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED1[106];
X  volatile const  uint32_t  RESERVED1[106];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  STATUS;                            /*!< Status                                                                */
X  volatile const  uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable or disable ADC                                                 */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED4[3];
X  volatile const  uint32_t  RESERVED4[3];
N  SAADC_CH_Type CH[8];                              /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED5[24];
X  volatile const  uint32_t  RESERVED5[24];
N  __IO uint32_t  RESOLUTION;                        /*!< Resolution configuration                                              */
X  volatile uint32_t  RESOLUTION;                         
N  __IO uint32_t  OVERSAMPLE;                        /*!< Oversampling configuration. OVERSAMPLE should not be combined
X  volatile uint32_t  OVERSAMPLE;                        
N                                                         with SCAN. The RESOLUTION is applied before averaging, thus
N                                                          for high OVERSAMPLE a higher RESOLUTION should be used.              */
N  __IO uint32_t  SAMPLERATE;                        /*!< Controls normal or continuous sample rate                             */
X  volatile uint32_t  SAMPLERATE;                         
N  __I  uint32_t  RESERVED6[12];
X  volatile const  uint32_t  RESERVED6[12];
N  SAADC_RESULT_Type RESULT;                         /*!< RESULT EasyDMA channel                                                */
N} NRF_SAADC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TIMER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Timer/Counter 0 (TIMER)
N  */
N
Ntypedef struct {                                    /*!< TIMER Structure                                                       */
N  __O  uint32_t  TASKS_START;                       /*!< Start Timer                                                           */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop Timer                                                            */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_COUNT;                       /*!< Increment Timer (Counter mode only)                                   */
X  volatile  uint32_t  TASKS_COUNT;                        
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear time                                                            */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __O  uint32_t  TASKS_SHUTDOWN;                    /*!< Deprecated register - Shut down timer                                 */
X  volatile  uint32_t  TASKS_SHUTDOWN;                     
N  __I  uint32_t  RESERVED0[11];
X  volatile const  uint32_t  RESERVED0[11];
N  __O  uint32_t  TASKS_CAPTURE[6];                  /*!< Description collection[0]: Capture Timer value to CC[0] register      */
X  volatile  uint32_t  TASKS_CAPTURE[6];                   
N  __I  uint32_t  RESERVED1[58];
X  volatile const  uint32_t  RESERVED1[58];
N  __IO uint32_t  EVENTS_COMPARE[6];                 /*!< Description collection[0]: Compare event on CC[0] match               */
X  volatile uint32_t  EVENTS_COMPARE[6];                  
N  __I  uint32_t  RESERVED2[42];
X  volatile const  uint32_t  RESERVED2[42];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[126];
X  volatile const  uint32_t  RESERVED4[126];
N  __IO uint32_t  MODE;                              /*!< Timer mode selection                                                  */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  BITMODE;                           /*!< Configure the number of bits used by the TIMER                        */
X  volatile uint32_t  BITMODE;                            
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  PRESCALER;                         /*!< Timer prescaler register                                              */
X  volatile uint32_t  PRESCALER;                          
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CC[6];                             /*!< Description collection[0]: Capture/Compare register 0                 */
X  volatile uint32_t  CC[6];                              
N} NRF_TIMER_Type;
N
N
N/* ================================================================================ */
N/* ================                       RTC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Real time counter 0 (RTC)
N  */
N
Ntypedef struct {                                    /*!< RTC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start RTC COUNTER                                                     */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop RTC COUNTER                                                      */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear RTC COUNTER                                                     */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __O  uint32_t  TASKS_TRIGOVRFLW;                  /*!< Set COUNTER to 0xFFFFF0                                               */
X  volatile  uint32_t  TASKS_TRIGOVRFLW;                   
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_TICK;                       /*!< Event on COUNTER increment                                            */
X  volatile uint32_t  EVENTS_TICK;                        
N  __IO uint32_t  EVENTS_OVRFLW;                     /*!< Event on COUNTER overflow                                             */
X  volatile uint32_t  EVENTS_OVRFLW;                      
N  __I  uint32_t  RESERVED1[14];
X  volatile const  uint32_t  RESERVED1[14];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Description collection[0]: Compare event on CC[0] match               */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[109];
X  volatile const  uint32_t  RESERVED2[109];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[13];
X  volatile const  uint32_t  RESERVED3[13];
N  __IO uint32_t  EVTEN;                             /*!< Enable or disable event routing                                       */
X  volatile uint32_t  EVTEN;                              
N  __IO uint32_t  EVTENSET;                          /*!< Enable event routing                                                  */
X  volatile uint32_t  EVTENSET;                           
N  __IO uint32_t  EVTENCLR;                          /*!< Disable event routing                                                 */
X  volatile uint32_t  EVTENCLR;                           
N  __I  uint32_t  RESERVED4[110];
X  volatile const  uint32_t  RESERVED4[110];
N  __I  uint32_t  COUNTER;                           /*!< Current COUNTER value                                                 */
X  volatile const  uint32_t  COUNTER;                            
N  __IO uint32_t  PRESCALER;                         /*!< 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must
X  volatile uint32_t  PRESCALER;                         
N                                                         be written when RTC is stopped                                        */
N  __I  uint32_t  RESERVED5[13];
X  volatile const  uint32_t  RESERVED5[13];
N  __IO uint32_t  CC[4];                             /*!< Description collection[0]: Compare register 0                         */
X  volatile uint32_t  CC[4];                              
N} NRF_RTC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TEMP                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Temperature Sensor (TEMP)
N  */
N
Ntypedef struct {                                    /*!< TEMP Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start temperature measurement                                         */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop temperature measurement                                          */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_DATARDY;                    /*!< Temperature measurement complete, data ready                          */
X  volatile uint32_t  EVENTS_DATARDY;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[127];
X  volatile const  uint32_t  RESERVED2[127];
N  __I  int32_t   TEMP;                              /*!< Temperature in degC (0.25deg steps)                                   */
X  volatile const  int32_t   TEMP;                               
N  __I  uint32_t  RESERVED3[5];
X  volatile const  uint32_t  RESERVED3[5];
N  __IO uint32_t  A0;                                /*!< Slope of 1st piece wise linear function                               */
X  volatile uint32_t  A0;                                 
N  __IO uint32_t  A1;                                /*!< Slope of 2nd piece wise linear function                               */
X  volatile uint32_t  A1;                                 
N  __IO uint32_t  A2;                                /*!< Slope of 3rd piece wise linear function                               */
X  volatile uint32_t  A2;                                 
N  __IO uint32_t  A3;                                /*!< Slope of 4th piece wise linear function                               */
X  volatile uint32_t  A3;                                 
N  __IO uint32_t  A4;                                /*!< Slope of 5th piece wise linear function                               */
X  volatile uint32_t  A4;                                 
N  __IO uint32_t  A5;                                /*!< Slope of 6th piece wise linear function                               */
X  volatile uint32_t  A5;                                 
N  __I  uint32_t  RESERVED4[2];
X  volatile const  uint32_t  RESERVED4[2];
N  __IO uint32_t  B0;                                /*!< y-intercept of 1st piece wise linear function                         */
X  volatile uint32_t  B0;                                 
N  __IO uint32_t  B1;                                /*!< y-intercept of 2nd piece wise linear function                         */
X  volatile uint32_t  B1;                                 
N  __IO uint32_t  B2;                                /*!< y-intercept of 3rd piece wise linear function                         */
X  volatile uint32_t  B2;                                 
N  __IO uint32_t  B3;                                /*!< y-intercept of 4th piece wise linear function                         */
X  volatile uint32_t  B3;                                 
N  __IO uint32_t  B4;                                /*!< y-intercept of 5th piece wise linear function                         */
X  volatile uint32_t  B4;                                 
N  __IO uint32_t  B5;                                /*!< y-intercept of 6th piece wise linear function                         */
X  volatile uint32_t  B5;                                 
N  __I  uint32_t  RESERVED5[2];
X  volatile const  uint32_t  RESERVED5[2];
N  __IO uint32_t  T0;                                /*!< End point of 1st piece wise linear function                           */
X  volatile uint32_t  T0;                                 
N  __IO uint32_t  T1;                                /*!< End point of 2nd piece wise linear function                           */
X  volatile uint32_t  T1;                                 
N  __IO uint32_t  T2;                                /*!< End point of 3rd piece wise linear function                           */
X  volatile uint32_t  T2;                                 
N  __IO uint32_t  T3;                                /*!< End point of 4th piece wise linear function                           */
X  volatile uint32_t  T3;                                 
N  __IO uint32_t  T4;                                /*!< End point of 5th piece wise linear function                           */
X  volatile uint32_t  T4;                                 
N} NRF_TEMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       RNG                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Random Number Generator (RNG)
N  */
N
Ntypedef struct {                                    /*!< RNG Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Task starting the random number generator                             */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Task stopping the random number generator                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_VALRDY;                     /*!< Event being generated for every new random number written to
X  volatile uint32_t  EVENTS_VALRDY;                     
N                                                         the VALUE register                                                    */
N  __I  uint32_t  RESERVED1[63];
X  volatile const  uint32_t  RESERVED1[63];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[126];
X  volatile const  uint32_t  RESERVED3[126];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register                                                */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  VALUE;                             /*!< Output random number                                                  */
X  volatile const  uint32_t  VALUE;                              
N} NRF_RNG_Type;
N
N
N/* ================================================================================ */
N/* ================                       ECB                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES ECB Mode Encryption (ECB)
N  */
N
Ntypedef struct {                                    /*!< ECB Structure                                                         */
N  __O  uint32_t  TASKS_STARTECB;                    /*!< Start ECB block encrypt                                               */
X  volatile  uint32_t  TASKS_STARTECB;                     
N  __O  uint32_t  TASKS_STOPECB;                     /*!< Abort a possible executing ECB operation                              */
X  volatile  uint32_t  TASKS_STOPECB;                      
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_ENDECB;                     /*!< ECB block encrypt complete                                            */
X  volatile uint32_t  EVENTS_ENDECB;                      
N  __IO uint32_t  EVENTS_ERRORECB;                   /*!< ECB block encrypt aborted because of a STOPECB task or due to
X  volatile uint32_t  EVENTS_ERRORECB;                   
N                                                         an error                                                              */
N  __I  uint32_t  RESERVED1[127];
X  volatile const  uint32_t  RESERVED1[127];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  ECBDATAPTR;                        /*!< ECB block encrypt memory pointers                                     */
X  volatile uint32_t  ECBDATAPTR;                         
N} NRF_ECB_Type;
N
N
N/* ================================================================================ */
N/* ================                       CCM                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES CCM Mode Encryption (CCM)
N  */
N
Ntypedef struct {                                    /*!< CCM Structure                                                         */
N  __O  uint32_t  TASKS_KSGEN;                       /*!< Start generation of key-stream. This operation will stop by
X  volatile  uint32_t  TASKS_KSGEN;                       
N                                                         itself when completed.                                                */
N  __O  uint32_t  TASKS_CRYPT;                       /*!< Start encryption/decryption. This operation will stop by itself
X  volatile  uint32_t  TASKS_CRYPT;                       
N                                                         when completed.                                                       */
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop encryption/decryption                                            */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_ENDKSGEN;                   /*!< Key-stream generation complete                                        */
X  volatile uint32_t  EVENTS_ENDKSGEN;                    
N  __IO uint32_t  EVENTS_ENDCRYPT;                   /*!< Encrypt/decrypt complete                                              */
X  volatile uint32_t  EVENTS_ENDCRYPT;                    
N  __IO uint32_t  EVENTS_ERROR;                      /*!< CCM error event                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  MICSTATUS;                         /*!< MIC check result                                                      */
X  volatile const  uint32_t  MICSTATUS;                          
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable                                                                */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  MODE;                              /*!< Operation mode                                                        */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  CNFPTR;                            /*!< Pointer to data structure holding AES key and NONCE vector            */
X  volatile uint32_t  CNFPTR;                             
N  __IO uint32_t  INPTR;                             /*!< Input pointer                                                         */
X  volatile uint32_t  INPTR;                              
N  __IO uint32_t  OUTPTR;                            /*!< Output pointer                                                        */
X  volatile uint32_t  OUTPTR;                             
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to data area used for temporary storage                       */
X  volatile uint32_t  SCRATCHPTR;                         
N} NRF_CCM_Type;
N
N
N/* ================================================================================ */
N/* ================                       AAR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Accelerated Address Resolver (AAR)
N  */
N
Ntypedef struct {                                    /*!< AAR Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start resolving addresses based on IRKs specified in the IRK
X  volatile  uint32_t  TASKS_START;                       
N                                                         data structure                                                        */
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop resolving addresses                                              */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  EVENTS_END;                        /*!< Address resolution procedure complete                                 */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_RESOLVED;                   /*!< Address resolved                                                      */
X  volatile uint32_t  EVENTS_RESOLVED;                    
N  __IO uint32_t  EVENTS_NOTRESOLVED;                /*!< Address not resolved                                                  */
X  volatile uint32_t  EVENTS_NOTRESOLVED;                 
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  STATUS;                            /*!< Resolution status                                                     */
X  volatile const  uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable AAR                                                            */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  NIRK;                              /*!< Number of IRKs                                                        */
X  volatile uint32_t  NIRK;                               
N  __IO uint32_t  IRKPTR;                            /*!< Pointer to IRK data structure                                         */
X  volatile uint32_t  IRKPTR;                             
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  ADDRPTR;                           /*!< Pointer to the resolvable address                                     */
X  volatile uint32_t  ADDRPTR;                            
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to data area used for temporary storage                       */
X  volatile uint32_t  SCRATCHPTR;                         
N} NRF_AAR_Type;
N
N
N/* ================================================================================ */
N/* ================                       WDT                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Watchdog Timer (WDT)
N  */
N
Ntypedef struct {                                    /*!< WDT Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the watchdog                                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __I  uint32_t  RESERVED0[63];
X  volatile const  uint32_t  RESERVED0[63];
N  __IO uint32_t  EVENTS_TIMEOUT;                    /*!< Watchdog timeout                                                      */
X  volatile uint32_t  EVENTS_TIMEOUT;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  RUNSTATUS;                         /*!< Run status                                                            */
X  volatile const  uint32_t  RUNSTATUS;                          
N  __I  uint32_t  REQSTATUS;                         /*!< Request status                                                        */
X  volatile const  uint32_t  REQSTATUS;                          
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  CRV;                               /*!< Counter reload value                                                  */
X  volatile uint32_t  CRV;                                
N  __IO uint32_t  RREN;                              /*!< Enable register for reload request registers                          */
X  volatile uint32_t  RREN;                               
N  __IO uint32_t  CONFIG;                            /*!< Configuration register                                                */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED4[60];
X  volatile const  uint32_t  RESERVED4[60];
N  __O  uint32_t  RR[8];                             /*!< Description collection[0]: Reload request 0                           */
X  volatile  uint32_t  RR[8];                              
N} NRF_WDT_Type;
N
N
N/* ================================================================================ */
N/* ================                      QDEC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Quadrature Decoder (QDEC)
N  */
N
Ntypedef struct {                                    /*!< QDEC Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Task starting the quadrature decoder                                  */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Task stopping the quadrature decoder                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_READCLRACC;                  /*!< Read and clear ACC and ACCDBL                                         */
X  volatile  uint32_t  TASKS_READCLRACC;                   
N  __O  uint32_t  TASKS_RDCLRACC;                    /*!< Read and clear ACC                                                    */
X  volatile  uint32_t  TASKS_RDCLRACC;                     
N  __O  uint32_t  TASKS_RDCLRDBL;                    /*!< Read and clear ACCDBL                                                 */
X  volatile  uint32_t  TASKS_RDCLRDBL;                     
N  __I  uint32_t  RESERVED0[59];
X  volatile const  uint32_t  RESERVED0[59];
N  __IO uint32_t  EVENTS_SAMPLERDY;                  /*!< Event being generated for every new sample value written to
X  volatile uint32_t  EVENTS_SAMPLERDY;                  
N                                                         the SAMPLE register                                                   */
N  __IO uint32_t  EVENTS_REPORTRDY;                  /*!< Non-null report ready                                                 */
X  volatile uint32_t  EVENTS_REPORTRDY;                   
N  __IO uint32_t  EVENTS_ACCOF;                      /*!< ACC or ACCDBL register overflow                                       */
X  volatile uint32_t  EVENTS_ACCOF;                       
N  __IO uint32_t  EVENTS_DBLRDY;                     /*!< Double displacement(s) detected                                       */
X  volatile uint32_t  EVENTS_DBLRDY;                      
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< QDEC has been stopped                                                 */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __I  uint32_t  RESERVED1[59];
X  volatile const  uint32_t  RESERVED1[59];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[125];
X  volatile const  uint32_t  RESERVED3[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable the quadrature decoder                                         */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  LEDPOL;                            /*!< LED output pin polarity                                               */
X  volatile uint32_t  LEDPOL;                             
N  __IO uint32_t  SAMPLEPER;                         /*!< Sample period                                                         */
X  volatile uint32_t  SAMPLEPER;                          
N  __I  int32_t   SAMPLE;                            /*!< Motion sample value                                                   */
X  volatile const  int32_t   SAMPLE;                             
N  __IO uint32_t  REPORTPER;                         /*!< Number of samples to be taken before REPORTRDY and DBLRDY events
X  volatile uint32_t  REPORTPER;                         
N                                                         can be generated                                                      */
N  __I  int32_t   ACC;                               /*!< Register accumulating the valid transitions                           */
X  volatile const  int32_t   ACC;                                
N  __I  int32_t   ACCREAD;                           /*!< Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC
X  volatile const  int32_t   ACCREAD;                           
N                                                         task                                                                  */
N  QDEC_PSEL_Type PSEL;                              /*!< Unspecified                                                           */
N  __IO uint32_t  DBFEN;                             /*!< Enable input debounce filters                                         */
X  volatile uint32_t  DBFEN;                              
N  __I  uint32_t  RESERVED4[5];
X  volatile const  uint32_t  RESERVED4[5];
N  __IO uint32_t  LEDPRE;                            /*!< Time period the LED is switched ON prior to sampling                  */
X  volatile uint32_t  LEDPRE;                             
N  __I  uint32_t  ACCDBL;                            /*!< Register accumulating the number of detected double transitions       */
X  volatile const  uint32_t  ACCDBL;                             
N  __I  uint32_t  ACCDBLREAD;                        /*!< Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL
X  volatile const  uint32_t  ACCDBLREAD;                        
N                                                         task                                                                  */
N} NRF_QDEC_Type;
N
N
N/* ================================================================================ */
N/* ================                      COMP                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Comparator (COMP)
N  */
N
Ntypedef struct {                                    /*!< COMP Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start comparator                                                      */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop comparator                                                       */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Sample comparator value                                               */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_READY;                      /*!< COMP is ready and output is valid                                     */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_DOWN;                       /*!< Downward crossing                                                     */
X  volatile uint32_t  EVENTS_DOWN;                        
N  __IO uint32_t  EVENTS_UP;                         /*!< Upward crossing                                                       */
X  volatile uint32_t  EVENTS_UP;                          
N  __IO uint32_t  EVENTS_CROSS;                      /*!< Downward or upward crossing                                           */
X  volatile uint32_t  EVENTS_CROSS;                       
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[63];
X  volatile const  uint32_t  RESERVED2[63];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  RESULT;                            /*!< Compare result                                                        */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< COMP enable                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PSEL;                              /*!< Pin select                                                            */
X  volatile uint32_t  PSEL;                               
N  __IO uint32_t  REFSEL;                            /*!< Reference source select                                               */
X  volatile uint32_t  REFSEL;                             
N  __IO uint32_t  EXTREFSEL;                         /*!< External reference select                                             */
X  volatile uint32_t  EXTREFSEL;                          
N  __I  uint32_t  RESERVED5[8];
X  volatile const  uint32_t  RESERVED5[8];
N  __IO uint32_t  TH;                                /*!< Threshold configuration for hysteresis unit                           */
X  volatile uint32_t  TH;                                 
N  __IO uint32_t  MODE;                              /*!< Mode configuration                                                    */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  HYST;                              /*!< Comparator hysteresis enable                                          */
X  volatile uint32_t  HYST;                               
N  __IO uint32_t  ISOURCE;                           /*!< Current source select on analog input                                 */
X  volatile uint32_t  ISOURCE;                            
N} NRF_COMP_Type;
N
N
N/* ================================================================================ */
N/* ================                     LPCOMP                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Low Power Comparator (LPCOMP)
N  */
N
Ntypedef struct {                                    /*!< LPCOMP Structure                                                      */
N  __O  uint32_t  TASKS_START;                       /*!< Start comparator                                                      */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop comparator                                                       */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Sample comparator value                                               */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_READY;                      /*!< LPCOMP is ready and output is valid                                   */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_DOWN;                       /*!< Downward crossing                                                     */
X  volatile uint32_t  EVENTS_DOWN;                        
N  __IO uint32_t  EVENTS_UP;                         /*!< Upward crossing                                                       */
X  volatile uint32_t  EVENTS_UP;                          
N  __IO uint32_t  EVENTS_CROSS;                      /*!< Downward or upward crossing                                           */
X  volatile uint32_t  EVENTS_CROSS;                       
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  RESULT;                            /*!< Compare result                                                        */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable LPCOMP                                                         */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PSEL;                              /*!< Input pin select                                                      */
X  volatile uint32_t  PSEL;                               
N  __IO uint32_t  REFSEL;                            /*!< Reference select                                                      */
X  volatile uint32_t  REFSEL;                             
N  __IO uint32_t  EXTREFSEL;                         /*!< External reference select                                             */
X  volatile uint32_t  EXTREFSEL;                          
N  __I  uint32_t  RESERVED5[4];
X  volatile const  uint32_t  RESERVED5[4];
N  __IO uint32_t  ANADETECT;                         /*!< Analog detect configuration                                           */
X  volatile uint32_t  ANADETECT;                          
N  __I  uint32_t  RESERVED6[5];
X  volatile const  uint32_t  RESERVED6[5];
N  __IO uint32_t  HYST;                              /*!< Comparator hysteresis enable                                          */
X  volatile uint32_t  HYST;                               
N} NRF_LPCOMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       SWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Software interrupt 0 (SWI)
N  */
N
Ntypedef struct {                                    /*!< SWI Structure                                                         */
N  __I  uint32_t  UNUSED;                            /*!< Unused.                                                               */
X  volatile const  uint32_t  UNUSED;                             
N} NRF_SWI_Type;
N
N
N/* ================================================================================ */
N/* ================                       EGU                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Event Generator Unit 0 (EGU)
N  */
N
Ntypedef struct {                                    /*!< EGU Structure                                                         */
N  __O  uint32_t  TASKS_TRIGGER[16];                 /*!< Description collection[0]: Trigger 0 for triggering the corresponding
X  volatile  uint32_t  TASKS_TRIGGER[16];                 
N                                                         TRIGGERED[0] event                                                    */
N  __I  uint32_t  RESERVED0[48];
X  volatile const  uint32_t  RESERVED0[48];
N  __IO uint32_t  EVENTS_TRIGGERED[16];              /*!< Description collection[0]: Event number 0 generated by triggering
X  volatile uint32_t  EVENTS_TRIGGERED[16];              
N                                                         the corresponding TRIGGER[0] task                                     */
N  __I  uint32_t  RESERVED1[112];
X  volatile const  uint32_t  RESERVED1[112];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N} NRF_EGU_Type;
N
N
N/* ================================================================================ */
N/* ================                       PWM                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Pulse Width Modulation Unit 0 (PWM)
N  */
N
Ntypedef struct {                                    /*!< PWM Structure                                                         */
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STOP;                        /*!< Stops PWM pulse generation on all channels at the end of current
X  volatile  uint32_t  TASKS_STOP;                        
N                                                         PWM period, and stops sequence playback                               */
N  __O  uint32_t  TASKS_SEQSTART[2];                 /*!< Description collection[0]: Loads the first PWM value on all
X  volatile  uint32_t  TASKS_SEQSTART[2];                 
N                                                         enabled channels from sequence 0, and starts playing that sequence
N                                                          at the rate defined in SEQ[0]REFRESH and/or DECODER.MODE. Causes
N                                                          PWM generation to start it was not running.                          */
N  __O  uint32_t  TASKS_NEXTSTEP;                    /*!< Steps by one value in the current sequence on all enabled channels
X  volatile  uint32_t  TASKS_NEXTSTEP;                    
N                                                         if DECODER.MODE=NextStep. Does not cause PWM generation to start
N                                                          it was not running.                                                  */
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< Response to STOP task, emitted when PWM pulses are no longer
X  volatile uint32_t  EVENTS_STOPPED;                    
N                                                         generated                                                             */
N  __IO uint32_t  EVENTS_SEQSTARTED[2];              /*!< Description collection[0]: First PWM period started on sequence
X  volatile uint32_t  EVENTS_SEQSTARTED[2];              
N                                                         0                                                                     */
N  __IO uint32_t  EVENTS_SEQEND[2];                  /*!< Description collection[0]: Emitted at end of every sequence
X  volatile uint32_t  EVENTS_SEQEND[2];                  
N                                                         0, when last value from RAM has been applied to wave counter          */
N  __IO uint32_t  EVENTS_PWMPERIODEND;               /*!< Emitted at the end of each PWM period                                 */
X  volatile uint32_t  EVENTS_PWMPERIODEND;                
N  __IO uint32_t  EVENTS_LOOPSDONE;                  /*!< Concatenated sequences have been played the amount of times
X  volatile uint32_t  EVENTS_LOOPSDONE;                  
N                                                         defined in LOOP.CNT                                                   */
N  __I  uint32_t  RESERVED2[56];
X  volatile const  uint32_t  RESERVED2[56];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut register                                                     */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[125];
X  volatile const  uint32_t  RESERVED4[125];
N  __IO uint32_t  ENABLE;                            /*!< PWM module enable register                                            */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  MODE;                              /*!< Selects operating mode of the wave counter                            */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  COUNTERTOP;                        /*!< Value up to which the pulse generator counter counts                  */
X  volatile uint32_t  COUNTERTOP;                         
N  __IO uint32_t  PRESCALER;                         /*!< Configuration for PWM_CLK                                             */
X  volatile uint32_t  PRESCALER;                          
N  __IO uint32_t  DECODER;                           /*!< Configuration of the decoder                                          */
X  volatile uint32_t  DECODER;                            
N  __IO uint32_t  LOOP;                              /*!< Amount of playback of a loop                                          */
X  volatile uint32_t  LOOP;                               
N  __I  uint32_t  RESERVED5[2];
X  volatile const  uint32_t  RESERVED5[2];
N  PWM_SEQ_Type SEQ[2];                              /*!< Unspecified                                                           */
N  PWM_PSEL_Type PSEL;                               /*!< Unspecified                                                           */
N} NRF_PWM_Type;
N
N
N/* ================================================================================ */
N/* ================                       PDM                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Pulse Density Modulation (Digital Microphone) Interface (PDM)
N  */
N
Ntypedef struct {                                    /*!< PDM Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Starts continuous PDM transfer                                        */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stops PDM transfer                                                    */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_STARTED;                    /*!< PDM transfer has started                                              */
X  volatile uint32_t  EVENTS_STARTED;                     
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< PDM transfer has finished                                             */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __IO uint32_t  EVENTS_END;                        /*!< The PDM has written the last sample specified by SAMPLE.MAXCNT
X  volatile uint32_t  EVENTS_END;                        
N                                                         (or the last sample after a STOP task has been received) to
N                                                          Data RAM                                                             */
N  __I  uint32_t  RESERVED1[125];
X  volatile const  uint32_t  RESERVED1[125];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[125];
X  volatile const  uint32_t  RESERVED2[125];
N  __IO uint32_t  ENABLE;                            /*!< PDM module enable register                                            */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PDMCLKCTRL;                        /*!< PDM clock generator control                                           */
X  volatile uint32_t  PDMCLKCTRL;                         
N  __IO uint32_t  MODE;                              /*!< Defines the routing of the connected PDM microphones' signals         */
X  volatile uint32_t  MODE;                               
N  __I  uint32_t  RESERVED3[3];
X  volatile const  uint32_t  RESERVED3[3];
N  __IO uint32_t  GAINL;                             /*!< Left output gain adjustment                                           */
X  volatile uint32_t  GAINL;                              
N  __IO uint32_t  GAINR;                             /*!< Right output gain adjustment                                          */
X  volatile uint32_t  GAINR;                              
N  __I  uint32_t  RESERVED4[8];
X  volatile const  uint32_t  RESERVED4[8];
N  PDM_PSEL_Type PSEL;                               /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED5[6];
X  volatile const  uint32_t  RESERVED5[6];
N  PDM_SAMPLE_Type SAMPLE;                           /*!< Unspecified                                                           */
N} NRF_PDM_Type;
N
N
N/* ================================================================================ */
N/* ================                      NVMC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Non Volatile Memory Controller (NVMC)
N  */
N
Ntypedef struct {                                    /*!< NVMC Structure                                                        */
N  __I  uint32_t  RESERVED0[256];
X  volatile const  uint32_t  RESERVED0[256];
N  __I  uint32_t  READY;                             /*!< Ready flag                                                            */
X  volatile const  uint32_t  READY;                              
N  __I  uint32_t  RESERVED1[64];
X  volatile const  uint32_t  RESERVED1[64];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register                                                */
X  volatile uint32_t  CONFIG;                             
N  
N  union {
N    __IO uint32_t  ERASEPCR1;                       /*!< Deprecated register - Register for erasing a page in Code area.
X    volatile uint32_t  ERASEPCR1;                       
N                                                         Equivalent to ERASEPAGE.                                              */
N    __IO uint32_t  ERASEPAGE;                       /*!< Register for erasing a page in Code area                              */
X    volatile uint32_t  ERASEPAGE;                        
N  };
N  __IO uint32_t  ERASEALL;                          /*!< Register for erasing all non-volatile user memory                     */
X  volatile uint32_t  ERASEALL;                           
N  __IO uint32_t  ERASEPCR0;                         /*!< Deprecated register - Register for erasing a page in Code area.
X  volatile uint32_t  ERASEPCR0;                         
N                                                         Equivalent to ERASEPAGE.                                              */
N  __IO uint32_t  ERASEUICR;                         /*!< Register for erasing User Information Configuration Registers         */
X  volatile uint32_t  ERASEUICR;                          
N  __I  uint32_t  RESERVED2[10];
X  volatile const  uint32_t  RESERVED2[10];
N  __IO uint32_t  ICACHECNF;                         /*!< I-Code cache configuration register.                                  */
X  volatile uint32_t  ICACHECNF;                          
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  IHIT;                              /*!< I-Code cache hit counter.                                             */
X  volatile uint32_t  IHIT;                               
N  __IO uint32_t  IMISS;                             /*!< I-Code cache miss counter.                                            */
X  volatile uint32_t  IMISS;                              
N} NRF_NVMC_Type;
N
N
N/* ================================================================================ */
N/* ================                       PPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Programmable Peripheral Interconnect (PPI)
N  */
N
Ntypedef struct {                                    /*!< PPI Structure                                                         */
N  PPI_TASKS_CHG_Type TASKS_CHG[6];                  /*!< Channel group tasks                                                   */
N  __I  uint32_t  RESERVED0[308];
X  volatile const  uint32_t  RESERVED0[308];
N  __IO uint32_t  CHEN;                              /*!< Channel enable register                                               */
X  volatile uint32_t  CHEN;                               
N  __IO uint32_t  CHENSET;                           /*!< Channel enable set register                                           */
X  volatile uint32_t  CHENSET;                            
N  __IO uint32_t  CHENCLR;                           /*!< Channel enable clear register                                         */
X  volatile uint32_t  CHENCLR;                            
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  PPI_CH_Type CH[20];                               /*!< PPI Channel                                                           */
N  __I  uint32_t  RESERVED2[148];
X  volatile const  uint32_t  RESERVED2[148];
N  __IO uint32_t  CHG[6];                            /*!< Description collection[0]: Channel group 0                            */
X  volatile uint32_t  CHG[6];                             
N  __I  uint32_t  RESERVED3[62];
X  volatile const  uint32_t  RESERVED3[62];
N  PPI_FORK_Type FORK[32];                           /*!< Fork                                                                  */
N} NRF_PPI_Type;
N
N
N/* ================================================================================ */
N/* ================                       MWU                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Memory Watch Unit (MWU)
N  */
N
Ntypedef struct {                                    /*!< MWU Structure                                                         */
N  __I  uint32_t  RESERVED0[64];
X  volatile const  uint32_t  RESERVED0[64];
N  MWU_EVENTS_REGION_Type EVENTS_REGION[4];          /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED1[16];
X  volatile const  uint32_t  RESERVED1[16];
N  MWU_EVENTS_PREGION_Type EVENTS_PREGION[2];        /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED2[100];
X  volatile const  uint32_t  RESERVED2[100];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[5];
X  volatile const  uint32_t  RESERVED3[5];
N  __IO uint32_t  NMIEN;                             /*!< Enable or disable non-maskable interrupt                              */
X  volatile uint32_t  NMIEN;                              
N  __IO uint32_t  NMIENSET;                          /*!< Enable non-maskable interrupt                                         */
X  volatile uint32_t  NMIENSET;                           
N  __IO uint32_t  NMIENCLR;                          /*!< Disable non-maskable interrupt                                        */
X  volatile uint32_t  NMIENCLR;                           
N  __I  uint32_t  RESERVED4[53];
X  volatile const  uint32_t  RESERVED4[53];
N  MWU_PERREGION_Type PERREGION[2];                  /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED5[64];
X  volatile const  uint32_t  RESERVED5[64];
N  __IO uint32_t  REGIONEN;                          /*!< Enable/disable regions watch                                          */
X  volatile uint32_t  REGIONEN;                           
N  __IO uint32_t  REGIONENSET;                       /*!< Enable regions watch                                                  */
X  volatile uint32_t  REGIONENSET;                        
N  __IO uint32_t  REGIONENCLR;                       /*!< Disable regions watch                                                 */
X  volatile uint32_t  REGIONENCLR;                        
N  __I  uint32_t  RESERVED6[57];
X  volatile const  uint32_t  RESERVED6[57];
N  MWU_REGION_Type REGION[4];                        /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED7[32];
X  volatile const  uint32_t  RESERVED7[32];
N  MWU_PREGION_Type PREGION[2];                      /*!< Unspecified                                                           */
N} NRF_MWU_Type;
N
N
N/* ================================================================================ */
N/* ================                       I2S                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Inter-IC Sound (I2S)
N  */
N
Ntypedef struct {                                    /*!< I2S Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Starts continuous I2S transfer. Also starts MCK generator when
X  volatile  uint32_t  TASKS_START;                       
N                                                         this is enabled.                                                      */
N  __O  uint32_t  TASKS_STOP;                        /*!< Stops I2S transfer. Also stops MCK generator. Triggering this
X  volatile  uint32_t  TASKS_STOP;                        
N                                                         task will cause the {event:STOPPED} event to be generated.            */
N  __I  uint32_t  RESERVED0[63];
X  volatile const  uint32_t  RESERVED0[63];
N  __IO uint32_t  EVENTS_RXPTRUPD;                   /*!< The RXD.PTR register has been copied to internal double-buffers.
X  volatile uint32_t  EVENTS_RXPTRUPD;                   
N                                                         When the I2S module is started and RX is enabled, this event
N                                                          will be generated for every RXTXD.MAXCNT words that are received
N                                                          on the SDIN pin.                                                     */
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< I2S transfer stopped.                                                 */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __IO uint32_t  EVENTS_TXPTRUPD;                   /*!< The TDX.PTR register has been copied to internal double-buffers.
X  volatile uint32_t  EVENTS_TXPTRUPD;                   
N                                                         When the I2S module is started and TX is enabled, this event
N                                                          will be generated for every RXTXD.MAXCNT words that are sent
N                                                          on the SDOUT pin.                                                    */
N  __I  uint32_t  RESERVED2[122];
X  volatile const  uint32_t  RESERVED2[122];
N  __IO uint32_t  INTEN;                             /*!< Enable or disable interrupt                                           */
X  volatile uint32_t  INTEN;                              
N  __IO uint32_t  INTENSET;                          /*!< Enable interrupt                                                      */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Disable interrupt                                                     */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[125];
X  volatile const  uint32_t  RESERVED3[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable I2S module.                                                    */
X  volatile uint32_t  ENABLE;                             
N  I2S_CONFIG_Type CONFIG;                           /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED4[3];
X  volatile const  uint32_t  RESERVED4[3];
N  I2S_RXD_Type RXD;                                 /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  I2S_TXD_Type TXD;                                 /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED6[3];
X  volatile const  uint32_t  RESERVED6[3];
N  I2S_RXTXD_Type RXTXD;                             /*!< Unspecified                                                           */
N  __I  uint32_t  RESERVED7[3];
X  volatile const  uint32_t  RESERVED7[3];
N  I2S_PSEL_Type PSEL;                               /*!< Unspecified                                                           */
N} NRF_I2S_Type;
N
N
N/* ================================================================================ */
N/* ================                       FPU                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief FPU (FPU)
N  */
N
Ntypedef struct {                                    /*!< FPU Structure                                                         */
N  __I  uint32_t  UNUSED;                            /*!< Unused.                                                               */
X  volatile const  uint32_t  UNUSED;                             
N} NRF_FPU_Type;
N
N
N/* ================================================================================ */
N/* ================                      GPIO                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief GPIO Port 1 (GPIO)
N  */
N
Ntypedef struct {                                    /*!< GPIO Structure                                                        */
N  __I  uint32_t  RESERVED0[321];
X  volatile const  uint32_t  RESERVED0[321];
N  __IO uint32_t  OUT;                               /*!< Write GPIO port                                                       */
X  volatile uint32_t  OUT;                                
N  __IO uint32_t  OUTSET;                            /*!< Set individual bits in GPIO port                                      */
X  volatile uint32_t  OUTSET;                             
N  __IO uint32_t  OUTCLR;                            /*!< Clear individual bits in GPIO port                                    */
X  volatile uint32_t  OUTCLR;                             
N  __I  uint32_t  IN;                                /*!< Read GPIO port                                                        */
X  volatile const  uint32_t  IN;                                 
N  __IO uint32_t  DIR;                               /*!< Direction of GPIO pins                                                */
X  volatile uint32_t  DIR;                                
N  __IO uint32_t  DIRSET;                            /*!< DIR set register                                                      */
X  volatile uint32_t  DIRSET;                             
N  __IO uint32_t  DIRCLR;                            /*!< DIR clear register                                                    */
X  volatile uint32_t  DIRCLR;                             
N  __IO uint32_t  LATCH;                             /*!< Latch register indicating what GPIO pins that have met the criteria
X  volatile uint32_t  LATCH;                             
N                                                         set in the PIN_CNF[n].SENSE registers                                 */
N  __IO uint32_t  DETECTMODE;                        /*!< Select between default DETECT signal behaviour and LDETECT mode       */
X  volatile uint32_t  DETECTMODE;                         
N  __I  uint32_t  RESERVED1[118];
X  volatile const  uint32_t  RESERVED1[118];
N  __IO uint32_t  PIN_CNF[32];                       /*!< Description collection[0]: Configuration of GPIO pins                 */
X  volatile uint32_t  PIN_CNF[32];                        
N} NRF_GPIO_Type;
N
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined(__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N
N
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N
N#define NRF_FICR_BASE                   0x10000000UL
N#define NRF_UICR_BASE                   0x10001000UL
N#define NRF_BPROT_BASE                  0x40000000UL
N#define NRF_POWER_BASE                  0x40000000UL
N#define NRF_CLOCK_BASE                  0x40000000UL
N#define NRF_RADIO_BASE                  0x40001000UL
N#define NRF_UARTE0_BASE                 0x40002000UL
N#define NRF_UART0_BASE                  0x40002000UL
N#define NRF_SPIM0_BASE                  0x40003000UL
N#define NRF_SPIS0_BASE                  0x40003000UL
N#define NRF_TWIM0_BASE                  0x40003000UL
N#define NRF_TWIS0_BASE                  0x40003000UL
N#define NRF_SPI0_BASE                   0x40003000UL
N#define NRF_TWI0_BASE                   0x40003000UL
N#define NRF_SPIM1_BASE                  0x40004000UL
N#define NRF_SPIS1_BASE                  0x40004000UL
N#define NRF_TWIM1_BASE                  0x40004000UL
N#define NRF_TWIS1_BASE                  0x40004000UL
N#define NRF_SPI1_BASE                   0x40004000UL
N#define NRF_TWI1_BASE                   0x40004000UL
N#define NRF_NFCT_BASE                   0x40005000UL
N#define NRF_GPIOTE_BASE                 0x40006000UL
N#define NRF_SAADC_BASE                  0x40007000UL
N#define NRF_TIMER0_BASE                 0x40008000UL
N#define NRF_TIMER1_BASE                 0x40009000UL
N#define NRF_TIMER2_BASE                 0x4000A000UL
N#define NRF_RTC0_BASE                   0x4000B000UL
N#define NRF_TEMP_BASE                   0x4000C000UL
N#define NRF_RNG_BASE                    0x4000D000UL
N#define NRF_ECB_BASE                    0x4000E000UL
N#define NRF_CCM_BASE                    0x4000F000UL
N#define NRF_AAR_BASE                    0x4000F000UL
N#define NRF_WDT_BASE                    0x40010000UL
N#define NRF_RTC1_BASE                   0x40011000UL
N#define NRF_QDEC_BASE                   0x40012000UL
N#define NRF_COMP_BASE                   0x40013000UL
N#define NRF_LPCOMP_BASE                 0x40013000UL
N#define NRF_SWI0_BASE                   0x40014000UL
N#define NRF_EGU0_BASE                   0x40014000UL
N#define NRF_SWI1_BASE                   0x40015000UL
N#define NRF_EGU1_BASE                   0x40015000UL
N#define NRF_SWI2_BASE                   0x40016000UL
N#define NRF_EGU2_BASE                   0x40016000UL
N#define NRF_SWI3_BASE                   0x40017000UL
N#define NRF_EGU3_BASE                   0x40017000UL
N#define NRF_SWI4_BASE                   0x40018000UL
N#define NRF_EGU4_BASE                   0x40018000UL
N#define NRF_SWI5_BASE                   0x40019000UL
N#define NRF_EGU5_BASE                   0x40019000UL
N#define NRF_TIMER3_BASE                 0x4001A000UL
N#define NRF_TIMER4_BASE                 0x4001B000UL
N#define NRF_PWM0_BASE                   0x4001C000UL
N#define NRF_PDM_BASE                    0x4001D000UL
N#define NRF_NVMC_BASE                   0x4001E000UL
N#define NRF_PPI_BASE                    0x4001F000UL
N#define NRF_MWU_BASE                    0x40020000UL
N#define NRF_PWM1_BASE                   0x40021000UL
N#define NRF_PWM2_BASE                   0x40022000UL
N#define NRF_SPIM2_BASE                  0x40023000UL
N#define NRF_SPIS2_BASE                  0x40023000UL
N#define NRF_SPI2_BASE                   0x40023000UL
N#define NRF_RTC2_BASE                   0x40024000UL
N#define NRF_I2S_BASE                    0x40025000UL
N#define NRF_FPU_BASE                    0x40026000UL
N#define NRF_P0_BASE                     0x50000000UL
N
N
N/* ================================================================================ */
N/* ================             Peripheral declaration             ================ */
N/* ================================================================================ */
N
N#define NRF_FICR                        ((NRF_FICR_Type           *) NRF_FICR_BASE)
N#define NRF_UICR                        ((NRF_UICR_Type           *) NRF_UICR_BASE)
N#define NRF_BPROT                       ((NRF_BPROT_Type          *) NRF_BPROT_BASE)
N#define NRF_POWER                       ((NRF_POWER_Type          *) NRF_POWER_BASE)
N#define NRF_CLOCK                       ((NRF_CLOCK_Type          *) NRF_CLOCK_BASE)
N#define NRF_RADIO                       ((NRF_RADIO_Type          *) NRF_RADIO_BASE)
N#define NRF_UARTE0                      ((NRF_UARTE_Type          *) NRF_UARTE0_BASE)
N#define NRF_UART0                       ((NRF_UART_Type           *) NRF_UART0_BASE)
N#define NRF_SPIM0                       ((NRF_SPIM_Type           *) NRF_SPIM0_BASE)
N#define NRF_SPIS0                       ((NRF_SPIS_Type           *) NRF_SPIS0_BASE)
N#define NRF_TWIM0                       ((NRF_TWIM_Type           *) NRF_TWIM0_BASE)
N#define NRF_TWIS0                       ((NRF_TWIS_Type           *) NRF_TWIS0_BASE)
N#define NRF_SPI0                        ((NRF_SPI_Type            *) NRF_SPI0_BASE)
N#define NRF_TWI0                        ((NRF_TWI_Type            *) NRF_TWI0_BASE)
N#define NRF_SPIM1                       ((NRF_SPIM_Type           *) NRF_SPIM1_BASE)
N#define NRF_SPIS1                       ((NRF_SPIS_Type           *) NRF_SPIS1_BASE)
N#define NRF_TWIM1                       ((NRF_TWIM_Type           *) NRF_TWIM1_BASE)
N#define NRF_TWIS1                       ((NRF_TWIS_Type           *) NRF_TWIS1_BASE)
N#define NRF_SPI1                        ((NRF_SPI_Type            *) NRF_SPI1_BASE)
N#define NRF_TWI1                        ((NRF_TWI_Type            *) NRF_TWI1_BASE)
N#define NRF_NFCT                        ((NRF_NFCT_Type           *) NRF_NFCT_BASE)
N#define NRF_GPIOTE                      ((NRF_GPIOTE_Type         *) NRF_GPIOTE_BASE)
N#define NRF_SAADC                       ((NRF_SAADC_Type          *) NRF_SAADC_BASE)
N#define NRF_TIMER0                      ((NRF_TIMER_Type          *) NRF_TIMER0_BASE)
N#define NRF_TIMER1                      ((NRF_TIMER_Type          *) NRF_TIMER1_BASE)
N#define NRF_TIMER2                      ((NRF_TIMER_Type          *) NRF_TIMER2_BASE)
N#define NRF_RTC0                        ((NRF_RTC_Type            *) NRF_RTC0_BASE)
N#define NRF_TEMP                        ((NRF_TEMP_Type           *) NRF_TEMP_BASE)
N#define NRF_RNG                         ((NRF_RNG_Type            *) NRF_RNG_BASE)
N#define NRF_ECB                         ((NRF_ECB_Type            *) NRF_ECB_BASE)
N#define NRF_CCM                         ((NRF_CCM_Type            *) NRF_CCM_BASE)
N#define NRF_AAR                         ((NRF_AAR_Type            *) NRF_AAR_BASE)
N#define NRF_WDT                         ((NRF_WDT_Type            *) NRF_WDT_BASE)
N#define NRF_RTC1                        ((NRF_RTC_Type            *) NRF_RTC1_BASE)
N#define NRF_QDEC                        ((NRF_QDEC_Type           *) NRF_QDEC_BASE)
N#define NRF_COMP                        ((NRF_COMP_Type           *) NRF_COMP_BASE)
N#define NRF_LPCOMP                      ((NRF_LPCOMP_Type         *) NRF_LPCOMP_BASE)
N#define NRF_SWI0                        ((NRF_SWI_Type            *) NRF_SWI0_BASE)
N#define NRF_EGU0                        ((NRF_EGU_Type            *) NRF_EGU0_BASE)
N#define NRF_SWI1                        ((NRF_SWI_Type            *) NRF_SWI1_BASE)
N#define NRF_EGU1                        ((NRF_EGU_Type            *) NRF_EGU1_BASE)
N#define NRF_SWI2                        ((NRF_SWI_Type            *) NRF_SWI2_BASE)
N#define NRF_EGU2                        ((NRF_EGU_Type            *) NRF_EGU2_BASE)
N#define NRF_SWI3                        ((NRF_SWI_Type            *) NRF_SWI3_BASE)
N#define NRF_EGU3                        ((NRF_EGU_Type            *) NRF_EGU3_BASE)
N#define NRF_SWI4                        ((NRF_SWI_Type            *) NRF_SWI4_BASE)
N#define NRF_EGU4                        ((NRF_EGU_Type            *) NRF_EGU4_BASE)
N#define NRF_SWI5                        ((NRF_SWI_Type            *) NRF_SWI5_BASE)
N#define NRF_EGU5                        ((NRF_EGU_Type            *) NRF_EGU5_BASE)
N#define NRF_TIMER3                      ((NRF_TIMER_Type          *) NRF_TIMER3_BASE)
N#define NRF_TIMER4                      ((NRF_TIMER_Type          *) NRF_TIMER4_BASE)
N#define NRF_PWM0                        ((NRF_PWM_Type            *) NRF_PWM0_BASE)
N#define NRF_PDM                         ((NRF_PDM_Type            *) NRF_PDM_BASE)
N#define NRF_NVMC                        ((NRF_NVMC_Type           *) NRF_NVMC_BASE)
N#define NRF_PPI                         ((NRF_PPI_Type            *) NRF_PPI_BASE)
N#define NRF_MWU                         ((NRF_MWU_Type            *) NRF_MWU_BASE)
N#define NRF_PWM1                        ((NRF_PWM_Type            *) NRF_PWM1_BASE)
N#define NRF_PWM2                        ((NRF_PWM_Type            *) NRF_PWM2_BASE)
N#define NRF_SPIM2                       ((NRF_SPIM_Type           *) NRF_SPIM2_BASE)
N#define NRF_SPIS2                       ((NRF_SPIS_Type           *) NRF_SPIS2_BASE)
N#define NRF_SPI2                        ((NRF_SPI_Type            *) NRF_SPI2_BASE)
N#define NRF_RTC2                        ((NRF_RTC_Type            *) NRF_RTC2_BASE)
N#define NRF_I2S                         ((NRF_I2S_Type            *) NRF_I2S_BASE)
N#define NRF_FPU                         ((NRF_FPU_Type            *) NRF_FPU_BASE)
N#define NRF_P0                          ((NRF_GPIO_Type           *) NRF_P0_BASE)
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group nrf52 */
N/** @} */ /* End of group Nordic Semiconductor */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* nrf52_H */
N
L 54 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf.h" 2
N        #include "nrf52_bitfields.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf52_bitfields.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef __NRF52_BITS_H
N#define __NRF52_BITS_H
N
N/*lint ++flb "Enter library region" */
N
N/* Peripheral: AAR */
N/* Description: Accelerated Address Resolver */
N
N/* Register: AAR_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 2 : Write '1' to Enable interrupt for NOTRESOLVED event */
N#define AAR_INTENSET_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
N#define AAR_INTENSET_NOTRESOLVED_Msk (0x1UL << AAR_INTENSET_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
N#define AAR_INTENSET_NOTRESOLVED_Disabled (0UL) /*!< Read: Disabled */
N#define AAR_INTENSET_NOTRESOLVED_Enabled (1UL) /*!< Read: Enabled */
N#define AAR_INTENSET_NOTRESOLVED_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for RESOLVED event */
N#define AAR_INTENSET_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
N#define AAR_INTENSET_RESOLVED_Msk (0x1UL << AAR_INTENSET_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
N#define AAR_INTENSET_RESOLVED_Disabled (0UL) /*!< Read: Disabled */
N#define AAR_INTENSET_RESOLVED_Enabled (1UL) /*!< Read: Enabled */
N#define AAR_INTENSET_RESOLVED_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for END event */
N#define AAR_INTENSET_END_Pos (0UL) /*!< Position of END field. */
N#define AAR_INTENSET_END_Msk (0x1UL << AAR_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define AAR_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
N#define AAR_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
N#define AAR_INTENSET_END_Set (1UL) /*!< Enable */
N
N/* Register: AAR_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 2 : Write '1' to Disable interrupt for NOTRESOLVED event */
N#define AAR_INTENCLR_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
N#define AAR_INTENCLR_NOTRESOLVED_Msk (0x1UL << AAR_INTENCLR_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
N#define AAR_INTENCLR_NOTRESOLVED_Disabled (0UL) /*!< Read: Disabled */
N#define AAR_INTENCLR_NOTRESOLVED_Enabled (1UL) /*!< Read: Enabled */
N#define AAR_INTENCLR_NOTRESOLVED_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for RESOLVED event */
N#define AAR_INTENCLR_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
N#define AAR_INTENCLR_RESOLVED_Msk (0x1UL << AAR_INTENCLR_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
N#define AAR_INTENCLR_RESOLVED_Disabled (0UL) /*!< Read: Disabled */
N#define AAR_INTENCLR_RESOLVED_Enabled (1UL) /*!< Read: Enabled */
N#define AAR_INTENCLR_RESOLVED_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for END event */
N#define AAR_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
N#define AAR_INTENCLR_END_Msk (0x1UL << AAR_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define AAR_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
N#define AAR_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
N#define AAR_INTENCLR_END_Clear (1UL) /*!< Disable */
N
N/* Register: AAR_STATUS */
N/* Description: Resolution status */
N
N/* Bits 3..0 : The IRK that was used last time an address was resolved */
N#define AAR_STATUS_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define AAR_STATUS_STATUS_Msk (0xFUL << AAR_STATUS_STATUS_Pos) /*!< Bit mask of STATUS field. */
N
N/* Register: AAR_ENABLE */
N/* Description: Enable AAR */
N
N/* Bits 1..0 : Enable or disable AAR */
N#define AAR_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define AAR_ENABLE_ENABLE_Msk (0x3UL << AAR_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define AAR_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
N#define AAR_ENABLE_ENABLE_Enabled (3UL) /*!< Enable */
N
N/* Register: AAR_NIRK */
N/* Description: Number of IRKs */
N
N/* Bits 4..0 : Number of Identity root keys available in the IRK data structure */
N#define AAR_NIRK_NIRK_Pos (0UL) /*!< Position of NIRK field. */
N#define AAR_NIRK_NIRK_Msk (0x1FUL << AAR_NIRK_NIRK_Pos) /*!< Bit mask of NIRK field. */
N
N/* Register: AAR_IRKPTR */
N/* Description: Pointer to IRK data structure */
N
N/* Bits 31..0 : Pointer to the IRK data structure */
N#define AAR_IRKPTR_IRKPTR_Pos (0UL) /*!< Position of IRKPTR field. */
N#define AAR_IRKPTR_IRKPTR_Msk (0xFFFFFFFFUL << AAR_IRKPTR_IRKPTR_Pos) /*!< Bit mask of IRKPTR field. */
N
N/* Register: AAR_ADDRPTR */
N/* Description: Pointer to the resolvable address */
N
N/* Bits 31..0 : Pointer to the resolvable address (6-bytes) */
N#define AAR_ADDRPTR_ADDRPTR_Pos (0UL) /*!< Position of ADDRPTR field. */
N#define AAR_ADDRPTR_ADDRPTR_Msk (0xFFFFFFFFUL << AAR_ADDRPTR_ADDRPTR_Pos) /*!< Bit mask of ADDRPTR field. */
N
N/* Register: AAR_SCRATCHPTR */
N/* Description: Pointer to data area used for temporary storage */
N
N/* Bits 31..0 : Pointer to a scratch data area used for temporary storage during resolution.A space of minimum 3 bytes must be reserved. */
N#define AAR_SCRATCHPTR_SCRATCHPTR_Pos (0UL) /*!< Position of SCRATCHPTR field. */
N#define AAR_SCRATCHPTR_SCRATCHPTR_Msk (0xFFFFFFFFUL << AAR_SCRATCHPTR_SCRATCHPTR_Pos) /*!< Bit mask of SCRATCHPTR field. */
N
N
N/* Peripheral: BPROT */
N/* Description: Block Protect */
N
N/* Register: BPROT_CONFIG0 */
N/* Description: Block protect configuration register 0 */
N
N/* Bit 31 : Enable protection for region 31. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION31_Pos (31UL) /*!< Position of REGION31 field. */
N#define BPROT_CONFIG0_REGION31_Msk (0x1UL << BPROT_CONFIG0_REGION31_Pos) /*!< Bit mask of REGION31 field. */
N#define BPROT_CONFIG0_REGION31_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION31_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 30 : Enable protection for region 30. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION30_Pos (30UL) /*!< Position of REGION30 field. */
N#define BPROT_CONFIG0_REGION30_Msk (0x1UL << BPROT_CONFIG0_REGION30_Pos) /*!< Bit mask of REGION30 field. */
N#define BPROT_CONFIG0_REGION30_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION30_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 29 : Enable protection for region 29. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION29_Pos (29UL) /*!< Position of REGION29 field. */
N#define BPROT_CONFIG0_REGION29_Msk (0x1UL << BPROT_CONFIG0_REGION29_Pos) /*!< Bit mask of REGION29 field. */
N#define BPROT_CONFIG0_REGION29_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION29_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 28 : Enable protection for region 28. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION28_Pos (28UL) /*!< Position of REGION28 field. */
N#define BPROT_CONFIG0_REGION28_Msk (0x1UL << BPROT_CONFIG0_REGION28_Pos) /*!< Bit mask of REGION28 field. */
N#define BPROT_CONFIG0_REGION28_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION28_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 27 : Enable protection for region 27. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION27_Pos (27UL) /*!< Position of REGION27 field. */
N#define BPROT_CONFIG0_REGION27_Msk (0x1UL << BPROT_CONFIG0_REGION27_Pos) /*!< Bit mask of REGION27 field. */
N#define BPROT_CONFIG0_REGION27_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION27_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 26 : Enable protection for region 26. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION26_Pos (26UL) /*!< Position of REGION26 field. */
N#define BPROT_CONFIG0_REGION26_Msk (0x1UL << BPROT_CONFIG0_REGION26_Pos) /*!< Bit mask of REGION26 field. */
N#define BPROT_CONFIG0_REGION26_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION26_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 25 : Enable protection for region 25. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION25_Pos (25UL) /*!< Position of REGION25 field. */
N#define BPROT_CONFIG0_REGION25_Msk (0x1UL << BPROT_CONFIG0_REGION25_Pos) /*!< Bit mask of REGION25 field. */
N#define BPROT_CONFIG0_REGION25_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION25_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 24 : Enable protection for region 24. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION24_Pos (24UL) /*!< Position of REGION24 field. */
N#define BPROT_CONFIG0_REGION24_Msk (0x1UL << BPROT_CONFIG0_REGION24_Pos) /*!< Bit mask of REGION24 field. */
N#define BPROT_CONFIG0_REGION24_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION24_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 23 : Enable protection for region 23. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION23_Pos (23UL) /*!< Position of REGION23 field. */
N#define BPROT_CONFIG0_REGION23_Msk (0x1UL << BPROT_CONFIG0_REGION23_Pos) /*!< Bit mask of REGION23 field. */
N#define BPROT_CONFIG0_REGION23_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION23_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 22 : Enable protection for region 22. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION22_Pos (22UL) /*!< Position of REGION22 field. */
N#define BPROT_CONFIG0_REGION22_Msk (0x1UL << BPROT_CONFIG0_REGION22_Pos) /*!< Bit mask of REGION22 field. */
N#define BPROT_CONFIG0_REGION22_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION22_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 21 : Enable protection for region 21. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION21_Pos (21UL) /*!< Position of REGION21 field. */
N#define BPROT_CONFIG0_REGION21_Msk (0x1UL << BPROT_CONFIG0_REGION21_Pos) /*!< Bit mask of REGION21 field. */
N#define BPROT_CONFIG0_REGION21_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION21_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 20 : Enable protection for region 20. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION20_Pos (20UL) /*!< Position of REGION20 field. */
N#define BPROT_CONFIG0_REGION20_Msk (0x1UL << BPROT_CONFIG0_REGION20_Pos) /*!< Bit mask of REGION20 field. */
N#define BPROT_CONFIG0_REGION20_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION20_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 19 : Enable protection for region 19. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION19_Pos (19UL) /*!< Position of REGION19 field. */
N#define BPROT_CONFIG0_REGION19_Msk (0x1UL << BPROT_CONFIG0_REGION19_Pos) /*!< Bit mask of REGION19 field. */
N#define BPROT_CONFIG0_REGION19_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION19_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 18 : Enable protection for region 18. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION18_Pos (18UL) /*!< Position of REGION18 field. */
N#define BPROT_CONFIG0_REGION18_Msk (0x1UL << BPROT_CONFIG0_REGION18_Pos) /*!< Bit mask of REGION18 field. */
N#define BPROT_CONFIG0_REGION18_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION18_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 17 : Enable protection for region 17. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION17_Pos (17UL) /*!< Position of REGION17 field. */
N#define BPROT_CONFIG0_REGION17_Msk (0x1UL << BPROT_CONFIG0_REGION17_Pos) /*!< Bit mask of REGION17 field. */
N#define BPROT_CONFIG0_REGION17_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION17_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 16 : Enable protection for region 16. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION16_Pos (16UL) /*!< Position of REGION16 field. */
N#define BPROT_CONFIG0_REGION16_Msk (0x1UL << BPROT_CONFIG0_REGION16_Pos) /*!< Bit mask of REGION16 field. */
N#define BPROT_CONFIG0_REGION16_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION16_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 15 : Enable protection for region 15. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION15_Pos (15UL) /*!< Position of REGION15 field. */
N#define BPROT_CONFIG0_REGION15_Msk (0x1UL << BPROT_CONFIG0_REGION15_Pos) /*!< Bit mask of REGION15 field. */
N#define BPROT_CONFIG0_REGION15_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION15_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 14 : Enable protection for region 14. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION14_Pos (14UL) /*!< Position of REGION14 field. */
N#define BPROT_CONFIG0_REGION14_Msk (0x1UL << BPROT_CONFIG0_REGION14_Pos) /*!< Bit mask of REGION14 field. */
N#define BPROT_CONFIG0_REGION14_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION14_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 13 : Enable protection for region 13. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION13_Pos (13UL) /*!< Position of REGION13 field. */
N#define BPROT_CONFIG0_REGION13_Msk (0x1UL << BPROT_CONFIG0_REGION13_Pos) /*!< Bit mask of REGION13 field. */
N#define BPROT_CONFIG0_REGION13_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION13_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 12 : Enable protection for region 12. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION12_Pos (12UL) /*!< Position of REGION12 field. */
N#define BPROT_CONFIG0_REGION12_Msk (0x1UL << BPROT_CONFIG0_REGION12_Pos) /*!< Bit mask of REGION12 field. */
N#define BPROT_CONFIG0_REGION12_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION12_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 11 : Enable protection for region 11. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION11_Pos (11UL) /*!< Position of REGION11 field. */
N#define BPROT_CONFIG0_REGION11_Msk (0x1UL << BPROT_CONFIG0_REGION11_Pos) /*!< Bit mask of REGION11 field. */
N#define BPROT_CONFIG0_REGION11_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION11_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 10 : Enable protection for region 10. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION10_Pos (10UL) /*!< Position of REGION10 field. */
N#define BPROT_CONFIG0_REGION10_Msk (0x1UL << BPROT_CONFIG0_REGION10_Pos) /*!< Bit mask of REGION10 field. */
N#define BPROT_CONFIG0_REGION10_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION10_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 9 : Enable protection for region 9. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION9_Pos (9UL) /*!< Position of REGION9 field. */
N#define BPROT_CONFIG0_REGION9_Msk (0x1UL << BPROT_CONFIG0_REGION9_Pos) /*!< Bit mask of REGION9 field. */
N#define BPROT_CONFIG0_REGION9_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION9_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 8 : Enable protection for region 8. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION8_Pos (8UL) /*!< Position of REGION8 field. */
N#define BPROT_CONFIG0_REGION8_Msk (0x1UL << BPROT_CONFIG0_REGION8_Pos) /*!< Bit mask of REGION8 field. */
N#define BPROT_CONFIG0_REGION8_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION8_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 7 : Enable protection for region 7. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION7_Pos (7UL) /*!< Position of REGION7 field. */
N#define BPROT_CONFIG0_REGION7_Msk (0x1UL << BPROT_CONFIG0_REGION7_Pos) /*!< Bit mask of REGION7 field. */
N#define BPROT_CONFIG0_REGION7_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION7_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 6 : Enable protection for region 6. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION6_Pos (6UL) /*!< Position of REGION6 field. */
N#define BPROT_CONFIG0_REGION6_Msk (0x1UL << BPROT_CONFIG0_REGION6_Pos) /*!< Bit mask of REGION6 field. */
N#define BPROT_CONFIG0_REGION6_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION6_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 5 : Enable protection for region 5. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION5_Pos (5UL) /*!< Position of REGION5 field. */
N#define BPROT_CONFIG0_REGION5_Msk (0x1UL << BPROT_CONFIG0_REGION5_Pos) /*!< Bit mask of REGION5 field. */
N#define BPROT_CONFIG0_REGION5_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION5_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 4 : Enable protection for region 4. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION4_Pos (4UL) /*!< Position of REGION4 field. */
N#define BPROT_CONFIG0_REGION4_Msk (0x1UL << BPROT_CONFIG0_REGION4_Pos) /*!< Bit mask of REGION4 field. */
N#define BPROT_CONFIG0_REGION4_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION4_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 3 : Enable protection for region 3. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION3_Pos (3UL) /*!< Position of REGION3 field. */
N#define BPROT_CONFIG0_REGION3_Msk (0x1UL << BPROT_CONFIG0_REGION3_Pos) /*!< Bit mask of REGION3 field. */
N#define BPROT_CONFIG0_REGION3_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION3_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 2 : Enable protection for region 2. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION2_Pos (2UL) /*!< Position of REGION2 field. */
N#define BPROT_CONFIG0_REGION2_Msk (0x1UL << BPROT_CONFIG0_REGION2_Pos) /*!< Bit mask of REGION2 field. */
N#define BPROT_CONFIG0_REGION2_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION2_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 1 : Enable protection for region 1. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION1_Pos (1UL) /*!< Position of REGION1 field. */
N#define BPROT_CONFIG0_REGION1_Msk (0x1UL << BPROT_CONFIG0_REGION1_Pos) /*!< Bit mask of REGION1 field. */
N#define BPROT_CONFIG0_REGION1_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION1_Enabled (1UL) /*!< Protection enable */
N
N/* Bit 0 : Enable protection for region 0. Write '0' has no effect. */
N#define BPROT_CONFIG0_REGION0_Pos (0UL) /*!< Position of REGION0 field. */
N#define BPROT_CONFIG0_REGION0_Msk (0x1UL << BPROT_CONFIG0_REGION0_Pos) /*!< Bit mask of REGION0 field. */
N#define BPROT_CONFIG0_REGION0_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG0_REGION0_Enabled (1UL) /*!< Protection enable */
N
N/* Register: BPROT_CONFIG1 */
N/* Description: Block protect configuration register 1 */
N
N/* Bit 31 : Enable protection for region 63. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION63_Pos (31UL) /*!< Position of REGION63 field. */
N#define BPROT_CONFIG1_REGION63_Msk (0x1UL << BPROT_CONFIG1_REGION63_Pos) /*!< Bit mask of REGION63 field. */
N#define BPROT_CONFIG1_REGION63_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION63_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 30 : Enable protection for region 62. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION62_Pos (30UL) /*!< Position of REGION62 field. */
N#define BPROT_CONFIG1_REGION62_Msk (0x1UL << BPROT_CONFIG1_REGION62_Pos) /*!< Bit mask of REGION62 field. */
N#define BPROT_CONFIG1_REGION62_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION62_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 29 : Enable protection for region 61. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION61_Pos (29UL) /*!< Position of REGION61 field. */
N#define BPROT_CONFIG1_REGION61_Msk (0x1UL << BPROT_CONFIG1_REGION61_Pos) /*!< Bit mask of REGION61 field. */
N#define BPROT_CONFIG1_REGION61_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION61_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 28 : Enable protection for region 60. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION60_Pos (28UL) /*!< Position of REGION60 field. */
N#define BPROT_CONFIG1_REGION60_Msk (0x1UL << BPROT_CONFIG1_REGION60_Pos) /*!< Bit mask of REGION60 field. */
N#define BPROT_CONFIG1_REGION60_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION60_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 27 : Enable protection for region 59. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION59_Pos (27UL) /*!< Position of REGION59 field. */
N#define BPROT_CONFIG1_REGION59_Msk (0x1UL << BPROT_CONFIG1_REGION59_Pos) /*!< Bit mask of REGION59 field. */
N#define BPROT_CONFIG1_REGION59_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION59_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 26 : Enable protection for region 58. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION58_Pos (26UL) /*!< Position of REGION58 field. */
N#define BPROT_CONFIG1_REGION58_Msk (0x1UL << BPROT_CONFIG1_REGION58_Pos) /*!< Bit mask of REGION58 field. */
N#define BPROT_CONFIG1_REGION58_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION58_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 25 : Enable protection for region 57. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION57_Pos (25UL) /*!< Position of REGION57 field. */
N#define BPROT_CONFIG1_REGION57_Msk (0x1UL << BPROT_CONFIG1_REGION57_Pos) /*!< Bit mask of REGION57 field. */
N#define BPROT_CONFIG1_REGION57_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION57_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 24 : Enable protection for region 56. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION56_Pos (24UL) /*!< Position of REGION56 field. */
N#define BPROT_CONFIG1_REGION56_Msk (0x1UL << BPROT_CONFIG1_REGION56_Pos) /*!< Bit mask of REGION56 field. */
N#define BPROT_CONFIG1_REGION56_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION56_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 23 : Enable protection for region 55. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION55_Pos (23UL) /*!< Position of REGION55 field. */
N#define BPROT_CONFIG1_REGION55_Msk (0x1UL << BPROT_CONFIG1_REGION55_Pos) /*!< Bit mask of REGION55 field. */
N#define BPROT_CONFIG1_REGION55_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION55_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 22 : Enable protection for region 54. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION54_Pos (22UL) /*!< Position of REGION54 field. */
N#define BPROT_CONFIG1_REGION54_Msk (0x1UL << BPROT_CONFIG1_REGION54_Pos) /*!< Bit mask of REGION54 field. */
N#define BPROT_CONFIG1_REGION54_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION54_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 21 : Enable protection for region 53. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION53_Pos (21UL) /*!< Position of REGION53 field. */
N#define BPROT_CONFIG1_REGION53_Msk (0x1UL << BPROT_CONFIG1_REGION53_Pos) /*!< Bit mask of REGION53 field. */
N#define BPROT_CONFIG1_REGION53_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION53_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 20 : Enable protection for region 52. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION52_Pos (20UL) /*!< Position of REGION52 field. */
N#define BPROT_CONFIG1_REGION52_Msk (0x1UL << BPROT_CONFIG1_REGION52_Pos) /*!< Bit mask of REGION52 field. */
N#define BPROT_CONFIG1_REGION52_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION52_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 19 : Enable protection for region 51. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION51_Pos (19UL) /*!< Position of REGION51 field. */
N#define BPROT_CONFIG1_REGION51_Msk (0x1UL << BPROT_CONFIG1_REGION51_Pos) /*!< Bit mask of REGION51 field. */
N#define BPROT_CONFIG1_REGION51_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION51_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 18 : Enable protection for region 50. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION50_Pos (18UL) /*!< Position of REGION50 field. */
N#define BPROT_CONFIG1_REGION50_Msk (0x1UL << BPROT_CONFIG1_REGION50_Pos) /*!< Bit mask of REGION50 field. */
N#define BPROT_CONFIG1_REGION50_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION50_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 17 : Enable protection for region 49. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION49_Pos (17UL) /*!< Position of REGION49 field. */
N#define BPROT_CONFIG1_REGION49_Msk (0x1UL << BPROT_CONFIG1_REGION49_Pos) /*!< Bit mask of REGION49 field. */
N#define BPROT_CONFIG1_REGION49_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION49_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 16 : Enable protection for region 48. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION48_Pos (16UL) /*!< Position of REGION48 field. */
N#define BPROT_CONFIG1_REGION48_Msk (0x1UL << BPROT_CONFIG1_REGION48_Pos) /*!< Bit mask of REGION48 field. */
N#define BPROT_CONFIG1_REGION48_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION48_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 15 : Enable protection for region 47. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION47_Pos (15UL) /*!< Position of REGION47 field. */
N#define BPROT_CONFIG1_REGION47_Msk (0x1UL << BPROT_CONFIG1_REGION47_Pos) /*!< Bit mask of REGION47 field. */
N#define BPROT_CONFIG1_REGION47_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION47_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 14 : Enable protection for region 46. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION46_Pos (14UL) /*!< Position of REGION46 field. */
N#define BPROT_CONFIG1_REGION46_Msk (0x1UL << BPROT_CONFIG1_REGION46_Pos) /*!< Bit mask of REGION46 field. */
N#define BPROT_CONFIG1_REGION46_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION46_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 13 : Enable protection for region 45. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION45_Pos (13UL) /*!< Position of REGION45 field. */
N#define BPROT_CONFIG1_REGION45_Msk (0x1UL << BPROT_CONFIG1_REGION45_Pos) /*!< Bit mask of REGION45 field. */
N#define BPROT_CONFIG1_REGION45_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION45_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 12 : Enable protection for region 44. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION44_Pos (12UL) /*!< Position of REGION44 field. */
N#define BPROT_CONFIG1_REGION44_Msk (0x1UL << BPROT_CONFIG1_REGION44_Pos) /*!< Bit mask of REGION44 field. */
N#define BPROT_CONFIG1_REGION44_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION44_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 11 : Enable protection for region 43. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION43_Pos (11UL) /*!< Position of REGION43 field. */
N#define BPROT_CONFIG1_REGION43_Msk (0x1UL << BPROT_CONFIG1_REGION43_Pos) /*!< Bit mask of REGION43 field. */
N#define BPROT_CONFIG1_REGION43_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION43_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 10 : Enable protection for region 42. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION42_Pos (10UL) /*!< Position of REGION42 field. */
N#define BPROT_CONFIG1_REGION42_Msk (0x1UL << BPROT_CONFIG1_REGION42_Pos) /*!< Bit mask of REGION42 field. */
N#define BPROT_CONFIG1_REGION42_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION42_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 9 : Enable protection for region 41. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION41_Pos (9UL) /*!< Position of REGION41 field. */
N#define BPROT_CONFIG1_REGION41_Msk (0x1UL << BPROT_CONFIG1_REGION41_Pos) /*!< Bit mask of REGION41 field. */
N#define BPROT_CONFIG1_REGION41_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION41_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 8 : Enable protection for region 40. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION40_Pos (8UL) /*!< Position of REGION40 field. */
N#define BPROT_CONFIG1_REGION40_Msk (0x1UL << BPROT_CONFIG1_REGION40_Pos) /*!< Bit mask of REGION40 field. */
N#define BPROT_CONFIG1_REGION40_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION40_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 7 : Enable protection for region 39. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION39_Pos (7UL) /*!< Position of REGION39 field. */
N#define BPROT_CONFIG1_REGION39_Msk (0x1UL << BPROT_CONFIG1_REGION39_Pos) /*!< Bit mask of REGION39 field. */
N#define BPROT_CONFIG1_REGION39_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION39_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 6 : Enable protection for region 38. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION38_Pos (6UL) /*!< Position of REGION38 field. */
N#define BPROT_CONFIG1_REGION38_Msk (0x1UL << BPROT_CONFIG1_REGION38_Pos) /*!< Bit mask of REGION38 field. */
N#define BPROT_CONFIG1_REGION38_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION38_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 5 : Enable protection for region 37. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION37_Pos (5UL) /*!< Position of REGION37 field. */
N#define BPROT_CONFIG1_REGION37_Msk (0x1UL << BPROT_CONFIG1_REGION37_Pos) /*!< Bit mask of REGION37 field. */
N#define BPROT_CONFIG1_REGION37_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION37_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 4 : Enable protection for region 36. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION36_Pos (4UL) /*!< Position of REGION36 field. */
N#define BPROT_CONFIG1_REGION36_Msk (0x1UL << BPROT_CONFIG1_REGION36_Pos) /*!< Bit mask of REGION36 field. */
N#define BPROT_CONFIG1_REGION36_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION36_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 3 : Enable protection for region 35. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION35_Pos (3UL) /*!< Position of REGION35 field. */
N#define BPROT_CONFIG1_REGION35_Msk (0x1UL << BPROT_CONFIG1_REGION35_Pos) /*!< Bit mask of REGION35 field. */
N#define BPROT_CONFIG1_REGION35_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION35_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 2 : Enable protection for region 34. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION34_Pos (2UL) /*!< Position of REGION34 field. */
N#define BPROT_CONFIG1_REGION34_Msk (0x1UL << BPROT_CONFIG1_REGION34_Pos) /*!< Bit mask of REGION34 field. */
N#define BPROT_CONFIG1_REGION34_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION34_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 1 : Enable protection for region 33. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION33_Pos (1UL) /*!< Position of REGION33 field. */
N#define BPROT_CONFIG1_REGION33_Msk (0x1UL << BPROT_CONFIG1_REGION33_Pos) /*!< Bit mask of REGION33 field. */
N#define BPROT_CONFIG1_REGION33_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION33_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 0 : Enable protection for region 32. Write '0' has no effect. */
N#define BPROT_CONFIG1_REGION32_Pos (0UL) /*!< Position of REGION32 field. */
N#define BPROT_CONFIG1_REGION32_Msk (0x1UL << BPROT_CONFIG1_REGION32_Pos) /*!< Bit mask of REGION32 field. */
N#define BPROT_CONFIG1_REGION32_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG1_REGION32_Enabled (1UL) /*!< Protection enabled */
N
N/* Register: BPROT_DISABLEINDEBUG */
N/* Description: Disable protection mechanism in debug interface mode */
N
N/* Bit 0 : Disable the protection mechanism for NVM regions while in debug interface mode. This register will only disable the protection mechanism if the device is in debug interface mode. */
N#define BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Pos (0UL) /*!< Position of DISABLEINDEBUG field. */
N#define BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Msk (0x1UL << BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Pos) /*!< Bit mask of DISABLEINDEBUG field. */
N#define BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Enabled (0UL) /*!< Enable in debug */
N#define BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Disabled (1UL) /*!< Disable in debug */
N
N/* Register: BPROT_CONFIG2 */
N/* Description: Block protect configuration register 2 */
N
N/* Bit 31 : Enable protection for region 95. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION95_Pos (31UL) /*!< Position of REGION95 field. */
N#define BPROT_CONFIG2_REGION95_Msk (0x1UL << BPROT_CONFIG2_REGION95_Pos) /*!< Bit mask of REGION95 field. */
N#define BPROT_CONFIG2_REGION95_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION95_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 30 : Enable protection for region 94. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION94_Pos (30UL) /*!< Position of REGION94 field. */
N#define BPROT_CONFIG2_REGION94_Msk (0x1UL << BPROT_CONFIG2_REGION94_Pos) /*!< Bit mask of REGION94 field. */
N#define BPROT_CONFIG2_REGION94_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION94_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 29 : Enable protection for region 93. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION93_Pos (29UL) /*!< Position of REGION93 field. */
N#define BPROT_CONFIG2_REGION93_Msk (0x1UL << BPROT_CONFIG2_REGION93_Pos) /*!< Bit mask of REGION93 field. */
N#define BPROT_CONFIG2_REGION93_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION93_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 28 : Enable protection for region 92. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION92_Pos (28UL) /*!< Position of REGION92 field. */
N#define BPROT_CONFIG2_REGION92_Msk (0x1UL << BPROT_CONFIG2_REGION92_Pos) /*!< Bit mask of REGION92 field. */
N#define BPROT_CONFIG2_REGION92_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION92_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 27 : Enable protection for region 91. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION91_Pos (27UL) /*!< Position of REGION91 field. */
N#define BPROT_CONFIG2_REGION91_Msk (0x1UL << BPROT_CONFIG2_REGION91_Pos) /*!< Bit mask of REGION91 field. */
N#define BPROT_CONFIG2_REGION91_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION91_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 26 : Enable protection for region 90. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION90_Pos (26UL) /*!< Position of REGION90 field. */
N#define BPROT_CONFIG2_REGION90_Msk (0x1UL << BPROT_CONFIG2_REGION90_Pos) /*!< Bit mask of REGION90 field. */
N#define BPROT_CONFIG2_REGION90_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION90_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 25 : Enable protection for region 89. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION89_Pos (25UL) /*!< Position of REGION89 field. */
N#define BPROT_CONFIG2_REGION89_Msk (0x1UL << BPROT_CONFIG2_REGION89_Pos) /*!< Bit mask of REGION89 field. */
N#define BPROT_CONFIG2_REGION89_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION89_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 24 : Enable protection for region 88. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION88_Pos (24UL) /*!< Position of REGION88 field. */
N#define BPROT_CONFIG2_REGION88_Msk (0x1UL << BPROT_CONFIG2_REGION88_Pos) /*!< Bit mask of REGION88 field. */
N#define BPROT_CONFIG2_REGION88_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION88_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 23 : Enable protection for region 87. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION87_Pos (23UL) /*!< Position of REGION87 field. */
N#define BPROT_CONFIG2_REGION87_Msk (0x1UL << BPROT_CONFIG2_REGION87_Pos) /*!< Bit mask of REGION87 field. */
N#define BPROT_CONFIG2_REGION87_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION87_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 22 : Enable protection for region 86. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION86_Pos (22UL) /*!< Position of REGION86 field. */
N#define BPROT_CONFIG2_REGION86_Msk (0x1UL << BPROT_CONFIG2_REGION86_Pos) /*!< Bit mask of REGION86 field. */
N#define BPROT_CONFIG2_REGION86_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION86_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 21 : Enable protection for region 85. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION85_Pos (21UL) /*!< Position of REGION85 field. */
N#define BPROT_CONFIG2_REGION85_Msk (0x1UL << BPROT_CONFIG2_REGION85_Pos) /*!< Bit mask of REGION85 field. */
N#define BPROT_CONFIG2_REGION85_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION85_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 20 : Enable protection for region 84. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION84_Pos (20UL) /*!< Position of REGION84 field. */
N#define BPROT_CONFIG2_REGION84_Msk (0x1UL << BPROT_CONFIG2_REGION84_Pos) /*!< Bit mask of REGION84 field. */
N#define BPROT_CONFIG2_REGION84_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION84_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 19 : Enable protection for region 83. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION83_Pos (19UL) /*!< Position of REGION83 field. */
N#define BPROT_CONFIG2_REGION83_Msk (0x1UL << BPROT_CONFIG2_REGION83_Pos) /*!< Bit mask of REGION83 field. */
N#define BPROT_CONFIG2_REGION83_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION83_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 18 : Enable protection for region 82. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION82_Pos (18UL) /*!< Position of REGION82 field. */
N#define BPROT_CONFIG2_REGION82_Msk (0x1UL << BPROT_CONFIG2_REGION82_Pos) /*!< Bit mask of REGION82 field. */
N#define BPROT_CONFIG2_REGION82_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION82_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 17 : Enable protection for region 81. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION81_Pos (17UL) /*!< Position of REGION81 field. */
N#define BPROT_CONFIG2_REGION81_Msk (0x1UL << BPROT_CONFIG2_REGION81_Pos) /*!< Bit mask of REGION81 field. */
N#define BPROT_CONFIG2_REGION81_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION81_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 16 : Enable protection for region 80. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION80_Pos (16UL) /*!< Position of REGION80 field. */
N#define BPROT_CONFIG2_REGION80_Msk (0x1UL << BPROT_CONFIG2_REGION80_Pos) /*!< Bit mask of REGION80 field. */
N#define BPROT_CONFIG2_REGION80_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION80_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 15 : Enable protection for region 79. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION79_Pos (15UL) /*!< Position of REGION79 field. */
N#define BPROT_CONFIG2_REGION79_Msk (0x1UL << BPROT_CONFIG2_REGION79_Pos) /*!< Bit mask of REGION79 field. */
N#define BPROT_CONFIG2_REGION79_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION79_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 14 : Enable protection for region 78. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION78_Pos (14UL) /*!< Position of REGION78 field. */
N#define BPROT_CONFIG2_REGION78_Msk (0x1UL << BPROT_CONFIG2_REGION78_Pos) /*!< Bit mask of REGION78 field. */
N#define BPROT_CONFIG2_REGION78_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION78_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 13 : Enable protection for region 77. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION77_Pos (13UL) /*!< Position of REGION77 field. */
N#define BPROT_CONFIG2_REGION77_Msk (0x1UL << BPROT_CONFIG2_REGION77_Pos) /*!< Bit mask of REGION77 field. */
N#define BPROT_CONFIG2_REGION77_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION77_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 12 : Enable protection for region 76. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION76_Pos (12UL) /*!< Position of REGION76 field. */
N#define BPROT_CONFIG2_REGION76_Msk (0x1UL << BPROT_CONFIG2_REGION76_Pos) /*!< Bit mask of REGION76 field. */
N#define BPROT_CONFIG2_REGION76_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION76_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 11 : Enable protection for region 75. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION75_Pos (11UL) /*!< Position of REGION75 field. */
N#define BPROT_CONFIG2_REGION75_Msk (0x1UL << BPROT_CONFIG2_REGION75_Pos) /*!< Bit mask of REGION75 field. */
N#define BPROT_CONFIG2_REGION75_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION75_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 10 : Enable protection for region 74. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION74_Pos (10UL) /*!< Position of REGION74 field. */
N#define BPROT_CONFIG2_REGION74_Msk (0x1UL << BPROT_CONFIG2_REGION74_Pos) /*!< Bit mask of REGION74 field. */
N#define BPROT_CONFIG2_REGION74_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION74_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 9 : Enable protection for region 73. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION73_Pos (9UL) /*!< Position of REGION73 field. */
N#define BPROT_CONFIG2_REGION73_Msk (0x1UL << BPROT_CONFIG2_REGION73_Pos) /*!< Bit mask of REGION73 field. */
N#define BPROT_CONFIG2_REGION73_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION73_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 8 : Enable protection for region 72. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION72_Pos (8UL) /*!< Position of REGION72 field. */
N#define BPROT_CONFIG2_REGION72_Msk (0x1UL << BPROT_CONFIG2_REGION72_Pos) /*!< Bit mask of REGION72 field. */
N#define BPROT_CONFIG2_REGION72_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION72_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 7 : Enable protection for region 71. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION71_Pos (7UL) /*!< Position of REGION71 field. */
N#define BPROT_CONFIG2_REGION71_Msk (0x1UL << BPROT_CONFIG2_REGION71_Pos) /*!< Bit mask of REGION71 field. */
N#define BPROT_CONFIG2_REGION71_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION71_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 6 : Enable protection for region 70. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION70_Pos (6UL) /*!< Position of REGION70 field. */
N#define BPROT_CONFIG2_REGION70_Msk (0x1UL << BPROT_CONFIG2_REGION70_Pos) /*!< Bit mask of REGION70 field. */
N#define BPROT_CONFIG2_REGION70_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION70_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 5 : Enable protection for region 69. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION69_Pos (5UL) /*!< Position of REGION69 field. */
N#define BPROT_CONFIG2_REGION69_Msk (0x1UL << BPROT_CONFIG2_REGION69_Pos) /*!< Bit mask of REGION69 field. */
N#define BPROT_CONFIG2_REGION69_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION69_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 4 : Enable protection for region 68. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION68_Pos (4UL) /*!< Position of REGION68 field. */
N#define BPROT_CONFIG2_REGION68_Msk (0x1UL << BPROT_CONFIG2_REGION68_Pos) /*!< Bit mask of REGION68 field. */
N#define BPROT_CONFIG2_REGION68_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION68_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 3 : Enable protection for region 67. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION67_Pos (3UL) /*!< Position of REGION67 field. */
N#define BPROT_CONFIG2_REGION67_Msk (0x1UL << BPROT_CONFIG2_REGION67_Pos) /*!< Bit mask of REGION67 field. */
N#define BPROT_CONFIG2_REGION67_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION67_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 2 : Enable protection for region 66. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION66_Pos (2UL) /*!< Position of REGION66 field. */
N#define BPROT_CONFIG2_REGION66_Msk (0x1UL << BPROT_CONFIG2_REGION66_Pos) /*!< Bit mask of REGION66 field. */
N#define BPROT_CONFIG2_REGION66_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION66_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 1 : Enable protection for region 65. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION65_Pos (1UL) /*!< Position of REGION65 field. */
N#define BPROT_CONFIG2_REGION65_Msk (0x1UL << BPROT_CONFIG2_REGION65_Pos) /*!< Bit mask of REGION65 field. */
N#define BPROT_CONFIG2_REGION65_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION65_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 0 : Enable protection for region 64. Write '0' has no effect. */
N#define BPROT_CONFIG2_REGION64_Pos (0UL) /*!< Position of REGION64 field. */
N#define BPROT_CONFIG2_REGION64_Msk (0x1UL << BPROT_CONFIG2_REGION64_Pos) /*!< Bit mask of REGION64 field. */
N#define BPROT_CONFIG2_REGION64_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG2_REGION64_Enabled (1UL) /*!< Protection enabled */
N
N/* Register: BPROT_CONFIG3 */
N/* Description: Block protect configuration register 3 */
N
N/* Bit 31 : Enable protection for region 127. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION127_Pos (31UL) /*!< Position of REGION127 field. */
N#define BPROT_CONFIG3_REGION127_Msk (0x1UL << BPROT_CONFIG3_REGION127_Pos) /*!< Bit mask of REGION127 field. */
N#define BPROT_CONFIG3_REGION127_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION127_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 30 : Enable protection for region 126. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION126_Pos (30UL) /*!< Position of REGION126 field. */
N#define BPROT_CONFIG3_REGION126_Msk (0x1UL << BPROT_CONFIG3_REGION126_Pos) /*!< Bit mask of REGION126 field. */
N#define BPROT_CONFIG3_REGION126_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION126_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 29 : Enable protection for region 125. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION125_Pos (29UL) /*!< Position of REGION125 field. */
N#define BPROT_CONFIG3_REGION125_Msk (0x1UL << BPROT_CONFIG3_REGION125_Pos) /*!< Bit mask of REGION125 field. */
N#define BPROT_CONFIG3_REGION125_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION125_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 28 : Enable protection for region 124. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION124_Pos (28UL) /*!< Position of REGION124 field. */
N#define BPROT_CONFIG3_REGION124_Msk (0x1UL << BPROT_CONFIG3_REGION124_Pos) /*!< Bit mask of REGION124 field. */
N#define BPROT_CONFIG3_REGION124_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION124_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 27 : Enable protection for region 123. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION123_Pos (27UL) /*!< Position of REGION123 field. */
N#define BPROT_CONFIG3_REGION123_Msk (0x1UL << BPROT_CONFIG3_REGION123_Pos) /*!< Bit mask of REGION123 field. */
N#define BPROT_CONFIG3_REGION123_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION123_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 26 : Enable protection for region 122. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION122_Pos (26UL) /*!< Position of REGION122 field. */
N#define BPROT_CONFIG3_REGION122_Msk (0x1UL << BPROT_CONFIG3_REGION122_Pos) /*!< Bit mask of REGION122 field. */
N#define BPROT_CONFIG3_REGION122_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION122_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 25 : Enable protection for region 121. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION121_Pos (25UL) /*!< Position of REGION121 field. */
N#define BPROT_CONFIG3_REGION121_Msk (0x1UL << BPROT_CONFIG3_REGION121_Pos) /*!< Bit mask of REGION121 field. */
N#define BPROT_CONFIG3_REGION121_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION121_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 24 : Enable protection for region 120. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION120_Pos (24UL) /*!< Position of REGION120 field. */
N#define BPROT_CONFIG3_REGION120_Msk (0x1UL << BPROT_CONFIG3_REGION120_Pos) /*!< Bit mask of REGION120 field. */
N#define BPROT_CONFIG3_REGION120_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION120_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 23 : Enable protection for region 119. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION119_Pos (23UL) /*!< Position of REGION119 field. */
N#define BPROT_CONFIG3_REGION119_Msk (0x1UL << BPROT_CONFIG3_REGION119_Pos) /*!< Bit mask of REGION119 field. */
N#define BPROT_CONFIG3_REGION119_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION119_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 22 : Enable protection for region 118. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION118_Pos (22UL) /*!< Position of REGION118 field. */
N#define BPROT_CONFIG3_REGION118_Msk (0x1UL << BPROT_CONFIG3_REGION118_Pos) /*!< Bit mask of REGION118 field. */
N#define BPROT_CONFIG3_REGION118_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION118_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 21 : Enable protection for region 117. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION117_Pos (21UL) /*!< Position of REGION117 field. */
N#define BPROT_CONFIG3_REGION117_Msk (0x1UL << BPROT_CONFIG3_REGION117_Pos) /*!< Bit mask of REGION117 field. */
N#define BPROT_CONFIG3_REGION117_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION117_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 20 : Enable protection for region 116. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION116_Pos (20UL) /*!< Position of REGION116 field. */
N#define BPROT_CONFIG3_REGION116_Msk (0x1UL << BPROT_CONFIG3_REGION116_Pos) /*!< Bit mask of REGION116 field. */
N#define BPROT_CONFIG3_REGION116_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION116_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 19 : Enable protection for region 115. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION115_Pos (19UL) /*!< Position of REGION115 field. */
N#define BPROT_CONFIG3_REGION115_Msk (0x1UL << BPROT_CONFIG3_REGION115_Pos) /*!< Bit mask of REGION115 field. */
N#define BPROT_CONFIG3_REGION115_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION115_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 18 : Enable protection for region 114. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION114_Pos (18UL) /*!< Position of REGION114 field. */
N#define BPROT_CONFIG3_REGION114_Msk (0x1UL << BPROT_CONFIG3_REGION114_Pos) /*!< Bit mask of REGION114 field. */
N#define BPROT_CONFIG3_REGION114_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION114_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 17 : Enable protection for region 113. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION113_Pos (17UL) /*!< Position of REGION113 field. */
N#define BPROT_CONFIG3_REGION113_Msk (0x1UL << BPROT_CONFIG3_REGION113_Pos) /*!< Bit mask of REGION113 field. */
N#define BPROT_CONFIG3_REGION113_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION113_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 16 : Enable protection for region 112. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION112_Pos (16UL) /*!< Position of REGION112 field. */
N#define BPROT_CONFIG3_REGION112_Msk (0x1UL << BPROT_CONFIG3_REGION112_Pos) /*!< Bit mask of REGION112 field. */
N#define BPROT_CONFIG3_REGION112_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION112_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 15 : Enable protection for region 111. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION111_Pos (15UL) /*!< Position of REGION111 field. */
N#define BPROT_CONFIG3_REGION111_Msk (0x1UL << BPROT_CONFIG3_REGION111_Pos) /*!< Bit mask of REGION111 field. */
N#define BPROT_CONFIG3_REGION111_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION111_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 14 : Enable protection for region 110. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION110_Pos (14UL) /*!< Position of REGION110 field. */
N#define BPROT_CONFIG3_REGION110_Msk (0x1UL << BPROT_CONFIG3_REGION110_Pos) /*!< Bit mask of REGION110 field. */
N#define BPROT_CONFIG3_REGION110_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION110_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 13 : Enable protection for region 109. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION109_Pos (13UL) /*!< Position of REGION109 field. */
N#define BPROT_CONFIG3_REGION109_Msk (0x1UL << BPROT_CONFIG3_REGION109_Pos) /*!< Bit mask of REGION109 field. */
N#define BPROT_CONFIG3_REGION109_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION109_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 12 : Enable protection for region 108. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION108_Pos (12UL) /*!< Position of REGION108 field. */
N#define BPROT_CONFIG3_REGION108_Msk (0x1UL << BPROT_CONFIG3_REGION108_Pos) /*!< Bit mask of REGION108 field. */
N#define BPROT_CONFIG3_REGION108_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION108_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 11 : Enable protection for region 107. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION107_Pos (11UL) /*!< Position of REGION107 field. */
N#define BPROT_CONFIG3_REGION107_Msk (0x1UL << BPROT_CONFIG3_REGION107_Pos) /*!< Bit mask of REGION107 field. */
N#define BPROT_CONFIG3_REGION107_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION107_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 10 : Enable protection for region 106. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION106_Pos (10UL) /*!< Position of REGION106 field. */
N#define BPROT_CONFIG3_REGION106_Msk (0x1UL << BPROT_CONFIG3_REGION106_Pos) /*!< Bit mask of REGION106 field. */
N#define BPROT_CONFIG3_REGION106_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION106_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 9 : Enable protection for region 105. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION105_Pos (9UL) /*!< Position of REGION105 field. */
N#define BPROT_CONFIG3_REGION105_Msk (0x1UL << BPROT_CONFIG3_REGION105_Pos) /*!< Bit mask of REGION105 field. */
N#define BPROT_CONFIG3_REGION105_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION105_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 8 : Enable protection for region 104. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION104_Pos (8UL) /*!< Position of REGION104 field. */
N#define BPROT_CONFIG3_REGION104_Msk (0x1UL << BPROT_CONFIG3_REGION104_Pos) /*!< Bit mask of REGION104 field. */
N#define BPROT_CONFIG3_REGION104_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION104_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 7 : Enable protection for region 103. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION103_Pos (7UL) /*!< Position of REGION103 field. */
N#define BPROT_CONFIG3_REGION103_Msk (0x1UL << BPROT_CONFIG3_REGION103_Pos) /*!< Bit mask of REGION103 field. */
N#define BPROT_CONFIG3_REGION103_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION103_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 6 : Enable protection for region 102. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION102_Pos (6UL) /*!< Position of REGION102 field. */
N#define BPROT_CONFIG3_REGION102_Msk (0x1UL << BPROT_CONFIG3_REGION102_Pos) /*!< Bit mask of REGION102 field. */
N#define BPROT_CONFIG3_REGION102_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION102_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 5 : Enable protection for region 101. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION101_Pos (5UL) /*!< Position of REGION101 field. */
N#define BPROT_CONFIG3_REGION101_Msk (0x1UL << BPROT_CONFIG3_REGION101_Pos) /*!< Bit mask of REGION101 field. */
N#define BPROT_CONFIG3_REGION101_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION101_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 4 : Enable protection for region 100. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION100_Pos (4UL) /*!< Position of REGION100 field. */
N#define BPROT_CONFIG3_REGION100_Msk (0x1UL << BPROT_CONFIG3_REGION100_Pos) /*!< Bit mask of REGION100 field. */
N#define BPROT_CONFIG3_REGION100_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION100_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 3 : Enable protection for region 99. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION99_Pos (3UL) /*!< Position of REGION99 field. */
N#define BPROT_CONFIG3_REGION99_Msk (0x1UL << BPROT_CONFIG3_REGION99_Pos) /*!< Bit mask of REGION99 field. */
N#define BPROT_CONFIG3_REGION99_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION99_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 2 : Enable protection for region 98. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION98_Pos (2UL) /*!< Position of REGION98 field. */
N#define BPROT_CONFIG3_REGION98_Msk (0x1UL << BPROT_CONFIG3_REGION98_Pos) /*!< Bit mask of REGION98 field. */
N#define BPROT_CONFIG3_REGION98_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION98_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 1 : Enable protection for region 97. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION97_Pos (1UL) /*!< Position of REGION97 field. */
N#define BPROT_CONFIG3_REGION97_Msk (0x1UL << BPROT_CONFIG3_REGION97_Pos) /*!< Bit mask of REGION97 field. */
N#define BPROT_CONFIG3_REGION97_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION97_Enabled (1UL) /*!< Protection enabled */
N
N/* Bit 0 : Enable protection for region 96. Write '0' has no effect. */
N#define BPROT_CONFIG3_REGION96_Pos (0UL) /*!< Position of REGION96 field. */
N#define BPROT_CONFIG3_REGION96_Msk (0x1UL << BPROT_CONFIG3_REGION96_Pos) /*!< Bit mask of REGION96 field. */
N#define BPROT_CONFIG3_REGION96_Disabled (0UL) /*!< Protection disabled */
N#define BPROT_CONFIG3_REGION96_Enabled (1UL) /*!< Protection enabled */
N
N
N/* Peripheral: CCM */
N/* Description: AES CCM Mode Encryption */
N
N/* Register: CCM_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 0 : Shortcut between ENDKSGEN event and CRYPT task */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Pos (0UL) /*!< Position of ENDKSGEN_CRYPT field. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Msk (0x1UL << CCM_SHORTS_ENDKSGEN_CRYPT_Pos) /*!< Bit mask of ENDKSGEN_CRYPT field. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Disabled (0UL) /*!< Disable shortcut */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: CCM_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 2 : Write '1' to Enable interrupt for ERROR event */
N#define CCM_INTENSET_ERROR_Pos (2UL) /*!< Position of ERROR field. */
N#define CCM_INTENSET_ERROR_Msk (0x1UL << CCM_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define CCM_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define CCM_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define CCM_INTENSET_ERROR_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for ENDCRYPT event */
N#define CCM_INTENSET_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
N#define CCM_INTENSET_ENDCRYPT_Msk (0x1UL << CCM_INTENSET_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
N#define CCM_INTENSET_ENDCRYPT_Disabled (0UL) /*!< Read: Disabled */
N#define CCM_INTENSET_ENDCRYPT_Enabled (1UL) /*!< Read: Enabled */
N#define CCM_INTENSET_ENDCRYPT_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for ENDKSGEN event */
N#define CCM_INTENSET_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
N#define CCM_INTENSET_ENDKSGEN_Msk (0x1UL << CCM_INTENSET_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
N#define CCM_INTENSET_ENDKSGEN_Disabled (0UL) /*!< Read: Disabled */
N#define CCM_INTENSET_ENDKSGEN_Enabled (1UL) /*!< Read: Enabled */
N#define CCM_INTENSET_ENDKSGEN_Set (1UL) /*!< Enable */
N
N/* Register: CCM_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 2 : Write '1' to Disable interrupt for ERROR event */
N#define CCM_INTENCLR_ERROR_Pos (2UL) /*!< Position of ERROR field. */
N#define CCM_INTENCLR_ERROR_Msk (0x1UL << CCM_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define CCM_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define CCM_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define CCM_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for ENDCRYPT event */
N#define CCM_INTENCLR_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
N#define CCM_INTENCLR_ENDCRYPT_Msk (0x1UL << CCM_INTENCLR_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
N#define CCM_INTENCLR_ENDCRYPT_Disabled (0UL) /*!< Read: Disabled */
N#define CCM_INTENCLR_ENDCRYPT_Enabled (1UL) /*!< Read: Enabled */
N#define CCM_INTENCLR_ENDCRYPT_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for ENDKSGEN event */
N#define CCM_INTENCLR_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
N#define CCM_INTENCLR_ENDKSGEN_Msk (0x1UL << CCM_INTENCLR_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
N#define CCM_INTENCLR_ENDKSGEN_Disabled (0UL) /*!< Read: Disabled */
N#define CCM_INTENCLR_ENDKSGEN_Enabled (1UL) /*!< Read: Enabled */
N#define CCM_INTENCLR_ENDKSGEN_Clear (1UL) /*!< Disable */
N
N/* Register: CCM_MICSTATUS */
N/* Description: MIC check result */
N
N/* Bit 0 : The result of the MIC check performed during the previous decryption operation */
N#define CCM_MICSTATUS_MICSTATUS_Pos (0UL) /*!< Position of MICSTATUS field. */
N#define CCM_MICSTATUS_MICSTATUS_Msk (0x1UL << CCM_MICSTATUS_MICSTATUS_Pos) /*!< Bit mask of MICSTATUS field. */
N#define CCM_MICSTATUS_MICSTATUS_CheckFailed (0UL) /*!< MIC check failed */
N#define CCM_MICSTATUS_MICSTATUS_CheckPassed (1UL) /*!< MIC check passed */
N
N/* Register: CCM_ENABLE */
N/* Description: Enable */
N
N/* Bits 1..0 : Enable or disable CCM */
N#define CCM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define CCM_ENABLE_ENABLE_Msk (0x3UL << CCM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define CCM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
N#define CCM_ENABLE_ENABLE_Enabled (2UL) /*!< Enable */
N
N/* Register: CCM_MODE */
N/* Description: Operation mode */
N
N/* Bit 24 : Packet length configuration */
N#define CCM_MODE_LENGTH_Pos (24UL) /*!< Position of LENGTH field. */
N#define CCM_MODE_LENGTH_Msk (0x1UL << CCM_MODE_LENGTH_Pos) /*!< Bit mask of LENGTH field. */
N#define CCM_MODE_LENGTH_Default (0UL) /*!< Default length. Effective length of LENGTH field is 5-bit */
N#define CCM_MODE_LENGTH_Extended (1UL) /*!< Extended length. Effective length of LENGTH field is 8-bit */
N
N/* Bit 16 : Data rate that the CCM shall run in synch with */
N#define CCM_MODE_DATARATE_Pos (16UL) /*!< Position of DATARATE field. */
N#define CCM_MODE_DATARATE_Msk (0x1UL << CCM_MODE_DATARATE_Pos) /*!< Bit mask of DATARATE field. */
N#define CCM_MODE_DATARATE_1Mbit (0UL) /*!< In synch with 1 Mbit data rate */
N#define CCM_MODE_DATARATE_2Mbit (1UL) /*!< In synch with 2 Mbit data rate */
N
N/* Bit 0 : The mode of operation to be used */
N#define CCM_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define CCM_MODE_MODE_Msk (0x1UL << CCM_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define CCM_MODE_MODE_Encryption (0UL) /*!< AES CCM packet encryption mode */
N#define CCM_MODE_MODE_Decryption (1UL) /*!< AES CCM packet decryption mode */
N
N/* Register: CCM_CNFPTR */
N/* Description: Pointer to data structure holding AES key and NONCE vector */
N
N/* Bits 31..0 : Pointer to the data structure holding the AES key and the CCM NONCE vector (see Table 1 CCM data structure overview) */
N#define CCM_CNFPTR_CNFPTR_Pos (0UL) /*!< Position of CNFPTR field. */
N#define CCM_CNFPTR_CNFPTR_Msk (0xFFFFFFFFUL << CCM_CNFPTR_CNFPTR_Pos) /*!< Bit mask of CNFPTR field. */
N
N/* Register: CCM_INPTR */
N/* Description: Input pointer */
N
N/* Bits 31..0 : Input pointer */
N#define CCM_INPTR_INPTR_Pos (0UL) /*!< Position of INPTR field. */
N#define CCM_INPTR_INPTR_Msk (0xFFFFFFFFUL << CCM_INPTR_INPTR_Pos) /*!< Bit mask of INPTR field. */
N
N/* Register: CCM_OUTPTR */
N/* Description: Output pointer */
N
N/* Bits 31..0 : Output pointer */
N#define CCM_OUTPTR_OUTPTR_Pos (0UL) /*!< Position of OUTPTR field. */
N#define CCM_OUTPTR_OUTPTR_Msk (0xFFFFFFFFUL << CCM_OUTPTR_OUTPTR_Pos) /*!< Bit mask of OUTPTR field. */
N
N/* Register: CCM_SCRATCHPTR */
N/* Description: Pointer to data area used for temporary storage */
N
N/* Bits 31..0 : Pointer to a scratch data area used for temporary storage during key-stream generation, MIC generation and encryption/decryption. */
N#define CCM_SCRATCHPTR_SCRATCHPTR_Pos (0UL) /*!< Position of SCRATCHPTR field. */
N#define CCM_SCRATCHPTR_SCRATCHPTR_Msk (0xFFFFFFFFUL << CCM_SCRATCHPTR_SCRATCHPTR_Pos) /*!< Bit mask of SCRATCHPTR field. */
N
N
N/* Peripheral: CLOCK */
N/* Description: Clock control */
N
N/* Register: CLOCK_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 4 : Write '1' to Enable interrupt for CTTO event */
N#define CLOCK_INTENSET_CTTO_Pos (4UL) /*!< Position of CTTO field. */
N#define CLOCK_INTENSET_CTTO_Msk (0x1UL << CLOCK_INTENSET_CTTO_Pos) /*!< Bit mask of CTTO field. */
N#define CLOCK_INTENSET_CTTO_Disabled (0UL) /*!< Read: Disabled */
N#define CLOCK_INTENSET_CTTO_Enabled (1UL) /*!< Read: Enabled */
N#define CLOCK_INTENSET_CTTO_Set (1UL) /*!< Enable */
N
N/* Bit 3 : Write '1' to Enable interrupt for DONE event */
N#define CLOCK_INTENSET_DONE_Pos (3UL) /*!< Position of DONE field. */
N#define CLOCK_INTENSET_DONE_Msk (0x1UL << CLOCK_INTENSET_DONE_Pos) /*!< Bit mask of DONE field. */
N#define CLOCK_INTENSET_DONE_Disabled (0UL) /*!< Read: Disabled */
N#define CLOCK_INTENSET_DONE_Enabled (1UL) /*!< Read: Enabled */
N#define CLOCK_INTENSET_DONE_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for LFCLKSTARTED event */
N#define CLOCK_INTENSET_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define CLOCK_INTENSET_LFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define CLOCK_INTENSET_LFCLKSTARTED_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for HFCLKSTARTED event */
N#define CLOCK_INTENSET_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define CLOCK_INTENSET_HFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define CLOCK_INTENSET_HFCLKSTARTED_Set (1UL) /*!< Enable */
N
N/* Register: CLOCK_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 4 : Write '1' to Disable interrupt for CTTO event */
N#define CLOCK_INTENCLR_CTTO_Pos (4UL) /*!< Position of CTTO field. */
N#define CLOCK_INTENCLR_CTTO_Msk (0x1UL << CLOCK_INTENCLR_CTTO_Pos) /*!< Bit mask of CTTO field. */
N#define CLOCK_INTENCLR_CTTO_Disabled (0UL) /*!< Read: Disabled */
N#define CLOCK_INTENCLR_CTTO_Enabled (1UL) /*!< Read: Enabled */
N#define CLOCK_INTENCLR_CTTO_Clear (1UL) /*!< Disable */
N
N/* Bit 3 : Write '1' to Disable interrupt for DONE event */
N#define CLOCK_INTENCLR_DONE_Pos (3UL) /*!< Position of DONE field. */
N#define CLOCK_INTENCLR_DONE_Msk (0x1UL << CLOCK_INTENCLR_DONE_Pos) /*!< Bit mask of DONE field. */
N#define CLOCK_INTENCLR_DONE_Disabled (0UL) /*!< Read: Disabled */
N#define CLOCK_INTENCLR_DONE_Enabled (1UL) /*!< Read: Enabled */
N#define CLOCK_INTENCLR_DONE_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for LFCLKSTARTED event */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for HFCLKSTARTED event */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Clear (1UL) /*!< Disable */
N
N/* Register: CLOCK_HFCLKRUN */
N/* Description: Status indicating that HFCLKSTART task has been triggered */
N
N/* Bit 0 : HFCLKSTART task triggered or not */
N#define CLOCK_HFCLKRUN_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define CLOCK_HFCLKRUN_STATUS_Msk (0x1UL << CLOCK_HFCLKRUN_STATUS_Pos) /*!< Bit mask of STATUS field. */
N#define CLOCK_HFCLKRUN_STATUS_NotTriggered (0UL) /*!< Task not triggered */
N#define CLOCK_HFCLKRUN_STATUS_Triggered (1UL) /*!< Task triggered */
N
N/* Register: CLOCK_HFCLKSTAT */
N/* Description: HFCLK status */
N
N/* Bit 16 : HFCLK state */
N#define CLOCK_HFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
N#define CLOCK_HFCLKSTAT_STATE_Msk (0x1UL << CLOCK_HFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
N#define CLOCK_HFCLKSTAT_STATE_NotRunning (0UL) /*!< HFCLK not running */
N#define CLOCK_HFCLKSTAT_STATE_Running (1UL) /*!< HFCLK running */
N
N/* Bit 0 : Source of HFCLK */
N#define CLOCK_HFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_HFCLKSTAT_SRC_Msk (0x1UL << CLOCK_HFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_HFCLKSTAT_SRC_RC (0UL) /*!< 64 MHz internal oscillator (HFINT) */
N#define CLOCK_HFCLKSTAT_SRC_Xtal (1UL) /*!< 64 MHz crystal oscillator (HFXO) */
N
N/* Register: CLOCK_LFCLKRUN */
N/* Description: Status indicating that LFCLKSTART task has been triggered */
N
N/* Bit 0 : LFCLKSTART task triggered or not */
N#define CLOCK_LFCLKRUN_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define CLOCK_LFCLKRUN_STATUS_Msk (0x1UL << CLOCK_LFCLKRUN_STATUS_Pos) /*!< Bit mask of STATUS field. */
N#define CLOCK_LFCLKRUN_STATUS_NotTriggered (0UL) /*!< Task not triggered */
N#define CLOCK_LFCLKRUN_STATUS_Triggered (1UL) /*!< Task triggered */
N
N/* Register: CLOCK_LFCLKSTAT */
N/* Description: LFCLK status */
N
N/* Bit 16 : LFCLK state */
N#define CLOCK_LFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
N#define CLOCK_LFCLKSTAT_STATE_Msk (0x1UL << CLOCK_LFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
N#define CLOCK_LFCLKSTAT_STATE_NotRunning (0UL) /*!< LFCLK not running */
N#define CLOCK_LFCLKSTAT_STATE_Running (1UL) /*!< LFCLK running */
N
N/* Bits 1..0 : Source of LFCLK */
N#define CLOCK_LFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSTAT_SRC_Msk (0x3UL << CLOCK_LFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSTAT_SRC_RC (0UL) /*!< 32.768 kHz RC oscillator */
N#define CLOCK_LFCLKSTAT_SRC_Xtal (1UL) /*!< 32.768 kHz crystal oscillator */
N#define CLOCK_LFCLKSTAT_SRC_Synth (2UL) /*!< 32.768 kHz synthesized from HFCLK */
N
N/* Register: CLOCK_LFCLKSRCCOPY */
N/* Description: Copy of LFCLKSRC register, set when LFCLKSTART task was triggered */
N
N/* Bits 1..0 : Clock source */
N#define CLOCK_LFCLKSRCCOPY_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSRCCOPY_SRC_Msk (0x3UL << CLOCK_LFCLKSRCCOPY_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSRCCOPY_SRC_RC (0UL) /*!< 32.768 kHz RC oscillator */
N#define CLOCK_LFCLKSRCCOPY_SRC_Xtal (1UL) /*!< 32.768 kHz crystal oscillator */
N#define CLOCK_LFCLKSRCCOPY_SRC_Synth (2UL) /*!< 32.768 kHz synthesized from HFCLK */
N
N/* Register: CLOCK_LFCLKSRC */
N/* Description: Clock source for the LFCLK */
N
N/* Bit 17 : Enable or disable external source for LFCLK */
N#define CLOCK_LFCLKSRC_EXTERNAL_Pos (17UL) /*!< Position of EXTERNAL field. */
N#define CLOCK_LFCLKSRC_EXTERNAL_Msk (0x1UL << CLOCK_LFCLKSRC_EXTERNAL_Pos) /*!< Bit mask of EXTERNAL field. */
N#define CLOCK_LFCLKSRC_EXTERNAL_Disabled (0UL) /*!< Disable external source (use with Xtal) */
N#define CLOCK_LFCLKSRC_EXTERNAL_Enabled (1UL) /*!< Enable use of external source instead of Xtal (SRC needs to be set to Xtal) */
N
N/* Bit 16 : Enable or disable bypass of LFCLK crystal oscillator with external clock source */
N#define CLOCK_LFCLKSRC_BYPASS_Pos (16UL) /*!< Position of BYPASS field. */
N#define CLOCK_LFCLKSRC_BYPASS_Msk (0x1UL << CLOCK_LFCLKSRC_BYPASS_Pos) /*!< Bit mask of BYPASS field. */
N#define CLOCK_LFCLKSRC_BYPASS_Disabled (0UL) /*!< Disable (use with Xtal or low-swing external source) */
N#define CLOCK_LFCLKSRC_BYPASS_Enabled (1UL) /*!< Enable (use with rail-to-rail external source) */
N
N/* Bits 1..0 : Clock source */
N#define CLOCK_LFCLKSRC_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSRC_SRC_Msk (0x3UL << CLOCK_LFCLKSRC_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSRC_SRC_RC (0UL) /*!< 32.768 kHz RC oscillator */
N#define CLOCK_LFCLKSRC_SRC_Xtal (1UL) /*!< 32.768 kHz crystal oscillator */
N#define CLOCK_LFCLKSRC_SRC_Synth (2UL) /*!< 32.768 kHz synthesized from HFCLK */
N
N/* Register: CLOCK_CTIV */
N/* Description: Calibration timer interval */
N
N/* Bits 6..0 : Calibration timer interval in multiple of 0.25 seconds. Range: 0.25 seconds to 31.75 seconds. */
N#define CLOCK_CTIV_CTIV_Pos (0UL) /*!< Position of CTIV field. */
N#define CLOCK_CTIV_CTIV_Msk (0x7FUL << CLOCK_CTIV_CTIV_Pos) /*!< Bit mask of CTIV field. */
N
N/* Register: CLOCK_TRACECONFIG */
N/* Description: Clocking options for the Trace Port debug interface */
N
N/* Bits 17..16 : Pin multiplexing of trace signals. */
N#define CLOCK_TRACECONFIG_TRACEMUX_Pos (16UL) /*!< Position of TRACEMUX field. */
N#define CLOCK_TRACECONFIG_TRACEMUX_Msk (0x3UL << CLOCK_TRACECONFIG_TRACEMUX_Pos) /*!< Bit mask of TRACEMUX field. */
N#define CLOCK_TRACECONFIG_TRACEMUX_GPIO (0UL) /*!< GPIOs multiplexed onto all trace-pins */
N#define CLOCK_TRACECONFIG_TRACEMUX_Serial (1UL) /*!< SWO multiplexed onto P0.18, GPIO multiplexed onto other trace pins */
N#define CLOCK_TRACECONFIG_TRACEMUX_Parallel (2UL) /*!< TRACECLK and TRACEDATA multiplexed onto P0.20, P0.18, P0.16, P0.15 and P0.14. */
N
N/* Bits 1..0 : Speed of Trace Port clock. Note that the TRACECLK pin will output this clock divided by two. */
N#define CLOCK_TRACECONFIG_TRACEPORTSPEED_Pos (0UL) /*!< Position of TRACEPORTSPEED field. */
N#define CLOCK_TRACECONFIG_TRACEPORTSPEED_Msk (0x3UL << CLOCK_TRACECONFIG_TRACEPORTSPEED_Pos) /*!< Bit mask of TRACEPORTSPEED field. */
N#define CLOCK_TRACECONFIG_TRACEPORTSPEED_32MHz (0UL) /*!< 32 MHz Trace Port clock (TRACECLK = 16 MHz) */
N#define CLOCK_TRACECONFIG_TRACEPORTSPEED_16MHz (1UL) /*!< 16 MHz Trace Port clock (TRACECLK = 8 MHz) */
N#define CLOCK_TRACECONFIG_TRACEPORTSPEED_8MHz (2UL) /*!< 8 MHz Trace Port clock (TRACECLK = 4 MHz) */
N#define CLOCK_TRACECONFIG_TRACEPORTSPEED_4MHz (3UL) /*!< 4 MHz Trace Port clock (TRACECLK = 2 MHz) */
N
N
N/* Peripheral: COMP */
N/* Description: Comparator */
N
N/* Register: COMP_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 4 : Shortcut between CROSS event and STOP task */
N#define COMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
N#define COMP_SHORTS_CROSS_STOP_Msk (0x1UL << COMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
N#define COMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define COMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 3 : Shortcut between UP event and STOP task */
N#define COMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
N#define COMP_SHORTS_UP_STOP_Msk (0x1UL << COMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
N#define COMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define COMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 2 : Shortcut between DOWN event and STOP task */
N#define COMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
N#define COMP_SHORTS_DOWN_STOP_Msk (0x1UL << COMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
N#define COMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define COMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 1 : Shortcut between READY event and STOP task */
N#define COMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
N#define COMP_SHORTS_READY_STOP_Msk (0x1UL << COMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
N#define COMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define COMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 0 : Shortcut between READY event and SAMPLE task */
N#define COMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
N#define COMP_SHORTS_READY_SAMPLE_Msk (0x1UL << COMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
N#define COMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Disable shortcut */
N#define COMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: COMP_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 3 : Enable or disable interrupt for CROSS event */
N#define COMP_INTEN_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define COMP_INTEN_CROSS_Msk (0x1UL << COMP_INTEN_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define COMP_INTEN_CROSS_Disabled (0UL) /*!< Disable */
N#define COMP_INTEN_CROSS_Enabled (1UL) /*!< Enable */
N
N/* Bit 2 : Enable or disable interrupt for UP event */
N#define COMP_INTEN_UP_Pos (2UL) /*!< Position of UP field. */
N#define COMP_INTEN_UP_Msk (0x1UL << COMP_INTEN_UP_Pos) /*!< Bit mask of UP field. */
N#define COMP_INTEN_UP_Disabled (0UL) /*!< Disable */
N#define COMP_INTEN_UP_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for DOWN event */
N#define COMP_INTEN_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define COMP_INTEN_DOWN_Msk (0x1UL << COMP_INTEN_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define COMP_INTEN_DOWN_Disabled (0UL) /*!< Disable */
N#define COMP_INTEN_DOWN_Enabled (1UL) /*!< Enable */
N
N/* Bit 0 : Enable or disable interrupt for READY event */
N#define COMP_INTEN_READY_Pos (0UL) /*!< Position of READY field. */
N#define COMP_INTEN_READY_Msk (0x1UL << COMP_INTEN_READY_Pos) /*!< Bit mask of READY field. */
N#define COMP_INTEN_READY_Disabled (0UL) /*!< Disable */
N#define COMP_INTEN_READY_Enabled (1UL) /*!< Enable */
N
N/* Register: COMP_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 3 : Write '1' to Enable interrupt for CROSS event */
N#define COMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define COMP_INTENSET_CROSS_Msk (0x1UL << COMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define COMP_INTENSET_CROSS_Disabled (0UL) /*!< Read: Disabled */
N#define COMP_INTENSET_CROSS_Enabled (1UL) /*!< Read: Enabled */
N#define COMP_INTENSET_CROSS_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for UP event */
N#define COMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
N#define COMP_INTENSET_UP_Msk (0x1UL << COMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
N#define COMP_INTENSET_UP_Disabled (0UL) /*!< Read: Disabled */
N#define COMP_INTENSET_UP_Enabled (1UL) /*!< Read: Enabled */
N#define COMP_INTENSET_UP_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for DOWN event */
N#define COMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define COMP_INTENSET_DOWN_Msk (0x1UL << COMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define COMP_INTENSET_DOWN_Disabled (0UL) /*!< Read: Disabled */
N#define COMP_INTENSET_DOWN_Enabled (1UL) /*!< Read: Enabled */
N#define COMP_INTENSET_DOWN_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for READY event */
N#define COMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define COMP_INTENSET_READY_Msk (0x1UL << COMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define COMP_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
N#define COMP_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
N#define COMP_INTENSET_READY_Set (1UL) /*!< Enable */
N
N/* Register: COMP_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 3 : Write '1' to Disable interrupt for CROSS event */
N#define COMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define COMP_INTENCLR_CROSS_Msk (0x1UL << COMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define COMP_INTENCLR_CROSS_Disabled (0UL) /*!< Read: Disabled */
N#define COMP_INTENCLR_CROSS_Enabled (1UL) /*!< Read: Enabled */
N#define COMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for UP event */
N#define COMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
N#define COMP_INTENCLR_UP_Msk (0x1UL << COMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
N#define COMP_INTENCLR_UP_Disabled (0UL) /*!< Read: Disabled */
N#define COMP_INTENCLR_UP_Enabled (1UL) /*!< Read: Enabled */
N#define COMP_INTENCLR_UP_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for DOWN event */
N#define COMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define COMP_INTENCLR_DOWN_Msk (0x1UL << COMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define COMP_INTENCLR_DOWN_Disabled (0UL) /*!< Read: Disabled */
N#define COMP_INTENCLR_DOWN_Enabled (1UL) /*!< Read: Enabled */
N#define COMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for READY event */
N#define COMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define COMP_INTENCLR_READY_Msk (0x1UL << COMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define COMP_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
N#define COMP_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
N#define COMP_INTENCLR_READY_Clear (1UL) /*!< Disable */
N
N/* Register: COMP_RESULT */
N/* Description: Compare result */
N
N/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
N#define COMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define COMP_RESULT_RESULT_Msk (0x1UL << COMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N#define COMP_RESULT_RESULT_Below (0UL) /*!< Input voltage is below the threshold (VIN+ &lt; VIN-) */
N#define COMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the threshold (VIN+ &gt; VIN-) */
N
N/* Register: COMP_ENABLE */
N/* Description: COMP enable */
N
N/* Bits 1..0 : Enable or disable COMP */
N#define COMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define COMP_ENABLE_ENABLE_Msk (0x3UL << COMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define COMP_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
N#define COMP_ENABLE_ENABLE_Enabled (2UL) /*!< Enable */
N
N/* Register: COMP_PSEL */
N/* Description: Pin select */
N
N/* Bits 2..0 : Analog pin select */
N#define COMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
N#define COMP_PSEL_PSEL_Msk (0x7UL << COMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define COMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< AIN0 selected as analog input */
N#define COMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< AIN1 selected as analog input */
N#define COMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< AIN2 selected as analog input */
N#define COMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< AIN3 selected as analog input */
N#define COMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< AIN4 selected as analog input */
N#define COMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< AIN5 selected as analog input */
N#define COMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< AIN6 selected as analog input */
N#define COMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< AIN7 selected as analog input */
N
N/* Register: COMP_REFSEL */
N/* Description: Reference source select */
N
N/* Bits 2..0 : Reference select */
N#define COMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
N#define COMP_REFSEL_REFSEL_Msk (0x7UL << COMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define COMP_REFSEL_REFSEL_Int1V2 (0UL) /*!< VREF = internal 1.2 V reference (VDD &gt;= 1.7 V) */
N#define COMP_REFSEL_REFSEL_Int1V8 (1UL) /*!< VREF = internal 1.8 V reference (VDD &gt;= VREF + 0.2 V) */
N#define COMP_REFSEL_REFSEL_Int2V4 (2UL) /*!< VREF = internal 2.4 V reference (VDD &gt;= VREF + 0.2 V) */
N#define COMP_REFSEL_REFSEL_VDD (4UL) /*!< VREF = VDD */
N#define COMP_REFSEL_REFSEL_ARef (7UL) /*!< VREF = AREF (VDD &gt;= VREF &gt;= AREFMIN) */
N
N/* Register: COMP_EXTREFSEL */
N/* Description: External reference select */
N
N/* Bit 0 : External analog reference select */
N#define COMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
N#define COMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << COMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use AIN0 as external analog reference */
N#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use AIN1 as external analog reference */
N
N/* Register: COMP_TH */
N/* Description: Threshold configuration for hysteresis unit */
N
N/* Bits 13..8 : VUP = (THUP+1)/64*VREF */
N#define COMP_TH_THUP_Pos (8UL) /*!< Position of THUP field. */
N#define COMP_TH_THUP_Msk (0x3FUL << COMP_TH_THUP_Pos) /*!< Bit mask of THUP field. */
N
N/* Bits 5..0 : VDOWN = (THDOWN+1)/64*VREF */
N#define COMP_TH_THDOWN_Pos (0UL) /*!< Position of THDOWN field. */
N#define COMP_TH_THDOWN_Msk (0x3FUL << COMP_TH_THDOWN_Pos) /*!< Bit mask of THDOWN field. */
N
N/* Register: COMP_MODE */
N/* Description: Mode configuration */
N
N/* Bit 8 : Main operation mode */
N#define COMP_MODE_MAIN_Pos (8UL) /*!< Position of MAIN field. */
N#define COMP_MODE_MAIN_Msk (0x1UL << COMP_MODE_MAIN_Pos) /*!< Bit mask of MAIN field. */
N#define COMP_MODE_MAIN_SE (0UL) /*!< Single ended mode */
N#define COMP_MODE_MAIN_Diff (1UL) /*!< Differential mode */
N
N/* Bits 1..0 : Speed and power mode */
N#define COMP_MODE_SP_Pos (0UL) /*!< Position of SP field. */
N#define COMP_MODE_SP_Msk (0x3UL << COMP_MODE_SP_Pos) /*!< Bit mask of SP field. */
N#define COMP_MODE_SP_Low (0UL) /*!< Low power mode */
N#define COMP_MODE_SP_Normal (1UL) /*!< Normal mode */
N#define COMP_MODE_SP_High (2UL) /*!< High speed mode */
N
N/* Register: COMP_HYST */
N/* Description: Comparator hysteresis enable */
N
N/* Bit 0 : Comparator hysteresis */
N#define COMP_HYST_HYST_Pos (0UL) /*!< Position of HYST field. */
N#define COMP_HYST_HYST_Msk (0x1UL << COMP_HYST_HYST_Pos) /*!< Bit mask of HYST field. */
N#define COMP_HYST_HYST_NoHyst (0UL) /*!< Comparator hysteresis disabled */
N#define COMP_HYST_HYST_Hyst50mV (1UL) /*!< Comparator hysteresis enabled */
N
N/* Register: COMP_ISOURCE */
N/* Description: Current source select on analog input */
N
N/* Bits 1..0 : Comparator hysteresis */
N#define COMP_ISOURCE_ISOURCE_Pos (0UL) /*!< Position of ISOURCE field. */
N#define COMP_ISOURCE_ISOURCE_Msk (0x3UL << COMP_ISOURCE_ISOURCE_Pos) /*!< Bit mask of ISOURCE field. */
N#define COMP_ISOURCE_ISOURCE_Off (0UL) /*!< Current source disabled */
N#define COMP_ISOURCE_ISOURCE_Ien2mA5 (1UL) /*!< Current source enabled (+/- 2.5 uA) */
N#define COMP_ISOURCE_ISOURCE_Ien5mA (2UL) /*!< Current source enabled (+/- 5 uA) */
N#define COMP_ISOURCE_ISOURCE_Ien10mA (3UL) /*!< Current source enabled (+/- 10 uA) */
N
N
N/* Peripheral: ECB */
N/* Description: AES ECB Mode Encryption */
N
N/* Register: ECB_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 1 : Write '1' to Enable interrupt for ERRORECB event */
N#define ECB_INTENSET_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
N#define ECB_INTENSET_ERRORECB_Msk (0x1UL << ECB_INTENSET_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
N#define ECB_INTENSET_ERRORECB_Disabled (0UL) /*!< Read: Disabled */
N#define ECB_INTENSET_ERRORECB_Enabled (1UL) /*!< Read: Enabled */
N#define ECB_INTENSET_ERRORECB_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for ENDECB event */
N#define ECB_INTENSET_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
N#define ECB_INTENSET_ENDECB_Msk (0x1UL << ECB_INTENSET_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
N#define ECB_INTENSET_ENDECB_Disabled (0UL) /*!< Read: Disabled */
N#define ECB_INTENSET_ENDECB_Enabled (1UL) /*!< Read: Enabled */
N#define ECB_INTENSET_ENDECB_Set (1UL) /*!< Enable */
N
N/* Register: ECB_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 1 : Write '1' to Disable interrupt for ERRORECB event */
N#define ECB_INTENCLR_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
N#define ECB_INTENCLR_ERRORECB_Msk (0x1UL << ECB_INTENCLR_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
N#define ECB_INTENCLR_ERRORECB_Disabled (0UL) /*!< Read: Disabled */
N#define ECB_INTENCLR_ERRORECB_Enabled (1UL) /*!< Read: Enabled */
N#define ECB_INTENCLR_ERRORECB_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for ENDECB event */
N#define ECB_INTENCLR_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
N#define ECB_INTENCLR_ENDECB_Msk (0x1UL << ECB_INTENCLR_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
N#define ECB_INTENCLR_ENDECB_Disabled (0UL) /*!< Read: Disabled */
N#define ECB_INTENCLR_ENDECB_Enabled (1UL) /*!< Read: Enabled */
N#define ECB_INTENCLR_ENDECB_Clear (1UL) /*!< Disable */
N
N/* Register: ECB_ECBDATAPTR */
N/* Description: ECB block encrypt memory pointers */
N
N/* Bits 31..0 : Pointer to the ECB data structure (see Table 1 ECB data structure overview) */
N#define ECB_ECBDATAPTR_ECBDATAPTR_Pos (0UL) /*!< Position of ECBDATAPTR field. */
N#define ECB_ECBDATAPTR_ECBDATAPTR_Msk (0xFFFFFFFFUL << ECB_ECBDATAPTR_ECBDATAPTR_Pos) /*!< Bit mask of ECBDATAPTR field. */
N
N
N/* Peripheral: EGU */
N/* Description: Event Generator Unit 0 */
N
N/* Register: EGU_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 15 : Enable or disable interrupt for TRIGGERED[15] event */
N#define EGU_INTEN_TRIGGERED15_Pos (15UL) /*!< Position of TRIGGERED15 field. */
N#define EGU_INTEN_TRIGGERED15_Msk (0x1UL << EGU_INTEN_TRIGGERED15_Pos) /*!< Bit mask of TRIGGERED15 field. */
N#define EGU_INTEN_TRIGGERED15_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED15_Enabled (1UL) /*!< Enable */
N
N/* Bit 14 : Enable or disable interrupt for TRIGGERED[14] event */
N#define EGU_INTEN_TRIGGERED14_Pos (14UL) /*!< Position of TRIGGERED14 field. */
N#define EGU_INTEN_TRIGGERED14_Msk (0x1UL << EGU_INTEN_TRIGGERED14_Pos) /*!< Bit mask of TRIGGERED14 field. */
N#define EGU_INTEN_TRIGGERED14_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED14_Enabled (1UL) /*!< Enable */
N
N/* Bit 13 : Enable or disable interrupt for TRIGGERED[13] event */
N#define EGU_INTEN_TRIGGERED13_Pos (13UL) /*!< Position of TRIGGERED13 field. */
N#define EGU_INTEN_TRIGGERED13_Msk (0x1UL << EGU_INTEN_TRIGGERED13_Pos) /*!< Bit mask of TRIGGERED13 field. */
N#define EGU_INTEN_TRIGGERED13_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED13_Enabled (1UL) /*!< Enable */
N
N/* Bit 12 : Enable or disable interrupt for TRIGGERED[12] event */
N#define EGU_INTEN_TRIGGERED12_Pos (12UL) /*!< Position of TRIGGERED12 field. */
N#define EGU_INTEN_TRIGGERED12_Msk (0x1UL << EGU_INTEN_TRIGGERED12_Pos) /*!< Bit mask of TRIGGERED12 field. */
N#define EGU_INTEN_TRIGGERED12_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED12_Enabled (1UL) /*!< Enable */
N
N/* Bit 11 : Enable or disable interrupt for TRIGGERED[11] event */
N#define EGU_INTEN_TRIGGERED11_Pos (11UL) /*!< Position of TRIGGERED11 field. */
N#define EGU_INTEN_TRIGGERED11_Msk (0x1UL << EGU_INTEN_TRIGGERED11_Pos) /*!< Bit mask of TRIGGERED11 field. */
N#define EGU_INTEN_TRIGGERED11_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED11_Enabled (1UL) /*!< Enable */
N
N/* Bit 10 : Enable or disable interrupt for TRIGGERED[10] event */
N#define EGU_INTEN_TRIGGERED10_Pos (10UL) /*!< Position of TRIGGERED10 field. */
N#define EGU_INTEN_TRIGGERED10_Msk (0x1UL << EGU_INTEN_TRIGGERED10_Pos) /*!< Bit mask of TRIGGERED10 field. */
N#define EGU_INTEN_TRIGGERED10_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED10_Enabled (1UL) /*!< Enable */
N
N/* Bit 9 : Enable or disable interrupt for TRIGGERED[9] event */
N#define EGU_INTEN_TRIGGERED9_Pos (9UL) /*!< Position of TRIGGERED9 field. */
N#define EGU_INTEN_TRIGGERED9_Msk (0x1UL << EGU_INTEN_TRIGGERED9_Pos) /*!< Bit mask of TRIGGERED9 field. */
N#define EGU_INTEN_TRIGGERED9_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED9_Enabled (1UL) /*!< Enable */
N
N/* Bit 8 : Enable or disable interrupt for TRIGGERED[8] event */
N#define EGU_INTEN_TRIGGERED8_Pos (8UL) /*!< Position of TRIGGERED8 field. */
N#define EGU_INTEN_TRIGGERED8_Msk (0x1UL << EGU_INTEN_TRIGGERED8_Pos) /*!< Bit mask of TRIGGERED8 field. */
N#define EGU_INTEN_TRIGGERED8_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED8_Enabled (1UL) /*!< Enable */
N
N/* Bit 7 : Enable or disable interrupt for TRIGGERED[7] event */
N#define EGU_INTEN_TRIGGERED7_Pos (7UL) /*!< Position of TRIGGERED7 field. */
N#define EGU_INTEN_TRIGGERED7_Msk (0x1UL << EGU_INTEN_TRIGGERED7_Pos) /*!< Bit mask of TRIGGERED7 field. */
N#define EGU_INTEN_TRIGGERED7_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED7_Enabled (1UL) /*!< Enable */
N
N/* Bit 6 : Enable or disable interrupt for TRIGGERED[6] event */
N#define EGU_INTEN_TRIGGERED6_Pos (6UL) /*!< Position of TRIGGERED6 field. */
N#define EGU_INTEN_TRIGGERED6_Msk (0x1UL << EGU_INTEN_TRIGGERED6_Pos) /*!< Bit mask of TRIGGERED6 field. */
N#define EGU_INTEN_TRIGGERED6_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED6_Enabled (1UL) /*!< Enable */
N
N/* Bit 5 : Enable or disable interrupt for TRIGGERED[5] event */
N#define EGU_INTEN_TRIGGERED5_Pos (5UL) /*!< Position of TRIGGERED5 field. */
N#define EGU_INTEN_TRIGGERED5_Msk (0x1UL << EGU_INTEN_TRIGGERED5_Pos) /*!< Bit mask of TRIGGERED5 field. */
N#define EGU_INTEN_TRIGGERED5_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED5_Enabled (1UL) /*!< Enable */
N
N/* Bit 4 : Enable or disable interrupt for TRIGGERED[4] event */
N#define EGU_INTEN_TRIGGERED4_Pos (4UL) /*!< Position of TRIGGERED4 field. */
N#define EGU_INTEN_TRIGGERED4_Msk (0x1UL << EGU_INTEN_TRIGGERED4_Pos) /*!< Bit mask of TRIGGERED4 field. */
N#define EGU_INTEN_TRIGGERED4_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED4_Enabled (1UL) /*!< Enable */
N
N/* Bit 3 : Enable or disable interrupt for TRIGGERED[3] event */
N#define EGU_INTEN_TRIGGERED3_Pos (3UL) /*!< Position of TRIGGERED3 field. */
N#define EGU_INTEN_TRIGGERED3_Msk (0x1UL << EGU_INTEN_TRIGGERED3_Pos) /*!< Bit mask of TRIGGERED3 field. */
N#define EGU_INTEN_TRIGGERED3_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED3_Enabled (1UL) /*!< Enable */
N
N/* Bit 2 : Enable or disable interrupt for TRIGGERED[2] event */
N#define EGU_INTEN_TRIGGERED2_Pos (2UL) /*!< Position of TRIGGERED2 field. */
N#define EGU_INTEN_TRIGGERED2_Msk (0x1UL << EGU_INTEN_TRIGGERED2_Pos) /*!< Bit mask of TRIGGERED2 field. */
N#define EGU_INTEN_TRIGGERED2_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED2_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for TRIGGERED[1] event */
N#define EGU_INTEN_TRIGGERED1_Pos (1UL) /*!< Position of TRIGGERED1 field. */
N#define EGU_INTEN_TRIGGERED1_Msk (0x1UL << EGU_INTEN_TRIGGERED1_Pos) /*!< Bit mask of TRIGGERED1 field. */
N#define EGU_INTEN_TRIGGERED1_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED1_Enabled (1UL) /*!< Enable */
N
N/* Bit 0 : Enable or disable interrupt for TRIGGERED[0] event */
N#define EGU_INTEN_TRIGGERED0_Pos (0UL) /*!< Position of TRIGGERED0 field. */
N#define EGU_INTEN_TRIGGERED0_Msk (0x1UL << EGU_INTEN_TRIGGERED0_Pos) /*!< Bit mask of TRIGGERED0 field. */
N#define EGU_INTEN_TRIGGERED0_Disabled (0UL) /*!< Disable */
N#define EGU_INTEN_TRIGGERED0_Enabled (1UL) /*!< Enable */
N
N/* Register: EGU_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 15 : Write '1' to Enable interrupt for TRIGGERED[15] event */
N#define EGU_INTENSET_TRIGGERED15_Pos (15UL) /*!< Position of TRIGGERED15 field. */
N#define EGU_INTENSET_TRIGGERED15_Msk (0x1UL << EGU_INTENSET_TRIGGERED15_Pos) /*!< Bit mask of TRIGGERED15 field. */
N#define EGU_INTENSET_TRIGGERED15_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED15_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED15_Set (1UL) /*!< Enable */
N
N/* Bit 14 : Write '1' to Enable interrupt for TRIGGERED[14] event */
N#define EGU_INTENSET_TRIGGERED14_Pos (14UL) /*!< Position of TRIGGERED14 field. */
N#define EGU_INTENSET_TRIGGERED14_Msk (0x1UL << EGU_INTENSET_TRIGGERED14_Pos) /*!< Bit mask of TRIGGERED14 field. */
N#define EGU_INTENSET_TRIGGERED14_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED14_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED14_Set (1UL) /*!< Enable */
N
N/* Bit 13 : Write '1' to Enable interrupt for TRIGGERED[13] event */
N#define EGU_INTENSET_TRIGGERED13_Pos (13UL) /*!< Position of TRIGGERED13 field. */
N#define EGU_INTENSET_TRIGGERED13_Msk (0x1UL << EGU_INTENSET_TRIGGERED13_Pos) /*!< Bit mask of TRIGGERED13 field. */
N#define EGU_INTENSET_TRIGGERED13_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED13_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED13_Set (1UL) /*!< Enable */
N
N/* Bit 12 : Write '1' to Enable interrupt for TRIGGERED[12] event */
N#define EGU_INTENSET_TRIGGERED12_Pos (12UL) /*!< Position of TRIGGERED12 field. */
N#define EGU_INTENSET_TRIGGERED12_Msk (0x1UL << EGU_INTENSET_TRIGGERED12_Pos) /*!< Bit mask of TRIGGERED12 field. */
N#define EGU_INTENSET_TRIGGERED12_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED12_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED12_Set (1UL) /*!< Enable */
N
N/* Bit 11 : Write '1' to Enable interrupt for TRIGGERED[11] event */
N#define EGU_INTENSET_TRIGGERED11_Pos (11UL) /*!< Position of TRIGGERED11 field. */
N#define EGU_INTENSET_TRIGGERED11_Msk (0x1UL << EGU_INTENSET_TRIGGERED11_Pos) /*!< Bit mask of TRIGGERED11 field. */
N#define EGU_INTENSET_TRIGGERED11_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED11_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED11_Set (1UL) /*!< Enable */
N
N/* Bit 10 : Write '1' to Enable interrupt for TRIGGERED[10] event */
N#define EGU_INTENSET_TRIGGERED10_Pos (10UL) /*!< Position of TRIGGERED10 field. */
N#define EGU_INTENSET_TRIGGERED10_Msk (0x1UL << EGU_INTENSET_TRIGGERED10_Pos) /*!< Bit mask of TRIGGERED10 field. */
N#define EGU_INTENSET_TRIGGERED10_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED10_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED10_Set (1UL) /*!< Enable */
N
N/* Bit 9 : Write '1' to Enable interrupt for TRIGGERED[9] event */
N#define EGU_INTENSET_TRIGGERED9_Pos (9UL) /*!< Position of TRIGGERED9 field. */
N#define EGU_INTENSET_TRIGGERED9_Msk (0x1UL << EGU_INTENSET_TRIGGERED9_Pos) /*!< Bit mask of TRIGGERED9 field. */
N#define EGU_INTENSET_TRIGGERED9_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED9_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED9_Set (1UL) /*!< Enable */
N
N/* Bit 8 : Write '1' to Enable interrupt for TRIGGERED[8] event */
N#define EGU_INTENSET_TRIGGERED8_Pos (8UL) /*!< Position of TRIGGERED8 field. */
N#define EGU_INTENSET_TRIGGERED8_Msk (0x1UL << EGU_INTENSET_TRIGGERED8_Pos) /*!< Bit mask of TRIGGERED8 field. */
N#define EGU_INTENSET_TRIGGERED8_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED8_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED8_Set (1UL) /*!< Enable */
N
N/* Bit 7 : Write '1' to Enable interrupt for TRIGGERED[7] event */
N#define EGU_INTENSET_TRIGGERED7_Pos (7UL) /*!< Position of TRIGGERED7 field. */
N#define EGU_INTENSET_TRIGGERED7_Msk (0x1UL << EGU_INTENSET_TRIGGERED7_Pos) /*!< Bit mask of TRIGGERED7 field. */
N#define EGU_INTENSET_TRIGGERED7_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED7_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED7_Set (1UL) /*!< Enable */
N
N/* Bit 6 : Write '1' to Enable interrupt for TRIGGERED[6] event */
N#define EGU_INTENSET_TRIGGERED6_Pos (6UL) /*!< Position of TRIGGERED6 field. */
N#define EGU_INTENSET_TRIGGERED6_Msk (0x1UL << EGU_INTENSET_TRIGGERED6_Pos) /*!< Bit mask of TRIGGERED6 field. */
N#define EGU_INTENSET_TRIGGERED6_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED6_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED6_Set (1UL) /*!< Enable */
N
N/* Bit 5 : Write '1' to Enable interrupt for TRIGGERED[5] event */
N#define EGU_INTENSET_TRIGGERED5_Pos (5UL) /*!< Position of TRIGGERED5 field. */
N#define EGU_INTENSET_TRIGGERED5_Msk (0x1UL << EGU_INTENSET_TRIGGERED5_Pos) /*!< Bit mask of TRIGGERED5 field. */
N#define EGU_INTENSET_TRIGGERED5_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED5_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED5_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable interrupt for TRIGGERED[4] event */
N#define EGU_INTENSET_TRIGGERED4_Pos (4UL) /*!< Position of TRIGGERED4 field. */
N#define EGU_INTENSET_TRIGGERED4_Msk (0x1UL << EGU_INTENSET_TRIGGERED4_Pos) /*!< Bit mask of TRIGGERED4 field. */
N#define EGU_INTENSET_TRIGGERED4_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED4_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED4_Set (1UL) /*!< Enable */
N
N/* Bit 3 : Write '1' to Enable interrupt for TRIGGERED[3] event */
N#define EGU_INTENSET_TRIGGERED3_Pos (3UL) /*!< Position of TRIGGERED3 field. */
N#define EGU_INTENSET_TRIGGERED3_Msk (0x1UL << EGU_INTENSET_TRIGGERED3_Pos) /*!< Bit mask of TRIGGERED3 field. */
N#define EGU_INTENSET_TRIGGERED3_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED3_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED3_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for TRIGGERED[2] event */
N#define EGU_INTENSET_TRIGGERED2_Pos (2UL) /*!< Position of TRIGGERED2 field. */
N#define EGU_INTENSET_TRIGGERED2_Msk (0x1UL << EGU_INTENSET_TRIGGERED2_Pos) /*!< Bit mask of TRIGGERED2 field. */
N#define EGU_INTENSET_TRIGGERED2_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED2_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED2_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for TRIGGERED[1] event */
N#define EGU_INTENSET_TRIGGERED1_Pos (1UL) /*!< Position of TRIGGERED1 field. */
N#define EGU_INTENSET_TRIGGERED1_Msk (0x1UL << EGU_INTENSET_TRIGGERED1_Pos) /*!< Bit mask of TRIGGERED1 field. */
N#define EGU_INTENSET_TRIGGERED1_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED1_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED1_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for TRIGGERED[0] event */
N#define EGU_INTENSET_TRIGGERED0_Pos (0UL) /*!< Position of TRIGGERED0 field. */
N#define EGU_INTENSET_TRIGGERED0_Msk (0x1UL << EGU_INTENSET_TRIGGERED0_Pos) /*!< Bit mask of TRIGGERED0 field. */
N#define EGU_INTENSET_TRIGGERED0_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENSET_TRIGGERED0_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENSET_TRIGGERED0_Set (1UL) /*!< Enable */
N
N/* Register: EGU_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 15 : Write '1' to Disable interrupt for TRIGGERED[15] event */
N#define EGU_INTENCLR_TRIGGERED15_Pos (15UL) /*!< Position of TRIGGERED15 field. */
N#define EGU_INTENCLR_TRIGGERED15_Msk (0x1UL << EGU_INTENCLR_TRIGGERED15_Pos) /*!< Bit mask of TRIGGERED15 field. */
N#define EGU_INTENCLR_TRIGGERED15_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED15_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED15_Clear (1UL) /*!< Disable */
N
N/* Bit 14 : Write '1' to Disable interrupt for TRIGGERED[14] event */
N#define EGU_INTENCLR_TRIGGERED14_Pos (14UL) /*!< Position of TRIGGERED14 field. */
N#define EGU_INTENCLR_TRIGGERED14_Msk (0x1UL << EGU_INTENCLR_TRIGGERED14_Pos) /*!< Bit mask of TRIGGERED14 field. */
N#define EGU_INTENCLR_TRIGGERED14_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED14_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED14_Clear (1UL) /*!< Disable */
N
N/* Bit 13 : Write '1' to Disable interrupt for TRIGGERED[13] event */
N#define EGU_INTENCLR_TRIGGERED13_Pos (13UL) /*!< Position of TRIGGERED13 field. */
N#define EGU_INTENCLR_TRIGGERED13_Msk (0x1UL << EGU_INTENCLR_TRIGGERED13_Pos) /*!< Bit mask of TRIGGERED13 field. */
N#define EGU_INTENCLR_TRIGGERED13_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED13_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED13_Clear (1UL) /*!< Disable */
N
N/* Bit 12 : Write '1' to Disable interrupt for TRIGGERED[12] event */
N#define EGU_INTENCLR_TRIGGERED12_Pos (12UL) /*!< Position of TRIGGERED12 field. */
N#define EGU_INTENCLR_TRIGGERED12_Msk (0x1UL << EGU_INTENCLR_TRIGGERED12_Pos) /*!< Bit mask of TRIGGERED12 field. */
N#define EGU_INTENCLR_TRIGGERED12_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED12_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED12_Clear (1UL) /*!< Disable */
N
N/* Bit 11 : Write '1' to Disable interrupt for TRIGGERED[11] event */
N#define EGU_INTENCLR_TRIGGERED11_Pos (11UL) /*!< Position of TRIGGERED11 field. */
N#define EGU_INTENCLR_TRIGGERED11_Msk (0x1UL << EGU_INTENCLR_TRIGGERED11_Pos) /*!< Bit mask of TRIGGERED11 field. */
N#define EGU_INTENCLR_TRIGGERED11_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED11_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED11_Clear (1UL) /*!< Disable */
N
N/* Bit 10 : Write '1' to Disable interrupt for TRIGGERED[10] event */
N#define EGU_INTENCLR_TRIGGERED10_Pos (10UL) /*!< Position of TRIGGERED10 field. */
N#define EGU_INTENCLR_TRIGGERED10_Msk (0x1UL << EGU_INTENCLR_TRIGGERED10_Pos) /*!< Bit mask of TRIGGERED10 field. */
N#define EGU_INTENCLR_TRIGGERED10_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED10_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED10_Clear (1UL) /*!< Disable */
N
N/* Bit 9 : Write '1' to Disable interrupt for TRIGGERED[9] event */
N#define EGU_INTENCLR_TRIGGERED9_Pos (9UL) /*!< Position of TRIGGERED9 field. */
N#define EGU_INTENCLR_TRIGGERED9_Msk (0x1UL << EGU_INTENCLR_TRIGGERED9_Pos) /*!< Bit mask of TRIGGERED9 field. */
N#define EGU_INTENCLR_TRIGGERED9_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED9_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED9_Clear (1UL) /*!< Disable */
N
N/* Bit 8 : Write '1' to Disable interrupt for TRIGGERED[8] event */
N#define EGU_INTENCLR_TRIGGERED8_Pos (8UL) /*!< Position of TRIGGERED8 field. */
N#define EGU_INTENCLR_TRIGGERED8_Msk (0x1UL << EGU_INTENCLR_TRIGGERED8_Pos) /*!< Bit mask of TRIGGERED8 field. */
N#define EGU_INTENCLR_TRIGGERED8_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED8_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED8_Clear (1UL) /*!< Disable */
N
N/* Bit 7 : Write '1' to Disable interrupt for TRIGGERED[7] event */
N#define EGU_INTENCLR_TRIGGERED7_Pos (7UL) /*!< Position of TRIGGERED7 field. */
N#define EGU_INTENCLR_TRIGGERED7_Msk (0x1UL << EGU_INTENCLR_TRIGGERED7_Pos) /*!< Bit mask of TRIGGERED7 field. */
N#define EGU_INTENCLR_TRIGGERED7_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED7_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED7_Clear (1UL) /*!< Disable */
N
N/* Bit 6 : Write '1' to Disable interrupt for TRIGGERED[6] event */
N#define EGU_INTENCLR_TRIGGERED6_Pos (6UL) /*!< Position of TRIGGERED6 field. */
N#define EGU_INTENCLR_TRIGGERED6_Msk (0x1UL << EGU_INTENCLR_TRIGGERED6_Pos) /*!< Bit mask of TRIGGERED6 field. */
N#define EGU_INTENCLR_TRIGGERED6_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED6_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED6_Clear (1UL) /*!< Disable */
N
N/* Bit 5 : Write '1' to Disable interrupt for TRIGGERED[5] event */
N#define EGU_INTENCLR_TRIGGERED5_Pos (5UL) /*!< Position of TRIGGERED5 field. */
N#define EGU_INTENCLR_TRIGGERED5_Msk (0x1UL << EGU_INTENCLR_TRIGGERED5_Pos) /*!< Bit mask of TRIGGERED5 field. */
N#define EGU_INTENCLR_TRIGGERED5_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED5_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED5_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable interrupt for TRIGGERED[4] event */
N#define EGU_INTENCLR_TRIGGERED4_Pos (4UL) /*!< Position of TRIGGERED4 field. */
N#define EGU_INTENCLR_TRIGGERED4_Msk (0x1UL << EGU_INTENCLR_TRIGGERED4_Pos) /*!< Bit mask of TRIGGERED4 field. */
N#define EGU_INTENCLR_TRIGGERED4_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED4_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED4_Clear (1UL) /*!< Disable */
N
N/* Bit 3 : Write '1' to Disable interrupt for TRIGGERED[3] event */
N#define EGU_INTENCLR_TRIGGERED3_Pos (3UL) /*!< Position of TRIGGERED3 field. */
N#define EGU_INTENCLR_TRIGGERED3_Msk (0x1UL << EGU_INTENCLR_TRIGGERED3_Pos) /*!< Bit mask of TRIGGERED3 field. */
N#define EGU_INTENCLR_TRIGGERED3_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED3_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED3_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for TRIGGERED[2] event */
N#define EGU_INTENCLR_TRIGGERED2_Pos (2UL) /*!< Position of TRIGGERED2 field. */
N#define EGU_INTENCLR_TRIGGERED2_Msk (0x1UL << EGU_INTENCLR_TRIGGERED2_Pos) /*!< Bit mask of TRIGGERED2 field. */
N#define EGU_INTENCLR_TRIGGERED2_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED2_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED2_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for TRIGGERED[1] event */
N#define EGU_INTENCLR_TRIGGERED1_Pos (1UL) /*!< Position of TRIGGERED1 field. */
N#define EGU_INTENCLR_TRIGGERED1_Msk (0x1UL << EGU_INTENCLR_TRIGGERED1_Pos) /*!< Bit mask of TRIGGERED1 field. */
N#define EGU_INTENCLR_TRIGGERED1_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED1_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED1_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for TRIGGERED[0] event */
N#define EGU_INTENCLR_TRIGGERED0_Pos (0UL) /*!< Position of TRIGGERED0 field. */
N#define EGU_INTENCLR_TRIGGERED0_Msk (0x1UL << EGU_INTENCLR_TRIGGERED0_Pos) /*!< Bit mask of TRIGGERED0 field. */
N#define EGU_INTENCLR_TRIGGERED0_Disabled (0UL) /*!< Read: Disabled */
N#define EGU_INTENCLR_TRIGGERED0_Enabled (1UL) /*!< Read: Enabled */
N#define EGU_INTENCLR_TRIGGERED0_Clear (1UL) /*!< Disable */
N
N
N/* Peripheral: FICR */
N/* Description: Factory Information Configuration Registers */
N
N/* Register: FICR_CODEPAGESIZE */
N/* Description: Code memory page size */
N
N/* Bits 31..0 : Code memory page size */
N#define FICR_CODEPAGESIZE_CODEPAGESIZE_Pos (0UL) /*!< Position of CODEPAGESIZE field. */
N#define FICR_CODEPAGESIZE_CODEPAGESIZE_Msk (0xFFFFFFFFUL << FICR_CODEPAGESIZE_CODEPAGESIZE_Pos) /*!< Bit mask of CODEPAGESIZE field. */
N
N/* Register: FICR_CODESIZE */
N/* Description: Code memory size */
N
N/* Bits 31..0 : Code memory size in number of pages */
N#define FICR_CODESIZE_CODESIZE_Pos (0UL) /*!< Position of CODESIZE field. */
N#define FICR_CODESIZE_CODESIZE_Msk (0xFFFFFFFFUL << FICR_CODESIZE_CODESIZE_Pos) /*!< Bit mask of CODESIZE field. */
N
N/* Register: FICR_DEVICEID */
N/* Description: Description collection[0]:  Device identifier */
N
N/* Bits 31..0 : 64 bit unique device identifier */
N#define FICR_DEVICEID_DEVICEID_Pos (0UL) /*!< Position of DEVICEID field. */
N#define FICR_DEVICEID_DEVICEID_Msk (0xFFFFFFFFUL << FICR_DEVICEID_DEVICEID_Pos) /*!< Bit mask of DEVICEID field. */
N
N/* Register: FICR_ER */
N/* Description: Description collection[0]:  Encryption Root, word 0 */
N
N/* Bits 31..0 : Encryption Root, word n */
N#define FICR_ER_ER_Pos (0UL) /*!< Position of ER field. */
N#define FICR_ER_ER_Msk (0xFFFFFFFFUL << FICR_ER_ER_Pos) /*!< Bit mask of ER field. */
N
N/* Register: FICR_IR */
N/* Description: Description collection[0]:  Identity Root, word 0 */
N
N/* Bits 31..0 : Identity Root, word n */
N#define FICR_IR_IR_Pos (0UL) /*!< Position of IR field. */
N#define FICR_IR_IR_Msk (0xFFFFFFFFUL << FICR_IR_IR_Pos) /*!< Bit mask of IR field. */
N
N/* Register: FICR_DEVICEADDRTYPE */
N/* Description: Device address type */
N
N/* Bit 0 : Device address type */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos (0UL) /*!< Position of DEVICEADDRTYPE field. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Msk (0x1UL << FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos) /*!< Bit mask of DEVICEADDRTYPE field. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Public (0UL) /*!< Public address */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Random (1UL) /*!< Random address */
N
N/* Register: FICR_DEVICEADDR */
N/* Description: Description collection[0]:  Device address 0 */
N
N/* Bits 31..0 : 48 bit device address */
N#define FICR_DEVICEADDR_DEVICEADDR_Pos (0UL) /*!< Position of DEVICEADDR field. */
N#define FICR_DEVICEADDR_DEVICEADDR_Msk (0xFFFFFFFFUL << FICR_DEVICEADDR_DEVICEADDR_Pos) /*!< Bit mask of DEVICEADDR field. */
N
N/* Register: FICR_INFO_PART */
N/* Description: Part code */
N
N/* Bits 31..0 : Part code */
N#define FICR_INFO_PART_PART_Pos (0UL) /*!< Position of PART field. */
N#define FICR_INFO_PART_PART_Msk (0xFFFFFFFFUL << FICR_INFO_PART_PART_Pos) /*!< Bit mask of PART field. */
N#define FICR_INFO_PART_PART_N52832 (0x52832UL) /*!< nRF52832 */
N#define FICR_INFO_PART_PART_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
N
N/* Register: FICR_INFO_VARIANT */
N/* Description: Part Variant, Hardware version and Production configuration */
N
N/* Bits 31..0 : Part Variant, Hardware version and Production configuration, encoded as ASCII */
N#define FICR_INFO_VARIANT_VARIANT_Pos (0UL) /*!< Position of VARIANT field. */
N#define FICR_INFO_VARIANT_VARIANT_Msk (0xFFFFFFFFUL << FICR_INFO_VARIANT_VARIANT_Pos) /*!< Bit mask of VARIANT field. */
N#define FICR_INFO_VARIANT_VARIANT_AAAA (0x41414141UL) /*!< AAAA */
N#define FICR_INFO_VARIANT_VARIANT_AAAB (0x41414142UL) /*!< AAAB */
N#define FICR_INFO_VARIANT_VARIANT_AABA (0x41414241UL) /*!< AABA */
N#define FICR_INFO_VARIANT_VARIANT_AABB (0x41414242UL) /*!< AABB */
N#define FICR_INFO_VARIANT_VARIANT_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
N
N/* Register: FICR_INFO_PACKAGE */
N/* Description: Package option */
N
N/* Bits 31..0 : Package option */
N#define FICR_INFO_PACKAGE_PACKAGE_Pos (0UL) /*!< Position of PACKAGE field. */
N#define FICR_INFO_PACKAGE_PACKAGE_Msk (0xFFFFFFFFUL << FICR_INFO_PACKAGE_PACKAGE_Pos) /*!< Bit mask of PACKAGE field. */
N#define FICR_INFO_PACKAGE_PACKAGE_QF (0x2000UL) /*!< QFxx - 48-pin QFN */
N#define FICR_INFO_PACKAGE_PACKAGE_CI (0x2001UL) /*!< CIxx - 7x8 WLCSP 56 balls */
N#define FICR_INFO_PACKAGE_PACKAGE_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
N
N/* Register: FICR_INFO_RAM */
N/* Description: RAM variant */
N
N/* Bits 31..0 : RAM variant */
N#define FICR_INFO_RAM_RAM_Pos (0UL) /*!< Position of RAM field. */
N#define FICR_INFO_RAM_RAM_Msk (0xFFFFFFFFUL << FICR_INFO_RAM_RAM_Pos) /*!< Bit mask of RAM field. */
N#define FICR_INFO_RAM_RAM_K16 (0x10UL) /*!< 16 kByte RAM */
N#define FICR_INFO_RAM_RAM_K32 (0x20UL) /*!< 32 kByte RAM */
N#define FICR_INFO_RAM_RAM_K64 (0x40UL) /*!< 64 kByte RAM */
N#define FICR_INFO_RAM_RAM_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
N
N/* Register: FICR_INFO_FLASH */
N/* Description: Flash variant */
N
N/* Bits 31..0 : Flash variant */
N#define FICR_INFO_FLASH_FLASH_Pos (0UL) /*!< Position of FLASH field. */
N#define FICR_INFO_FLASH_FLASH_Msk (0xFFFFFFFFUL << FICR_INFO_FLASH_FLASH_Pos) /*!< Bit mask of FLASH field. */
N#define FICR_INFO_FLASH_FLASH_K128 (0x80UL) /*!< 128 kByte FLASH */
N#define FICR_INFO_FLASH_FLASH_K256 (0x100UL) /*!< 256 kByte FLASH */
N#define FICR_INFO_FLASH_FLASH_K512 (0x200UL) /*!< 512 kByte FLASH */
N#define FICR_INFO_FLASH_FLASH_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
N
N/* Register: FICR_TEMP_A0 */
N/* Description: Slope definition A0. */
N
N/* Bits 11..0 : A (slope definition) register. */
N#define FICR_TEMP_A0_A_Pos (0UL) /*!< Position of A field. */
N#define FICR_TEMP_A0_A_Msk (0xFFFUL << FICR_TEMP_A0_A_Pos) /*!< Bit mask of A field. */
N
N/* Register: FICR_TEMP_A1 */
N/* Description: Slope definition A1. */
N
N/* Bits 11..0 : A (slope definition) register. */
N#define FICR_TEMP_A1_A_Pos (0UL) /*!< Position of A field. */
N#define FICR_TEMP_A1_A_Msk (0xFFFUL << FICR_TEMP_A1_A_Pos) /*!< Bit mask of A field. */
N
N/* Register: FICR_TEMP_A2 */
N/* Description: Slope definition A2. */
N
N/* Bits 11..0 : A (slope definition) register. */
N#define FICR_TEMP_A2_A_Pos (0UL) /*!< Position of A field. */
N#define FICR_TEMP_A2_A_Msk (0xFFFUL << FICR_TEMP_A2_A_Pos) /*!< Bit mask of A field. */
N
N/* Register: FICR_TEMP_A3 */
N/* Description: Slope definition A3. */
N
N/* Bits 11..0 : A (slope definition) register. */
N#define FICR_TEMP_A3_A_Pos (0UL) /*!< Position of A field. */
N#define FICR_TEMP_A3_A_Msk (0xFFFUL << FICR_TEMP_A3_A_Pos) /*!< Bit mask of A field. */
N
N/* Register: FICR_TEMP_A4 */
N/* Description: Slope definition A4. */
N
N/* Bits 11..0 : A (slope definition) register. */
N#define FICR_TEMP_A4_A_Pos (0UL) /*!< Position of A field. */
N#define FICR_TEMP_A4_A_Msk (0xFFFUL << FICR_TEMP_A4_A_Pos) /*!< Bit mask of A field. */
N
N/* Register: FICR_TEMP_A5 */
N/* Description: Slope definition A5. */
N
N/* Bits 11..0 : A (slope definition) register. */
N#define FICR_TEMP_A5_A_Pos (0UL) /*!< Position of A field. */
N#define FICR_TEMP_A5_A_Msk (0xFFFUL << FICR_TEMP_A5_A_Pos) /*!< Bit mask of A field. */
N
N/* Register: FICR_TEMP_B0 */
N/* Description: y-intercept B0. */
N
N/* Bits 13..0 : B (y-intercept) */
N#define FICR_TEMP_B0_B_Pos (0UL) /*!< Position of B field. */
N#define FICR_TEMP_B0_B_Msk (0x3FFFUL << FICR_TEMP_B0_B_Pos) /*!< Bit mask of B field. */
N
N/* Register: FICR_TEMP_B1 */
N/* Description: y-intercept B1. */
N
N/* Bits 13..0 : B (y-intercept) */
N#define FICR_TEMP_B1_B_Pos (0UL) /*!< Position of B field. */
N#define FICR_TEMP_B1_B_Msk (0x3FFFUL << FICR_TEMP_B1_B_Pos) /*!< Bit mask of B field. */
N
N/* Register: FICR_TEMP_B2 */
N/* Description: y-intercept B2. */
N
N/* Bits 13..0 : B (y-intercept) */
N#define FICR_TEMP_B2_B_Pos (0UL) /*!< Position of B field. */
N#define FICR_TEMP_B2_B_Msk (0x3FFFUL << FICR_TEMP_B2_B_Pos) /*!< Bit mask of B field. */
N
N/* Register: FICR_TEMP_B3 */
N/* Description: y-intercept B3. */
N
N/* Bits 13..0 : B (y-intercept) */
N#define FICR_TEMP_B3_B_Pos (0UL) /*!< Position of B field. */
N#define FICR_TEMP_B3_B_Msk (0x3FFFUL << FICR_TEMP_B3_B_Pos) /*!< Bit mask of B field. */
N
N/* Register: FICR_TEMP_B4 */
N/* Description: y-intercept B4. */
N
N/* Bits 13..0 : B (y-intercept) */
N#define FICR_TEMP_B4_B_Pos (0UL) /*!< Position of B field. */
N#define FICR_TEMP_B4_B_Msk (0x3FFFUL << FICR_TEMP_B4_B_Pos) /*!< Bit mask of B field. */
N
N/* Register: FICR_TEMP_B5 */
N/* Description: y-intercept B5. */
N
N/* Bits 13..0 : B (y-intercept) */
N#define FICR_TEMP_B5_B_Pos (0UL) /*!< Position of B field. */
N#define FICR_TEMP_B5_B_Msk (0x3FFFUL << FICR_TEMP_B5_B_Pos) /*!< Bit mask of B field. */
N
N/* Register: FICR_TEMP_T0 */
N/* Description: Segment end T0. */
N
N/* Bits 7..0 : T (segment end)register. */
N#define FICR_TEMP_T0_T_Pos (0UL) /*!< Position of T field. */
N#define FICR_TEMP_T0_T_Msk (0xFFUL << FICR_TEMP_T0_T_Pos) /*!< Bit mask of T field. */
N
N/* Register: FICR_TEMP_T1 */
N/* Description: Segment end T1. */
N
N/* Bits 7..0 : T (segment end)register. */
N#define FICR_TEMP_T1_T_Pos (0UL) /*!< Position of T field. */
N#define FICR_TEMP_T1_T_Msk (0xFFUL << FICR_TEMP_T1_T_Pos) /*!< Bit mask of T field. */
N
N/* Register: FICR_TEMP_T2 */
N/* Description: Segment end T2. */
N
N/* Bits 7..0 : T (segment end)register. */
N#define FICR_TEMP_T2_T_Pos (0UL) /*!< Position of T field. */
N#define FICR_TEMP_T2_T_Msk (0xFFUL << FICR_TEMP_T2_T_Pos) /*!< Bit mask of T field. */
N
N/* Register: FICR_TEMP_T3 */
N/* Description: Segment end T3. */
N
N/* Bits 7..0 : T (segment end)register. */
N#define FICR_TEMP_T3_T_Pos (0UL) /*!< Position of T field. */
N#define FICR_TEMP_T3_T_Msk (0xFFUL << FICR_TEMP_T3_T_Pos) /*!< Bit mask of T field. */
N
N/* Register: FICR_TEMP_T4 */
N/* Description: Segment end T4. */
N
N/* Bits 7..0 : T (segment end)register. */
N#define FICR_TEMP_T4_T_Pos (0UL) /*!< Position of T field. */
N#define FICR_TEMP_T4_T_Msk (0xFFUL << FICR_TEMP_T4_T_Pos) /*!< Bit mask of T field. */
N
N/* Register: FICR_NFC_TAGHEADER0 */
N/* Description: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST. */
N
N/* Bits 31..24 : Unique identifier byte 3 */
N#define FICR_NFC_TAGHEADER0_UD3_Pos (24UL) /*!< Position of UD3 field. */
N#define FICR_NFC_TAGHEADER0_UD3_Msk (0xFFUL << FICR_NFC_TAGHEADER0_UD3_Pos) /*!< Bit mask of UD3 field. */
N
N/* Bits 23..16 : Unique identifier byte 2 */
N#define FICR_NFC_TAGHEADER0_UD2_Pos (16UL) /*!< Position of UD2 field. */
N#define FICR_NFC_TAGHEADER0_UD2_Msk (0xFFUL << FICR_NFC_TAGHEADER0_UD2_Pos) /*!< Bit mask of UD2 field. */
N
N/* Bits 15..8 : Unique identifier byte 1 */
N#define FICR_NFC_TAGHEADER0_UD1_Pos (8UL) /*!< Position of UD1 field. */
N#define FICR_NFC_TAGHEADER0_UD1_Msk (0xFFUL << FICR_NFC_TAGHEADER0_UD1_Pos) /*!< Bit mask of UD1 field. */
N
N/* Bits 7..0 : Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F */
N#define FICR_NFC_TAGHEADER0_MFGID_Pos (0UL) /*!< Position of MFGID field. */
N#define FICR_NFC_TAGHEADER0_MFGID_Msk (0xFFUL << FICR_NFC_TAGHEADER0_MFGID_Pos) /*!< Bit mask of MFGID field. */
N
N/* Register: FICR_NFC_TAGHEADER1 */
N/* Description: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST. */
N
N/* Bits 31..24 : Unique identifier byte 7 */
N#define FICR_NFC_TAGHEADER1_UD7_Pos (24UL) /*!< Position of UD7 field. */
N#define FICR_NFC_TAGHEADER1_UD7_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD7_Pos) /*!< Bit mask of UD7 field. */
N
N/* Bits 23..16 : Unique identifier byte 6 */
N#define FICR_NFC_TAGHEADER1_UD6_Pos (16UL) /*!< Position of UD6 field. */
N#define FICR_NFC_TAGHEADER1_UD6_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD6_Pos) /*!< Bit mask of UD6 field. */
N
N/* Bits 15..8 : Unique identifier byte 5 */
N#define FICR_NFC_TAGHEADER1_UD5_Pos (8UL) /*!< Position of UD5 field. */
N#define FICR_NFC_TAGHEADER1_UD5_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD5_Pos) /*!< Bit mask of UD5 field. */
N
N/* Bits 7..0 : Unique identifier byte 4 */
N#define FICR_NFC_TAGHEADER1_UD4_Pos (0UL) /*!< Position of UD4 field. */
N#define FICR_NFC_TAGHEADER1_UD4_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD4_Pos) /*!< Bit mask of UD4 field. */
N
N/* Register: FICR_NFC_TAGHEADER2 */
N/* Description: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST. */
N
N/* Bits 31..24 : Unique identifier byte 11 */
N#define FICR_NFC_TAGHEADER2_UD11_Pos (24UL) /*!< Position of UD11 field. */
N#define FICR_NFC_TAGHEADER2_UD11_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD11_Pos) /*!< Bit mask of UD11 field. */
N
N/* Bits 23..16 : Unique identifier byte 10 */
N#define FICR_NFC_TAGHEADER2_UD10_Pos (16UL) /*!< Position of UD10 field. */
N#define FICR_NFC_TAGHEADER2_UD10_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD10_Pos) /*!< Bit mask of UD10 field. */
N
N/* Bits 15..8 : Unique identifier byte 9 */
N#define FICR_NFC_TAGHEADER2_UD9_Pos (8UL) /*!< Position of UD9 field. */
N#define FICR_NFC_TAGHEADER2_UD9_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD9_Pos) /*!< Bit mask of UD9 field. */
N
N/* Bits 7..0 : Unique identifier byte 8 */
N#define FICR_NFC_TAGHEADER2_UD8_Pos (0UL) /*!< Position of UD8 field. */
N#define FICR_NFC_TAGHEADER2_UD8_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD8_Pos) /*!< Bit mask of UD8 field. */
N
N/* Register: FICR_NFC_TAGHEADER3 */
N/* Description: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST. */
N
N/* Bits 31..24 : Unique identifier byte 15 */
N#define FICR_NFC_TAGHEADER3_UD15_Pos (24UL) /*!< Position of UD15 field. */
N#define FICR_NFC_TAGHEADER3_UD15_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD15_Pos) /*!< Bit mask of UD15 field. */
N
N/* Bits 23..16 : Unique identifier byte 14 */
N#define FICR_NFC_TAGHEADER3_UD14_Pos (16UL) /*!< Position of UD14 field. */
N#define FICR_NFC_TAGHEADER3_UD14_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD14_Pos) /*!< Bit mask of UD14 field. */
N
N/* Bits 15..8 : Unique identifier byte 13 */
N#define FICR_NFC_TAGHEADER3_UD13_Pos (8UL) /*!< Position of UD13 field. */
N#define FICR_NFC_TAGHEADER3_UD13_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD13_Pos) /*!< Bit mask of UD13 field. */
N
N/* Bits 7..0 : Unique identifier byte 12 */
N#define FICR_NFC_TAGHEADER3_UD12_Pos (0UL) /*!< Position of UD12 field. */
N#define FICR_NFC_TAGHEADER3_UD12_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD12_Pos) /*!< Bit mask of UD12 field. */
N
N
N/* Peripheral: GPIOTE */
N/* Description: GPIO Tasks and Events */
N
N/* Register: GPIOTE_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 31 : Write '1' to Enable interrupt for PORT event */
N#define GPIOTE_INTENSET_PORT_Pos (31UL) /*!< Position of PORT field. */
N#define GPIOTE_INTENSET_PORT_Msk (0x1UL << GPIOTE_INTENSET_PORT_Pos) /*!< Bit mask of PORT field. */
N#define GPIOTE_INTENSET_PORT_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENSET_PORT_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENSET_PORT_Set (1UL) /*!< Enable */
N
N/* Bit 7 : Write '1' to Enable interrupt for IN[7] event */
N#define GPIOTE_INTENSET_IN7_Pos (7UL) /*!< Position of IN7 field. */
N#define GPIOTE_INTENSET_IN7_Msk (0x1UL << GPIOTE_INTENSET_IN7_Pos) /*!< Bit mask of IN7 field. */
N#define GPIOTE_INTENSET_IN7_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENSET_IN7_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENSET_IN7_Set (1UL) /*!< Enable */
N
N/* Bit 6 : Write '1' to Enable interrupt for IN[6] event */
N#define GPIOTE_INTENSET_IN6_Pos (6UL) /*!< Position of IN6 field. */
N#define GPIOTE_INTENSET_IN6_Msk (0x1UL << GPIOTE_INTENSET_IN6_Pos) /*!< Bit mask of IN6 field. */
N#define GPIOTE_INTENSET_IN6_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENSET_IN6_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENSET_IN6_Set (1UL) /*!< Enable */
N
N/* Bit 5 : Write '1' to Enable interrupt for IN[5] event */
N#define GPIOTE_INTENSET_IN5_Pos (5UL) /*!< Position of IN5 field. */
N#define GPIOTE_INTENSET_IN5_Msk (0x1UL << GPIOTE_INTENSET_IN5_Pos) /*!< Bit mask of IN5 field. */
N#define GPIOTE_INTENSET_IN5_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENSET_IN5_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENSET_IN5_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable interrupt for IN[4] event */
N#define GPIOTE_INTENSET_IN4_Pos (4UL) /*!< Position of IN4 field. */
N#define GPIOTE_INTENSET_IN4_Msk (0x1UL << GPIOTE_INTENSET_IN4_Pos) /*!< Bit mask of IN4 field. */
N#define GPIOTE_INTENSET_IN4_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENSET_IN4_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENSET_IN4_Set (1UL) /*!< Enable */
N
N/* Bit 3 : Write '1' to Enable interrupt for IN[3] event */
N#define GPIOTE_INTENSET_IN3_Pos (3UL) /*!< Position of IN3 field. */
N#define GPIOTE_INTENSET_IN3_Msk (0x1UL << GPIOTE_INTENSET_IN3_Pos) /*!< Bit mask of IN3 field. */
N#define GPIOTE_INTENSET_IN3_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENSET_IN3_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENSET_IN3_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for IN[2] event */
N#define GPIOTE_INTENSET_IN2_Pos (2UL) /*!< Position of IN2 field. */
N#define GPIOTE_INTENSET_IN2_Msk (0x1UL << GPIOTE_INTENSET_IN2_Pos) /*!< Bit mask of IN2 field. */
N#define GPIOTE_INTENSET_IN2_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENSET_IN2_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENSET_IN2_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for IN[1] event */
N#define GPIOTE_INTENSET_IN1_Pos (1UL) /*!< Position of IN1 field. */
N#define GPIOTE_INTENSET_IN1_Msk (0x1UL << GPIOTE_INTENSET_IN1_Pos) /*!< Bit mask of IN1 field. */
N#define GPIOTE_INTENSET_IN1_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENSET_IN1_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENSET_IN1_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for IN[0] event */
N#define GPIOTE_INTENSET_IN0_Pos (0UL) /*!< Position of IN0 field. */
N#define GPIOTE_INTENSET_IN0_Msk (0x1UL << GPIOTE_INTENSET_IN0_Pos) /*!< Bit mask of IN0 field. */
N#define GPIOTE_INTENSET_IN0_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENSET_IN0_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENSET_IN0_Set (1UL) /*!< Enable */
N
N/* Register: GPIOTE_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 31 : Write '1' to Disable interrupt for PORT event */
N#define GPIOTE_INTENCLR_PORT_Pos (31UL) /*!< Position of PORT field. */
N#define GPIOTE_INTENCLR_PORT_Msk (0x1UL << GPIOTE_INTENCLR_PORT_Pos) /*!< Bit mask of PORT field. */
N#define GPIOTE_INTENCLR_PORT_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENCLR_PORT_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENCLR_PORT_Clear (1UL) /*!< Disable */
N
N/* Bit 7 : Write '1' to Disable interrupt for IN[7] event */
N#define GPIOTE_INTENCLR_IN7_Pos (7UL) /*!< Position of IN7 field. */
N#define GPIOTE_INTENCLR_IN7_Msk (0x1UL << GPIOTE_INTENCLR_IN7_Pos) /*!< Bit mask of IN7 field. */
N#define GPIOTE_INTENCLR_IN7_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENCLR_IN7_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENCLR_IN7_Clear (1UL) /*!< Disable */
N
N/* Bit 6 : Write '1' to Disable interrupt for IN[6] event */
N#define GPIOTE_INTENCLR_IN6_Pos (6UL) /*!< Position of IN6 field. */
N#define GPIOTE_INTENCLR_IN6_Msk (0x1UL << GPIOTE_INTENCLR_IN6_Pos) /*!< Bit mask of IN6 field. */
N#define GPIOTE_INTENCLR_IN6_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENCLR_IN6_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENCLR_IN6_Clear (1UL) /*!< Disable */
N
N/* Bit 5 : Write '1' to Disable interrupt for IN[5] event */
N#define GPIOTE_INTENCLR_IN5_Pos (5UL) /*!< Position of IN5 field. */
N#define GPIOTE_INTENCLR_IN5_Msk (0x1UL << GPIOTE_INTENCLR_IN5_Pos) /*!< Bit mask of IN5 field. */
N#define GPIOTE_INTENCLR_IN5_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENCLR_IN5_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENCLR_IN5_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable interrupt for IN[4] event */
N#define GPIOTE_INTENCLR_IN4_Pos (4UL) /*!< Position of IN4 field. */
N#define GPIOTE_INTENCLR_IN4_Msk (0x1UL << GPIOTE_INTENCLR_IN4_Pos) /*!< Bit mask of IN4 field. */
N#define GPIOTE_INTENCLR_IN4_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENCLR_IN4_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENCLR_IN4_Clear (1UL) /*!< Disable */
N
N/* Bit 3 : Write '1' to Disable interrupt for IN[3] event */
N#define GPIOTE_INTENCLR_IN3_Pos (3UL) /*!< Position of IN3 field. */
N#define GPIOTE_INTENCLR_IN3_Msk (0x1UL << GPIOTE_INTENCLR_IN3_Pos) /*!< Bit mask of IN3 field. */
N#define GPIOTE_INTENCLR_IN3_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENCLR_IN3_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENCLR_IN3_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for IN[2] event */
N#define GPIOTE_INTENCLR_IN2_Pos (2UL) /*!< Position of IN2 field. */
N#define GPIOTE_INTENCLR_IN2_Msk (0x1UL << GPIOTE_INTENCLR_IN2_Pos) /*!< Bit mask of IN2 field. */
N#define GPIOTE_INTENCLR_IN2_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENCLR_IN2_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENCLR_IN2_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for IN[1] event */
N#define GPIOTE_INTENCLR_IN1_Pos (1UL) /*!< Position of IN1 field. */
N#define GPIOTE_INTENCLR_IN1_Msk (0x1UL << GPIOTE_INTENCLR_IN1_Pos) /*!< Bit mask of IN1 field. */
N#define GPIOTE_INTENCLR_IN1_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENCLR_IN1_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENCLR_IN1_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for IN[0] event */
N#define GPIOTE_INTENCLR_IN0_Pos (0UL) /*!< Position of IN0 field. */
N#define GPIOTE_INTENCLR_IN0_Msk (0x1UL << GPIOTE_INTENCLR_IN0_Pos) /*!< Bit mask of IN0 field. */
N#define GPIOTE_INTENCLR_IN0_Disabled (0UL) /*!< Read: Disabled */
N#define GPIOTE_INTENCLR_IN0_Enabled (1UL) /*!< Read: Enabled */
N#define GPIOTE_INTENCLR_IN0_Clear (1UL) /*!< Disable */
N
N/* Register: GPIOTE_CONFIG */
N/* Description: Description collection[0]:  Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event */
N
N/* Bit 20 : When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect. */
N#define GPIOTE_CONFIG_OUTINIT_Pos (20UL) /*!< Position of OUTINIT field. */
N#define GPIOTE_CONFIG_OUTINIT_Msk (0x1UL << GPIOTE_CONFIG_OUTINIT_Pos) /*!< Bit mask of OUTINIT field. */
N#define GPIOTE_CONFIG_OUTINIT_Low (0UL) /*!< Task mode: Initial value of pin before task triggering is low */
N#define GPIOTE_CONFIG_OUTINIT_High (1UL) /*!< Task mode: Initial value of pin before task triggering is high */
N
N/* Bits 17..16 : When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event. */
N#define GPIOTE_CONFIG_POLARITY_Pos (16UL) /*!< Position of POLARITY field. */
N#define GPIOTE_CONFIG_POLARITY_Msk (0x3UL << GPIOTE_CONFIG_POLARITY_Pos) /*!< Bit mask of POLARITY field. */
N#define GPIOTE_CONFIG_POLARITY_None (0UL) /*!< Task mode: No effect on pin from OUT[n] task. Event mode: no IN[n] event generated on pin activity. */
N#define GPIOTE_CONFIG_POLARITY_LoToHi (1UL) /*!< Task mode: Set pin from OUT[n] task. Event mode: Generate IN[n] event when rising edge on pin. */
N#define GPIOTE_CONFIG_POLARITY_HiToLo (2UL) /*!< Task mode: Clear pin from OUT[n] task. Event mode: Generate IN[n] event when falling edge on pin. */
N#define GPIOTE_CONFIG_POLARITY_Toggle (3UL) /*!< Task mode: Toggle pin from OUT[n]. Event mode: Generate IN[n] when any change on pin. */
N
N/* Bits 12..8 : GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event */
N#define GPIOTE_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
N#define GPIOTE_CONFIG_PSEL_Msk (0x1FUL << GPIOTE_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
N
N/* Bits 1..0 : Mode */
N#define GPIOTE_CONFIG_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define GPIOTE_CONFIG_MODE_Msk (0x3UL << GPIOTE_CONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
N#define GPIOTE_CONFIG_MODE_Disabled (0UL) /*!< Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module. */
N#define GPIOTE_CONFIG_MODE_Event (1UL) /*!< Event mode */
N#define GPIOTE_CONFIG_MODE_Task (3UL) /*!< Task mode */
N
N
N/* Peripheral: I2S */
N/* Description: Inter-IC Sound */
N
N/* Register: I2S_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 5 : Enable or disable interrupt for TXPTRUPD event */
N#define I2S_INTEN_TXPTRUPD_Pos (5UL) /*!< Position of TXPTRUPD field. */
N#define I2S_INTEN_TXPTRUPD_Msk (0x1UL << I2S_INTEN_TXPTRUPD_Pos) /*!< Bit mask of TXPTRUPD field. */
N#define I2S_INTEN_TXPTRUPD_Disabled (0UL) /*!< Disable */
N#define I2S_INTEN_TXPTRUPD_Enabled (1UL) /*!< Enable */
N
N/* Bit 2 : Enable or disable interrupt for STOPPED event */
N#define I2S_INTEN_STOPPED_Pos (2UL) /*!< Position of STOPPED field. */
N#define I2S_INTEN_STOPPED_Msk (0x1UL << I2S_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define I2S_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
N#define I2S_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for RXPTRUPD event */
N#define I2S_INTEN_RXPTRUPD_Pos (1UL) /*!< Position of RXPTRUPD field. */
N#define I2S_INTEN_RXPTRUPD_Msk (0x1UL << I2S_INTEN_RXPTRUPD_Pos) /*!< Bit mask of RXPTRUPD field. */
N#define I2S_INTEN_RXPTRUPD_Disabled (0UL) /*!< Disable */
N#define I2S_INTEN_RXPTRUPD_Enabled (1UL) /*!< Enable */
N
N/* Register: I2S_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 5 : Write '1' to Enable interrupt for TXPTRUPD event */
N#define I2S_INTENSET_TXPTRUPD_Pos (5UL) /*!< Position of TXPTRUPD field. */
N#define I2S_INTENSET_TXPTRUPD_Msk (0x1UL << I2S_INTENSET_TXPTRUPD_Pos) /*!< Bit mask of TXPTRUPD field. */
N#define I2S_INTENSET_TXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
N#define I2S_INTENSET_TXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
N#define I2S_INTENSET_TXPTRUPD_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for STOPPED event */
N#define I2S_INTENSET_STOPPED_Pos (2UL) /*!< Position of STOPPED field. */
N#define I2S_INTENSET_STOPPED_Msk (0x1UL << I2S_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define I2S_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define I2S_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define I2S_INTENSET_STOPPED_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for RXPTRUPD event */
N#define I2S_INTENSET_RXPTRUPD_Pos (1UL) /*!< Position of RXPTRUPD field. */
N#define I2S_INTENSET_RXPTRUPD_Msk (0x1UL << I2S_INTENSET_RXPTRUPD_Pos) /*!< Bit mask of RXPTRUPD field. */
N#define I2S_INTENSET_RXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
N#define I2S_INTENSET_RXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
N#define I2S_INTENSET_RXPTRUPD_Set (1UL) /*!< Enable */
N
N/* Register: I2S_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 5 : Write '1' to Disable interrupt for TXPTRUPD event */
N#define I2S_INTENCLR_TXPTRUPD_Pos (5UL) /*!< Position of TXPTRUPD field. */
N#define I2S_INTENCLR_TXPTRUPD_Msk (0x1UL << I2S_INTENCLR_TXPTRUPD_Pos) /*!< Bit mask of TXPTRUPD field. */
N#define I2S_INTENCLR_TXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
N#define I2S_INTENCLR_TXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
N#define I2S_INTENCLR_TXPTRUPD_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for STOPPED event */
N#define I2S_INTENCLR_STOPPED_Pos (2UL) /*!< Position of STOPPED field. */
N#define I2S_INTENCLR_STOPPED_Msk (0x1UL << I2S_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define I2S_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define I2S_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define I2S_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for RXPTRUPD event */
N#define I2S_INTENCLR_RXPTRUPD_Pos (1UL) /*!< Position of RXPTRUPD field. */
N#define I2S_INTENCLR_RXPTRUPD_Msk (0x1UL << I2S_INTENCLR_RXPTRUPD_Pos) /*!< Bit mask of RXPTRUPD field. */
N#define I2S_INTENCLR_RXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
N#define I2S_INTENCLR_RXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
N#define I2S_INTENCLR_RXPTRUPD_Clear (1UL) /*!< Disable */
N
N/* Register: I2S_ENABLE */
N/* Description: Enable I2S module. */
N
N/* Bit 0 : Enable I2S module. */
N#define I2S_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define I2S_ENABLE_ENABLE_Msk (0x1UL << I2S_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define I2S_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
N#define I2S_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
N
N/* Register: I2S_CONFIG_MODE */
N/* Description: I2S mode. */
N
N/* Bit 0 : I2S mode. */
N#define I2S_CONFIG_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define I2S_CONFIG_MODE_MODE_Msk (0x1UL << I2S_CONFIG_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define I2S_CONFIG_MODE_MODE_Master (0UL) /*!< Master mode. SCK and LRCK generated from internal master clcok (MCK) and output on pins defined by PSEL.xxx. */
N#define I2S_CONFIG_MODE_MODE_Slave (1UL) /*!< Slave mode. SCK and LRCK generated by external master and received on pins defined by PSEL.xxx */
N
N/* Register: I2S_CONFIG_RXEN */
N/* Description: Reception (RX) enable. */
N
N/* Bit 0 : Reception (RX) enable. */
N#define I2S_CONFIG_RXEN_RXEN_Pos (0UL) /*!< Position of RXEN field. */
N#define I2S_CONFIG_RXEN_RXEN_Msk (0x1UL << I2S_CONFIG_RXEN_RXEN_Pos) /*!< Bit mask of RXEN field. */
N#define I2S_CONFIG_RXEN_RXEN_Disabled (0UL) /*!< Reception disabled and now data will be written to the RXD.PTR address. */
N#define I2S_CONFIG_RXEN_RXEN_Enabled (1UL) /*!< Reception enabled. */
N
N/* Register: I2S_CONFIG_TXEN */
N/* Description: Transmission (TX) enable. */
N
N/* Bit 0 : Transmission (TX) enable. */
N#define I2S_CONFIG_TXEN_TXEN_Pos (0UL) /*!< Position of TXEN field. */
N#define I2S_CONFIG_TXEN_TXEN_Msk (0x1UL << I2S_CONFIG_TXEN_TXEN_Pos) /*!< Bit mask of TXEN field. */
N#define I2S_CONFIG_TXEN_TXEN_Disabled (0UL) /*!< Transmission disabled and now data will be read from the RXD.TXD address. */
N#define I2S_CONFIG_TXEN_TXEN_Enabled (1UL) /*!< Transmission enabled. */
N
N/* Register: I2S_CONFIG_MCKEN */
N/* Description: Master clock generator enable. */
N
N/* Bit 0 : Master clock generator enable. */
N#define I2S_CONFIG_MCKEN_MCKEN_Pos (0UL) /*!< Position of MCKEN field. */
N#define I2S_CONFIG_MCKEN_MCKEN_Msk (0x1UL << I2S_CONFIG_MCKEN_MCKEN_Pos) /*!< Bit mask of MCKEN field. */
N#define I2S_CONFIG_MCKEN_MCKEN_Disabled (0UL) /*!< Master clock generator disabled and PSEL.MCK not connected(available as GPIO). */
N#define I2S_CONFIG_MCKEN_MCKEN_Enabled (1UL) /*!< Master clock generator running and MCK output on PSEL.MCK. */
N
N/* Register: I2S_CONFIG_MCKFREQ */
N/* Description: Master clock generator frequency. */
N
N/* Bits 31..0 : Master clock generator frequency. */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_Pos (0UL) /*!< Position of MCKFREQ field. */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_Msk (0xFFFFFFFFUL << I2S_CONFIG_MCKFREQ_MCKFREQ_Pos) /*!< Bit mask of MCKFREQ field. */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV125 (0x020C0000UL) /*!< 32 MHz / 125 = 0.256 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV63 (0x04100000UL) /*!< 32 MHz / 63 = 0.5079365 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV42 (0x06000000UL) /*!< 32 MHz / 42 = 0.7619048 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV32 (0x08000000UL) /*!< 32 MHz / 32 = 1.0 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV31 (0x08400000UL) /*!< 32 MHz / 31 = 1.0322581 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV30 (0x08800000UL) /*!< 32 MHz / 30 = 1.0666667 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV23 (0x0B000000UL) /*!< 32 MHz / 23 = 1.3913043 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV21 (0x0C000000UL) /*!< 32 MHz / 21 = 1.5238095 */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV16 (0x10000000UL) /*!< 32 MHz / 16 = 2.0 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV15 (0x11000000UL) /*!< 32 MHz / 15 = 2.1333333 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV11 (0x16000000UL) /*!< 32 MHz / 11 = 2.9090909 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV10 (0x18000000UL) /*!< 32 MHz / 10 = 3.2 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV8 (0x20000000UL) /*!< 32 MHz / 8 = 4.0 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV6 (0x28000000UL) /*!< 32 MHz / 6 = 5.3333333 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV5 (0x30000000UL) /*!< 32 MHz / 5 = 6.4 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV4 (0x40000000UL) /*!< 32 MHz / 4 = 8.0 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV3 (0x50000000UL) /*!< 32 MHz / 3 = 10.6666667 MHz */
N#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV2 (0x80000000UL) /*!< 32 MHz / 2 = 16.0 MHz */
N
N/* Register: I2S_CONFIG_RATIO */
N/* Description: MCK / LRCK ratio. */
N
N/* Bits 3..0 : MCK / LRCK ratio. */
N#define I2S_CONFIG_RATIO_RATIO_Pos (0UL) /*!< Position of RATIO field. */
N#define I2S_CONFIG_RATIO_RATIO_Msk (0xFUL << I2S_CONFIG_RATIO_RATIO_Pos) /*!< Bit mask of RATIO field. */
N#define I2S_CONFIG_RATIO_RATIO_32X (0UL) /*!< LRCK = MCK / 32 */
N#define I2S_CONFIG_RATIO_RATIO_48X (1UL) /*!< LRCK = MCK / 48 */
N#define I2S_CONFIG_RATIO_RATIO_64X (2UL) /*!< LRCK = MCK / 64 */
N#define I2S_CONFIG_RATIO_RATIO_96X (3UL) /*!< LRCK = MCK / 96 */
N#define I2S_CONFIG_RATIO_RATIO_128X (4UL) /*!< LRCK = MCK / 128 */
N#define I2S_CONFIG_RATIO_RATIO_192X (5UL) /*!< LRCK = MCK / 192 */
N#define I2S_CONFIG_RATIO_RATIO_256X (6UL) /*!< LRCK = MCK / 256 */
N#define I2S_CONFIG_RATIO_RATIO_384X (7UL) /*!< LRCK = MCK / 384 */
N#define I2S_CONFIG_RATIO_RATIO_512X (8UL) /*!< LRCK = MCK / 512 */
N
N/* Register: I2S_CONFIG_SWIDTH */
N/* Description: Sample width. */
N
N/* Bits 1..0 : Sample width. */
N#define I2S_CONFIG_SWIDTH_SWIDTH_Pos (0UL) /*!< Position of SWIDTH field. */
N#define I2S_CONFIG_SWIDTH_SWIDTH_Msk (0x3UL << I2S_CONFIG_SWIDTH_SWIDTH_Pos) /*!< Bit mask of SWIDTH field. */
N#define I2S_CONFIG_SWIDTH_SWIDTH_8Bit (0UL) /*!< 8 bit. */
N#define I2S_CONFIG_SWIDTH_SWIDTH_16Bit (1UL) /*!< 16 bit. */
N#define I2S_CONFIG_SWIDTH_SWIDTH_24Bit (2UL) /*!< 24 bit. */
N
N/* Register: I2S_CONFIG_ALIGN */
N/* Description: Alignment of sample within a frame. */
N
N/* Bit 0 : Alignment of sample within a frame. */
N#define I2S_CONFIG_ALIGN_ALIGN_Pos (0UL) /*!< Position of ALIGN field. */
N#define I2S_CONFIG_ALIGN_ALIGN_Msk (0x1UL << I2S_CONFIG_ALIGN_ALIGN_Pos) /*!< Bit mask of ALIGN field. */
N#define I2S_CONFIG_ALIGN_ALIGN_Left (0UL) /*!< Left-aligned. */
N#define I2S_CONFIG_ALIGN_ALIGN_Right (1UL) /*!< Right-aligned. */
N
N/* Register: I2S_CONFIG_FORMAT */
N/* Description: Frame format. */
N
N/* Bit 0 : Frame format. */
N#define I2S_CONFIG_FORMAT_FORMAT_Pos (0UL) /*!< Position of FORMAT field. */
N#define I2S_CONFIG_FORMAT_FORMAT_Msk (0x1UL << I2S_CONFIG_FORMAT_FORMAT_Pos) /*!< Bit mask of FORMAT field. */
N#define I2S_CONFIG_FORMAT_FORMAT_I2S (0UL) /*!< Original I2S format. */
N#define I2S_CONFIG_FORMAT_FORMAT_Aligned (1UL) /*!< Alternate (left- or right-aligned) format. */
N
N/* Register: I2S_CONFIG_CHANNELS */
N/* Description: Enable channels. */
N
N/* Bits 1..0 : Enable channels. */
N#define I2S_CONFIG_CHANNELS_CHANNELS_Pos (0UL) /*!< Position of CHANNELS field. */
N#define I2S_CONFIG_CHANNELS_CHANNELS_Msk (0x3UL << I2S_CONFIG_CHANNELS_CHANNELS_Pos) /*!< Bit mask of CHANNELS field. */
N#define I2S_CONFIG_CHANNELS_CHANNELS_Stereo (0UL) /*!< Stereo. */
N#define I2S_CONFIG_CHANNELS_CHANNELS_Left (1UL) /*!< Left only. */
N#define I2S_CONFIG_CHANNELS_CHANNELS_Right (2UL) /*!< Right only. */
N
N/* Register: I2S_RXD_PTR */
N/* Description: Receive buffer RAM start address. */
N
N/* Bits 31..0 : Receive buffer Data RAM start address. When receiving, words containing samples will be written to this address. This address is a word aligned Data RAM address. */
N#define I2S_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define I2S_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << I2S_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: I2S_TXD_PTR */
N/* Description: Transmit buffer RAM start address. */
N
N/* Bits 31..0 : Transmit buffer Data RAM start address. When transmitting, words containing samples will be fetched from this address. This address is a word aligned Data RAM address. */
N#define I2S_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define I2S_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << I2S_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: I2S_RXTXD_MAXCNT */
N/* Description: Size of RXD and TXD buffers. */
N
N/* Bits 13..0 : Size of RXD and TXD buffers in number of 32 bit words. */
N#define I2S_RXTXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define I2S_RXTXD_MAXCNT_MAXCNT_Msk (0x3FFFUL << I2S_RXTXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: I2S_PSEL_MCK */
N/* Description: Pin select for MCK signal. */
N
N/* Bit 31 : Connection */
N#define I2S_PSEL_MCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define I2S_PSEL_MCK_CONNECT_Msk (0x1UL << I2S_PSEL_MCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define I2S_PSEL_MCK_CONNECT_Connected (0UL) /*!< Connect */
N#define I2S_PSEL_MCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define I2S_PSEL_MCK_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define I2S_PSEL_MCK_PIN_Msk (0x1FUL << I2S_PSEL_MCK_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: I2S_PSEL_SCK */
N/* Description: Pin select for SCK signal. */
N
N/* Bit 31 : Connection */
N#define I2S_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define I2S_PSEL_SCK_CONNECT_Msk (0x1UL << I2S_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define I2S_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
N#define I2S_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define I2S_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define I2S_PSEL_SCK_PIN_Msk (0x1FUL << I2S_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: I2S_PSEL_LRCK */
N/* Description: Pin select for LRCK signal. */
N
N/* Bit 31 : Connection */
N#define I2S_PSEL_LRCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define I2S_PSEL_LRCK_CONNECT_Msk (0x1UL << I2S_PSEL_LRCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define I2S_PSEL_LRCK_CONNECT_Connected (0UL) /*!< Connect */
N#define I2S_PSEL_LRCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define I2S_PSEL_LRCK_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define I2S_PSEL_LRCK_PIN_Msk (0x1FUL << I2S_PSEL_LRCK_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: I2S_PSEL_SDIN */
N/* Description: Pin select for SDIN signal. */
N
N/* Bit 31 : Connection */
N#define I2S_PSEL_SDIN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define I2S_PSEL_SDIN_CONNECT_Msk (0x1UL << I2S_PSEL_SDIN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define I2S_PSEL_SDIN_CONNECT_Connected (0UL) /*!< Connect */
N#define I2S_PSEL_SDIN_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define I2S_PSEL_SDIN_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define I2S_PSEL_SDIN_PIN_Msk (0x1FUL << I2S_PSEL_SDIN_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: I2S_PSEL_SDOUT */
N/* Description: Pin select for SDOUT signal. */
N
N/* Bit 31 : Connection */
N#define I2S_PSEL_SDOUT_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define I2S_PSEL_SDOUT_CONNECT_Msk (0x1UL << I2S_PSEL_SDOUT_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define I2S_PSEL_SDOUT_CONNECT_Connected (0UL) /*!< Connect */
N#define I2S_PSEL_SDOUT_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define I2S_PSEL_SDOUT_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define I2S_PSEL_SDOUT_PIN_Msk (0x1FUL << I2S_PSEL_SDOUT_PIN_Pos) /*!< Bit mask of PIN field. */
N
N
N/* Peripheral: LPCOMP */
N/* Description: Low Power Comparator */
N
N/* Register: LPCOMP_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 4 : Shortcut between CROSS event and STOP task */
N#define LPCOMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
N#define LPCOMP_SHORTS_CROSS_STOP_Msk (0x1UL << LPCOMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
N#define LPCOMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define LPCOMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 3 : Shortcut between UP event and STOP task */
N#define LPCOMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
N#define LPCOMP_SHORTS_UP_STOP_Msk (0x1UL << LPCOMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
N#define LPCOMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define LPCOMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 2 : Shortcut between DOWN event and STOP task */
N#define LPCOMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
N#define LPCOMP_SHORTS_DOWN_STOP_Msk (0x1UL << LPCOMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
N#define LPCOMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define LPCOMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 1 : Shortcut between READY event and STOP task */
N#define LPCOMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
N#define LPCOMP_SHORTS_READY_STOP_Msk (0x1UL << LPCOMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
N#define LPCOMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define LPCOMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 0 : Shortcut between READY event and SAMPLE task */
N#define LPCOMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Msk (0x1UL << LPCOMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Disable shortcut */
N#define LPCOMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: LPCOMP_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 3 : Write '1' to Enable interrupt for CROSS event */
N#define LPCOMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define LPCOMP_INTENSET_CROSS_Msk (0x1UL << LPCOMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define LPCOMP_INTENSET_CROSS_Disabled (0UL) /*!< Read: Disabled */
N#define LPCOMP_INTENSET_CROSS_Enabled (1UL) /*!< Read: Enabled */
N#define LPCOMP_INTENSET_CROSS_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for UP event */
N#define LPCOMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
N#define LPCOMP_INTENSET_UP_Msk (0x1UL << LPCOMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
N#define LPCOMP_INTENSET_UP_Disabled (0UL) /*!< Read: Disabled */
N#define LPCOMP_INTENSET_UP_Enabled (1UL) /*!< Read: Enabled */
N#define LPCOMP_INTENSET_UP_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for DOWN event */
N#define LPCOMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define LPCOMP_INTENSET_DOWN_Msk (0x1UL << LPCOMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define LPCOMP_INTENSET_DOWN_Disabled (0UL) /*!< Read: Disabled */
N#define LPCOMP_INTENSET_DOWN_Enabled (1UL) /*!< Read: Enabled */
N#define LPCOMP_INTENSET_DOWN_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for READY event */
N#define LPCOMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define LPCOMP_INTENSET_READY_Msk (0x1UL << LPCOMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define LPCOMP_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
N#define LPCOMP_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
N#define LPCOMP_INTENSET_READY_Set (1UL) /*!< Enable */
N
N/* Register: LPCOMP_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 3 : Write '1' to Disable interrupt for CROSS event */
N#define LPCOMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define LPCOMP_INTENCLR_CROSS_Msk (0x1UL << LPCOMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define LPCOMP_INTENCLR_CROSS_Disabled (0UL) /*!< Read: Disabled */
N#define LPCOMP_INTENCLR_CROSS_Enabled (1UL) /*!< Read: Enabled */
N#define LPCOMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for UP event */
N#define LPCOMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
N#define LPCOMP_INTENCLR_UP_Msk (0x1UL << LPCOMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
N#define LPCOMP_INTENCLR_UP_Disabled (0UL) /*!< Read: Disabled */
N#define LPCOMP_INTENCLR_UP_Enabled (1UL) /*!< Read: Enabled */
N#define LPCOMP_INTENCLR_UP_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for DOWN event */
N#define LPCOMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define LPCOMP_INTENCLR_DOWN_Msk (0x1UL << LPCOMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define LPCOMP_INTENCLR_DOWN_Disabled (0UL) /*!< Read: Disabled */
N#define LPCOMP_INTENCLR_DOWN_Enabled (1UL) /*!< Read: Enabled */
N#define LPCOMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for READY event */
N#define LPCOMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define LPCOMP_INTENCLR_READY_Msk (0x1UL << LPCOMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define LPCOMP_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
N#define LPCOMP_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
N#define LPCOMP_INTENCLR_READY_Clear (1UL) /*!< Disable */
N
N/* Register: LPCOMP_RESULT */
N/* Description: Compare result */
N
N/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
N#define LPCOMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define LPCOMP_RESULT_RESULT_Msk (0x1UL << LPCOMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N#define LPCOMP_RESULT_RESULT_Below (0UL) /*!< Input voltage is below the reference threshold (VIN+ &lt; VIN-). */
N#define LPCOMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the reference threshold (VIN+ &gt; VIN-). */
N
N/* Register: LPCOMP_ENABLE */
N/* Description: Enable LPCOMP */
N
N/* Bits 1..0 : Enable or disable LPCOMP */
N#define LPCOMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define LPCOMP_ENABLE_ENABLE_Msk (0x3UL << LPCOMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define LPCOMP_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
N#define LPCOMP_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
N
N/* Register: LPCOMP_PSEL */
N/* Description: Input pin select */
N
N/* Bits 2..0 : Analog pin select */
N#define LPCOMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
N#define LPCOMP_PSEL_PSEL_Msk (0x7UL << LPCOMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define LPCOMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< AIN0 selected as analog input */
N#define LPCOMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< AIN1 selected as analog input */
N#define LPCOMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< AIN2 selected as analog input */
N#define LPCOMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< AIN3 selected as analog input */
N#define LPCOMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< AIN4 selected as analog input */
N#define LPCOMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< AIN5 selected as analog input */
N#define LPCOMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< AIN6 selected as analog input */
N#define LPCOMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< AIN7 selected as analog input */
N
N/* Register: LPCOMP_REFSEL */
N/* Description: Reference select */
N
N/* Bits 3..0 : Reference select */
N#define LPCOMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
N#define LPCOMP_REFSEL_REFSEL_Msk (0xFUL << LPCOMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define LPCOMP_REFSEL_REFSEL_Ref1_8Vdd (0UL) /*!< VDD * 1/8 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref2_8Vdd (1UL) /*!< VDD * 2/8 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref3_8Vdd (2UL) /*!< VDD * 3/8 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref4_8Vdd (3UL) /*!< VDD * 4/8 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref5_8Vdd (4UL) /*!< VDD * 5/8 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref6_8Vdd (5UL) /*!< VDD * 6/8 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref7_8Vdd (6UL) /*!< VDD * 7/8 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_ARef (7UL) /*!< External analog reference selected */
N#define LPCOMP_REFSEL_REFSEL_Ref1_16Vdd (8UL) /*!< VDD * 1/16 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref3_16Vdd (9UL) /*!< VDD * 3/16 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref5_16Vdd (10UL) /*!< VDD * 5/16 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref7_16Vdd (11UL) /*!< VDD * 7/16 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref9_16Vdd (12UL) /*!< VDD * 9/16 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref11_16Vdd (13UL) /*!< VDD * 11/16 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref13_16Vdd (14UL) /*!< VDD * 13/16 selected as reference */
N#define LPCOMP_REFSEL_REFSEL_Ref15_16Vdd (15UL) /*!< VDD * 15/16 selected as reference */
N
N/* Register: LPCOMP_EXTREFSEL */
N/* Description: External reference select */
N
N/* Bit 0 : External analog reference select */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << LPCOMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use AIN0 as external analog reference */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use AIN1 as external analog reference */
N
N/* Register: LPCOMP_ANADETECT */
N/* Description: Analog detect configuration */
N
N/* Bits 1..0 : Analog detect configuration */
N#define LPCOMP_ANADETECT_ANADETECT_Pos (0UL) /*!< Position of ANADETECT field. */
N#define LPCOMP_ANADETECT_ANADETECT_Msk (0x3UL << LPCOMP_ANADETECT_ANADETECT_Pos) /*!< Bit mask of ANADETECT field. */
N#define LPCOMP_ANADETECT_ANADETECT_Cross (0UL) /*!< Generate ANADETECT on crossing, both upward crossing and downward crossing */
N#define LPCOMP_ANADETECT_ANADETECT_Up (1UL) /*!< Generate ANADETECT on upward crossing only */
N#define LPCOMP_ANADETECT_ANADETECT_Down (2UL) /*!< Generate ANADETECT on downward crossing only */
N
N/* Register: LPCOMP_HYST */
N/* Description: Comparator hysteresis enable */
N
N/* Bit 0 : Comparator hysteresis enable */
N#define LPCOMP_HYST_HYST_Pos (0UL) /*!< Position of HYST field. */
N#define LPCOMP_HYST_HYST_Msk (0x1UL << LPCOMP_HYST_HYST_Pos) /*!< Bit mask of HYST field. */
N#define LPCOMP_HYST_HYST_NoHyst (0UL) /*!< Comparator hysteresis disabled */
N#define LPCOMP_HYST_HYST_Hyst50mV (1UL) /*!< Comparator hysteresis disabled (typ. 50 mV) */
N
N
N/* Peripheral: MWU */
N/* Description: Memory Watch Unit */
N
N/* Register: MWU_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 27 : Enable or disable interrupt for PREGION[1].RA event */
N#define MWU_INTEN_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
N#define MWU_INTEN_PREGION1RA_Msk (0x1UL << MWU_INTEN_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
N#define MWU_INTEN_PREGION1RA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_PREGION1RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 26 : Enable or disable interrupt for PREGION[1].WA event */
N#define MWU_INTEN_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
N#define MWU_INTEN_PREGION1WA_Msk (0x1UL << MWU_INTEN_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
N#define MWU_INTEN_PREGION1WA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_PREGION1WA_Enabled (1UL) /*!< Enable */
N
N/* Bit 25 : Enable or disable interrupt for PREGION[0].RA event */
N#define MWU_INTEN_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
N#define MWU_INTEN_PREGION0RA_Msk (0x1UL << MWU_INTEN_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
N#define MWU_INTEN_PREGION0RA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_PREGION0RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 24 : Enable or disable interrupt for PREGION[0].WA event */
N#define MWU_INTEN_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
N#define MWU_INTEN_PREGION0WA_Msk (0x1UL << MWU_INTEN_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
N#define MWU_INTEN_PREGION0WA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_PREGION0WA_Enabled (1UL) /*!< Enable */
N
N/* Bit 7 : Enable or disable interrupt for REGION[3].RA event */
N#define MWU_INTEN_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
N#define MWU_INTEN_REGION3RA_Msk (0x1UL << MWU_INTEN_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
N#define MWU_INTEN_REGION3RA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_REGION3RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 6 : Enable or disable interrupt for REGION[3].WA event */
N#define MWU_INTEN_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
N#define MWU_INTEN_REGION3WA_Msk (0x1UL << MWU_INTEN_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
N#define MWU_INTEN_REGION3WA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_REGION3WA_Enabled (1UL) /*!< Enable */
N
N/* Bit 5 : Enable or disable interrupt for REGION[2].RA event */
N#define MWU_INTEN_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
N#define MWU_INTEN_REGION2RA_Msk (0x1UL << MWU_INTEN_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
N#define MWU_INTEN_REGION2RA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_REGION2RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 4 : Enable or disable interrupt for REGION[2].WA event */
N#define MWU_INTEN_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
N#define MWU_INTEN_REGION2WA_Msk (0x1UL << MWU_INTEN_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
N#define MWU_INTEN_REGION2WA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_REGION2WA_Enabled (1UL) /*!< Enable */
N
N/* Bit 3 : Enable or disable interrupt for REGION[1].RA event */
N#define MWU_INTEN_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
N#define MWU_INTEN_REGION1RA_Msk (0x1UL << MWU_INTEN_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
N#define MWU_INTEN_REGION1RA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_REGION1RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 2 : Enable or disable interrupt for REGION[1].WA event */
N#define MWU_INTEN_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
N#define MWU_INTEN_REGION1WA_Msk (0x1UL << MWU_INTEN_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
N#define MWU_INTEN_REGION1WA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_REGION1WA_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for REGION[0].RA event */
N#define MWU_INTEN_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
N#define MWU_INTEN_REGION0RA_Msk (0x1UL << MWU_INTEN_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
N#define MWU_INTEN_REGION0RA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_REGION0RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 0 : Enable or disable interrupt for REGION[0].WA event */
N#define MWU_INTEN_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
N#define MWU_INTEN_REGION0WA_Msk (0x1UL << MWU_INTEN_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
N#define MWU_INTEN_REGION0WA_Disabled (0UL) /*!< Disable */
N#define MWU_INTEN_REGION0WA_Enabled (1UL) /*!< Enable */
N
N/* Register: MWU_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 27 : Write '1' to Enable interrupt for PREGION[1].RA event */
N#define MWU_INTENSET_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
N#define MWU_INTENSET_PREGION1RA_Msk (0x1UL << MWU_INTENSET_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
N#define MWU_INTENSET_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_PREGION1RA_Set (1UL) /*!< Enable */
N
N/* Bit 26 : Write '1' to Enable interrupt for PREGION[1].WA event */
N#define MWU_INTENSET_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
N#define MWU_INTENSET_PREGION1WA_Msk (0x1UL << MWU_INTENSET_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
N#define MWU_INTENSET_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_PREGION1WA_Set (1UL) /*!< Enable */
N
N/* Bit 25 : Write '1' to Enable interrupt for PREGION[0].RA event */
N#define MWU_INTENSET_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
N#define MWU_INTENSET_PREGION0RA_Msk (0x1UL << MWU_INTENSET_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
N#define MWU_INTENSET_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_PREGION0RA_Set (1UL) /*!< Enable */
N
N/* Bit 24 : Write '1' to Enable interrupt for PREGION[0].WA event */
N#define MWU_INTENSET_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
N#define MWU_INTENSET_PREGION0WA_Msk (0x1UL << MWU_INTENSET_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
N#define MWU_INTENSET_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_PREGION0WA_Set (1UL) /*!< Enable */
N
N/* Bit 7 : Write '1' to Enable interrupt for REGION[3].RA event */
N#define MWU_INTENSET_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
N#define MWU_INTENSET_REGION3RA_Msk (0x1UL << MWU_INTENSET_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
N#define MWU_INTENSET_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_REGION3RA_Set (1UL) /*!< Enable */
N
N/* Bit 6 : Write '1' to Enable interrupt for REGION[3].WA event */
N#define MWU_INTENSET_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
N#define MWU_INTENSET_REGION3WA_Msk (0x1UL << MWU_INTENSET_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
N#define MWU_INTENSET_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_REGION3WA_Set (1UL) /*!< Enable */
N
N/* Bit 5 : Write '1' to Enable interrupt for REGION[2].RA event */
N#define MWU_INTENSET_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
N#define MWU_INTENSET_REGION2RA_Msk (0x1UL << MWU_INTENSET_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
N#define MWU_INTENSET_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_REGION2RA_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable interrupt for REGION[2].WA event */
N#define MWU_INTENSET_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
N#define MWU_INTENSET_REGION2WA_Msk (0x1UL << MWU_INTENSET_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
N#define MWU_INTENSET_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_REGION2WA_Set (1UL) /*!< Enable */
N
N/* Bit 3 : Write '1' to Enable interrupt for REGION[1].RA event */
N#define MWU_INTENSET_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
N#define MWU_INTENSET_REGION1RA_Msk (0x1UL << MWU_INTENSET_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
N#define MWU_INTENSET_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_REGION1RA_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for REGION[1].WA event */
N#define MWU_INTENSET_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
N#define MWU_INTENSET_REGION1WA_Msk (0x1UL << MWU_INTENSET_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
N#define MWU_INTENSET_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_REGION1WA_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for REGION[0].RA event */
N#define MWU_INTENSET_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
N#define MWU_INTENSET_REGION0RA_Msk (0x1UL << MWU_INTENSET_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
N#define MWU_INTENSET_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_REGION0RA_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for REGION[0].WA event */
N#define MWU_INTENSET_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
N#define MWU_INTENSET_REGION0WA_Msk (0x1UL << MWU_INTENSET_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
N#define MWU_INTENSET_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENSET_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENSET_REGION0WA_Set (1UL) /*!< Enable */
N
N/* Register: MWU_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 27 : Write '1' to Disable interrupt for PREGION[1].RA event */
N#define MWU_INTENCLR_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
N#define MWU_INTENCLR_PREGION1RA_Msk (0x1UL << MWU_INTENCLR_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
N#define MWU_INTENCLR_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_PREGION1RA_Clear (1UL) /*!< Disable */
N
N/* Bit 26 : Write '1' to Disable interrupt for PREGION[1].WA event */
N#define MWU_INTENCLR_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
N#define MWU_INTENCLR_PREGION1WA_Msk (0x1UL << MWU_INTENCLR_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
N#define MWU_INTENCLR_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_PREGION1WA_Clear (1UL) /*!< Disable */
N
N/* Bit 25 : Write '1' to Disable interrupt for PREGION[0].RA event */
N#define MWU_INTENCLR_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
N#define MWU_INTENCLR_PREGION0RA_Msk (0x1UL << MWU_INTENCLR_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
N#define MWU_INTENCLR_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_PREGION0RA_Clear (1UL) /*!< Disable */
N
N/* Bit 24 : Write '1' to Disable interrupt for PREGION[0].WA event */
N#define MWU_INTENCLR_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
N#define MWU_INTENCLR_PREGION0WA_Msk (0x1UL << MWU_INTENCLR_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
N#define MWU_INTENCLR_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_PREGION0WA_Clear (1UL) /*!< Disable */
N
N/* Bit 7 : Write '1' to Disable interrupt for REGION[3].RA event */
N#define MWU_INTENCLR_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
N#define MWU_INTENCLR_REGION3RA_Msk (0x1UL << MWU_INTENCLR_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
N#define MWU_INTENCLR_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_REGION3RA_Clear (1UL) /*!< Disable */
N
N/* Bit 6 : Write '1' to Disable interrupt for REGION[3].WA event */
N#define MWU_INTENCLR_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
N#define MWU_INTENCLR_REGION3WA_Msk (0x1UL << MWU_INTENCLR_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
N#define MWU_INTENCLR_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_REGION3WA_Clear (1UL) /*!< Disable */
N
N/* Bit 5 : Write '1' to Disable interrupt for REGION[2].RA event */
N#define MWU_INTENCLR_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
N#define MWU_INTENCLR_REGION2RA_Msk (0x1UL << MWU_INTENCLR_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
N#define MWU_INTENCLR_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_REGION2RA_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable interrupt for REGION[2].WA event */
N#define MWU_INTENCLR_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
N#define MWU_INTENCLR_REGION2WA_Msk (0x1UL << MWU_INTENCLR_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
N#define MWU_INTENCLR_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_REGION2WA_Clear (1UL) /*!< Disable */
N
N/* Bit 3 : Write '1' to Disable interrupt for REGION[1].RA event */
N#define MWU_INTENCLR_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
N#define MWU_INTENCLR_REGION1RA_Msk (0x1UL << MWU_INTENCLR_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
N#define MWU_INTENCLR_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_REGION1RA_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for REGION[1].WA event */
N#define MWU_INTENCLR_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
N#define MWU_INTENCLR_REGION1WA_Msk (0x1UL << MWU_INTENCLR_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
N#define MWU_INTENCLR_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_REGION1WA_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for REGION[0].RA event */
N#define MWU_INTENCLR_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
N#define MWU_INTENCLR_REGION0RA_Msk (0x1UL << MWU_INTENCLR_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
N#define MWU_INTENCLR_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_REGION0RA_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for REGION[0].WA event */
N#define MWU_INTENCLR_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
N#define MWU_INTENCLR_REGION0WA_Msk (0x1UL << MWU_INTENCLR_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
N#define MWU_INTENCLR_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_INTENCLR_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_INTENCLR_REGION0WA_Clear (1UL) /*!< Disable */
N
N/* Register: MWU_NMIEN */
N/* Description: Enable or disable non-maskable interrupt */
N
N/* Bit 27 : Enable or disable non-maskable interrupt for PREGION[1].RA event */
N#define MWU_NMIEN_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
N#define MWU_NMIEN_PREGION1RA_Msk (0x1UL << MWU_NMIEN_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
N#define MWU_NMIEN_PREGION1RA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_PREGION1RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 26 : Enable or disable non-maskable interrupt for PREGION[1].WA event */
N#define MWU_NMIEN_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
N#define MWU_NMIEN_PREGION1WA_Msk (0x1UL << MWU_NMIEN_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
N#define MWU_NMIEN_PREGION1WA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_PREGION1WA_Enabled (1UL) /*!< Enable */
N
N/* Bit 25 : Enable or disable non-maskable interrupt for PREGION[0].RA event */
N#define MWU_NMIEN_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
N#define MWU_NMIEN_PREGION0RA_Msk (0x1UL << MWU_NMIEN_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
N#define MWU_NMIEN_PREGION0RA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_PREGION0RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 24 : Enable or disable non-maskable interrupt for PREGION[0].WA event */
N#define MWU_NMIEN_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
N#define MWU_NMIEN_PREGION0WA_Msk (0x1UL << MWU_NMIEN_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
N#define MWU_NMIEN_PREGION0WA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_PREGION0WA_Enabled (1UL) /*!< Enable */
N
N/* Bit 7 : Enable or disable non-maskable interrupt for REGION[3].RA event */
N#define MWU_NMIEN_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
N#define MWU_NMIEN_REGION3RA_Msk (0x1UL << MWU_NMIEN_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
N#define MWU_NMIEN_REGION3RA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_REGION3RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 6 : Enable or disable non-maskable interrupt for REGION[3].WA event */
N#define MWU_NMIEN_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
N#define MWU_NMIEN_REGION3WA_Msk (0x1UL << MWU_NMIEN_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
N#define MWU_NMIEN_REGION3WA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_REGION3WA_Enabled (1UL) /*!< Enable */
N
N/* Bit 5 : Enable or disable non-maskable interrupt for REGION[2].RA event */
N#define MWU_NMIEN_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
N#define MWU_NMIEN_REGION2RA_Msk (0x1UL << MWU_NMIEN_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
N#define MWU_NMIEN_REGION2RA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_REGION2RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 4 : Enable or disable non-maskable interrupt for REGION[2].WA event */
N#define MWU_NMIEN_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
N#define MWU_NMIEN_REGION2WA_Msk (0x1UL << MWU_NMIEN_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
N#define MWU_NMIEN_REGION2WA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_REGION2WA_Enabled (1UL) /*!< Enable */
N
N/* Bit 3 : Enable or disable non-maskable interrupt for REGION[1].RA event */
N#define MWU_NMIEN_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
N#define MWU_NMIEN_REGION1RA_Msk (0x1UL << MWU_NMIEN_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
N#define MWU_NMIEN_REGION1RA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_REGION1RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 2 : Enable or disable non-maskable interrupt for REGION[1].WA event */
N#define MWU_NMIEN_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
N#define MWU_NMIEN_REGION1WA_Msk (0x1UL << MWU_NMIEN_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
N#define MWU_NMIEN_REGION1WA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_REGION1WA_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable non-maskable interrupt for REGION[0].RA event */
N#define MWU_NMIEN_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
N#define MWU_NMIEN_REGION0RA_Msk (0x1UL << MWU_NMIEN_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
N#define MWU_NMIEN_REGION0RA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_REGION0RA_Enabled (1UL) /*!< Enable */
N
N/* Bit 0 : Enable or disable non-maskable interrupt for REGION[0].WA event */
N#define MWU_NMIEN_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
N#define MWU_NMIEN_REGION0WA_Msk (0x1UL << MWU_NMIEN_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
N#define MWU_NMIEN_REGION0WA_Disabled (0UL) /*!< Disable */
N#define MWU_NMIEN_REGION0WA_Enabled (1UL) /*!< Enable */
N
N/* Register: MWU_NMIENSET */
N/* Description: Enable non-maskable interrupt */
N
N/* Bit 27 : Write '1' to Enable non-maskable interrupt for PREGION[1].RA event */
N#define MWU_NMIENSET_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
N#define MWU_NMIENSET_PREGION1RA_Msk (0x1UL << MWU_NMIENSET_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
N#define MWU_NMIENSET_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_PREGION1RA_Set (1UL) /*!< Enable */
N
N/* Bit 26 : Write '1' to Enable non-maskable interrupt for PREGION[1].WA event */
N#define MWU_NMIENSET_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
N#define MWU_NMIENSET_PREGION1WA_Msk (0x1UL << MWU_NMIENSET_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
N#define MWU_NMIENSET_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_PREGION1WA_Set (1UL) /*!< Enable */
N
N/* Bit 25 : Write '1' to Enable non-maskable interrupt for PREGION[0].RA event */
N#define MWU_NMIENSET_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
N#define MWU_NMIENSET_PREGION0RA_Msk (0x1UL << MWU_NMIENSET_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
N#define MWU_NMIENSET_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_PREGION0RA_Set (1UL) /*!< Enable */
N
N/* Bit 24 : Write '1' to Enable non-maskable interrupt for PREGION[0].WA event */
N#define MWU_NMIENSET_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
N#define MWU_NMIENSET_PREGION0WA_Msk (0x1UL << MWU_NMIENSET_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
N#define MWU_NMIENSET_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_PREGION0WA_Set (1UL) /*!< Enable */
N
N/* Bit 7 : Write '1' to Enable non-maskable interrupt for REGION[3].RA event */
N#define MWU_NMIENSET_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
N#define MWU_NMIENSET_REGION3RA_Msk (0x1UL << MWU_NMIENSET_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
N#define MWU_NMIENSET_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_REGION3RA_Set (1UL) /*!< Enable */
N
N/* Bit 6 : Write '1' to Enable non-maskable interrupt for REGION[3].WA event */
N#define MWU_NMIENSET_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
N#define MWU_NMIENSET_REGION3WA_Msk (0x1UL << MWU_NMIENSET_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
N#define MWU_NMIENSET_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_REGION3WA_Set (1UL) /*!< Enable */
N
N/* Bit 5 : Write '1' to Enable non-maskable interrupt for REGION[2].RA event */
N#define MWU_NMIENSET_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
N#define MWU_NMIENSET_REGION2RA_Msk (0x1UL << MWU_NMIENSET_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
N#define MWU_NMIENSET_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_REGION2RA_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable non-maskable interrupt for REGION[2].WA event */
N#define MWU_NMIENSET_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
N#define MWU_NMIENSET_REGION2WA_Msk (0x1UL << MWU_NMIENSET_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
N#define MWU_NMIENSET_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_REGION2WA_Set (1UL) /*!< Enable */
N
N/* Bit 3 : Write '1' to Enable non-maskable interrupt for REGION[1].RA event */
N#define MWU_NMIENSET_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
N#define MWU_NMIENSET_REGION1RA_Msk (0x1UL << MWU_NMIENSET_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
N#define MWU_NMIENSET_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_REGION1RA_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable non-maskable interrupt for REGION[1].WA event */
N#define MWU_NMIENSET_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
N#define MWU_NMIENSET_REGION1WA_Msk (0x1UL << MWU_NMIENSET_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
N#define MWU_NMIENSET_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_REGION1WA_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable non-maskable interrupt for REGION[0].RA event */
N#define MWU_NMIENSET_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
N#define MWU_NMIENSET_REGION0RA_Msk (0x1UL << MWU_NMIENSET_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
N#define MWU_NMIENSET_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_REGION0RA_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable non-maskable interrupt for REGION[0].WA event */
N#define MWU_NMIENSET_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
N#define MWU_NMIENSET_REGION0WA_Msk (0x1UL << MWU_NMIENSET_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
N#define MWU_NMIENSET_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENSET_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENSET_REGION0WA_Set (1UL) /*!< Enable */
N
N/* Register: MWU_NMIENCLR */
N/* Description: Disable non-maskable interrupt */
N
N/* Bit 27 : Write '1' to Disable non-maskable interrupt for PREGION[1].RA event */
N#define MWU_NMIENCLR_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
N#define MWU_NMIENCLR_PREGION1RA_Msk (0x1UL << MWU_NMIENCLR_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
N#define MWU_NMIENCLR_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_PREGION1RA_Clear (1UL) /*!< Disable */
N
N/* Bit 26 : Write '1' to Disable non-maskable interrupt for PREGION[1].WA event */
N#define MWU_NMIENCLR_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
N#define MWU_NMIENCLR_PREGION1WA_Msk (0x1UL << MWU_NMIENCLR_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
N#define MWU_NMIENCLR_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_PREGION1WA_Clear (1UL) /*!< Disable */
N
N/* Bit 25 : Write '1' to Disable non-maskable interrupt for PREGION[0].RA event */
N#define MWU_NMIENCLR_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
N#define MWU_NMIENCLR_PREGION0RA_Msk (0x1UL << MWU_NMIENCLR_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
N#define MWU_NMIENCLR_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_PREGION0RA_Clear (1UL) /*!< Disable */
N
N/* Bit 24 : Write '1' to Disable non-maskable interrupt for PREGION[0].WA event */
N#define MWU_NMIENCLR_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
N#define MWU_NMIENCLR_PREGION0WA_Msk (0x1UL << MWU_NMIENCLR_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
N#define MWU_NMIENCLR_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_PREGION0WA_Clear (1UL) /*!< Disable */
N
N/* Bit 7 : Write '1' to Disable non-maskable interrupt for REGION[3].RA event */
N#define MWU_NMIENCLR_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
N#define MWU_NMIENCLR_REGION3RA_Msk (0x1UL << MWU_NMIENCLR_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
N#define MWU_NMIENCLR_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_REGION3RA_Clear (1UL) /*!< Disable */
N
N/* Bit 6 : Write '1' to Disable non-maskable interrupt for REGION[3].WA event */
N#define MWU_NMIENCLR_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
N#define MWU_NMIENCLR_REGION3WA_Msk (0x1UL << MWU_NMIENCLR_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
N#define MWU_NMIENCLR_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_REGION3WA_Clear (1UL) /*!< Disable */
N
N/* Bit 5 : Write '1' to Disable non-maskable interrupt for REGION[2].RA event */
N#define MWU_NMIENCLR_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
N#define MWU_NMIENCLR_REGION2RA_Msk (0x1UL << MWU_NMIENCLR_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
N#define MWU_NMIENCLR_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_REGION2RA_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable non-maskable interrupt for REGION[2].WA event */
N#define MWU_NMIENCLR_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
N#define MWU_NMIENCLR_REGION2WA_Msk (0x1UL << MWU_NMIENCLR_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
N#define MWU_NMIENCLR_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_REGION2WA_Clear (1UL) /*!< Disable */
N
N/* Bit 3 : Write '1' to Disable non-maskable interrupt for REGION[1].RA event */
N#define MWU_NMIENCLR_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
N#define MWU_NMIENCLR_REGION1RA_Msk (0x1UL << MWU_NMIENCLR_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
N#define MWU_NMIENCLR_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_REGION1RA_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable non-maskable interrupt for REGION[1].WA event */
N#define MWU_NMIENCLR_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
N#define MWU_NMIENCLR_REGION1WA_Msk (0x1UL << MWU_NMIENCLR_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
N#define MWU_NMIENCLR_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_REGION1WA_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable non-maskable interrupt for REGION[0].RA event */
N#define MWU_NMIENCLR_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
N#define MWU_NMIENCLR_REGION0RA_Msk (0x1UL << MWU_NMIENCLR_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
N#define MWU_NMIENCLR_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_REGION0RA_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable non-maskable interrupt for REGION[0].WA event */
N#define MWU_NMIENCLR_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
N#define MWU_NMIENCLR_REGION0WA_Msk (0x1UL << MWU_NMIENCLR_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
N#define MWU_NMIENCLR_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
N#define MWU_NMIENCLR_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
N#define MWU_NMIENCLR_REGION0WA_Clear (1UL) /*!< Disable */
N
N/* Register: MWU_PERREGION_SUBSTATWA */
N/* Description: Description cluster[0]:  Source of event/interrupt in region 0, write access detected while corresponding subregion was enabled for watching */
N
N/* Bit 31 : Subregion 31 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR31_Pos (31UL) /*!< Position of SR31 field. */
N#define MWU_PERREGION_SUBSTATWA_SR31_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR31_Pos) /*!< Bit mask of SR31 field. */
N#define MWU_PERREGION_SUBSTATWA_SR31_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR31_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 30 : Subregion 30 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR30_Pos (30UL) /*!< Position of SR30 field. */
N#define MWU_PERREGION_SUBSTATWA_SR30_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR30_Pos) /*!< Bit mask of SR30 field. */
N#define MWU_PERREGION_SUBSTATWA_SR30_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR30_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 29 : Subregion 29 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR29_Pos (29UL) /*!< Position of SR29 field. */
N#define MWU_PERREGION_SUBSTATWA_SR29_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR29_Pos) /*!< Bit mask of SR29 field. */
N#define MWU_PERREGION_SUBSTATWA_SR29_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR29_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 28 : Subregion 28 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR28_Pos (28UL) /*!< Position of SR28 field. */
N#define MWU_PERREGION_SUBSTATWA_SR28_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR28_Pos) /*!< Bit mask of SR28 field. */
N#define MWU_PERREGION_SUBSTATWA_SR28_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR28_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 27 : Subregion 27 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR27_Pos (27UL) /*!< Position of SR27 field. */
N#define MWU_PERREGION_SUBSTATWA_SR27_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR27_Pos) /*!< Bit mask of SR27 field. */
N#define MWU_PERREGION_SUBSTATWA_SR27_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR27_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 26 : Subregion 26 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR26_Pos (26UL) /*!< Position of SR26 field. */
N#define MWU_PERREGION_SUBSTATWA_SR26_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR26_Pos) /*!< Bit mask of SR26 field. */
N#define MWU_PERREGION_SUBSTATWA_SR26_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR26_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 25 : Subregion 25 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR25_Pos (25UL) /*!< Position of SR25 field. */
N#define MWU_PERREGION_SUBSTATWA_SR25_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR25_Pos) /*!< Bit mask of SR25 field. */
N#define MWU_PERREGION_SUBSTATWA_SR25_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR25_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 24 : Subregion 24 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR24_Pos (24UL) /*!< Position of SR24 field. */
N#define MWU_PERREGION_SUBSTATWA_SR24_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR24_Pos) /*!< Bit mask of SR24 field. */
N#define MWU_PERREGION_SUBSTATWA_SR24_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR24_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 23 : Subregion 23 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR23_Pos (23UL) /*!< Position of SR23 field. */
N#define MWU_PERREGION_SUBSTATWA_SR23_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR23_Pos) /*!< Bit mask of SR23 field. */
N#define MWU_PERREGION_SUBSTATWA_SR23_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR23_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 22 : Subregion 22 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR22_Pos (22UL) /*!< Position of SR22 field. */
N#define MWU_PERREGION_SUBSTATWA_SR22_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR22_Pos) /*!< Bit mask of SR22 field. */
N#define MWU_PERREGION_SUBSTATWA_SR22_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR22_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 21 : Subregion 21 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR21_Pos (21UL) /*!< Position of SR21 field. */
N#define MWU_PERREGION_SUBSTATWA_SR21_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR21_Pos) /*!< Bit mask of SR21 field. */
N#define MWU_PERREGION_SUBSTATWA_SR21_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR21_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 20 : Subregion 20 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR20_Pos (20UL) /*!< Position of SR20 field. */
N#define MWU_PERREGION_SUBSTATWA_SR20_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR20_Pos) /*!< Bit mask of SR20 field. */
N#define MWU_PERREGION_SUBSTATWA_SR20_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR20_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 19 : Subregion 19 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR19_Pos (19UL) /*!< Position of SR19 field. */
N#define MWU_PERREGION_SUBSTATWA_SR19_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR19_Pos) /*!< Bit mask of SR19 field. */
N#define MWU_PERREGION_SUBSTATWA_SR19_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR19_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 18 : Subregion 18 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR18_Pos (18UL) /*!< Position of SR18 field. */
N#define MWU_PERREGION_SUBSTATWA_SR18_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR18_Pos) /*!< Bit mask of SR18 field. */
N#define MWU_PERREGION_SUBSTATWA_SR18_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR18_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 17 : Subregion 17 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR17_Pos (17UL) /*!< Position of SR17 field. */
N#define MWU_PERREGION_SUBSTATWA_SR17_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR17_Pos) /*!< Bit mask of SR17 field. */
N#define MWU_PERREGION_SUBSTATWA_SR17_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR17_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 16 : Subregion 16 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR16_Pos (16UL) /*!< Position of SR16 field. */
N#define MWU_PERREGION_SUBSTATWA_SR16_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR16_Pos) /*!< Bit mask of SR16 field. */
N#define MWU_PERREGION_SUBSTATWA_SR16_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR16_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 15 : Subregion 15 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR15_Pos (15UL) /*!< Position of SR15 field. */
N#define MWU_PERREGION_SUBSTATWA_SR15_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR15_Pos) /*!< Bit mask of SR15 field. */
N#define MWU_PERREGION_SUBSTATWA_SR15_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR15_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 14 : Subregion 14 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR14_Pos (14UL) /*!< Position of SR14 field. */
N#define MWU_PERREGION_SUBSTATWA_SR14_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR14_Pos) /*!< Bit mask of SR14 field. */
N#define MWU_PERREGION_SUBSTATWA_SR14_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR14_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 13 : Subregion 13 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR13_Pos (13UL) /*!< Position of SR13 field. */
N#define MWU_PERREGION_SUBSTATWA_SR13_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR13_Pos) /*!< Bit mask of SR13 field. */
N#define MWU_PERREGION_SUBSTATWA_SR13_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR13_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 12 : Subregion 12 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR12_Pos (12UL) /*!< Position of SR12 field. */
N#define MWU_PERREGION_SUBSTATWA_SR12_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR12_Pos) /*!< Bit mask of SR12 field. */
N#define MWU_PERREGION_SUBSTATWA_SR12_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR12_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 11 : Subregion 11 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR11_Pos (11UL) /*!< Position of SR11 field. */
N#define MWU_PERREGION_SUBSTATWA_SR11_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR11_Pos) /*!< Bit mask of SR11 field. */
N#define MWU_PERREGION_SUBSTATWA_SR11_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR11_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 10 : Subregion 10 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR10_Pos (10UL) /*!< Position of SR10 field. */
N#define MWU_PERREGION_SUBSTATWA_SR10_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR10_Pos) /*!< Bit mask of SR10 field. */
N#define MWU_PERREGION_SUBSTATWA_SR10_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR10_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 9 : Subregion 9 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR9_Pos (9UL) /*!< Position of SR9 field. */
N#define MWU_PERREGION_SUBSTATWA_SR9_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR9_Pos) /*!< Bit mask of SR9 field. */
N#define MWU_PERREGION_SUBSTATWA_SR9_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR9_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 8 : Subregion 8 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR8_Pos (8UL) /*!< Position of SR8 field. */
N#define MWU_PERREGION_SUBSTATWA_SR8_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR8_Pos) /*!< Bit mask of SR8 field. */
N#define MWU_PERREGION_SUBSTATWA_SR8_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR8_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 7 : Subregion 7 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR7_Pos (7UL) /*!< Position of SR7 field. */
N#define MWU_PERREGION_SUBSTATWA_SR7_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR7_Pos) /*!< Bit mask of SR7 field. */
N#define MWU_PERREGION_SUBSTATWA_SR7_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR7_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 6 : Subregion 6 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR6_Pos (6UL) /*!< Position of SR6 field. */
N#define MWU_PERREGION_SUBSTATWA_SR6_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR6_Pos) /*!< Bit mask of SR6 field. */
N#define MWU_PERREGION_SUBSTATWA_SR6_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR6_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 5 : Subregion 5 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR5_Pos (5UL) /*!< Position of SR5 field. */
N#define MWU_PERREGION_SUBSTATWA_SR5_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR5_Pos) /*!< Bit mask of SR5 field. */
N#define MWU_PERREGION_SUBSTATWA_SR5_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR5_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 4 : Subregion 4 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR4_Pos (4UL) /*!< Position of SR4 field. */
N#define MWU_PERREGION_SUBSTATWA_SR4_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR4_Pos) /*!< Bit mask of SR4 field. */
N#define MWU_PERREGION_SUBSTATWA_SR4_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR4_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 3 : Subregion 3 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR3_Pos (3UL) /*!< Position of SR3 field. */
N#define MWU_PERREGION_SUBSTATWA_SR3_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR3_Pos) /*!< Bit mask of SR3 field. */
N#define MWU_PERREGION_SUBSTATWA_SR3_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR3_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 2 : Subregion 2 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR2_Pos (2UL) /*!< Position of SR2 field. */
N#define MWU_PERREGION_SUBSTATWA_SR2_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR2_Pos) /*!< Bit mask of SR2 field. */
N#define MWU_PERREGION_SUBSTATWA_SR2_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR2_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 1 : Subregion 1 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR1_Pos (1UL) /*!< Position of SR1 field. */
N#define MWU_PERREGION_SUBSTATWA_SR1_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR1_Pos) /*!< Bit mask of SR1 field. */
N#define MWU_PERREGION_SUBSTATWA_SR1_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR1_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Bit 0 : Subregion 0 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATWA_SR0_Pos (0UL) /*!< Position of SR0 field. */
N#define MWU_PERREGION_SUBSTATWA_SR0_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR0_Pos) /*!< Bit mask of SR0 field. */
N#define MWU_PERREGION_SUBSTATWA_SR0_NoAccess (0UL) /*!< No write access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATWA_SR0_Access (1UL) /*!< Write access(es) occurred in this subregion */
N
N/* Register: MWU_PERREGION_SUBSTATRA */
N/* Description: Description cluster[0]:  Source of event/interrupt in region 0, read access detected while corresponding subregion was enabled for watching */
N
N/* Bit 31 : Subregion 31 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR31_Pos (31UL) /*!< Position of SR31 field. */
N#define MWU_PERREGION_SUBSTATRA_SR31_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR31_Pos) /*!< Bit mask of SR31 field. */
N#define MWU_PERREGION_SUBSTATRA_SR31_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR31_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 30 : Subregion 30 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR30_Pos (30UL) /*!< Position of SR30 field. */
N#define MWU_PERREGION_SUBSTATRA_SR30_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR30_Pos) /*!< Bit mask of SR30 field. */
N#define MWU_PERREGION_SUBSTATRA_SR30_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR30_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 29 : Subregion 29 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR29_Pos (29UL) /*!< Position of SR29 field. */
N#define MWU_PERREGION_SUBSTATRA_SR29_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR29_Pos) /*!< Bit mask of SR29 field. */
N#define MWU_PERREGION_SUBSTATRA_SR29_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR29_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 28 : Subregion 28 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR28_Pos (28UL) /*!< Position of SR28 field. */
N#define MWU_PERREGION_SUBSTATRA_SR28_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR28_Pos) /*!< Bit mask of SR28 field. */
N#define MWU_PERREGION_SUBSTATRA_SR28_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR28_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 27 : Subregion 27 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR27_Pos (27UL) /*!< Position of SR27 field. */
N#define MWU_PERREGION_SUBSTATRA_SR27_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR27_Pos) /*!< Bit mask of SR27 field. */
N#define MWU_PERREGION_SUBSTATRA_SR27_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR27_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 26 : Subregion 26 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR26_Pos (26UL) /*!< Position of SR26 field. */
N#define MWU_PERREGION_SUBSTATRA_SR26_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR26_Pos) /*!< Bit mask of SR26 field. */
N#define MWU_PERREGION_SUBSTATRA_SR26_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR26_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 25 : Subregion 25 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR25_Pos (25UL) /*!< Position of SR25 field. */
N#define MWU_PERREGION_SUBSTATRA_SR25_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR25_Pos) /*!< Bit mask of SR25 field. */
N#define MWU_PERREGION_SUBSTATRA_SR25_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR25_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 24 : Subregion 24 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR24_Pos (24UL) /*!< Position of SR24 field. */
N#define MWU_PERREGION_SUBSTATRA_SR24_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR24_Pos) /*!< Bit mask of SR24 field. */
N#define MWU_PERREGION_SUBSTATRA_SR24_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR24_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 23 : Subregion 23 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR23_Pos (23UL) /*!< Position of SR23 field. */
N#define MWU_PERREGION_SUBSTATRA_SR23_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR23_Pos) /*!< Bit mask of SR23 field. */
N#define MWU_PERREGION_SUBSTATRA_SR23_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR23_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 22 : Subregion 22 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR22_Pos (22UL) /*!< Position of SR22 field. */
N#define MWU_PERREGION_SUBSTATRA_SR22_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR22_Pos) /*!< Bit mask of SR22 field. */
N#define MWU_PERREGION_SUBSTATRA_SR22_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR22_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 21 : Subregion 21 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR21_Pos (21UL) /*!< Position of SR21 field. */
N#define MWU_PERREGION_SUBSTATRA_SR21_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR21_Pos) /*!< Bit mask of SR21 field. */
N#define MWU_PERREGION_SUBSTATRA_SR21_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR21_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 20 : Subregion 20 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR20_Pos (20UL) /*!< Position of SR20 field. */
N#define MWU_PERREGION_SUBSTATRA_SR20_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR20_Pos) /*!< Bit mask of SR20 field. */
N#define MWU_PERREGION_SUBSTATRA_SR20_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR20_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 19 : Subregion 19 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR19_Pos (19UL) /*!< Position of SR19 field. */
N#define MWU_PERREGION_SUBSTATRA_SR19_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR19_Pos) /*!< Bit mask of SR19 field. */
N#define MWU_PERREGION_SUBSTATRA_SR19_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR19_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 18 : Subregion 18 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR18_Pos (18UL) /*!< Position of SR18 field. */
N#define MWU_PERREGION_SUBSTATRA_SR18_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR18_Pos) /*!< Bit mask of SR18 field. */
N#define MWU_PERREGION_SUBSTATRA_SR18_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR18_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 17 : Subregion 17 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR17_Pos (17UL) /*!< Position of SR17 field. */
N#define MWU_PERREGION_SUBSTATRA_SR17_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR17_Pos) /*!< Bit mask of SR17 field. */
N#define MWU_PERREGION_SUBSTATRA_SR17_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR17_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 16 : Subregion 16 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR16_Pos (16UL) /*!< Position of SR16 field. */
N#define MWU_PERREGION_SUBSTATRA_SR16_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR16_Pos) /*!< Bit mask of SR16 field. */
N#define MWU_PERREGION_SUBSTATRA_SR16_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR16_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 15 : Subregion 15 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR15_Pos (15UL) /*!< Position of SR15 field. */
N#define MWU_PERREGION_SUBSTATRA_SR15_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR15_Pos) /*!< Bit mask of SR15 field. */
N#define MWU_PERREGION_SUBSTATRA_SR15_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR15_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 14 : Subregion 14 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR14_Pos (14UL) /*!< Position of SR14 field. */
N#define MWU_PERREGION_SUBSTATRA_SR14_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR14_Pos) /*!< Bit mask of SR14 field. */
N#define MWU_PERREGION_SUBSTATRA_SR14_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR14_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 13 : Subregion 13 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR13_Pos (13UL) /*!< Position of SR13 field. */
N#define MWU_PERREGION_SUBSTATRA_SR13_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR13_Pos) /*!< Bit mask of SR13 field. */
N#define MWU_PERREGION_SUBSTATRA_SR13_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR13_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 12 : Subregion 12 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR12_Pos (12UL) /*!< Position of SR12 field. */
N#define MWU_PERREGION_SUBSTATRA_SR12_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR12_Pos) /*!< Bit mask of SR12 field. */
N#define MWU_PERREGION_SUBSTATRA_SR12_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR12_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 11 : Subregion 11 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR11_Pos (11UL) /*!< Position of SR11 field. */
N#define MWU_PERREGION_SUBSTATRA_SR11_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR11_Pos) /*!< Bit mask of SR11 field. */
N#define MWU_PERREGION_SUBSTATRA_SR11_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR11_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 10 : Subregion 10 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR10_Pos (10UL) /*!< Position of SR10 field. */
N#define MWU_PERREGION_SUBSTATRA_SR10_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR10_Pos) /*!< Bit mask of SR10 field. */
N#define MWU_PERREGION_SUBSTATRA_SR10_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR10_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 9 : Subregion 9 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR9_Pos (9UL) /*!< Position of SR9 field. */
N#define MWU_PERREGION_SUBSTATRA_SR9_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR9_Pos) /*!< Bit mask of SR9 field. */
N#define MWU_PERREGION_SUBSTATRA_SR9_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR9_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 8 : Subregion 8 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR8_Pos (8UL) /*!< Position of SR8 field. */
N#define MWU_PERREGION_SUBSTATRA_SR8_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR8_Pos) /*!< Bit mask of SR8 field. */
N#define MWU_PERREGION_SUBSTATRA_SR8_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR8_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 7 : Subregion 7 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR7_Pos (7UL) /*!< Position of SR7 field. */
N#define MWU_PERREGION_SUBSTATRA_SR7_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR7_Pos) /*!< Bit mask of SR7 field. */
N#define MWU_PERREGION_SUBSTATRA_SR7_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR7_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 6 : Subregion 6 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR6_Pos (6UL) /*!< Position of SR6 field. */
N#define MWU_PERREGION_SUBSTATRA_SR6_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR6_Pos) /*!< Bit mask of SR6 field. */
N#define MWU_PERREGION_SUBSTATRA_SR6_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR6_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 5 : Subregion 5 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR5_Pos (5UL) /*!< Position of SR5 field. */
N#define MWU_PERREGION_SUBSTATRA_SR5_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR5_Pos) /*!< Bit mask of SR5 field. */
N#define MWU_PERREGION_SUBSTATRA_SR5_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR5_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 4 : Subregion 4 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR4_Pos (4UL) /*!< Position of SR4 field. */
N#define MWU_PERREGION_SUBSTATRA_SR4_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR4_Pos) /*!< Bit mask of SR4 field. */
N#define MWU_PERREGION_SUBSTATRA_SR4_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR4_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 3 : Subregion 3 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR3_Pos (3UL) /*!< Position of SR3 field. */
N#define MWU_PERREGION_SUBSTATRA_SR3_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR3_Pos) /*!< Bit mask of SR3 field. */
N#define MWU_PERREGION_SUBSTATRA_SR3_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR3_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 2 : Subregion 2 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR2_Pos (2UL) /*!< Position of SR2 field. */
N#define MWU_PERREGION_SUBSTATRA_SR2_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR2_Pos) /*!< Bit mask of SR2 field. */
N#define MWU_PERREGION_SUBSTATRA_SR2_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR2_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 1 : Subregion 1 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR1_Pos (1UL) /*!< Position of SR1 field. */
N#define MWU_PERREGION_SUBSTATRA_SR1_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR1_Pos) /*!< Bit mask of SR1 field. */
N#define MWU_PERREGION_SUBSTATRA_SR1_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR1_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Bit 0 : Subregion 0 in region 0 (write '1' to clear) */
N#define MWU_PERREGION_SUBSTATRA_SR0_Pos (0UL) /*!< Position of SR0 field. */
N#define MWU_PERREGION_SUBSTATRA_SR0_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR0_Pos) /*!< Bit mask of SR0 field. */
N#define MWU_PERREGION_SUBSTATRA_SR0_NoAccess (0UL) /*!< No read access occurred in this subregion */
N#define MWU_PERREGION_SUBSTATRA_SR0_Access (1UL) /*!< Read access(es) occurred in this subregion */
N
N/* Register: MWU_REGIONEN */
N/* Description: Enable/disable regions watch */
N
N/* Bit 27 : Enable/disable read access watch in PREGION[1] */
N#define MWU_REGIONEN_PRGN1RA_Pos (27UL) /*!< Position of PRGN1RA field. */
N#define MWU_REGIONEN_PRGN1RA_Msk (0x1UL << MWU_REGIONEN_PRGN1RA_Pos) /*!< Bit mask of PRGN1RA field. */
N#define MWU_REGIONEN_PRGN1RA_Disable (0UL) /*!< Disable read access watch in this PREGION */
N#define MWU_REGIONEN_PRGN1RA_Enable (1UL) /*!< Enable read access watch in this PREGION */
N
N/* Bit 26 : Enable/disable write access watch in PREGION[1] */
N#define MWU_REGIONEN_PRGN1WA_Pos (26UL) /*!< Position of PRGN1WA field. */
N#define MWU_REGIONEN_PRGN1WA_Msk (0x1UL << MWU_REGIONEN_PRGN1WA_Pos) /*!< Bit mask of PRGN1WA field. */
N#define MWU_REGIONEN_PRGN1WA_Disable (0UL) /*!< Disable write access watch in this PREGION */
N#define MWU_REGIONEN_PRGN1WA_Enable (1UL) /*!< Enable write access watch in this PREGION */
N
N/* Bit 25 : Enable/disable read access watch in PREGION[0] */
N#define MWU_REGIONEN_PRGN0RA_Pos (25UL) /*!< Position of PRGN0RA field. */
N#define MWU_REGIONEN_PRGN0RA_Msk (0x1UL << MWU_REGIONEN_PRGN0RA_Pos) /*!< Bit mask of PRGN0RA field. */
N#define MWU_REGIONEN_PRGN0RA_Disable (0UL) /*!< Disable read access watch in this PREGION */
N#define MWU_REGIONEN_PRGN0RA_Enable (1UL) /*!< Enable read access watch in this PREGION */
N
N/* Bit 24 : Enable/disable write access watch in PREGION[0] */
N#define MWU_REGIONEN_PRGN0WA_Pos (24UL) /*!< Position of PRGN0WA field. */
N#define MWU_REGIONEN_PRGN0WA_Msk (0x1UL << MWU_REGIONEN_PRGN0WA_Pos) /*!< Bit mask of PRGN0WA field. */
N#define MWU_REGIONEN_PRGN0WA_Disable (0UL) /*!< Disable write access watch in this PREGION */
N#define MWU_REGIONEN_PRGN0WA_Enable (1UL) /*!< Enable write access watch in this PREGION */
N
N/* Bit 7 : Enable/disable read access watch in region[3] */
N#define MWU_REGIONEN_RGN3RA_Pos (7UL) /*!< Position of RGN3RA field. */
N#define MWU_REGIONEN_RGN3RA_Msk (0x1UL << MWU_REGIONEN_RGN3RA_Pos) /*!< Bit mask of RGN3RA field. */
N#define MWU_REGIONEN_RGN3RA_Disable (0UL) /*!< Disable read access watch in this region */
N#define MWU_REGIONEN_RGN3RA_Enable (1UL) /*!< Enable read access watch in this region */
N
N/* Bit 6 : Enable/disable write access watch in region[3] */
N#define MWU_REGIONEN_RGN3WA_Pos (6UL) /*!< Position of RGN3WA field. */
N#define MWU_REGIONEN_RGN3WA_Msk (0x1UL << MWU_REGIONEN_RGN3WA_Pos) /*!< Bit mask of RGN3WA field. */
N#define MWU_REGIONEN_RGN3WA_Disable (0UL) /*!< Disable write access watch in this region */
N#define MWU_REGIONEN_RGN3WA_Enable (1UL) /*!< Enable write access watch in this region */
N
N/* Bit 5 : Enable/disable read access watch in region[2] */
N#define MWU_REGIONEN_RGN2RA_Pos (5UL) /*!< Position of RGN2RA field. */
N#define MWU_REGIONEN_RGN2RA_Msk (0x1UL << MWU_REGIONEN_RGN2RA_Pos) /*!< Bit mask of RGN2RA field. */
N#define MWU_REGIONEN_RGN2RA_Disable (0UL) /*!< Disable read access watch in this region */
N#define MWU_REGIONEN_RGN2RA_Enable (1UL) /*!< Enable read access watch in this region */
N
N/* Bit 4 : Enable/disable write access watch in region[2] */
N#define MWU_REGIONEN_RGN2WA_Pos (4UL) /*!< Position of RGN2WA field. */
N#define MWU_REGIONEN_RGN2WA_Msk (0x1UL << MWU_REGIONEN_RGN2WA_Pos) /*!< Bit mask of RGN2WA field. */
N#define MWU_REGIONEN_RGN2WA_Disable (0UL) /*!< Disable write access watch in this region */
N#define MWU_REGIONEN_RGN2WA_Enable (1UL) /*!< Enable write access watch in this region */
N
N/* Bit 3 : Enable/disable read access watch in region[1] */
N#define MWU_REGIONEN_RGN1RA_Pos (3UL) /*!< Position of RGN1RA field. */
N#define MWU_REGIONEN_RGN1RA_Msk (0x1UL << MWU_REGIONEN_RGN1RA_Pos) /*!< Bit mask of RGN1RA field. */
N#define MWU_REGIONEN_RGN1RA_Disable (0UL) /*!< Disable read access watch in this region */
N#define MWU_REGIONEN_RGN1RA_Enable (1UL) /*!< Enable read access watch in this region */
N
N/* Bit 2 : Enable/disable write access watch in region[1] */
N#define MWU_REGIONEN_RGN1WA_Pos (2UL) /*!< Position of RGN1WA field. */
N#define MWU_REGIONEN_RGN1WA_Msk (0x1UL << MWU_REGIONEN_RGN1WA_Pos) /*!< Bit mask of RGN1WA field. */
N#define MWU_REGIONEN_RGN1WA_Disable (0UL) /*!< Disable write access watch in this region */
N#define MWU_REGIONEN_RGN1WA_Enable (1UL) /*!< Enable write access watch in this region */
N
N/* Bit 1 : Enable/disable read access watch in region[0] */
N#define MWU_REGIONEN_RGN0RA_Pos (1UL) /*!< Position of RGN0RA field. */
N#define MWU_REGIONEN_RGN0RA_Msk (0x1UL << MWU_REGIONEN_RGN0RA_Pos) /*!< Bit mask of RGN0RA field. */
N#define MWU_REGIONEN_RGN0RA_Disable (0UL) /*!< Disable read access watch in this region */
N#define MWU_REGIONEN_RGN0RA_Enable (1UL) /*!< Enable read access watch in this region */
N
N/* Bit 0 : Enable/disable write access watch in region[0] */
N#define MWU_REGIONEN_RGN0WA_Pos (0UL) /*!< Position of RGN0WA field. */
N#define MWU_REGIONEN_RGN0WA_Msk (0x1UL << MWU_REGIONEN_RGN0WA_Pos) /*!< Bit mask of RGN0WA field. */
N#define MWU_REGIONEN_RGN0WA_Disable (0UL) /*!< Disable write access watch in this region */
N#define MWU_REGIONEN_RGN0WA_Enable (1UL) /*!< Enable write access watch in this region */
N
N/* Register: MWU_REGIONENSET */
N/* Description: Enable regions watch */
N
N/* Bit 27 : Enable read access watch in PREGION[1] */
N#define MWU_REGIONENSET_PRGN1RA_Pos (27UL) /*!< Position of PRGN1RA field. */
N#define MWU_REGIONENSET_PRGN1RA_Msk (0x1UL << MWU_REGIONENSET_PRGN1RA_Pos) /*!< Bit mask of PRGN1RA field. */
N#define MWU_REGIONENSET_PRGN1RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
N#define MWU_REGIONENSET_PRGN1RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
N#define MWU_REGIONENSET_PRGN1RA_Set (1UL) /*!< Enable read access watch in this PREGION */
N
N/* Bit 26 : Enable write access watch in PREGION[1] */
N#define MWU_REGIONENSET_PRGN1WA_Pos (26UL) /*!< Position of PRGN1WA field. */
N#define MWU_REGIONENSET_PRGN1WA_Msk (0x1UL << MWU_REGIONENSET_PRGN1WA_Pos) /*!< Bit mask of PRGN1WA field. */
N#define MWU_REGIONENSET_PRGN1WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
N#define MWU_REGIONENSET_PRGN1WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
N#define MWU_REGIONENSET_PRGN1WA_Set (1UL) /*!< Enable write access watch in this PREGION */
N
N/* Bit 25 : Enable read access watch in PREGION[0] */
N#define MWU_REGIONENSET_PRGN0RA_Pos (25UL) /*!< Position of PRGN0RA field. */
N#define MWU_REGIONENSET_PRGN0RA_Msk (0x1UL << MWU_REGIONENSET_PRGN0RA_Pos) /*!< Bit mask of PRGN0RA field. */
N#define MWU_REGIONENSET_PRGN0RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
N#define MWU_REGIONENSET_PRGN0RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
N#define MWU_REGIONENSET_PRGN0RA_Set (1UL) /*!< Enable read access watch in this PREGION */
N
N/* Bit 24 : Enable write access watch in PREGION[0] */
N#define MWU_REGIONENSET_PRGN0WA_Pos (24UL) /*!< Position of PRGN0WA field. */
N#define MWU_REGIONENSET_PRGN0WA_Msk (0x1UL << MWU_REGIONENSET_PRGN0WA_Pos) /*!< Bit mask of PRGN0WA field. */
N#define MWU_REGIONENSET_PRGN0WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
N#define MWU_REGIONENSET_PRGN0WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
N#define MWU_REGIONENSET_PRGN0WA_Set (1UL) /*!< Enable write access watch in this PREGION */
N
N/* Bit 7 : Enable read access watch in region[3] */
N#define MWU_REGIONENSET_RGN3RA_Pos (7UL) /*!< Position of RGN3RA field. */
N#define MWU_REGIONENSET_RGN3RA_Msk (0x1UL << MWU_REGIONENSET_RGN3RA_Pos) /*!< Bit mask of RGN3RA field. */
N#define MWU_REGIONENSET_RGN3RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
N#define MWU_REGIONENSET_RGN3RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
N#define MWU_REGIONENSET_RGN3RA_Set (1UL) /*!< Enable read access watch in this region */
N
N/* Bit 6 : Enable write access watch in region[3] */
N#define MWU_REGIONENSET_RGN3WA_Pos (6UL) /*!< Position of RGN3WA field. */
N#define MWU_REGIONENSET_RGN3WA_Msk (0x1UL << MWU_REGIONENSET_RGN3WA_Pos) /*!< Bit mask of RGN3WA field. */
N#define MWU_REGIONENSET_RGN3WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
N#define MWU_REGIONENSET_RGN3WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
N#define MWU_REGIONENSET_RGN3WA_Set (1UL) /*!< Enable write access watch in this region */
N
N/* Bit 5 : Enable read access watch in region[2] */
N#define MWU_REGIONENSET_RGN2RA_Pos (5UL) /*!< Position of RGN2RA field. */
N#define MWU_REGIONENSET_RGN2RA_Msk (0x1UL << MWU_REGIONENSET_RGN2RA_Pos) /*!< Bit mask of RGN2RA field. */
N#define MWU_REGIONENSET_RGN2RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
N#define MWU_REGIONENSET_RGN2RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
N#define MWU_REGIONENSET_RGN2RA_Set (1UL) /*!< Enable read access watch in this region */
N
N/* Bit 4 : Enable write access watch in region[2] */
N#define MWU_REGIONENSET_RGN2WA_Pos (4UL) /*!< Position of RGN2WA field. */
N#define MWU_REGIONENSET_RGN2WA_Msk (0x1UL << MWU_REGIONENSET_RGN2WA_Pos) /*!< Bit mask of RGN2WA field. */
N#define MWU_REGIONENSET_RGN2WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
N#define MWU_REGIONENSET_RGN2WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
N#define MWU_REGIONENSET_RGN2WA_Set (1UL) /*!< Enable write access watch in this region */
N
N/* Bit 3 : Enable read access watch in region[1] */
N#define MWU_REGIONENSET_RGN1RA_Pos (3UL) /*!< Position of RGN1RA field. */
N#define MWU_REGIONENSET_RGN1RA_Msk (0x1UL << MWU_REGIONENSET_RGN1RA_Pos) /*!< Bit mask of RGN1RA field. */
N#define MWU_REGIONENSET_RGN1RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
N#define MWU_REGIONENSET_RGN1RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
N#define MWU_REGIONENSET_RGN1RA_Set (1UL) /*!< Enable read access watch in this region */
N
N/* Bit 2 : Enable write access watch in region[1] */
N#define MWU_REGIONENSET_RGN1WA_Pos (2UL) /*!< Position of RGN1WA field. */
N#define MWU_REGIONENSET_RGN1WA_Msk (0x1UL << MWU_REGIONENSET_RGN1WA_Pos) /*!< Bit mask of RGN1WA field. */
N#define MWU_REGIONENSET_RGN1WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
N#define MWU_REGIONENSET_RGN1WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
N#define MWU_REGIONENSET_RGN1WA_Set (1UL) /*!< Enable write access watch in this region */
N
N/* Bit 1 : Enable read access watch in region[0] */
N#define MWU_REGIONENSET_RGN0RA_Pos (1UL) /*!< Position of RGN0RA field. */
N#define MWU_REGIONENSET_RGN0RA_Msk (0x1UL << MWU_REGIONENSET_RGN0RA_Pos) /*!< Bit mask of RGN0RA field. */
N#define MWU_REGIONENSET_RGN0RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
N#define MWU_REGIONENSET_RGN0RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
N#define MWU_REGIONENSET_RGN0RA_Set (1UL) /*!< Enable read access watch in this region */
N
N/* Bit 0 : Enable write access watch in region[0] */
N#define MWU_REGIONENSET_RGN0WA_Pos (0UL) /*!< Position of RGN0WA field. */
N#define MWU_REGIONENSET_RGN0WA_Msk (0x1UL << MWU_REGIONENSET_RGN0WA_Pos) /*!< Bit mask of RGN0WA field. */
N#define MWU_REGIONENSET_RGN0WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
N#define MWU_REGIONENSET_RGN0WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
N#define MWU_REGIONENSET_RGN0WA_Set (1UL) /*!< Enable write access watch in this region */
N
N/* Register: MWU_REGIONENCLR */
N/* Description: Disable regions watch */
N
N/* Bit 27 : Disable read access watch in PREGION[1] */
N#define MWU_REGIONENCLR_PRGN1RA_Pos (27UL) /*!< Position of PRGN1RA field. */
N#define MWU_REGIONENCLR_PRGN1RA_Msk (0x1UL << MWU_REGIONENCLR_PRGN1RA_Pos) /*!< Bit mask of PRGN1RA field. */
N#define MWU_REGIONENCLR_PRGN1RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
N#define MWU_REGIONENCLR_PRGN1RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
N#define MWU_REGIONENCLR_PRGN1RA_Clear (1UL) /*!< Disable read access watch in this PREGION */
N
N/* Bit 26 : Disable write access watch in PREGION[1] */
N#define MWU_REGIONENCLR_PRGN1WA_Pos (26UL) /*!< Position of PRGN1WA field. */
N#define MWU_REGIONENCLR_PRGN1WA_Msk (0x1UL << MWU_REGIONENCLR_PRGN1WA_Pos) /*!< Bit mask of PRGN1WA field. */
N#define MWU_REGIONENCLR_PRGN1WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
N#define MWU_REGIONENCLR_PRGN1WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
N#define MWU_REGIONENCLR_PRGN1WA_Clear (1UL) /*!< Disable write access watch in this PREGION */
N
N/* Bit 25 : Disable read access watch in PREGION[0] */
N#define MWU_REGIONENCLR_PRGN0RA_Pos (25UL) /*!< Position of PRGN0RA field. */
N#define MWU_REGIONENCLR_PRGN0RA_Msk (0x1UL << MWU_REGIONENCLR_PRGN0RA_Pos) /*!< Bit mask of PRGN0RA field. */
N#define MWU_REGIONENCLR_PRGN0RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
N#define MWU_REGIONENCLR_PRGN0RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
N#define MWU_REGIONENCLR_PRGN0RA_Clear (1UL) /*!< Disable read access watch in this PREGION */
N
N/* Bit 24 : Disable write access watch in PREGION[0] */
N#define MWU_REGIONENCLR_PRGN0WA_Pos (24UL) /*!< Position of PRGN0WA field. */
N#define MWU_REGIONENCLR_PRGN0WA_Msk (0x1UL << MWU_REGIONENCLR_PRGN0WA_Pos) /*!< Bit mask of PRGN0WA field. */
N#define MWU_REGIONENCLR_PRGN0WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
N#define MWU_REGIONENCLR_PRGN0WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
N#define MWU_REGIONENCLR_PRGN0WA_Clear (1UL) /*!< Disable write access watch in this PREGION */
N
N/* Bit 7 : Disable read access watch in region[3] */
N#define MWU_REGIONENCLR_RGN3RA_Pos (7UL) /*!< Position of RGN3RA field. */
N#define MWU_REGIONENCLR_RGN3RA_Msk (0x1UL << MWU_REGIONENCLR_RGN3RA_Pos) /*!< Bit mask of RGN3RA field. */
N#define MWU_REGIONENCLR_RGN3RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
N#define MWU_REGIONENCLR_RGN3RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
N#define MWU_REGIONENCLR_RGN3RA_Clear (1UL) /*!< Disable read access watch in this region */
N
N/* Bit 6 : Disable write access watch in region[3] */
N#define MWU_REGIONENCLR_RGN3WA_Pos (6UL) /*!< Position of RGN3WA field. */
N#define MWU_REGIONENCLR_RGN3WA_Msk (0x1UL << MWU_REGIONENCLR_RGN3WA_Pos) /*!< Bit mask of RGN3WA field. */
N#define MWU_REGIONENCLR_RGN3WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
N#define MWU_REGIONENCLR_RGN3WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
N#define MWU_REGIONENCLR_RGN3WA_Clear (1UL) /*!< Disable write access watch in this region */
N
N/* Bit 5 : Disable read access watch in region[2] */
N#define MWU_REGIONENCLR_RGN2RA_Pos (5UL) /*!< Position of RGN2RA field. */
N#define MWU_REGIONENCLR_RGN2RA_Msk (0x1UL << MWU_REGIONENCLR_RGN2RA_Pos) /*!< Bit mask of RGN2RA field. */
N#define MWU_REGIONENCLR_RGN2RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
N#define MWU_REGIONENCLR_RGN2RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
N#define MWU_REGIONENCLR_RGN2RA_Clear (1UL) /*!< Disable read access watch in this region */
N
N/* Bit 4 : Disable write access watch in region[2] */
N#define MWU_REGIONENCLR_RGN2WA_Pos (4UL) /*!< Position of RGN2WA field. */
N#define MWU_REGIONENCLR_RGN2WA_Msk (0x1UL << MWU_REGIONENCLR_RGN2WA_Pos) /*!< Bit mask of RGN2WA field. */
N#define MWU_REGIONENCLR_RGN2WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
N#define MWU_REGIONENCLR_RGN2WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
N#define MWU_REGIONENCLR_RGN2WA_Clear (1UL) /*!< Disable write access watch in this region */
N
N/* Bit 3 : Disable read access watch in region[1] */
N#define MWU_REGIONENCLR_RGN1RA_Pos (3UL) /*!< Position of RGN1RA field. */
N#define MWU_REGIONENCLR_RGN1RA_Msk (0x1UL << MWU_REGIONENCLR_RGN1RA_Pos) /*!< Bit mask of RGN1RA field. */
N#define MWU_REGIONENCLR_RGN1RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
N#define MWU_REGIONENCLR_RGN1RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
N#define MWU_REGIONENCLR_RGN1RA_Clear (1UL) /*!< Disable read access watch in this region */
N
N/* Bit 2 : Disable write access watch in region[1] */
N#define MWU_REGIONENCLR_RGN1WA_Pos (2UL) /*!< Position of RGN1WA field. */
N#define MWU_REGIONENCLR_RGN1WA_Msk (0x1UL << MWU_REGIONENCLR_RGN1WA_Pos) /*!< Bit mask of RGN1WA field. */
N#define MWU_REGIONENCLR_RGN1WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
N#define MWU_REGIONENCLR_RGN1WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
N#define MWU_REGIONENCLR_RGN1WA_Clear (1UL) /*!< Disable write access watch in this region */
N
N/* Bit 1 : Disable read access watch in region[0] */
N#define MWU_REGIONENCLR_RGN0RA_Pos (1UL) /*!< Position of RGN0RA field. */
N#define MWU_REGIONENCLR_RGN0RA_Msk (0x1UL << MWU_REGIONENCLR_RGN0RA_Pos) /*!< Bit mask of RGN0RA field. */
N#define MWU_REGIONENCLR_RGN0RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
N#define MWU_REGIONENCLR_RGN0RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
N#define MWU_REGIONENCLR_RGN0RA_Clear (1UL) /*!< Disable read access watch in this region */
N
N/* Bit 0 : Disable write access watch in region[0] */
N#define MWU_REGIONENCLR_RGN0WA_Pos (0UL) /*!< Position of RGN0WA field. */
N#define MWU_REGIONENCLR_RGN0WA_Msk (0x1UL << MWU_REGIONENCLR_RGN0WA_Pos) /*!< Bit mask of RGN0WA field. */
N#define MWU_REGIONENCLR_RGN0WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
N#define MWU_REGIONENCLR_RGN0WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
N#define MWU_REGIONENCLR_RGN0WA_Clear (1UL) /*!< Disable write access watch in this region */
N
N/* Register: MWU_REGION_START */
N/* Description: Description cluster[0]:  Start address for region 0 */
N
N/* Bits 31..0 : Start address for region */
N#define MWU_REGION_START_START_Pos (0UL) /*!< Position of START field. */
N#define MWU_REGION_START_START_Msk (0xFFFFFFFFUL << MWU_REGION_START_START_Pos) /*!< Bit mask of START field. */
N
N/* Register: MWU_REGION_END */
N/* Description: Description cluster[0]:  End address of region 0 */
N
N/* Bits 31..0 : End address of region. */
N#define MWU_REGION_END_END_Pos (0UL) /*!< Position of END field. */
N#define MWU_REGION_END_END_Msk (0xFFFFFFFFUL << MWU_REGION_END_END_Pos) /*!< Bit mask of END field. */
N
N/* Register: MWU_PREGION_START */
N/* Description: Description cluster[0]:  Reserved for future use */
N
N/* Bits 31..0 : Reserved for future use */
N#define MWU_PREGION_START_START_Pos (0UL) /*!< Position of START field. */
N#define MWU_PREGION_START_START_Msk (0xFFFFFFFFUL << MWU_PREGION_START_START_Pos) /*!< Bit mask of START field. */
N
N/* Register: MWU_PREGION_END */
N/* Description: Description cluster[0]:  Reserved for future use */
N
N/* Bits 31..0 : Reserved for future use */
N#define MWU_PREGION_END_END_Pos (0UL) /*!< Position of END field. */
N#define MWU_PREGION_END_END_Msk (0xFFFFFFFFUL << MWU_PREGION_END_END_Pos) /*!< Bit mask of END field. */
N
N/* Register: MWU_PREGION_SUBS */
N/* Description: Description cluster[0]:  Subregions of region 0 */
N
N/* Bit 31 : Include or exclude subregion 31 in region */
N#define MWU_PREGION_SUBS_SR31_Pos (31UL) /*!< Position of SR31 field. */
N#define MWU_PREGION_SUBS_SR31_Msk (0x1UL << MWU_PREGION_SUBS_SR31_Pos) /*!< Bit mask of SR31 field. */
N#define MWU_PREGION_SUBS_SR31_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR31_Include (1UL) /*!< Include */
N
N/* Bit 30 : Include or exclude subregion 30 in region */
N#define MWU_PREGION_SUBS_SR30_Pos (30UL) /*!< Position of SR30 field. */
N#define MWU_PREGION_SUBS_SR30_Msk (0x1UL << MWU_PREGION_SUBS_SR30_Pos) /*!< Bit mask of SR30 field. */
N#define MWU_PREGION_SUBS_SR30_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR30_Include (1UL) /*!< Include */
N
N/* Bit 29 : Include or exclude subregion 29 in region */
N#define MWU_PREGION_SUBS_SR29_Pos (29UL) /*!< Position of SR29 field. */
N#define MWU_PREGION_SUBS_SR29_Msk (0x1UL << MWU_PREGION_SUBS_SR29_Pos) /*!< Bit mask of SR29 field. */
N#define MWU_PREGION_SUBS_SR29_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR29_Include (1UL) /*!< Include */
N
N/* Bit 28 : Include or exclude subregion 28 in region */
N#define MWU_PREGION_SUBS_SR28_Pos (28UL) /*!< Position of SR28 field. */
N#define MWU_PREGION_SUBS_SR28_Msk (0x1UL << MWU_PREGION_SUBS_SR28_Pos) /*!< Bit mask of SR28 field. */
N#define MWU_PREGION_SUBS_SR28_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR28_Include (1UL) /*!< Include */
N
N/* Bit 27 : Include or exclude subregion 27 in region */
N#define MWU_PREGION_SUBS_SR27_Pos (27UL) /*!< Position of SR27 field. */
N#define MWU_PREGION_SUBS_SR27_Msk (0x1UL << MWU_PREGION_SUBS_SR27_Pos) /*!< Bit mask of SR27 field. */
N#define MWU_PREGION_SUBS_SR27_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR27_Include (1UL) /*!< Include */
N
N/* Bit 26 : Include or exclude subregion 26 in region */
N#define MWU_PREGION_SUBS_SR26_Pos (26UL) /*!< Position of SR26 field. */
N#define MWU_PREGION_SUBS_SR26_Msk (0x1UL << MWU_PREGION_SUBS_SR26_Pos) /*!< Bit mask of SR26 field. */
N#define MWU_PREGION_SUBS_SR26_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR26_Include (1UL) /*!< Include */
N
N/* Bit 25 : Include or exclude subregion 25 in region */
N#define MWU_PREGION_SUBS_SR25_Pos (25UL) /*!< Position of SR25 field. */
N#define MWU_PREGION_SUBS_SR25_Msk (0x1UL << MWU_PREGION_SUBS_SR25_Pos) /*!< Bit mask of SR25 field. */
N#define MWU_PREGION_SUBS_SR25_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR25_Include (1UL) /*!< Include */
N
N/* Bit 24 : Include or exclude subregion 24 in region */
N#define MWU_PREGION_SUBS_SR24_Pos (24UL) /*!< Position of SR24 field. */
N#define MWU_PREGION_SUBS_SR24_Msk (0x1UL << MWU_PREGION_SUBS_SR24_Pos) /*!< Bit mask of SR24 field. */
N#define MWU_PREGION_SUBS_SR24_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR24_Include (1UL) /*!< Include */
N
N/* Bit 23 : Include or exclude subregion 23 in region */
N#define MWU_PREGION_SUBS_SR23_Pos (23UL) /*!< Position of SR23 field. */
N#define MWU_PREGION_SUBS_SR23_Msk (0x1UL << MWU_PREGION_SUBS_SR23_Pos) /*!< Bit mask of SR23 field. */
N#define MWU_PREGION_SUBS_SR23_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR23_Include (1UL) /*!< Include */
N
N/* Bit 22 : Include or exclude subregion 22 in region */
N#define MWU_PREGION_SUBS_SR22_Pos (22UL) /*!< Position of SR22 field. */
N#define MWU_PREGION_SUBS_SR22_Msk (0x1UL << MWU_PREGION_SUBS_SR22_Pos) /*!< Bit mask of SR22 field. */
N#define MWU_PREGION_SUBS_SR22_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR22_Include (1UL) /*!< Include */
N
N/* Bit 21 : Include or exclude subregion 21 in region */
N#define MWU_PREGION_SUBS_SR21_Pos (21UL) /*!< Position of SR21 field. */
N#define MWU_PREGION_SUBS_SR21_Msk (0x1UL << MWU_PREGION_SUBS_SR21_Pos) /*!< Bit mask of SR21 field. */
N#define MWU_PREGION_SUBS_SR21_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR21_Include (1UL) /*!< Include */
N
N/* Bit 20 : Include or exclude subregion 20 in region */
N#define MWU_PREGION_SUBS_SR20_Pos (20UL) /*!< Position of SR20 field. */
N#define MWU_PREGION_SUBS_SR20_Msk (0x1UL << MWU_PREGION_SUBS_SR20_Pos) /*!< Bit mask of SR20 field. */
N#define MWU_PREGION_SUBS_SR20_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR20_Include (1UL) /*!< Include */
N
N/* Bit 19 : Include or exclude subregion 19 in region */
N#define MWU_PREGION_SUBS_SR19_Pos (19UL) /*!< Position of SR19 field. */
N#define MWU_PREGION_SUBS_SR19_Msk (0x1UL << MWU_PREGION_SUBS_SR19_Pos) /*!< Bit mask of SR19 field. */
N#define MWU_PREGION_SUBS_SR19_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR19_Include (1UL) /*!< Include */
N
N/* Bit 18 : Include or exclude subregion 18 in region */
N#define MWU_PREGION_SUBS_SR18_Pos (18UL) /*!< Position of SR18 field. */
N#define MWU_PREGION_SUBS_SR18_Msk (0x1UL << MWU_PREGION_SUBS_SR18_Pos) /*!< Bit mask of SR18 field. */
N#define MWU_PREGION_SUBS_SR18_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR18_Include (1UL) /*!< Include */
N
N/* Bit 17 : Include or exclude subregion 17 in region */
N#define MWU_PREGION_SUBS_SR17_Pos (17UL) /*!< Position of SR17 field. */
N#define MWU_PREGION_SUBS_SR17_Msk (0x1UL << MWU_PREGION_SUBS_SR17_Pos) /*!< Bit mask of SR17 field. */
N#define MWU_PREGION_SUBS_SR17_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR17_Include (1UL) /*!< Include */
N
N/* Bit 16 : Include or exclude subregion 16 in region */
N#define MWU_PREGION_SUBS_SR16_Pos (16UL) /*!< Position of SR16 field. */
N#define MWU_PREGION_SUBS_SR16_Msk (0x1UL << MWU_PREGION_SUBS_SR16_Pos) /*!< Bit mask of SR16 field. */
N#define MWU_PREGION_SUBS_SR16_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR16_Include (1UL) /*!< Include */
N
N/* Bit 15 : Include or exclude subregion 15 in region */
N#define MWU_PREGION_SUBS_SR15_Pos (15UL) /*!< Position of SR15 field. */
N#define MWU_PREGION_SUBS_SR15_Msk (0x1UL << MWU_PREGION_SUBS_SR15_Pos) /*!< Bit mask of SR15 field. */
N#define MWU_PREGION_SUBS_SR15_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR15_Include (1UL) /*!< Include */
N
N/* Bit 14 : Include or exclude subregion 14 in region */
N#define MWU_PREGION_SUBS_SR14_Pos (14UL) /*!< Position of SR14 field. */
N#define MWU_PREGION_SUBS_SR14_Msk (0x1UL << MWU_PREGION_SUBS_SR14_Pos) /*!< Bit mask of SR14 field. */
N#define MWU_PREGION_SUBS_SR14_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR14_Include (1UL) /*!< Include */
N
N/* Bit 13 : Include or exclude subregion 13 in region */
N#define MWU_PREGION_SUBS_SR13_Pos (13UL) /*!< Position of SR13 field. */
N#define MWU_PREGION_SUBS_SR13_Msk (0x1UL << MWU_PREGION_SUBS_SR13_Pos) /*!< Bit mask of SR13 field. */
N#define MWU_PREGION_SUBS_SR13_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR13_Include (1UL) /*!< Include */
N
N/* Bit 12 : Include or exclude subregion 12 in region */
N#define MWU_PREGION_SUBS_SR12_Pos (12UL) /*!< Position of SR12 field. */
N#define MWU_PREGION_SUBS_SR12_Msk (0x1UL << MWU_PREGION_SUBS_SR12_Pos) /*!< Bit mask of SR12 field. */
N#define MWU_PREGION_SUBS_SR12_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR12_Include (1UL) /*!< Include */
N
N/* Bit 11 : Include or exclude subregion 11 in region */
N#define MWU_PREGION_SUBS_SR11_Pos (11UL) /*!< Position of SR11 field. */
N#define MWU_PREGION_SUBS_SR11_Msk (0x1UL << MWU_PREGION_SUBS_SR11_Pos) /*!< Bit mask of SR11 field. */
N#define MWU_PREGION_SUBS_SR11_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR11_Include (1UL) /*!< Include */
N
N/* Bit 10 : Include or exclude subregion 10 in region */
N#define MWU_PREGION_SUBS_SR10_Pos (10UL) /*!< Position of SR10 field. */
N#define MWU_PREGION_SUBS_SR10_Msk (0x1UL << MWU_PREGION_SUBS_SR10_Pos) /*!< Bit mask of SR10 field. */
N#define MWU_PREGION_SUBS_SR10_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR10_Include (1UL) /*!< Include */
N
N/* Bit 9 : Include or exclude subregion 9 in region */
N#define MWU_PREGION_SUBS_SR9_Pos (9UL) /*!< Position of SR9 field. */
N#define MWU_PREGION_SUBS_SR9_Msk (0x1UL << MWU_PREGION_SUBS_SR9_Pos) /*!< Bit mask of SR9 field. */
N#define MWU_PREGION_SUBS_SR9_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR9_Include (1UL) /*!< Include */
N
N/* Bit 8 : Include or exclude subregion 8 in region */
N#define MWU_PREGION_SUBS_SR8_Pos (8UL) /*!< Position of SR8 field. */
N#define MWU_PREGION_SUBS_SR8_Msk (0x1UL << MWU_PREGION_SUBS_SR8_Pos) /*!< Bit mask of SR8 field. */
N#define MWU_PREGION_SUBS_SR8_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR8_Include (1UL) /*!< Include */
N
N/* Bit 7 : Include or exclude subregion 7 in region */
N#define MWU_PREGION_SUBS_SR7_Pos (7UL) /*!< Position of SR7 field. */
N#define MWU_PREGION_SUBS_SR7_Msk (0x1UL << MWU_PREGION_SUBS_SR7_Pos) /*!< Bit mask of SR7 field. */
N#define MWU_PREGION_SUBS_SR7_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR7_Include (1UL) /*!< Include */
N
N/* Bit 6 : Include or exclude subregion 6 in region */
N#define MWU_PREGION_SUBS_SR6_Pos (6UL) /*!< Position of SR6 field. */
N#define MWU_PREGION_SUBS_SR6_Msk (0x1UL << MWU_PREGION_SUBS_SR6_Pos) /*!< Bit mask of SR6 field. */
N#define MWU_PREGION_SUBS_SR6_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR6_Include (1UL) /*!< Include */
N
N/* Bit 5 : Include or exclude subregion 5 in region */
N#define MWU_PREGION_SUBS_SR5_Pos (5UL) /*!< Position of SR5 field. */
N#define MWU_PREGION_SUBS_SR5_Msk (0x1UL << MWU_PREGION_SUBS_SR5_Pos) /*!< Bit mask of SR5 field. */
N#define MWU_PREGION_SUBS_SR5_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR5_Include (1UL) /*!< Include */
N
N/* Bit 4 : Include or exclude subregion 4 in region */
N#define MWU_PREGION_SUBS_SR4_Pos (4UL) /*!< Position of SR4 field. */
N#define MWU_PREGION_SUBS_SR4_Msk (0x1UL << MWU_PREGION_SUBS_SR4_Pos) /*!< Bit mask of SR4 field. */
N#define MWU_PREGION_SUBS_SR4_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR4_Include (1UL) /*!< Include */
N
N/* Bit 3 : Include or exclude subregion 3 in region */
N#define MWU_PREGION_SUBS_SR3_Pos (3UL) /*!< Position of SR3 field. */
N#define MWU_PREGION_SUBS_SR3_Msk (0x1UL << MWU_PREGION_SUBS_SR3_Pos) /*!< Bit mask of SR3 field. */
N#define MWU_PREGION_SUBS_SR3_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR3_Include (1UL) /*!< Include */
N
N/* Bit 2 : Include or exclude subregion 2 in region */
N#define MWU_PREGION_SUBS_SR2_Pos (2UL) /*!< Position of SR2 field. */
N#define MWU_PREGION_SUBS_SR2_Msk (0x1UL << MWU_PREGION_SUBS_SR2_Pos) /*!< Bit mask of SR2 field. */
N#define MWU_PREGION_SUBS_SR2_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR2_Include (1UL) /*!< Include */
N
N/* Bit 1 : Include or exclude subregion 1 in region */
N#define MWU_PREGION_SUBS_SR1_Pos (1UL) /*!< Position of SR1 field. */
N#define MWU_PREGION_SUBS_SR1_Msk (0x1UL << MWU_PREGION_SUBS_SR1_Pos) /*!< Bit mask of SR1 field. */
N#define MWU_PREGION_SUBS_SR1_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR1_Include (1UL) /*!< Include */
N
N/* Bit 0 : Include or exclude subregion 0 in region */
N#define MWU_PREGION_SUBS_SR0_Pos (0UL) /*!< Position of SR0 field. */
N#define MWU_PREGION_SUBS_SR0_Msk (0x1UL << MWU_PREGION_SUBS_SR0_Pos) /*!< Bit mask of SR0 field. */
N#define MWU_PREGION_SUBS_SR0_Exclude (0UL) /*!< Exclude */
N#define MWU_PREGION_SUBS_SR0_Include (1UL) /*!< Include */
N
N
N/* Peripheral: NFCT */
N/* Description: NFC-A compatible radio */
N
N/* Register: NFCT_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 1 : Shortcut between FIELDLOST event and SENSE task */
N#define NFCT_SHORTS_FIELDLOST_SENSE_Pos (1UL) /*!< Position of FIELDLOST_SENSE field. */
N#define NFCT_SHORTS_FIELDLOST_SENSE_Msk (0x1UL << NFCT_SHORTS_FIELDLOST_SENSE_Pos) /*!< Bit mask of FIELDLOST_SENSE field. */
N#define NFCT_SHORTS_FIELDLOST_SENSE_Disabled (0UL) /*!< Disable shortcut */
N#define NFCT_SHORTS_FIELDLOST_SENSE_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 0 : Shortcut between FIELDDETECTED event and ACTIVATE task */
N#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Pos (0UL) /*!< Position of FIELDDETECTED_ACTIVATE field. */
N#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Msk (0x1UL << NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Pos) /*!< Bit mask of FIELDDETECTED_ACTIVATE field. */
N#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Disabled (0UL) /*!< Disable shortcut */
N#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: NFCT_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 20 : Enable or disable interrupt for STARTED event */
N#define NFCT_INTEN_STARTED_Pos (20UL) /*!< Position of STARTED field. */
N#define NFCT_INTEN_STARTED_Msk (0x1UL << NFCT_INTEN_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define NFCT_INTEN_STARTED_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_STARTED_Enabled (1UL) /*!< Enable */
N
N/* Bit 19 : Enable or disable interrupt for SELECTED event */
N#define NFCT_INTEN_SELECTED_Pos (19UL) /*!< Position of SELECTED field. */
N#define NFCT_INTEN_SELECTED_Msk (0x1UL << NFCT_INTEN_SELECTED_Pos) /*!< Bit mask of SELECTED field. */
N#define NFCT_INTEN_SELECTED_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_SELECTED_Enabled (1UL) /*!< Enable */
N
N/* Bit 18 : Enable or disable interrupt for COLLISION event */
N#define NFCT_INTEN_COLLISION_Pos (18UL) /*!< Position of COLLISION field. */
N#define NFCT_INTEN_COLLISION_Msk (0x1UL << NFCT_INTEN_COLLISION_Pos) /*!< Bit mask of COLLISION field. */
N#define NFCT_INTEN_COLLISION_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_COLLISION_Enabled (1UL) /*!< Enable */
N
N/* Bit 14 : Enable or disable interrupt for AUTOCOLRESSTARTED event */
N#define NFCT_INTEN_AUTOCOLRESSTARTED_Pos (14UL) /*!< Position of AUTOCOLRESSTARTED field. */
N#define NFCT_INTEN_AUTOCOLRESSTARTED_Msk (0x1UL << NFCT_INTEN_AUTOCOLRESSTARTED_Pos) /*!< Bit mask of AUTOCOLRESSTARTED field. */
N#define NFCT_INTEN_AUTOCOLRESSTARTED_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_AUTOCOLRESSTARTED_Enabled (1UL) /*!< Enable */
N
N/* Bit 12 : Enable or disable interrupt for ENDTX event */
N#define NFCT_INTEN_ENDTX_Pos (12UL) /*!< Position of ENDTX field. */
N#define NFCT_INTEN_ENDTX_Msk (0x1UL << NFCT_INTEN_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
N#define NFCT_INTEN_ENDTX_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_ENDTX_Enabled (1UL) /*!< Enable */
N
N/* Bit 11 : Enable or disable interrupt for ENDRX event */
N#define NFCT_INTEN_ENDRX_Pos (11UL) /*!< Position of ENDRX field. */
N#define NFCT_INTEN_ENDRX_Msk (0x1UL << NFCT_INTEN_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define NFCT_INTEN_ENDRX_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_ENDRX_Enabled (1UL) /*!< Enable */
N
N/* Bit 10 : Enable or disable interrupt for RXERROR event */
N#define NFCT_INTEN_RXERROR_Pos (10UL) /*!< Position of RXERROR field. */
N#define NFCT_INTEN_RXERROR_Msk (0x1UL << NFCT_INTEN_RXERROR_Pos) /*!< Bit mask of RXERROR field. */
N#define NFCT_INTEN_RXERROR_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_RXERROR_Enabled (1UL) /*!< Enable */
N
N/* Bit 7 : Enable or disable interrupt for ERROR event */
N#define NFCT_INTEN_ERROR_Pos (7UL) /*!< Position of ERROR field. */
N#define NFCT_INTEN_ERROR_Msk (0x1UL << NFCT_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define NFCT_INTEN_ERROR_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_ERROR_Enabled (1UL) /*!< Enable */
N
N/* Bit 6 : Enable or disable interrupt for RXFRAMEEND event */
N#define NFCT_INTEN_RXFRAMEEND_Pos (6UL) /*!< Position of RXFRAMEEND field. */
N#define NFCT_INTEN_RXFRAMEEND_Msk (0x1UL << NFCT_INTEN_RXFRAMEEND_Pos) /*!< Bit mask of RXFRAMEEND field. */
N#define NFCT_INTEN_RXFRAMEEND_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_RXFRAMEEND_Enabled (1UL) /*!< Enable */
N
N/* Bit 5 : Enable or disable interrupt for RXFRAMESTART event */
N#define NFCT_INTEN_RXFRAMESTART_Pos (5UL) /*!< Position of RXFRAMESTART field. */
N#define NFCT_INTEN_RXFRAMESTART_Msk (0x1UL << NFCT_INTEN_RXFRAMESTART_Pos) /*!< Bit mask of RXFRAMESTART field. */
N#define NFCT_INTEN_RXFRAMESTART_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_RXFRAMESTART_Enabled (1UL) /*!< Enable */
N
N/* Bit 4 : Enable or disable interrupt for TXFRAMEEND event */
N#define NFCT_INTEN_TXFRAMEEND_Pos (4UL) /*!< Position of TXFRAMEEND field. */
N#define NFCT_INTEN_TXFRAMEEND_Msk (0x1UL << NFCT_INTEN_TXFRAMEEND_Pos) /*!< Bit mask of TXFRAMEEND field. */
N#define NFCT_INTEN_TXFRAMEEND_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_TXFRAMEEND_Enabled (1UL) /*!< Enable */
N
N/* Bit 3 : Enable or disable interrupt for TXFRAMESTART event */
N#define NFCT_INTEN_TXFRAMESTART_Pos (3UL) /*!< Position of TXFRAMESTART field. */
N#define NFCT_INTEN_TXFRAMESTART_Msk (0x1UL << NFCT_INTEN_TXFRAMESTART_Pos) /*!< Bit mask of TXFRAMESTART field. */
N#define NFCT_INTEN_TXFRAMESTART_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_TXFRAMESTART_Enabled (1UL) /*!< Enable */
N
N/* Bit 2 : Enable or disable interrupt for FIELDLOST event */
N#define NFCT_INTEN_FIELDLOST_Pos (2UL) /*!< Position of FIELDLOST field. */
N#define NFCT_INTEN_FIELDLOST_Msk (0x1UL << NFCT_INTEN_FIELDLOST_Pos) /*!< Bit mask of FIELDLOST field. */
N#define NFCT_INTEN_FIELDLOST_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_FIELDLOST_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for FIELDDETECTED event */
N#define NFCT_INTEN_FIELDDETECTED_Pos (1UL) /*!< Position of FIELDDETECTED field. */
N#define NFCT_INTEN_FIELDDETECTED_Msk (0x1UL << NFCT_INTEN_FIELDDETECTED_Pos) /*!< Bit mask of FIELDDETECTED field. */
N#define NFCT_INTEN_FIELDDETECTED_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_FIELDDETECTED_Enabled (1UL) /*!< Enable */
N
N/* Bit 0 : Enable or disable interrupt for READY event */
N#define NFCT_INTEN_READY_Pos (0UL) /*!< Position of READY field. */
N#define NFCT_INTEN_READY_Msk (0x1UL << NFCT_INTEN_READY_Pos) /*!< Bit mask of READY field. */
N#define NFCT_INTEN_READY_Disabled (0UL) /*!< Disable */
N#define NFCT_INTEN_READY_Enabled (1UL) /*!< Enable */
N
N/* Register: NFCT_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 20 : Write '1' to Enable interrupt for STARTED event */
N#define NFCT_INTENSET_STARTED_Pos (20UL) /*!< Position of STARTED field. */
N#define NFCT_INTENSET_STARTED_Msk (0x1UL << NFCT_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define NFCT_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_STARTED_Set (1UL) /*!< Enable */
N
N/* Bit 19 : Write '1' to Enable interrupt for SELECTED event */
N#define NFCT_INTENSET_SELECTED_Pos (19UL) /*!< Position of SELECTED field. */
N#define NFCT_INTENSET_SELECTED_Msk (0x1UL << NFCT_INTENSET_SELECTED_Pos) /*!< Bit mask of SELECTED field. */
N#define NFCT_INTENSET_SELECTED_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_SELECTED_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_SELECTED_Set (1UL) /*!< Enable */
N
N/* Bit 18 : Write '1' to Enable interrupt for COLLISION event */
N#define NFCT_INTENSET_COLLISION_Pos (18UL) /*!< Position of COLLISION field. */
N#define NFCT_INTENSET_COLLISION_Msk (0x1UL << NFCT_INTENSET_COLLISION_Pos) /*!< Bit mask of COLLISION field. */
N#define NFCT_INTENSET_COLLISION_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_COLLISION_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_COLLISION_Set (1UL) /*!< Enable */
N
N/* Bit 14 : Write '1' to Enable interrupt for AUTOCOLRESSTARTED event */
N#define NFCT_INTENSET_AUTOCOLRESSTARTED_Pos (14UL) /*!< Position of AUTOCOLRESSTARTED field. */
N#define NFCT_INTENSET_AUTOCOLRESSTARTED_Msk (0x1UL << NFCT_INTENSET_AUTOCOLRESSTARTED_Pos) /*!< Bit mask of AUTOCOLRESSTARTED field. */
N#define NFCT_INTENSET_AUTOCOLRESSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_AUTOCOLRESSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_AUTOCOLRESSTARTED_Set (1UL) /*!< Enable */
N
N/* Bit 12 : Write '1' to Enable interrupt for ENDTX event */
N#define NFCT_INTENSET_ENDTX_Pos (12UL) /*!< Position of ENDTX field. */
N#define NFCT_INTENSET_ENDTX_Msk (0x1UL << NFCT_INTENSET_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
N#define NFCT_INTENSET_ENDTX_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_ENDTX_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_ENDTX_Set (1UL) /*!< Enable */
N
N/* Bit 11 : Write '1' to Enable interrupt for ENDRX event */
N#define NFCT_INTENSET_ENDRX_Pos (11UL) /*!< Position of ENDRX field. */
N#define NFCT_INTENSET_ENDRX_Msk (0x1UL << NFCT_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define NFCT_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_ENDRX_Set (1UL) /*!< Enable */
N
N/* Bit 10 : Write '1' to Enable interrupt for RXERROR event */
N#define NFCT_INTENSET_RXERROR_Pos (10UL) /*!< Position of RXERROR field. */
N#define NFCT_INTENSET_RXERROR_Msk (0x1UL << NFCT_INTENSET_RXERROR_Pos) /*!< Bit mask of RXERROR field. */
N#define NFCT_INTENSET_RXERROR_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_RXERROR_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_RXERROR_Set (1UL) /*!< Enable */
N
N/* Bit 7 : Write '1' to Enable interrupt for ERROR event */
N#define NFCT_INTENSET_ERROR_Pos (7UL) /*!< Position of ERROR field. */
N#define NFCT_INTENSET_ERROR_Msk (0x1UL << NFCT_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define NFCT_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_ERROR_Set (1UL) /*!< Enable */
N
N/* Bit 6 : Write '1' to Enable interrupt for RXFRAMEEND event */
N#define NFCT_INTENSET_RXFRAMEEND_Pos (6UL) /*!< Position of RXFRAMEEND field. */
N#define NFCT_INTENSET_RXFRAMEEND_Msk (0x1UL << NFCT_INTENSET_RXFRAMEEND_Pos) /*!< Bit mask of RXFRAMEEND field. */
N#define NFCT_INTENSET_RXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_RXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_RXFRAMEEND_Set (1UL) /*!< Enable */
N
N/* Bit 5 : Write '1' to Enable interrupt for RXFRAMESTART event */
N#define NFCT_INTENSET_RXFRAMESTART_Pos (5UL) /*!< Position of RXFRAMESTART field. */
N#define NFCT_INTENSET_RXFRAMESTART_Msk (0x1UL << NFCT_INTENSET_RXFRAMESTART_Pos) /*!< Bit mask of RXFRAMESTART field. */
N#define NFCT_INTENSET_RXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_RXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_RXFRAMESTART_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable interrupt for TXFRAMEEND event */
N#define NFCT_INTENSET_TXFRAMEEND_Pos (4UL) /*!< Position of TXFRAMEEND field. */
N#define NFCT_INTENSET_TXFRAMEEND_Msk (0x1UL << NFCT_INTENSET_TXFRAMEEND_Pos) /*!< Bit mask of TXFRAMEEND field. */
N#define NFCT_INTENSET_TXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_TXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_TXFRAMEEND_Set (1UL) /*!< Enable */
N
N/* Bit 3 : Write '1' to Enable interrupt for TXFRAMESTART event */
N#define NFCT_INTENSET_TXFRAMESTART_Pos (3UL) /*!< Position of TXFRAMESTART field. */
N#define NFCT_INTENSET_TXFRAMESTART_Msk (0x1UL << NFCT_INTENSET_TXFRAMESTART_Pos) /*!< Bit mask of TXFRAMESTART field. */
N#define NFCT_INTENSET_TXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_TXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_TXFRAMESTART_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for FIELDLOST event */
N#define NFCT_INTENSET_FIELDLOST_Pos (2UL) /*!< Position of FIELDLOST field. */
N#define NFCT_INTENSET_FIELDLOST_Msk (0x1UL << NFCT_INTENSET_FIELDLOST_Pos) /*!< Bit mask of FIELDLOST field. */
N#define NFCT_INTENSET_FIELDLOST_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_FIELDLOST_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_FIELDLOST_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for FIELDDETECTED event */
N#define NFCT_INTENSET_FIELDDETECTED_Pos (1UL) /*!< Position of FIELDDETECTED field. */
N#define NFCT_INTENSET_FIELDDETECTED_Msk (0x1UL << NFCT_INTENSET_FIELDDETECTED_Pos) /*!< Bit mask of FIELDDETECTED field. */
N#define NFCT_INTENSET_FIELDDETECTED_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_FIELDDETECTED_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_FIELDDETECTED_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for READY event */
N#define NFCT_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define NFCT_INTENSET_READY_Msk (0x1UL << NFCT_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define NFCT_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENSET_READY_Set (1UL) /*!< Enable */
N
N/* Register: NFCT_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 20 : Write '1' to Disable interrupt for STARTED event */
N#define NFCT_INTENCLR_STARTED_Pos (20UL) /*!< Position of STARTED field. */
N#define NFCT_INTENCLR_STARTED_Msk (0x1UL << NFCT_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define NFCT_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
N
N/* Bit 19 : Write '1' to Disable interrupt for SELECTED event */
N#define NFCT_INTENCLR_SELECTED_Pos (19UL) /*!< Position of SELECTED field. */
N#define NFCT_INTENCLR_SELECTED_Msk (0x1UL << NFCT_INTENCLR_SELECTED_Pos) /*!< Bit mask of SELECTED field. */
N#define NFCT_INTENCLR_SELECTED_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_SELECTED_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_SELECTED_Clear (1UL) /*!< Disable */
N
N/* Bit 18 : Write '1' to Disable interrupt for COLLISION event */
N#define NFCT_INTENCLR_COLLISION_Pos (18UL) /*!< Position of COLLISION field. */
N#define NFCT_INTENCLR_COLLISION_Msk (0x1UL << NFCT_INTENCLR_COLLISION_Pos) /*!< Bit mask of COLLISION field. */
N#define NFCT_INTENCLR_COLLISION_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_COLLISION_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_COLLISION_Clear (1UL) /*!< Disable */
N
N/* Bit 14 : Write '1' to Disable interrupt for AUTOCOLRESSTARTED event */
N#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Pos (14UL) /*!< Position of AUTOCOLRESSTARTED field. */
N#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Msk (0x1UL << NFCT_INTENCLR_AUTOCOLRESSTARTED_Pos) /*!< Bit mask of AUTOCOLRESSTARTED field. */
N#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Clear (1UL) /*!< Disable */
N
N/* Bit 12 : Write '1' to Disable interrupt for ENDTX event */
N#define NFCT_INTENCLR_ENDTX_Pos (12UL) /*!< Position of ENDTX field. */
N#define NFCT_INTENCLR_ENDTX_Msk (0x1UL << NFCT_INTENCLR_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
N#define NFCT_INTENCLR_ENDTX_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_ENDTX_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_ENDTX_Clear (1UL) /*!< Disable */
N
N/* Bit 11 : Write '1' to Disable interrupt for ENDRX event */
N#define NFCT_INTENCLR_ENDRX_Pos (11UL) /*!< Position of ENDRX field. */
N#define NFCT_INTENCLR_ENDRX_Msk (0x1UL << NFCT_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define NFCT_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
N
N/* Bit 10 : Write '1' to Disable interrupt for RXERROR event */
N#define NFCT_INTENCLR_RXERROR_Pos (10UL) /*!< Position of RXERROR field. */
N#define NFCT_INTENCLR_RXERROR_Msk (0x1UL << NFCT_INTENCLR_RXERROR_Pos) /*!< Bit mask of RXERROR field. */
N#define NFCT_INTENCLR_RXERROR_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_RXERROR_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_RXERROR_Clear (1UL) /*!< Disable */
N
N/* Bit 7 : Write '1' to Disable interrupt for ERROR event */
N#define NFCT_INTENCLR_ERROR_Pos (7UL) /*!< Position of ERROR field. */
N#define NFCT_INTENCLR_ERROR_Msk (0x1UL << NFCT_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define NFCT_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
N
N/* Bit 6 : Write '1' to Disable interrupt for RXFRAMEEND event */
N#define NFCT_INTENCLR_RXFRAMEEND_Pos (6UL) /*!< Position of RXFRAMEEND field. */
N#define NFCT_INTENCLR_RXFRAMEEND_Msk (0x1UL << NFCT_INTENCLR_RXFRAMEEND_Pos) /*!< Bit mask of RXFRAMEEND field. */
N#define NFCT_INTENCLR_RXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_RXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_RXFRAMEEND_Clear (1UL) /*!< Disable */
N
N/* Bit 5 : Write '1' to Disable interrupt for RXFRAMESTART event */
N#define NFCT_INTENCLR_RXFRAMESTART_Pos (5UL) /*!< Position of RXFRAMESTART field. */
N#define NFCT_INTENCLR_RXFRAMESTART_Msk (0x1UL << NFCT_INTENCLR_RXFRAMESTART_Pos) /*!< Bit mask of RXFRAMESTART field. */
N#define NFCT_INTENCLR_RXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_RXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_RXFRAMESTART_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable interrupt for TXFRAMEEND event */
N#define NFCT_INTENCLR_TXFRAMEEND_Pos (4UL) /*!< Position of TXFRAMEEND field. */
N#define NFCT_INTENCLR_TXFRAMEEND_Msk (0x1UL << NFCT_INTENCLR_TXFRAMEEND_Pos) /*!< Bit mask of TXFRAMEEND field. */
N#define NFCT_INTENCLR_TXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_TXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_TXFRAMEEND_Clear (1UL) /*!< Disable */
N
N/* Bit 3 : Write '1' to Disable interrupt for TXFRAMESTART event */
N#define NFCT_INTENCLR_TXFRAMESTART_Pos (3UL) /*!< Position of TXFRAMESTART field. */
N#define NFCT_INTENCLR_TXFRAMESTART_Msk (0x1UL << NFCT_INTENCLR_TXFRAMESTART_Pos) /*!< Bit mask of TXFRAMESTART field. */
N#define NFCT_INTENCLR_TXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_TXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_TXFRAMESTART_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for FIELDLOST event */
N#define NFCT_INTENCLR_FIELDLOST_Pos (2UL) /*!< Position of FIELDLOST field. */
N#define NFCT_INTENCLR_FIELDLOST_Msk (0x1UL << NFCT_INTENCLR_FIELDLOST_Pos) /*!< Bit mask of FIELDLOST field. */
N#define NFCT_INTENCLR_FIELDLOST_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_FIELDLOST_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_FIELDLOST_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for FIELDDETECTED event */
N#define NFCT_INTENCLR_FIELDDETECTED_Pos (1UL) /*!< Position of FIELDDETECTED field. */
N#define NFCT_INTENCLR_FIELDDETECTED_Msk (0x1UL << NFCT_INTENCLR_FIELDDETECTED_Pos) /*!< Bit mask of FIELDDETECTED field. */
N#define NFCT_INTENCLR_FIELDDETECTED_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_FIELDDETECTED_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_FIELDDETECTED_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for READY event */
N#define NFCT_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define NFCT_INTENCLR_READY_Msk (0x1UL << NFCT_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define NFCT_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
N#define NFCT_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
N#define NFCT_INTENCLR_READY_Clear (1UL) /*!< Disable */
N
N/* Register: NFCT_ERRORSTATUS */
N/* Description: NFC Error Status register */
N
N/* Bit 3 : Field level is too low at min load resistance */
N#define NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Pos (3UL) /*!< Position of NFCFIELDTOOWEAK field. */
N#define NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Msk (0x1UL << NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Pos) /*!< Bit mask of NFCFIELDTOOWEAK field. */
N
N/* Bit 2 : Field level is too high at max load resistance */
N#define NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Pos (2UL) /*!< Position of NFCFIELDTOOSTRONG field. */
N#define NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Msk (0x1UL << NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Pos) /*!< Bit mask of NFCFIELDTOOSTRONG field. */
N
N/* Bit 0 : No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX */
N#define NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Pos (0UL) /*!< Position of FRAMEDELAYTIMEOUT field. */
N#define NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Msk (0x1UL << NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Pos) /*!< Bit mask of FRAMEDELAYTIMEOUT field. */
N
N/* Register: NFCT_FRAMESTATUS_RX */
N/* Description: Result of last incoming frames */
N
N/* Bit 3 : Overrun detected */
N#define NFCT_FRAMESTATUS_RX_OVERRUN_Pos (3UL) /*!< Position of OVERRUN field. */
N#define NFCT_FRAMESTATUS_RX_OVERRUN_Msk (0x1UL << NFCT_FRAMESTATUS_RX_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
N#define NFCT_FRAMESTATUS_RX_OVERRUN_NoOverrun (0UL) /*!< No overrun detected */
N#define NFCT_FRAMESTATUS_RX_OVERRUN_Overrun (1UL) /*!< Overrun error */
N
N/* Bit 2 : Parity status of received frame */
N#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_Pos (2UL) /*!< Position of PARITYSTATUS field. */
N#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_Msk (0x1UL << NFCT_FRAMESTATUS_RX_PARITYSTATUS_Pos) /*!< Bit mask of PARITYSTATUS field. */
N#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_ParityOK (0UL) /*!< Frame received with parity OK */
N#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_ParityError (1UL) /*!< Frame received with parity error */
N
N/* Bit 0 : No valid End of Frame detected */
N#define NFCT_FRAMESTATUS_RX_CRCERROR_Pos (0UL) /*!< Position of CRCERROR field. */
N#define NFCT_FRAMESTATUS_RX_CRCERROR_Msk (0x1UL << NFCT_FRAMESTATUS_RX_CRCERROR_Pos) /*!< Bit mask of CRCERROR field. */
N#define NFCT_FRAMESTATUS_RX_CRCERROR_CRCCorrect (0UL) /*!< Valid CRC detected */
N#define NFCT_FRAMESTATUS_RX_CRCERROR_CRCError (1UL) /*!< CRC received does not match local check */
N
N/* Register: NFCT_CURRENTLOADCTRL */
N/* Description: Current value driven to the NFC Load Control */
N
N/* Bits 5..0 : Current value driven to the NFC Load Control */
N#define NFCT_CURRENTLOADCTRL_CURRENTLOADCTRL_Pos (0UL) /*!< Position of CURRENTLOADCTRL field. */
N#define NFCT_CURRENTLOADCTRL_CURRENTLOADCTRL_Msk (0x3FUL << NFCT_CURRENTLOADCTRL_CURRENTLOADCTRL_Pos) /*!< Bit mask of CURRENTLOADCTRL field. */
N
N/* Register: NFCT_FIELDPRESENT */
N/* Description: Indicates the presence or not of a valid field */
N
N/* Bit 1 : Indicates if the low level has locked to the field */
N#define NFCT_FIELDPRESENT_LOCKDETECT_Pos (1UL) /*!< Position of LOCKDETECT field. */
N#define NFCT_FIELDPRESENT_LOCKDETECT_Msk (0x1UL << NFCT_FIELDPRESENT_LOCKDETECT_Pos) /*!< Bit mask of LOCKDETECT field. */
N#define NFCT_FIELDPRESENT_LOCKDETECT_NotLocked (0UL) /*!< Not locked to field */
N#define NFCT_FIELDPRESENT_LOCKDETECT_Locked (1UL) /*!< Locked to field */
N
N/* Bit 0 : Indicates the presence or not of a valid field. Available only in the activated state. */
N#define NFCT_FIELDPRESENT_FIELDPRESENT_Pos (0UL) /*!< Position of FIELDPRESENT field. */
N#define NFCT_FIELDPRESENT_FIELDPRESENT_Msk (0x1UL << NFCT_FIELDPRESENT_FIELDPRESENT_Pos) /*!< Bit mask of FIELDPRESENT field. */
N#define NFCT_FIELDPRESENT_FIELDPRESENT_NoField (0UL) /*!< No valid field detected */
N#define NFCT_FIELDPRESENT_FIELDPRESENT_FieldPresent (1UL) /*!< Valid field detected */
N
N/* Register: NFCT_FRAMEDELAYMIN */
N/* Description: Minimum frame delay */
N
N/* Bits 15..0 : Minimum frame delay in number of 13.56 MHz clocks */
N#define NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos (0UL) /*!< Position of FRAMEDELAYMIN field. */
N#define NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Msk (0xFFFFUL << NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos) /*!< Bit mask of FRAMEDELAYMIN field. */
N
N/* Register: NFCT_FRAMEDELAYMAX */
N/* Description: Maximum frame delay */
N
N/* Bits 15..0 : Maximum frame delay in number of 13.56 MHz clocks */
N#define NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos (0UL) /*!< Position of FRAMEDELAYMAX field. */
N#define NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Msk (0xFFFFUL << NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos) /*!< Bit mask of FRAMEDELAYMAX field. */
N
N/* Register: NFCT_FRAMEDELAYMODE */
N/* Description: Configuration register for the Frame Delay Timer */
N
N/* Bits 1..0 : Configuration register for the Frame Delay Timer */
N#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Pos (0UL) /*!< Position of FRAMEDELAYMODE field. */
N#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Msk (0x3UL << NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Pos) /*!< Bit mask of FRAMEDELAYMODE field. */
N#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_FreeRun (0UL) /*!< Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout. */
N#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Window (1UL) /*!< Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX */
N#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_ExactVal (2UL) /*!< Frame is transmitted exactly at FRAMEDELAYMAX */
N#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_WindowGrid (3UL) /*!< Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX */
N
N/* Register: NFCT_PACKETPTR */
N/* Description: Packet pointer for TXD and RXD data storage in Data RAM */
N
N/* Bits 31..0 : Packet pointer for TXD and RXD data storage in Data RAM. This address is a byte aligned RAM address. */
N#define NFCT_PACKETPTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define NFCT_PACKETPTR_PTR_Msk (0xFFFFFFFFUL << NFCT_PACKETPTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: NFCT_MAXLEN */
N/* Description: Size of allocated for TXD and RXD data storage buffer in Data RAM */
N
N/* Bits 8..0 : Size of allocated for TXD and RXD data storage buffer in Data RAM */
N#define NFCT_MAXLEN_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
N#define NFCT_MAXLEN_MAXLEN_Msk (0x1FFUL << NFCT_MAXLEN_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
N
N/* Register: NFCT_TXD_FRAMECONFIG */
N/* Description: Configuration of outgoing frames */
N
N/* Bit 4 : CRC mode for outgoing frames */
N#define NFCT_TXD_FRAMECONFIG_CRCMODETX_Pos (4UL) /*!< Position of CRCMODETX field. */
N#define NFCT_TXD_FRAMECONFIG_CRCMODETX_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_CRCMODETX_Pos) /*!< Bit mask of CRCMODETX field. */
N#define NFCT_TXD_FRAMECONFIG_CRCMODETX_NoCRCTX (0UL) /*!< CRC is not added to the frame */
N#define NFCT_TXD_FRAMECONFIG_CRCMODETX_CRC16TX (1UL) /*!< 16 bit CRC added to the frame based on all the data read from RAM that is used in the frame */
N
N/* Bit 2 : Adding SoF or not in TX frames */
N#define NFCT_TXD_FRAMECONFIG_SOF_Pos (2UL) /*!< Position of SOF field. */
N#define NFCT_TXD_FRAMECONFIG_SOF_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_SOF_Pos) /*!< Bit mask of SOF field. */
N#define NFCT_TXD_FRAMECONFIG_SOF_NoSoF (0UL) /*!< Start of Frame symbol not added */
N#define NFCT_TXD_FRAMECONFIG_SOF_SoF (1UL) /*!< Start of Frame symbol added */
N
N/* Bit 1 : Discarding unused bits in start or at end of a Frame */
N#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_Pos (1UL) /*!< Position of DISCARDMODE field. */
N#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_DISCARDMODE_Pos) /*!< Bit mask of DISCARDMODE field. */
N#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_DiscardEnd (0UL) /*!< Unused bits is discarded at end of frame */
N#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_DiscardStart (1UL) /*!< Unused bits is discarded at start of frame */
N
N/* Bit 0 : Adding parity or not in the frame */
N#define NFCT_TXD_FRAMECONFIG_PARITY_Pos (0UL) /*!< Position of PARITY field. */
N#define NFCT_TXD_FRAMECONFIG_PARITY_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define NFCT_TXD_FRAMECONFIG_PARITY_NoParity (0UL) /*!< Parity is not added in TX frames */
N#define NFCT_TXD_FRAMECONFIG_PARITY_Parity (1UL) /*!< Parity is added TX frames */
N
N/* Register: NFCT_TXD_AMOUNT */
N/* Description: Size of outgoing frame */
N
N/* Bits 11..3 : Number of complete bytes that shall be included in the frame, excluding CRC, parity and framing */
N#define NFCT_TXD_AMOUNT_TXDATABYTES_Pos (3UL) /*!< Position of TXDATABYTES field. */
N#define NFCT_TXD_AMOUNT_TXDATABYTES_Msk (0x1FFUL << NFCT_TXD_AMOUNT_TXDATABYTES_Pos) /*!< Bit mask of TXDATABYTES field. */
N
N/* Bits 2..0 : Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit). */
N#define NFCT_TXD_AMOUNT_TXDATABITS_Pos (0UL) /*!< Position of TXDATABITS field. */
N#define NFCT_TXD_AMOUNT_TXDATABITS_Msk (0x7UL << NFCT_TXD_AMOUNT_TXDATABITS_Pos) /*!< Bit mask of TXDATABITS field. */
N
N/* Register: NFCT_RXD_FRAMECONFIG */
N/* Description: Configuration of incoming frames */
N
N/* Bit 4 : CRC mode for incoming frames */
N#define NFCT_RXD_FRAMECONFIG_CRCMODERX_Pos (4UL) /*!< Position of CRCMODERX field. */
N#define NFCT_RXD_FRAMECONFIG_CRCMODERX_Msk (0x1UL << NFCT_RXD_FRAMECONFIG_CRCMODERX_Pos) /*!< Bit mask of CRCMODERX field. */
N#define NFCT_RXD_FRAMECONFIG_CRCMODERX_NoCRCRX (0UL) /*!< CRC is not expected in RX frames */
N#define NFCT_RXD_FRAMECONFIG_CRCMODERX_CRC16RX (1UL) /*!< Last 16 bits in RX frame is CRC, CRC is checked and CRCSTATUS updated */
N
N/* Bit 2 : SoF expected or not in RX frames */
N#define NFCT_RXD_FRAMECONFIG_SOF_Pos (2UL) /*!< Position of SOF field. */
N#define NFCT_RXD_FRAMECONFIG_SOF_Msk (0x1UL << NFCT_RXD_FRAMECONFIG_SOF_Pos) /*!< Bit mask of SOF field. */
N#define NFCT_RXD_FRAMECONFIG_SOF_NoSoF (0UL) /*!< Start of Frame symbol is not expected in RX frames */
N#define NFCT_RXD_FRAMECONFIG_SOF_SoF (1UL) /*!< Start of Frame symbol is expected in RX frames */
N
N/* Bit 0 : Parity expected or not in RX frame */
N#define NFCT_RXD_FRAMECONFIG_PARITY_Pos (0UL) /*!< Position of PARITY field. */
N#define NFCT_RXD_FRAMECONFIG_PARITY_Msk (0x1UL << NFCT_RXD_FRAMECONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define NFCT_RXD_FRAMECONFIG_PARITY_NoParity (0UL) /*!< Parity is not expected in RX frames */
N#define NFCT_RXD_FRAMECONFIG_PARITY_Parity (1UL) /*!< Parity is expected in RX frames */
N
N/* Register: NFCT_RXD_AMOUNT */
N/* Description: Size of last incoming frame */
N
N/* Bits 11..3 : Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing) */
N#define NFCT_RXD_AMOUNT_RXDATABYTES_Pos (3UL) /*!< Position of RXDATABYTES field. */
N#define NFCT_RXD_AMOUNT_RXDATABYTES_Msk (0x1FFUL << NFCT_RXD_AMOUNT_RXDATABYTES_Pos) /*!< Bit mask of RXDATABYTES field. */
N
N/* Bits 2..0 : Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing). */
N#define NFCT_RXD_AMOUNT_RXDATABITS_Pos (0UL) /*!< Position of RXDATABITS field. */
N#define NFCT_RXD_AMOUNT_RXDATABITS_Msk (0x7UL << NFCT_RXD_AMOUNT_RXDATABITS_Pos) /*!< Bit mask of RXDATABITS field. */
N
N/* Register: NFCT_NFCID1_LAST */
N/* Description: Last NFCID1 part (4, 7 or 10 bytes ID) */
N
N/* Bits 31..24 : NFCID1 byte W */
N#define NFCT_NFCID1_LAST_NFCID1_W_Pos (24UL) /*!< Position of NFCID1_W field. */
N#define NFCT_NFCID1_LAST_NFCID1_W_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_W_Pos) /*!< Bit mask of NFCID1_W field. */
N
N/* Bits 23..16 : NFCID1 byte X */
N#define NFCT_NFCID1_LAST_NFCID1_X_Pos (16UL) /*!< Position of NFCID1_X field. */
N#define NFCT_NFCID1_LAST_NFCID1_X_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_X_Pos) /*!< Bit mask of NFCID1_X field. */
N
N/* Bits 15..8 : NFCID1 byte Y */
N#define NFCT_NFCID1_LAST_NFCID1_Y_Pos (8UL) /*!< Position of NFCID1_Y field. */
N#define NFCT_NFCID1_LAST_NFCID1_Y_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_Y_Pos) /*!< Bit mask of NFCID1_Y field. */
N
N/* Bits 7..0 : NFCID1 byte Z (very last byte sent) */
N#define NFCT_NFCID1_LAST_NFCID1_Z_Pos (0UL) /*!< Position of NFCID1_Z field. */
N#define NFCT_NFCID1_LAST_NFCID1_Z_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_Z_Pos) /*!< Bit mask of NFCID1_Z field. */
N
N/* Register: NFCT_NFCID1_2ND_LAST */
N/* Description: Second last NFCID1 part (7 or 10 bytes ID) */
N
N/* Bits 23..16 : NFCID1 byte T */
N#define NFCT_NFCID1_2ND_LAST_NFCID1_T_Pos (16UL) /*!< Position of NFCID1_T field. */
N#define NFCT_NFCID1_2ND_LAST_NFCID1_T_Msk (0xFFUL << NFCT_NFCID1_2ND_LAST_NFCID1_T_Pos) /*!< Bit mask of NFCID1_T field. */
N
N/* Bits 15..8 : NFCID1 byte U */
N#define NFCT_NFCID1_2ND_LAST_NFCID1_U_Pos (8UL) /*!< Position of NFCID1_U field. */
N#define NFCT_NFCID1_2ND_LAST_NFCID1_U_Msk (0xFFUL << NFCT_NFCID1_2ND_LAST_NFCID1_U_Pos) /*!< Bit mask of NFCID1_U field. */
N
N/* Bits 7..0 : NFCID1 byte V */
N#define NFCT_NFCID1_2ND_LAST_NFCID1_V_Pos (0UL) /*!< Position of NFCID1_V field. */
N#define NFCT_NFCID1_2ND_LAST_NFCID1_V_Msk (0xFFUL << NFCT_NFCID1_2ND_LAST_NFCID1_V_Pos) /*!< Bit mask of NFCID1_V field. */
N
N/* Register: NFCT_NFCID1_3RD_LAST */
N/* Description: Third last NFCID1 part (10 bytes ID) */
N
N/* Bits 23..16 : NFCID1 byte Q */
N#define NFCT_NFCID1_3RD_LAST_NFCID1_Q_Pos (16UL) /*!< Position of NFCID1_Q field. */
N#define NFCT_NFCID1_3RD_LAST_NFCID1_Q_Msk (0xFFUL << NFCT_NFCID1_3RD_LAST_NFCID1_Q_Pos) /*!< Bit mask of NFCID1_Q field. */
N
N/* Bits 15..8 : NFCID1 byte R */
N#define NFCT_NFCID1_3RD_LAST_NFCID1_R_Pos (8UL) /*!< Position of NFCID1_R field. */
N#define NFCT_NFCID1_3RD_LAST_NFCID1_R_Msk (0xFFUL << NFCT_NFCID1_3RD_LAST_NFCID1_R_Pos) /*!< Bit mask of NFCID1_R field. */
N
N/* Bits 7..0 : NFCID1 byte S */
N#define NFCT_NFCID1_3RD_LAST_NFCID1_S_Pos (0UL) /*!< Position of NFCID1_S field. */
N#define NFCT_NFCID1_3RD_LAST_NFCID1_S_Msk (0xFFUL << NFCT_NFCID1_3RD_LAST_NFCID1_S_Pos) /*!< Bit mask of NFCID1_S field. */
N
N/* Register: NFCT_SENSRES */
N/* Description: NFC-A SENS_RES auto-response settings */
N
N/* Bits 15..12 : Reserved for future use. Shall be 0. */
N#define NFCT_SENSRES_RFU74_Pos (12UL) /*!< Position of RFU74 field. */
N#define NFCT_SENSRES_RFU74_Msk (0xFUL << NFCT_SENSRES_RFU74_Pos) /*!< Bit mask of RFU74 field. */
N
N/* Bits 11..8 : Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification */
N#define NFCT_SENSRES_PLATFCONFIG_Pos (8UL) /*!< Position of PLATFCONFIG field. */
N#define NFCT_SENSRES_PLATFCONFIG_Msk (0xFUL << NFCT_SENSRES_PLATFCONFIG_Pos) /*!< Bit mask of PLATFCONFIG field. */
N
N/* Bits 7..6 : NFCID1 size. This value is used by the Auto collision resolution engine. */
N#define NFCT_SENSRES_NFCIDSIZE_Pos (6UL) /*!< Position of NFCIDSIZE field. */
N#define NFCT_SENSRES_NFCIDSIZE_Msk (0x3UL << NFCT_SENSRES_NFCIDSIZE_Pos) /*!< Bit mask of NFCIDSIZE field. */
N#define NFCT_SENSRES_NFCIDSIZE_NFCID1Single (0UL) /*!< NFCID1 size: single (4 bytes) */
N#define NFCT_SENSRES_NFCIDSIZE_NFCID1Double (1UL) /*!< NFCID1 size: double (7 bytes) */
N#define NFCT_SENSRES_NFCIDSIZE_NFCID1Triple (2UL) /*!< NFCID1 size: triple (10 bytes) */
N
N/* Bit 5 : Reserved for future use. Shall be 0. */
N#define NFCT_SENSRES_RFU5_Pos (5UL) /*!< Position of RFU5 field. */
N#define NFCT_SENSRES_RFU5_Msk (0x1UL << NFCT_SENSRES_RFU5_Pos) /*!< Bit mask of RFU5 field. */
N
N/* Bits 4..0 : Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification */
N#define NFCT_SENSRES_BITFRAMESDD_Pos (0UL) /*!< Position of BITFRAMESDD field. */
N#define NFCT_SENSRES_BITFRAMESDD_Msk (0x1FUL << NFCT_SENSRES_BITFRAMESDD_Pos) /*!< Bit mask of BITFRAMESDD field. */
N#define NFCT_SENSRES_BITFRAMESDD_SDD00000 (0UL) /*!< SDD pattern 00000 */
N#define NFCT_SENSRES_BITFRAMESDD_SDD00001 (1UL) /*!< SDD pattern 00001 */
N#define NFCT_SENSRES_BITFRAMESDD_SDD00010 (2UL) /*!< SDD pattern 00010 */
N#define NFCT_SENSRES_BITFRAMESDD_SDD00100 (4UL) /*!< SDD pattern 00100 */
N#define NFCT_SENSRES_BITFRAMESDD_SDD01000 (8UL) /*!< SDD pattern 01000 */
N#define NFCT_SENSRES_BITFRAMESDD_SDD10000 (16UL) /*!< SDD pattern 10000 */
N
N/* Register: NFCT_SELRES */
N/* Description: NFC-A SEL_RES auto-response settings */
N
N/* Bit 7 : Reserved for future use. Shall be 0. */
N#define NFCT_SELRES_RFU7_Pos (7UL) /*!< Position of RFU7 field. */
N#define NFCT_SELRES_RFU7_Msk (0x1UL << NFCT_SELRES_RFU7_Pos) /*!< Bit mask of RFU7 field. */
N
N/* Bits 6..5 : Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification */
N#define NFCT_SELRES_PROTOCOL_Pos (5UL) /*!< Position of PROTOCOL field. */
N#define NFCT_SELRES_PROTOCOL_Msk (0x3UL << NFCT_SELRES_PROTOCOL_Pos) /*!< Bit mask of PROTOCOL field. */
N
N/* Bits 4..3 : Reserved for future use. Shall be 0. */
N#define NFCT_SELRES_RFU43_Pos (3UL) /*!< Position of RFU43 field. */
N#define NFCT_SELRES_RFU43_Msk (0x3UL << NFCT_SELRES_RFU43_Pos) /*!< Bit mask of RFU43 field. */
N
N/* Bit 2 : Cascade bit (controlled by hardware, write has no effect) */
N#define NFCT_SELRES_CASCADE_Pos (2UL) /*!< Position of CASCADE field. */
N#define NFCT_SELRES_CASCADE_Msk (0x1UL << NFCT_SELRES_CASCADE_Pos) /*!< Bit mask of CASCADE field. */
N#define NFCT_SELRES_CASCADE_Complete (0UL) /*!< NFCID1 complete */
N#define NFCT_SELRES_CASCADE_NotComplete (1UL) /*!< NFCID1 not complete */
N
N/* Bits 1..0 : Reserved for future use. Shall be 0. */
N#define NFCT_SELRES_RFU10_Pos (0UL) /*!< Position of RFU10 field. */
N#define NFCT_SELRES_RFU10_Msk (0x3UL << NFCT_SELRES_RFU10_Pos) /*!< Bit mask of RFU10 field. */
N
N
N/* Peripheral: NVMC */
N/* Description: Non Volatile Memory Controller */
N
N/* Register: NVMC_READY */
N/* Description: Ready flag */
N
N/* Bit 0 : NVMC is ready or busy */
N#define NVMC_READY_READY_Pos (0UL) /*!< Position of READY field. */
N#define NVMC_READY_READY_Msk (0x1UL << NVMC_READY_READY_Pos) /*!< Bit mask of READY field. */
N#define NVMC_READY_READY_Busy (0UL) /*!< NVMC is busy (on-going write or erase operation) */
N#define NVMC_READY_READY_Ready (1UL) /*!< NVMC is ready */
N
N/* Register: NVMC_CONFIG */
N/* Description: Configuration register */
N
N/* Bits 1..0 : Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated. */
N#define NVMC_CONFIG_WEN_Pos (0UL) /*!< Position of WEN field. */
N#define NVMC_CONFIG_WEN_Msk (0x3UL << NVMC_CONFIG_WEN_Pos) /*!< Bit mask of WEN field. */
N#define NVMC_CONFIG_WEN_Ren (0UL) /*!< Read only access */
N#define NVMC_CONFIG_WEN_Wen (1UL) /*!< Write Enabled */
N#define NVMC_CONFIG_WEN_Een (2UL) /*!< Erase enabled */
N
N/* Register: NVMC_ERASEPAGE */
N/* Description: Register for erasing a page in Code area */
N
N/* Bits 31..0 : Register for starting erase of a page in Code area */
N#define NVMC_ERASEPAGE_ERASEPAGE_Pos (0UL) /*!< Position of ERASEPAGE field. */
N#define NVMC_ERASEPAGE_ERASEPAGE_Msk (0xFFFFFFFFUL << NVMC_ERASEPAGE_ERASEPAGE_Pos) /*!< Bit mask of ERASEPAGE field. */
N
N/* Register: NVMC_ERASEPCR1 */
N/* Description: Deprecated register -  Register for erasing a page in Code area. Equivalent to ERASEPAGE. */
N
N/* Bits 31..0 : Register for erasing a page in Code area. Equivalent to ERASEPAGE. */
N#define NVMC_ERASEPCR1_ERASEPCR1_Pos (0UL) /*!< Position of ERASEPCR1 field. */
N#define NVMC_ERASEPCR1_ERASEPCR1_Msk (0xFFFFFFFFUL << NVMC_ERASEPCR1_ERASEPCR1_Pos) /*!< Bit mask of ERASEPCR1 field. */
N
N/* Register: NVMC_ERASEALL */
N/* Description: Register for erasing all non-volatile user memory */
N
N/* Bit 0 : Erase all non-volatile memory including UICR registers. Note that code erase has to be enabled by CONFIG.EEN before the UICR can be erased. */
N#define NVMC_ERASEALL_ERASEALL_Pos (0UL) /*!< Position of ERASEALL field. */
N#define NVMC_ERASEALL_ERASEALL_Msk (0x1UL << NVMC_ERASEALL_ERASEALL_Pos) /*!< Bit mask of ERASEALL field. */
N#define NVMC_ERASEALL_ERASEALL_NoOperation (0UL) /*!< No operation */
N#define NVMC_ERASEALL_ERASEALL_Erase (1UL) /*!< Start chip erase */
N
N/* Register: NVMC_ERASEPCR0 */
N/* Description: Deprecated register -  Register for erasing a page in Code area. Equivalent to ERASEPAGE. */
N
N/* Bits 31..0 : Register for starting erase of a page in Code area. Equivalent to ERASEPAGE. */
N#define NVMC_ERASEPCR0_ERASEPCR0_Pos (0UL) /*!< Position of ERASEPCR0 field. */
N#define NVMC_ERASEPCR0_ERASEPCR0_Msk (0xFFFFFFFFUL << NVMC_ERASEPCR0_ERASEPCR0_Pos) /*!< Bit mask of ERASEPCR0 field. */
N
N/* Register: NVMC_ERASEUICR */
N/* Description: Register for erasing User Information Configuration Registers */
N
N/* Bit 0 : Register starting erase of all User Information Configuration Registers. Note that code erase has to be enabled by CONFIG.EEN before the UICR can be erased. */
N#define NVMC_ERASEUICR_ERASEUICR_Pos (0UL) /*!< Position of ERASEUICR field. */
N#define NVMC_ERASEUICR_ERASEUICR_Msk (0x1UL << NVMC_ERASEUICR_ERASEUICR_Pos) /*!< Bit mask of ERASEUICR field. */
N#define NVMC_ERASEUICR_ERASEUICR_NoOperation (0UL) /*!< No operation */
N#define NVMC_ERASEUICR_ERASEUICR_Erase (1UL) /*!< Start erase of UICR */
N
N/* Register: NVMC_ICACHECNF */
N/* Description: I-Code cache configuration register. */
N
N/* Bit 8 : Cache profiling enable */
N#define NVMC_ICACHECNF_CACHEPROFEN_Pos (8UL) /*!< Position of CACHEPROFEN field. */
N#define NVMC_ICACHECNF_CACHEPROFEN_Msk (0x1UL << NVMC_ICACHECNF_CACHEPROFEN_Pos) /*!< Bit mask of CACHEPROFEN field. */
N#define NVMC_ICACHECNF_CACHEPROFEN_Disabled (0UL) /*!< Disable cache profiling */
N#define NVMC_ICACHECNF_CACHEPROFEN_Enabled (1UL) /*!< Enable cache profiling */
N
N/* Bit 0 : Cache enable */
N#define NVMC_ICACHECNF_CACHEEN_Pos (0UL) /*!< Position of CACHEEN field. */
N#define NVMC_ICACHECNF_CACHEEN_Msk (0x1UL << NVMC_ICACHECNF_CACHEEN_Pos) /*!< Bit mask of CACHEEN field. */
N#define NVMC_ICACHECNF_CACHEEN_Disabled (0UL) /*!< Disable cache. Invalidates all cache entries. */
N#define NVMC_ICACHECNF_CACHEEN_Enabled (1UL) /*!< Enable cache */
N
N/* Register: NVMC_IHIT */
N/* Description: I-Code cache hit counter. */
N
N/* Bits 31..0 : Number of cache hits */
N#define NVMC_IHIT_HITS_Pos (0UL) /*!< Position of HITS field. */
N#define NVMC_IHIT_HITS_Msk (0xFFFFFFFFUL << NVMC_IHIT_HITS_Pos) /*!< Bit mask of HITS field. */
N
N/* Register: NVMC_IMISS */
N/* Description: I-Code cache miss counter. */
N
N/* Bits 31..0 : Number of cache misses */
N#define NVMC_IMISS_MISSES_Pos (0UL) /*!< Position of MISSES field. */
N#define NVMC_IMISS_MISSES_Msk (0xFFFFFFFFUL << NVMC_IMISS_MISSES_Pos) /*!< Bit mask of MISSES field. */
N
N
N/* Peripheral: GPIO */
N/* Description: GPIO Port 1 */
N
N/* Register: GPIO_OUT */
N/* Description: Write GPIO port */
N
N/* Bit 31 : Pin 31 */
N#define GPIO_OUT_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUT_PIN31_Msk (0x1UL << GPIO_OUT_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUT_PIN31_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN31_High (1UL) /*!< Pin driver is high */
N
N/* Bit 30 : Pin 30 */
N#define GPIO_OUT_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUT_PIN30_Msk (0x1UL << GPIO_OUT_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUT_PIN30_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN30_High (1UL) /*!< Pin driver is high */
N
N/* Bit 29 : Pin 29 */
N#define GPIO_OUT_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUT_PIN29_Msk (0x1UL << GPIO_OUT_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUT_PIN29_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN29_High (1UL) /*!< Pin driver is high */
N
N/* Bit 28 : Pin 28 */
N#define GPIO_OUT_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUT_PIN28_Msk (0x1UL << GPIO_OUT_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUT_PIN28_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN28_High (1UL) /*!< Pin driver is high */
N
N/* Bit 27 : Pin 27 */
N#define GPIO_OUT_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUT_PIN27_Msk (0x1UL << GPIO_OUT_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUT_PIN27_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN27_High (1UL) /*!< Pin driver is high */
N
N/* Bit 26 : Pin 26 */
N#define GPIO_OUT_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUT_PIN26_Msk (0x1UL << GPIO_OUT_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUT_PIN26_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN26_High (1UL) /*!< Pin driver is high */
N
N/* Bit 25 : Pin 25 */
N#define GPIO_OUT_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUT_PIN25_Msk (0x1UL << GPIO_OUT_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUT_PIN25_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN25_High (1UL) /*!< Pin driver is high */
N
N/* Bit 24 : Pin 24 */
N#define GPIO_OUT_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUT_PIN24_Msk (0x1UL << GPIO_OUT_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUT_PIN24_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN24_High (1UL) /*!< Pin driver is high */
N
N/* Bit 23 : Pin 23 */
N#define GPIO_OUT_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUT_PIN23_Msk (0x1UL << GPIO_OUT_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUT_PIN23_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN23_High (1UL) /*!< Pin driver is high */
N
N/* Bit 22 : Pin 22 */
N#define GPIO_OUT_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUT_PIN22_Msk (0x1UL << GPIO_OUT_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUT_PIN22_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN22_High (1UL) /*!< Pin driver is high */
N
N/* Bit 21 : Pin 21 */
N#define GPIO_OUT_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUT_PIN21_Msk (0x1UL << GPIO_OUT_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUT_PIN21_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN21_High (1UL) /*!< Pin driver is high */
N
N/* Bit 20 : Pin 20 */
N#define GPIO_OUT_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUT_PIN20_Msk (0x1UL << GPIO_OUT_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUT_PIN20_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN20_High (1UL) /*!< Pin driver is high */
N
N/* Bit 19 : Pin 19 */
N#define GPIO_OUT_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUT_PIN19_Msk (0x1UL << GPIO_OUT_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUT_PIN19_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN19_High (1UL) /*!< Pin driver is high */
N
N/* Bit 18 : Pin 18 */
N#define GPIO_OUT_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUT_PIN18_Msk (0x1UL << GPIO_OUT_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUT_PIN18_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN18_High (1UL) /*!< Pin driver is high */
N
N/* Bit 17 : Pin 17 */
N#define GPIO_OUT_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUT_PIN17_Msk (0x1UL << GPIO_OUT_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUT_PIN17_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN17_High (1UL) /*!< Pin driver is high */
N
N/* Bit 16 : Pin 16 */
N#define GPIO_OUT_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUT_PIN16_Msk (0x1UL << GPIO_OUT_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUT_PIN16_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN16_High (1UL) /*!< Pin driver is high */
N
N/* Bit 15 : Pin 15 */
N#define GPIO_OUT_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUT_PIN15_Msk (0x1UL << GPIO_OUT_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUT_PIN15_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN15_High (1UL) /*!< Pin driver is high */
N
N/* Bit 14 : Pin 14 */
N#define GPIO_OUT_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUT_PIN14_Msk (0x1UL << GPIO_OUT_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUT_PIN14_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN14_High (1UL) /*!< Pin driver is high */
N
N/* Bit 13 : Pin 13 */
N#define GPIO_OUT_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUT_PIN13_Msk (0x1UL << GPIO_OUT_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUT_PIN13_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN13_High (1UL) /*!< Pin driver is high */
N
N/* Bit 12 : Pin 12 */
N#define GPIO_OUT_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUT_PIN12_Msk (0x1UL << GPIO_OUT_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUT_PIN12_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN12_High (1UL) /*!< Pin driver is high */
N
N/* Bit 11 : Pin 11 */
N#define GPIO_OUT_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUT_PIN11_Msk (0x1UL << GPIO_OUT_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUT_PIN11_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN11_High (1UL) /*!< Pin driver is high */
N
N/* Bit 10 : Pin 10 */
N#define GPIO_OUT_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUT_PIN10_Msk (0x1UL << GPIO_OUT_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUT_PIN10_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN10_High (1UL) /*!< Pin driver is high */
N
N/* Bit 9 : Pin 9 */
N#define GPIO_OUT_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUT_PIN9_Msk (0x1UL << GPIO_OUT_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUT_PIN9_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN9_High (1UL) /*!< Pin driver is high */
N
N/* Bit 8 : Pin 8 */
N#define GPIO_OUT_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUT_PIN8_Msk (0x1UL << GPIO_OUT_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUT_PIN8_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN8_High (1UL) /*!< Pin driver is high */
N
N/* Bit 7 : Pin 7 */
N#define GPIO_OUT_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUT_PIN7_Msk (0x1UL << GPIO_OUT_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUT_PIN7_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN7_High (1UL) /*!< Pin driver is high */
N
N/* Bit 6 : Pin 6 */
N#define GPIO_OUT_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUT_PIN6_Msk (0x1UL << GPIO_OUT_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUT_PIN6_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN6_High (1UL) /*!< Pin driver is high */
N
N/* Bit 5 : Pin 5 */
N#define GPIO_OUT_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUT_PIN5_Msk (0x1UL << GPIO_OUT_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUT_PIN5_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN5_High (1UL) /*!< Pin driver is high */
N
N/* Bit 4 : Pin 4 */
N#define GPIO_OUT_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUT_PIN4_Msk (0x1UL << GPIO_OUT_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUT_PIN4_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN4_High (1UL) /*!< Pin driver is high */
N
N/* Bit 3 : Pin 3 */
N#define GPIO_OUT_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUT_PIN3_Msk (0x1UL << GPIO_OUT_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUT_PIN3_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN3_High (1UL) /*!< Pin driver is high */
N
N/* Bit 2 : Pin 2 */
N#define GPIO_OUT_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUT_PIN2_Msk (0x1UL << GPIO_OUT_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUT_PIN2_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN2_High (1UL) /*!< Pin driver is high */
N
N/* Bit 1 : Pin 1 */
N#define GPIO_OUT_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUT_PIN1_Msk (0x1UL << GPIO_OUT_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUT_PIN1_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN1_High (1UL) /*!< Pin driver is high */
N
N/* Bit 0 : Pin 0 */
N#define GPIO_OUT_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUT_PIN0_Msk (0x1UL << GPIO_OUT_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUT_PIN0_Low (0UL) /*!< Pin driver is low */
N#define GPIO_OUT_PIN0_High (1UL) /*!< Pin driver is high */
N
N/* Register: GPIO_OUTSET */
N/* Description: Set individual bits in GPIO port */
N
N/* Bit 31 : Pin 31 */
N#define GPIO_OUTSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUTSET_PIN31_Msk (0x1UL << GPIO_OUTSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUTSET_PIN31_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN31_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN31_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 30 : Pin 30 */
N#define GPIO_OUTSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUTSET_PIN30_Msk (0x1UL << GPIO_OUTSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUTSET_PIN30_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN30_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN30_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 29 : Pin 29 */
N#define GPIO_OUTSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUTSET_PIN29_Msk (0x1UL << GPIO_OUTSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUTSET_PIN29_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN29_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN29_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 28 : Pin 28 */
N#define GPIO_OUTSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUTSET_PIN28_Msk (0x1UL << GPIO_OUTSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUTSET_PIN28_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN28_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN28_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 27 : Pin 27 */
N#define GPIO_OUTSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUTSET_PIN27_Msk (0x1UL << GPIO_OUTSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUTSET_PIN27_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN27_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN27_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 26 : Pin 26 */
N#define GPIO_OUTSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUTSET_PIN26_Msk (0x1UL << GPIO_OUTSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUTSET_PIN26_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN26_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN26_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 25 : Pin 25 */
N#define GPIO_OUTSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUTSET_PIN25_Msk (0x1UL << GPIO_OUTSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUTSET_PIN25_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN25_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN25_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 24 : Pin 24 */
N#define GPIO_OUTSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUTSET_PIN24_Msk (0x1UL << GPIO_OUTSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUTSET_PIN24_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN24_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN24_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 23 : Pin 23 */
N#define GPIO_OUTSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUTSET_PIN23_Msk (0x1UL << GPIO_OUTSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUTSET_PIN23_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN23_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN23_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 22 : Pin 22 */
N#define GPIO_OUTSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUTSET_PIN22_Msk (0x1UL << GPIO_OUTSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUTSET_PIN22_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN22_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN22_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 21 : Pin 21 */
N#define GPIO_OUTSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUTSET_PIN21_Msk (0x1UL << GPIO_OUTSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUTSET_PIN21_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN21_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN21_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 20 : Pin 20 */
N#define GPIO_OUTSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUTSET_PIN20_Msk (0x1UL << GPIO_OUTSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUTSET_PIN20_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN20_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN20_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 19 : Pin 19 */
N#define GPIO_OUTSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUTSET_PIN19_Msk (0x1UL << GPIO_OUTSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUTSET_PIN19_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN19_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN19_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 18 : Pin 18 */
N#define GPIO_OUTSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUTSET_PIN18_Msk (0x1UL << GPIO_OUTSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUTSET_PIN18_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN18_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN18_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 17 : Pin 17 */
N#define GPIO_OUTSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUTSET_PIN17_Msk (0x1UL << GPIO_OUTSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUTSET_PIN17_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN17_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN17_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 16 : Pin 16 */
N#define GPIO_OUTSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUTSET_PIN16_Msk (0x1UL << GPIO_OUTSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUTSET_PIN16_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN16_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN16_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 15 : Pin 15 */
N#define GPIO_OUTSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUTSET_PIN15_Msk (0x1UL << GPIO_OUTSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUTSET_PIN15_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN15_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN15_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 14 : Pin 14 */
N#define GPIO_OUTSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUTSET_PIN14_Msk (0x1UL << GPIO_OUTSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUTSET_PIN14_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN14_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN14_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 13 : Pin 13 */
N#define GPIO_OUTSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUTSET_PIN13_Msk (0x1UL << GPIO_OUTSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUTSET_PIN13_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN13_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN13_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 12 : Pin 12 */
N#define GPIO_OUTSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUTSET_PIN12_Msk (0x1UL << GPIO_OUTSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUTSET_PIN12_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN12_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN12_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 11 : Pin 11 */
N#define GPIO_OUTSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUTSET_PIN11_Msk (0x1UL << GPIO_OUTSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUTSET_PIN11_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN11_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN11_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 10 : Pin 10 */
N#define GPIO_OUTSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUTSET_PIN10_Msk (0x1UL << GPIO_OUTSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUTSET_PIN10_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN10_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN10_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 9 : Pin 9 */
N#define GPIO_OUTSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUTSET_PIN9_Msk (0x1UL << GPIO_OUTSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUTSET_PIN9_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN9_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN9_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 8 : Pin 8 */
N#define GPIO_OUTSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUTSET_PIN8_Msk (0x1UL << GPIO_OUTSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUTSET_PIN8_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN8_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN8_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 7 : Pin 7 */
N#define GPIO_OUTSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUTSET_PIN7_Msk (0x1UL << GPIO_OUTSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUTSET_PIN7_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN7_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN7_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 6 : Pin 6 */
N#define GPIO_OUTSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUTSET_PIN6_Msk (0x1UL << GPIO_OUTSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUTSET_PIN6_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN6_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN6_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 5 : Pin 5 */
N#define GPIO_OUTSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUTSET_PIN5_Msk (0x1UL << GPIO_OUTSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUTSET_PIN5_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN5_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN5_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 4 : Pin 4 */
N#define GPIO_OUTSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUTSET_PIN4_Msk (0x1UL << GPIO_OUTSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUTSET_PIN4_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN4_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN4_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 3 : Pin 3 */
N#define GPIO_OUTSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUTSET_PIN3_Msk (0x1UL << GPIO_OUTSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUTSET_PIN3_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN3_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN3_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 2 : Pin 2 */
N#define GPIO_OUTSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUTSET_PIN2_Msk (0x1UL << GPIO_OUTSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUTSET_PIN2_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN2_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN2_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 1 : Pin 1 */
N#define GPIO_OUTSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUTSET_PIN1_Msk (0x1UL << GPIO_OUTSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUTSET_PIN1_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN1_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN1_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Bit 0 : Pin 0 */
N#define GPIO_OUTSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUTSET_PIN0_Msk (0x1UL << GPIO_OUTSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUTSET_PIN0_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTSET_PIN0_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTSET_PIN0_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
N
N/* Register: GPIO_OUTCLR */
N/* Description: Clear individual bits in GPIO port */
N
N/* Bit 31 : Pin 31 */
N#define GPIO_OUTCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUTCLR_PIN31_Msk (0x1UL << GPIO_OUTCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUTCLR_PIN31_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN31_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN31_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 30 : Pin 30 */
N#define GPIO_OUTCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUTCLR_PIN30_Msk (0x1UL << GPIO_OUTCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUTCLR_PIN30_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN30_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN30_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 29 : Pin 29 */
N#define GPIO_OUTCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUTCLR_PIN29_Msk (0x1UL << GPIO_OUTCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUTCLR_PIN29_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN29_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN29_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 28 : Pin 28 */
N#define GPIO_OUTCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUTCLR_PIN28_Msk (0x1UL << GPIO_OUTCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUTCLR_PIN28_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN28_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN28_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 27 : Pin 27 */
N#define GPIO_OUTCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUTCLR_PIN27_Msk (0x1UL << GPIO_OUTCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUTCLR_PIN27_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN27_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN27_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 26 : Pin 26 */
N#define GPIO_OUTCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUTCLR_PIN26_Msk (0x1UL << GPIO_OUTCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUTCLR_PIN26_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN26_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN26_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 25 : Pin 25 */
N#define GPIO_OUTCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUTCLR_PIN25_Msk (0x1UL << GPIO_OUTCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUTCLR_PIN25_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN25_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN25_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 24 : Pin 24 */
N#define GPIO_OUTCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUTCLR_PIN24_Msk (0x1UL << GPIO_OUTCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUTCLR_PIN24_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN24_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN24_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 23 : Pin 23 */
N#define GPIO_OUTCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUTCLR_PIN23_Msk (0x1UL << GPIO_OUTCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUTCLR_PIN23_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN23_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN23_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 22 : Pin 22 */
N#define GPIO_OUTCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUTCLR_PIN22_Msk (0x1UL << GPIO_OUTCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUTCLR_PIN22_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN22_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN22_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 21 : Pin 21 */
N#define GPIO_OUTCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUTCLR_PIN21_Msk (0x1UL << GPIO_OUTCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUTCLR_PIN21_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN21_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN21_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 20 : Pin 20 */
N#define GPIO_OUTCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUTCLR_PIN20_Msk (0x1UL << GPIO_OUTCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUTCLR_PIN20_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN20_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN20_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 19 : Pin 19 */
N#define GPIO_OUTCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUTCLR_PIN19_Msk (0x1UL << GPIO_OUTCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUTCLR_PIN19_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN19_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN19_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 18 : Pin 18 */
N#define GPIO_OUTCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUTCLR_PIN18_Msk (0x1UL << GPIO_OUTCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUTCLR_PIN18_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN18_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN18_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 17 : Pin 17 */
N#define GPIO_OUTCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUTCLR_PIN17_Msk (0x1UL << GPIO_OUTCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUTCLR_PIN17_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN17_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN17_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 16 : Pin 16 */
N#define GPIO_OUTCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUTCLR_PIN16_Msk (0x1UL << GPIO_OUTCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUTCLR_PIN16_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN16_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN16_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 15 : Pin 15 */
N#define GPIO_OUTCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUTCLR_PIN15_Msk (0x1UL << GPIO_OUTCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUTCLR_PIN15_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN15_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN15_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 14 : Pin 14 */
N#define GPIO_OUTCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUTCLR_PIN14_Msk (0x1UL << GPIO_OUTCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUTCLR_PIN14_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN14_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN14_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 13 : Pin 13 */
N#define GPIO_OUTCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUTCLR_PIN13_Msk (0x1UL << GPIO_OUTCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUTCLR_PIN13_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN13_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN13_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 12 : Pin 12 */
N#define GPIO_OUTCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUTCLR_PIN12_Msk (0x1UL << GPIO_OUTCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUTCLR_PIN12_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN12_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN12_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 11 : Pin 11 */
N#define GPIO_OUTCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUTCLR_PIN11_Msk (0x1UL << GPIO_OUTCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUTCLR_PIN11_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN11_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN11_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 10 : Pin 10 */
N#define GPIO_OUTCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUTCLR_PIN10_Msk (0x1UL << GPIO_OUTCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUTCLR_PIN10_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN10_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN10_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 9 : Pin 9 */
N#define GPIO_OUTCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUTCLR_PIN9_Msk (0x1UL << GPIO_OUTCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUTCLR_PIN9_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN9_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN9_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 8 : Pin 8 */
N#define GPIO_OUTCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUTCLR_PIN8_Msk (0x1UL << GPIO_OUTCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUTCLR_PIN8_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN8_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN8_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 7 : Pin 7 */
N#define GPIO_OUTCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUTCLR_PIN7_Msk (0x1UL << GPIO_OUTCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUTCLR_PIN7_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN7_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN7_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 6 : Pin 6 */
N#define GPIO_OUTCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUTCLR_PIN6_Msk (0x1UL << GPIO_OUTCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUTCLR_PIN6_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN6_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN6_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 5 : Pin 5 */
N#define GPIO_OUTCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUTCLR_PIN5_Msk (0x1UL << GPIO_OUTCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUTCLR_PIN5_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN5_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN5_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 4 : Pin 4 */
N#define GPIO_OUTCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUTCLR_PIN4_Msk (0x1UL << GPIO_OUTCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUTCLR_PIN4_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN4_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN4_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 3 : Pin 3 */
N#define GPIO_OUTCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUTCLR_PIN3_Msk (0x1UL << GPIO_OUTCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUTCLR_PIN3_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN3_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN3_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 2 : Pin 2 */
N#define GPIO_OUTCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUTCLR_PIN2_Msk (0x1UL << GPIO_OUTCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUTCLR_PIN2_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN2_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN2_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 1 : Pin 1 */
N#define GPIO_OUTCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUTCLR_PIN1_Msk (0x1UL << GPIO_OUTCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUTCLR_PIN1_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN1_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN1_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Bit 0 : Pin 0 */
N#define GPIO_OUTCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUTCLR_PIN0_Msk (0x1UL << GPIO_OUTCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUTCLR_PIN0_Low (0UL) /*!< Read: pin driver is low */
N#define GPIO_OUTCLR_PIN0_High (1UL) /*!< Read: pin driver is high */
N#define GPIO_OUTCLR_PIN0_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
N
N/* Register: GPIO_IN */
N/* Description: Read GPIO port */
N
N/* Bit 31 : Pin 31 */
N#define GPIO_IN_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_IN_PIN31_Msk (0x1UL << GPIO_IN_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_IN_PIN31_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN31_High (1UL) /*!< Pin input is high */
N
N/* Bit 30 : Pin 30 */
N#define GPIO_IN_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_IN_PIN30_Msk (0x1UL << GPIO_IN_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_IN_PIN30_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN30_High (1UL) /*!< Pin input is high */
N
N/* Bit 29 : Pin 29 */
N#define GPIO_IN_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_IN_PIN29_Msk (0x1UL << GPIO_IN_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_IN_PIN29_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN29_High (1UL) /*!< Pin input is high */
N
N/* Bit 28 : Pin 28 */
N#define GPIO_IN_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_IN_PIN28_Msk (0x1UL << GPIO_IN_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_IN_PIN28_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN28_High (1UL) /*!< Pin input is high */
N
N/* Bit 27 : Pin 27 */
N#define GPIO_IN_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_IN_PIN27_Msk (0x1UL << GPIO_IN_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_IN_PIN27_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN27_High (1UL) /*!< Pin input is high */
N
N/* Bit 26 : Pin 26 */
N#define GPIO_IN_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_IN_PIN26_Msk (0x1UL << GPIO_IN_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_IN_PIN26_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN26_High (1UL) /*!< Pin input is high */
N
N/* Bit 25 : Pin 25 */
N#define GPIO_IN_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_IN_PIN25_Msk (0x1UL << GPIO_IN_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_IN_PIN25_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN25_High (1UL) /*!< Pin input is high */
N
N/* Bit 24 : Pin 24 */
N#define GPIO_IN_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_IN_PIN24_Msk (0x1UL << GPIO_IN_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_IN_PIN24_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN24_High (1UL) /*!< Pin input is high */
N
N/* Bit 23 : Pin 23 */
N#define GPIO_IN_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_IN_PIN23_Msk (0x1UL << GPIO_IN_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_IN_PIN23_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN23_High (1UL) /*!< Pin input is high */
N
N/* Bit 22 : Pin 22 */
N#define GPIO_IN_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_IN_PIN22_Msk (0x1UL << GPIO_IN_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_IN_PIN22_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN22_High (1UL) /*!< Pin input is high */
N
N/* Bit 21 : Pin 21 */
N#define GPIO_IN_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_IN_PIN21_Msk (0x1UL << GPIO_IN_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_IN_PIN21_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN21_High (1UL) /*!< Pin input is high */
N
N/* Bit 20 : Pin 20 */
N#define GPIO_IN_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_IN_PIN20_Msk (0x1UL << GPIO_IN_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_IN_PIN20_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN20_High (1UL) /*!< Pin input is high */
N
N/* Bit 19 : Pin 19 */
N#define GPIO_IN_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_IN_PIN19_Msk (0x1UL << GPIO_IN_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_IN_PIN19_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN19_High (1UL) /*!< Pin input is high */
N
N/* Bit 18 : Pin 18 */
N#define GPIO_IN_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_IN_PIN18_Msk (0x1UL << GPIO_IN_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_IN_PIN18_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN18_High (1UL) /*!< Pin input is high */
N
N/* Bit 17 : Pin 17 */
N#define GPIO_IN_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_IN_PIN17_Msk (0x1UL << GPIO_IN_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_IN_PIN17_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN17_High (1UL) /*!< Pin input is high */
N
N/* Bit 16 : Pin 16 */
N#define GPIO_IN_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_IN_PIN16_Msk (0x1UL << GPIO_IN_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_IN_PIN16_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN16_High (1UL) /*!< Pin input is high */
N
N/* Bit 15 : Pin 15 */
N#define GPIO_IN_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_IN_PIN15_Msk (0x1UL << GPIO_IN_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_IN_PIN15_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN15_High (1UL) /*!< Pin input is high */
N
N/* Bit 14 : Pin 14 */
N#define GPIO_IN_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_IN_PIN14_Msk (0x1UL << GPIO_IN_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_IN_PIN14_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN14_High (1UL) /*!< Pin input is high */
N
N/* Bit 13 : Pin 13 */
N#define GPIO_IN_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_IN_PIN13_Msk (0x1UL << GPIO_IN_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_IN_PIN13_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN13_High (1UL) /*!< Pin input is high */
N
N/* Bit 12 : Pin 12 */
N#define GPIO_IN_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_IN_PIN12_Msk (0x1UL << GPIO_IN_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_IN_PIN12_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN12_High (1UL) /*!< Pin input is high */
N
N/* Bit 11 : Pin 11 */
N#define GPIO_IN_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_IN_PIN11_Msk (0x1UL << GPIO_IN_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_IN_PIN11_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN11_High (1UL) /*!< Pin input is high */
N
N/* Bit 10 : Pin 10 */
N#define GPIO_IN_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_IN_PIN10_Msk (0x1UL << GPIO_IN_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_IN_PIN10_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN10_High (1UL) /*!< Pin input is high */
N
N/* Bit 9 : Pin 9 */
N#define GPIO_IN_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_IN_PIN9_Msk (0x1UL << GPIO_IN_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_IN_PIN9_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN9_High (1UL) /*!< Pin input is high */
N
N/* Bit 8 : Pin 8 */
N#define GPIO_IN_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_IN_PIN8_Msk (0x1UL << GPIO_IN_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_IN_PIN8_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN8_High (1UL) /*!< Pin input is high */
N
N/* Bit 7 : Pin 7 */
N#define GPIO_IN_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_IN_PIN7_Msk (0x1UL << GPIO_IN_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_IN_PIN7_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN7_High (1UL) /*!< Pin input is high */
N
N/* Bit 6 : Pin 6 */
N#define GPIO_IN_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_IN_PIN6_Msk (0x1UL << GPIO_IN_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_IN_PIN6_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN6_High (1UL) /*!< Pin input is high */
N
N/* Bit 5 : Pin 5 */
N#define GPIO_IN_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_IN_PIN5_Msk (0x1UL << GPIO_IN_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_IN_PIN5_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN5_High (1UL) /*!< Pin input is high */
N
N/* Bit 4 : Pin 4 */
N#define GPIO_IN_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_IN_PIN4_Msk (0x1UL << GPIO_IN_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_IN_PIN4_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN4_High (1UL) /*!< Pin input is high */
N
N/* Bit 3 : Pin 3 */
N#define GPIO_IN_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_IN_PIN3_Msk (0x1UL << GPIO_IN_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_IN_PIN3_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN3_High (1UL) /*!< Pin input is high */
N
N/* Bit 2 : Pin 2 */
N#define GPIO_IN_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_IN_PIN2_Msk (0x1UL << GPIO_IN_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_IN_PIN2_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN2_High (1UL) /*!< Pin input is high */
N
N/* Bit 1 : Pin 1 */
N#define GPIO_IN_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_IN_PIN1_Msk (0x1UL << GPIO_IN_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_IN_PIN1_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN1_High (1UL) /*!< Pin input is high */
N
N/* Bit 0 : Pin 0 */
N#define GPIO_IN_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_IN_PIN0_Msk (0x1UL << GPIO_IN_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_IN_PIN0_Low (0UL) /*!< Pin input is low */
N#define GPIO_IN_PIN0_High (1UL) /*!< Pin input is high */
N
N/* Register: GPIO_DIR */
N/* Description: Direction of GPIO pins */
N
N/* Bit 31 : Pin 31 */
N#define GPIO_DIR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIR_PIN31_Msk (0x1UL << GPIO_DIR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIR_PIN31_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN31_Output (1UL) /*!< Pin set as output */
N
N/* Bit 30 : Pin 30 */
N#define GPIO_DIR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIR_PIN30_Msk (0x1UL << GPIO_DIR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIR_PIN30_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN30_Output (1UL) /*!< Pin set as output */
N
N/* Bit 29 : Pin 29 */
N#define GPIO_DIR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIR_PIN29_Msk (0x1UL << GPIO_DIR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIR_PIN29_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN29_Output (1UL) /*!< Pin set as output */
N
N/* Bit 28 : Pin 28 */
N#define GPIO_DIR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIR_PIN28_Msk (0x1UL << GPIO_DIR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIR_PIN28_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN28_Output (1UL) /*!< Pin set as output */
N
N/* Bit 27 : Pin 27 */
N#define GPIO_DIR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIR_PIN27_Msk (0x1UL << GPIO_DIR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIR_PIN27_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN27_Output (1UL) /*!< Pin set as output */
N
N/* Bit 26 : Pin 26 */
N#define GPIO_DIR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIR_PIN26_Msk (0x1UL << GPIO_DIR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIR_PIN26_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN26_Output (1UL) /*!< Pin set as output */
N
N/* Bit 25 : Pin 25 */
N#define GPIO_DIR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIR_PIN25_Msk (0x1UL << GPIO_DIR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIR_PIN25_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN25_Output (1UL) /*!< Pin set as output */
N
N/* Bit 24 : Pin 24 */
N#define GPIO_DIR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIR_PIN24_Msk (0x1UL << GPIO_DIR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIR_PIN24_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN24_Output (1UL) /*!< Pin set as output */
N
N/* Bit 23 : Pin 23 */
N#define GPIO_DIR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIR_PIN23_Msk (0x1UL << GPIO_DIR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIR_PIN23_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN23_Output (1UL) /*!< Pin set as output */
N
N/* Bit 22 : Pin 22 */
N#define GPIO_DIR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIR_PIN22_Msk (0x1UL << GPIO_DIR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIR_PIN22_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN22_Output (1UL) /*!< Pin set as output */
N
N/* Bit 21 : Pin 21 */
N#define GPIO_DIR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIR_PIN21_Msk (0x1UL << GPIO_DIR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIR_PIN21_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN21_Output (1UL) /*!< Pin set as output */
N
N/* Bit 20 : Pin 20 */
N#define GPIO_DIR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIR_PIN20_Msk (0x1UL << GPIO_DIR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIR_PIN20_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN20_Output (1UL) /*!< Pin set as output */
N
N/* Bit 19 : Pin 19 */
N#define GPIO_DIR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIR_PIN19_Msk (0x1UL << GPIO_DIR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIR_PIN19_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN19_Output (1UL) /*!< Pin set as output */
N
N/* Bit 18 : Pin 18 */
N#define GPIO_DIR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIR_PIN18_Msk (0x1UL << GPIO_DIR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIR_PIN18_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN18_Output (1UL) /*!< Pin set as output */
N
N/* Bit 17 : Pin 17 */
N#define GPIO_DIR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIR_PIN17_Msk (0x1UL << GPIO_DIR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIR_PIN17_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN17_Output (1UL) /*!< Pin set as output */
N
N/* Bit 16 : Pin 16 */
N#define GPIO_DIR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIR_PIN16_Msk (0x1UL << GPIO_DIR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIR_PIN16_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN16_Output (1UL) /*!< Pin set as output */
N
N/* Bit 15 : Pin 15 */
N#define GPIO_DIR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIR_PIN15_Msk (0x1UL << GPIO_DIR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIR_PIN15_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN15_Output (1UL) /*!< Pin set as output */
N
N/* Bit 14 : Pin 14 */
N#define GPIO_DIR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIR_PIN14_Msk (0x1UL << GPIO_DIR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIR_PIN14_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN14_Output (1UL) /*!< Pin set as output */
N
N/* Bit 13 : Pin 13 */
N#define GPIO_DIR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIR_PIN13_Msk (0x1UL << GPIO_DIR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIR_PIN13_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN13_Output (1UL) /*!< Pin set as output */
N
N/* Bit 12 : Pin 12 */
N#define GPIO_DIR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIR_PIN12_Msk (0x1UL << GPIO_DIR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIR_PIN12_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN12_Output (1UL) /*!< Pin set as output */
N
N/* Bit 11 : Pin 11 */
N#define GPIO_DIR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIR_PIN11_Msk (0x1UL << GPIO_DIR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIR_PIN11_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN11_Output (1UL) /*!< Pin set as output */
N
N/* Bit 10 : Pin 10 */
N#define GPIO_DIR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIR_PIN10_Msk (0x1UL << GPIO_DIR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIR_PIN10_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN10_Output (1UL) /*!< Pin set as output */
N
N/* Bit 9 : Pin 9 */
N#define GPIO_DIR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIR_PIN9_Msk (0x1UL << GPIO_DIR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIR_PIN9_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN9_Output (1UL) /*!< Pin set as output */
N
N/* Bit 8 : Pin 8 */
N#define GPIO_DIR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIR_PIN8_Msk (0x1UL << GPIO_DIR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIR_PIN8_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN8_Output (1UL) /*!< Pin set as output */
N
N/* Bit 7 : Pin 7 */
N#define GPIO_DIR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIR_PIN7_Msk (0x1UL << GPIO_DIR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIR_PIN7_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN7_Output (1UL) /*!< Pin set as output */
N
N/* Bit 6 : Pin 6 */
N#define GPIO_DIR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIR_PIN6_Msk (0x1UL << GPIO_DIR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIR_PIN6_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN6_Output (1UL) /*!< Pin set as output */
N
N/* Bit 5 : Pin 5 */
N#define GPIO_DIR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIR_PIN5_Msk (0x1UL << GPIO_DIR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIR_PIN5_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN5_Output (1UL) /*!< Pin set as output */
N
N/* Bit 4 : Pin 4 */
N#define GPIO_DIR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIR_PIN4_Msk (0x1UL << GPIO_DIR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIR_PIN4_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN4_Output (1UL) /*!< Pin set as output */
N
N/* Bit 3 : Pin 3 */
N#define GPIO_DIR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIR_PIN3_Msk (0x1UL << GPIO_DIR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIR_PIN3_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN3_Output (1UL) /*!< Pin set as output */
N
N/* Bit 2 : Pin 2 */
N#define GPIO_DIR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIR_PIN2_Msk (0x1UL << GPIO_DIR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIR_PIN2_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN2_Output (1UL) /*!< Pin set as output */
N
N/* Bit 1 : Pin 1 */
N#define GPIO_DIR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIR_PIN1_Msk (0x1UL << GPIO_DIR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIR_PIN1_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN1_Output (1UL) /*!< Pin set as output */
N
N/* Bit 0 : Pin 0 */
N#define GPIO_DIR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIR_PIN0_Msk (0x1UL << GPIO_DIR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIR_PIN0_Input (0UL) /*!< Pin set as input */
N#define GPIO_DIR_PIN0_Output (1UL) /*!< Pin set as output */
N
N/* Register: GPIO_DIRSET */
N/* Description: DIR set register */
N
N/* Bit 31 : Set as output pin 31 */
N#define GPIO_DIRSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIRSET_PIN31_Msk (0x1UL << GPIO_DIRSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIRSET_PIN31_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN31_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN31_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 30 : Set as output pin 30 */
N#define GPIO_DIRSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIRSET_PIN30_Msk (0x1UL << GPIO_DIRSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIRSET_PIN30_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN30_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN30_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 29 : Set as output pin 29 */
N#define GPIO_DIRSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIRSET_PIN29_Msk (0x1UL << GPIO_DIRSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIRSET_PIN29_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN29_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN29_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 28 : Set as output pin 28 */
N#define GPIO_DIRSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIRSET_PIN28_Msk (0x1UL << GPIO_DIRSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIRSET_PIN28_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN28_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN28_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 27 : Set as output pin 27 */
N#define GPIO_DIRSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIRSET_PIN27_Msk (0x1UL << GPIO_DIRSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIRSET_PIN27_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN27_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN27_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 26 : Set as output pin 26 */
N#define GPIO_DIRSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIRSET_PIN26_Msk (0x1UL << GPIO_DIRSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIRSET_PIN26_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN26_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN26_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 25 : Set as output pin 25 */
N#define GPIO_DIRSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIRSET_PIN25_Msk (0x1UL << GPIO_DIRSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIRSET_PIN25_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN25_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN25_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 24 : Set as output pin 24 */
N#define GPIO_DIRSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIRSET_PIN24_Msk (0x1UL << GPIO_DIRSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIRSET_PIN24_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN24_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN24_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 23 : Set as output pin 23 */
N#define GPIO_DIRSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIRSET_PIN23_Msk (0x1UL << GPIO_DIRSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIRSET_PIN23_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN23_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN23_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 22 : Set as output pin 22 */
N#define GPIO_DIRSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIRSET_PIN22_Msk (0x1UL << GPIO_DIRSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIRSET_PIN22_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN22_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN22_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 21 : Set as output pin 21 */
N#define GPIO_DIRSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIRSET_PIN21_Msk (0x1UL << GPIO_DIRSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIRSET_PIN21_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN21_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN21_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 20 : Set as output pin 20 */
N#define GPIO_DIRSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIRSET_PIN20_Msk (0x1UL << GPIO_DIRSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIRSET_PIN20_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN20_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN20_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 19 : Set as output pin 19 */
N#define GPIO_DIRSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIRSET_PIN19_Msk (0x1UL << GPIO_DIRSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIRSET_PIN19_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN19_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN19_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 18 : Set as output pin 18 */
N#define GPIO_DIRSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIRSET_PIN18_Msk (0x1UL << GPIO_DIRSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIRSET_PIN18_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN18_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN18_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 17 : Set as output pin 17 */
N#define GPIO_DIRSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIRSET_PIN17_Msk (0x1UL << GPIO_DIRSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIRSET_PIN17_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN17_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN17_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 16 : Set as output pin 16 */
N#define GPIO_DIRSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIRSET_PIN16_Msk (0x1UL << GPIO_DIRSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIRSET_PIN16_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN16_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN16_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 15 : Set as output pin 15 */
N#define GPIO_DIRSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIRSET_PIN15_Msk (0x1UL << GPIO_DIRSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIRSET_PIN15_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN15_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN15_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 14 : Set as output pin 14 */
N#define GPIO_DIRSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIRSET_PIN14_Msk (0x1UL << GPIO_DIRSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIRSET_PIN14_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN14_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN14_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 13 : Set as output pin 13 */
N#define GPIO_DIRSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIRSET_PIN13_Msk (0x1UL << GPIO_DIRSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIRSET_PIN13_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN13_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN13_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 12 : Set as output pin 12 */
N#define GPIO_DIRSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIRSET_PIN12_Msk (0x1UL << GPIO_DIRSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIRSET_PIN12_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN12_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN12_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 11 : Set as output pin 11 */
N#define GPIO_DIRSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIRSET_PIN11_Msk (0x1UL << GPIO_DIRSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIRSET_PIN11_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN11_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN11_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 10 : Set as output pin 10 */
N#define GPIO_DIRSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIRSET_PIN10_Msk (0x1UL << GPIO_DIRSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIRSET_PIN10_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN10_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN10_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 9 : Set as output pin 9 */
N#define GPIO_DIRSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIRSET_PIN9_Msk (0x1UL << GPIO_DIRSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIRSET_PIN9_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN9_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN9_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 8 : Set as output pin 8 */
N#define GPIO_DIRSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIRSET_PIN8_Msk (0x1UL << GPIO_DIRSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIRSET_PIN8_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN8_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN8_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 7 : Set as output pin 7 */
N#define GPIO_DIRSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIRSET_PIN7_Msk (0x1UL << GPIO_DIRSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIRSET_PIN7_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN7_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN7_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 6 : Set as output pin 6 */
N#define GPIO_DIRSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIRSET_PIN6_Msk (0x1UL << GPIO_DIRSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIRSET_PIN6_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN6_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN6_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 5 : Set as output pin 5 */
N#define GPIO_DIRSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIRSET_PIN5_Msk (0x1UL << GPIO_DIRSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIRSET_PIN5_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN5_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN5_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 4 : Set as output pin 4 */
N#define GPIO_DIRSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIRSET_PIN4_Msk (0x1UL << GPIO_DIRSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIRSET_PIN4_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN4_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN4_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 3 : Set as output pin 3 */
N#define GPIO_DIRSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIRSET_PIN3_Msk (0x1UL << GPIO_DIRSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIRSET_PIN3_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN3_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN3_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 2 : Set as output pin 2 */
N#define GPIO_DIRSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIRSET_PIN2_Msk (0x1UL << GPIO_DIRSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIRSET_PIN2_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN2_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN2_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 1 : Set as output pin 1 */
N#define GPIO_DIRSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIRSET_PIN1_Msk (0x1UL << GPIO_DIRSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIRSET_PIN1_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN1_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN1_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Bit 0 : Set as output pin 0 */
N#define GPIO_DIRSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIRSET_PIN0_Msk (0x1UL << GPIO_DIRSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIRSET_PIN0_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRSET_PIN0_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRSET_PIN0_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
N
N/* Register: GPIO_DIRCLR */
N/* Description: DIR clear register */
N
N/* Bit 31 : Set as input pin 31 */
N#define GPIO_DIRCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIRCLR_PIN31_Msk (0x1UL << GPIO_DIRCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIRCLR_PIN31_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN31_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN31_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 30 : Set as input pin 30 */
N#define GPIO_DIRCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIRCLR_PIN30_Msk (0x1UL << GPIO_DIRCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIRCLR_PIN30_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN30_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN30_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 29 : Set as input pin 29 */
N#define GPIO_DIRCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIRCLR_PIN29_Msk (0x1UL << GPIO_DIRCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIRCLR_PIN29_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN29_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN29_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 28 : Set as input pin 28 */
N#define GPIO_DIRCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIRCLR_PIN28_Msk (0x1UL << GPIO_DIRCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIRCLR_PIN28_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN28_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN28_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 27 : Set as input pin 27 */
N#define GPIO_DIRCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIRCLR_PIN27_Msk (0x1UL << GPIO_DIRCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIRCLR_PIN27_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN27_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN27_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 26 : Set as input pin 26 */
N#define GPIO_DIRCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIRCLR_PIN26_Msk (0x1UL << GPIO_DIRCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIRCLR_PIN26_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN26_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN26_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 25 : Set as input pin 25 */
N#define GPIO_DIRCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIRCLR_PIN25_Msk (0x1UL << GPIO_DIRCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIRCLR_PIN25_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN25_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN25_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 24 : Set as input pin 24 */
N#define GPIO_DIRCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIRCLR_PIN24_Msk (0x1UL << GPIO_DIRCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIRCLR_PIN24_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN24_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN24_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 23 : Set as input pin 23 */
N#define GPIO_DIRCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIRCLR_PIN23_Msk (0x1UL << GPIO_DIRCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIRCLR_PIN23_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN23_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN23_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 22 : Set as input pin 22 */
N#define GPIO_DIRCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIRCLR_PIN22_Msk (0x1UL << GPIO_DIRCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIRCLR_PIN22_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN22_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN22_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 21 : Set as input pin 21 */
N#define GPIO_DIRCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIRCLR_PIN21_Msk (0x1UL << GPIO_DIRCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIRCLR_PIN21_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN21_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN21_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 20 : Set as input pin 20 */
N#define GPIO_DIRCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIRCLR_PIN20_Msk (0x1UL << GPIO_DIRCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIRCLR_PIN20_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN20_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN20_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 19 : Set as input pin 19 */
N#define GPIO_DIRCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIRCLR_PIN19_Msk (0x1UL << GPIO_DIRCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIRCLR_PIN19_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN19_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN19_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 18 : Set as input pin 18 */
N#define GPIO_DIRCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIRCLR_PIN18_Msk (0x1UL << GPIO_DIRCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIRCLR_PIN18_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN18_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN18_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 17 : Set as input pin 17 */
N#define GPIO_DIRCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIRCLR_PIN17_Msk (0x1UL << GPIO_DIRCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIRCLR_PIN17_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN17_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN17_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 16 : Set as input pin 16 */
N#define GPIO_DIRCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIRCLR_PIN16_Msk (0x1UL << GPIO_DIRCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIRCLR_PIN16_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN16_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN16_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 15 : Set as input pin 15 */
N#define GPIO_DIRCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIRCLR_PIN15_Msk (0x1UL << GPIO_DIRCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIRCLR_PIN15_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN15_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN15_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 14 : Set as input pin 14 */
N#define GPIO_DIRCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIRCLR_PIN14_Msk (0x1UL << GPIO_DIRCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIRCLR_PIN14_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN14_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN14_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 13 : Set as input pin 13 */
N#define GPIO_DIRCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIRCLR_PIN13_Msk (0x1UL << GPIO_DIRCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIRCLR_PIN13_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN13_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN13_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 12 : Set as input pin 12 */
N#define GPIO_DIRCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIRCLR_PIN12_Msk (0x1UL << GPIO_DIRCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIRCLR_PIN12_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN12_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN12_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 11 : Set as input pin 11 */
N#define GPIO_DIRCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIRCLR_PIN11_Msk (0x1UL << GPIO_DIRCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIRCLR_PIN11_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN11_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN11_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 10 : Set as input pin 10 */
N#define GPIO_DIRCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIRCLR_PIN10_Msk (0x1UL << GPIO_DIRCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIRCLR_PIN10_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN10_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN10_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 9 : Set as input pin 9 */
N#define GPIO_DIRCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIRCLR_PIN9_Msk (0x1UL << GPIO_DIRCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIRCLR_PIN9_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN9_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN9_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 8 : Set as input pin 8 */
N#define GPIO_DIRCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIRCLR_PIN8_Msk (0x1UL << GPIO_DIRCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIRCLR_PIN8_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN8_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN8_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 7 : Set as input pin 7 */
N#define GPIO_DIRCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIRCLR_PIN7_Msk (0x1UL << GPIO_DIRCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIRCLR_PIN7_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN7_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN7_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 6 : Set as input pin 6 */
N#define GPIO_DIRCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIRCLR_PIN6_Msk (0x1UL << GPIO_DIRCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIRCLR_PIN6_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN6_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN6_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 5 : Set as input pin 5 */
N#define GPIO_DIRCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIRCLR_PIN5_Msk (0x1UL << GPIO_DIRCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIRCLR_PIN5_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN5_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN5_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 4 : Set as input pin 4 */
N#define GPIO_DIRCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIRCLR_PIN4_Msk (0x1UL << GPIO_DIRCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIRCLR_PIN4_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN4_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN4_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 3 : Set as input pin 3 */
N#define GPIO_DIRCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIRCLR_PIN3_Msk (0x1UL << GPIO_DIRCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIRCLR_PIN3_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN3_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN3_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 2 : Set as input pin 2 */
N#define GPIO_DIRCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIRCLR_PIN2_Msk (0x1UL << GPIO_DIRCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIRCLR_PIN2_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN2_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN2_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 1 : Set as input pin 1 */
N#define GPIO_DIRCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIRCLR_PIN1_Msk (0x1UL << GPIO_DIRCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIRCLR_PIN1_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN1_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN1_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Bit 0 : Set as input pin 0 */
N#define GPIO_DIRCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIRCLR_PIN0_Msk (0x1UL << GPIO_DIRCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIRCLR_PIN0_Input (0UL) /*!< Read: pin set as input */
N#define GPIO_DIRCLR_PIN0_Output (1UL) /*!< Read: pin set as output */
N#define GPIO_DIRCLR_PIN0_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
N
N/* Register: GPIO_LATCH */
N/* Description: Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers */
N
N/* Bit 31 : Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_LATCH_PIN31_Msk (0x1UL << GPIO_LATCH_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_LATCH_PIN31_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN31_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 30 : Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_LATCH_PIN30_Msk (0x1UL << GPIO_LATCH_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_LATCH_PIN30_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN30_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 29 : Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_LATCH_PIN29_Msk (0x1UL << GPIO_LATCH_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_LATCH_PIN29_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN29_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 28 : Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_LATCH_PIN28_Msk (0x1UL << GPIO_LATCH_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_LATCH_PIN28_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN28_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 27 : Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_LATCH_PIN27_Msk (0x1UL << GPIO_LATCH_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_LATCH_PIN27_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN27_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 26 : Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_LATCH_PIN26_Msk (0x1UL << GPIO_LATCH_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_LATCH_PIN26_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN26_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 25 : Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_LATCH_PIN25_Msk (0x1UL << GPIO_LATCH_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_LATCH_PIN25_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN25_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 24 : Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_LATCH_PIN24_Msk (0x1UL << GPIO_LATCH_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_LATCH_PIN24_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN24_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 23 : Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_LATCH_PIN23_Msk (0x1UL << GPIO_LATCH_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_LATCH_PIN23_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN23_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 22 : Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_LATCH_PIN22_Msk (0x1UL << GPIO_LATCH_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_LATCH_PIN22_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN22_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 21 : Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_LATCH_PIN21_Msk (0x1UL << GPIO_LATCH_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_LATCH_PIN21_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN21_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 20 : Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_LATCH_PIN20_Msk (0x1UL << GPIO_LATCH_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_LATCH_PIN20_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN20_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 19 : Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_LATCH_PIN19_Msk (0x1UL << GPIO_LATCH_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_LATCH_PIN19_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN19_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 18 : Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_LATCH_PIN18_Msk (0x1UL << GPIO_LATCH_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_LATCH_PIN18_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN18_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 17 : Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_LATCH_PIN17_Msk (0x1UL << GPIO_LATCH_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_LATCH_PIN17_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN17_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 16 : Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_LATCH_PIN16_Msk (0x1UL << GPIO_LATCH_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_LATCH_PIN16_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN16_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 15 : Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_LATCH_PIN15_Msk (0x1UL << GPIO_LATCH_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_LATCH_PIN15_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN15_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 14 : Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_LATCH_PIN14_Msk (0x1UL << GPIO_LATCH_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_LATCH_PIN14_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN14_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 13 : Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_LATCH_PIN13_Msk (0x1UL << GPIO_LATCH_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_LATCH_PIN13_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN13_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 12 : Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_LATCH_PIN12_Msk (0x1UL << GPIO_LATCH_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_LATCH_PIN12_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN12_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 11 : Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_LATCH_PIN11_Msk (0x1UL << GPIO_LATCH_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_LATCH_PIN11_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN11_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 10 : Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_LATCH_PIN10_Msk (0x1UL << GPIO_LATCH_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_LATCH_PIN10_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN10_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 9 : Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_LATCH_PIN9_Msk (0x1UL << GPIO_LATCH_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_LATCH_PIN9_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN9_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 8 : Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_LATCH_PIN8_Msk (0x1UL << GPIO_LATCH_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_LATCH_PIN8_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN8_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 7 : Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_LATCH_PIN7_Msk (0x1UL << GPIO_LATCH_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_LATCH_PIN7_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN7_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 6 : Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_LATCH_PIN6_Msk (0x1UL << GPIO_LATCH_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_LATCH_PIN6_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN6_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 5 : Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_LATCH_PIN5_Msk (0x1UL << GPIO_LATCH_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_LATCH_PIN5_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN5_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 4 : Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_LATCH_PIN4_Msk (0x1UL << GPIO_LATCH_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_LATCH_PIN4_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN4_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 3 : Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_LATCH_PIN3_Msk (0x1UL << GPIO_LATCH_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_LATCH_PIN3_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN3_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 2 : Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_LATCH_PIN2_Msk (0x1UL << GPIO_LATCH_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_LATCH_PIN2_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN2_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 1 : Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_LATCH_PIN1_Msk (0x1UL << GPIO_LATCH_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_LATCH_PIN1_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN1_Latched (1UL) /*!< Criteria has been met */
N
N/* Bit 0 : Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear. */
N#define GPIO_LATCH_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_LATCH_PIN0_Msk (0x1UL << GPIO_LATCH_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_LATCH_PIN0_NotLatched (0UL) /*!< Criteria has not been met */
N#define GPIO_LATCH_PIN0_Latched (1UL) /*!< Criteria has been met */
N
N/* Register: GPIO_DETECTMODE */
N/* Description: Select between default DETECT signal behaviour and LDETECT mode */
N
N/* Bit 0 : Select between default DETECT signal behaviour and LDETECT mode */
N#define GPIO_DETECTMODE_DETECTMODE_Pos (0UL) /*!< Position of DETECTMODE field. */
N#define GPIO_DETECTMODE_DETECTMODE_Msk (0x1UL << GPIO_DETECTMODE_DETECTMODE_Pos) /*!< Bit mask of DETECTMODE field. */
N#define GPIO_DETECTMODE_DETECTMODE_Default (0UL) /*!< DETECT directly connected to PIN DETECT signals */
N#define GPIO_DETECTMODE_DETECTMODE_LDETECT (1UL) /*!< Use the latched LDETECT behaviour */
N
N/* Register: GPIO_PIN_CNF */
N/* Description: Description collection[0]:  Configuration of GPIO pins */
N
N/* Bits 17..16 : Pin sensing mechanism */
N#define GPIO_PIN_CNF_SENSE_Pos (16UL) /*!< Position of SENSE field. */
N#define GPIO_PIN_CNF_SENSE_Msk (0x3UL << GPIO_PIN_CNF_SENSE_Pos) /*!< Bit mask of SENSE field. */
N#define GPIO_PIN_CNF_SENSE_Disabled (0UL) /*!< Disabled */
N#define GPIO_PIN_CNF_SENSE_High (2UL) /*!< Sense for high level */
N#define GPIO_PIN_CNF_SENSE_Low (3UL) /*!< Sense for low level */
N
N/* Bits 10..8 : Drive configuration */
N#define GPIO_PIN_CNF_DRIVE_Pos (8UL) /*!< Position of DRIVE field. */
N#define GPIO_PIN_CNF_DRIVE_Msk (0x7UL << GPIO_PIN_CNF_DRIVE_Pos) /*!< Bit mask of DRIVE field. */
N#define GPIO_PIN_CNF_DRIVE_S0S1 (0UL) /*!< Standard '0', standard '1' */
N#define GPIO_PIN_CNF_DRIVE_H0S1 (1UL) /*!< High drive '0', standard '1' */
N#define GPIO_PIN_CNF_DRIVE_S0H1 (2UL) /*!< Standard '0', high drive '1' */
N#define GPIO_PIN_CNF_DRIVE_H0H1 (3UL) /*!< High drive '0', high 'drive '1'' */
N#define GPIO_PIN_CNF_DRIVE_D0S1 (4UL) /*!< Disconnect '0' standard '1' (normally used for wired-or connections) */
N#define GPIO_PIN_CNF_DRIVE_D0H1 (5UL) /*!< Disconnect '0', high drive '1' (normally used for wired-or connections) */
N#define GPIO_PIN_CNF_DRIVE_S0D1 (6UL) /*!< Standard '0'. disconnect '1' (normally used for wired-and connections) */
N#define GPIO_PIN_CNF_DRIVE_H0D1 (7UL) /*!< High drive '0', disconnect '1' (normally used for wired-and connections) */
N
N/* Bits 3..2 : Pull configuration */
N#define GPIO_PIN_CNF_PULL_Pos (2UL) /*!< Position of PULL field. */
N#define GPIO_PIN_CNF_PULL_Msk (0x3UL << GPIO_PIN_CNF_PULL_Pos) /*!< Bit mask of PULL field. */
N#define GPIO_PIN_CNF_PULL_Disabled (0UL) /*!< No pull */
N#define GPIO_PIN_CNF_PULL_Pulldown (1UL) /*!< Pull down on pin */
N#define GPIO_PIN_CNF_PULL_Pullup (3UL) /*!< Pull up on pin */
N
N/* Bit 1 : Connect or disconnect input buffer */
N#define GPIO_PIN_CNF_INPUT_Pos (1UL) /*!< Position of INPUT field. */
N#define GPIO_PIN_CNF_INPUT_Msk (0x1UL << GPIO_PIN_CNF_INPUT_Pos) /*!< Bit mask of INPUT field. */
N#define GPIO_PIN_CNF_INPUT_Connect (0UL) /*!< Connect input buffer */
N#define GPIO_PIN_CNF_INPUT_Disconnect (1UL) /*!< Disconnect input buffer */
N
N/* Bit 0 : Pin direction. Same physical register as DIR register */
N#define GPIO_PIN_CNF_DIR_Pos (0UL) /*!< Position of DIR field. */
N#define GPIO_PIN_CNF_DIR_Msk (0x1UL << GPIO_PIN_CNF_DIR_Pos) /*!< Bit mask of DIR field. */
N#define GPIO_PIN_CNF_DIR_Input (0UL) /*!< Configure pin as an input pin */
N#define GPIO_PIN_CNF_DIR_Output (1UL) /*!< Configure pin as an output pin */
N
N
N/* Peripheral: PDM */
N/* Description: Pulse Density Modulation (Digital Microphone) Interface */
N
N/* Register: PDM_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 2 : Enable or disable interrupt for END event */
N#define PDM_INTEN_END_Pos (2UL) /*!< Position of END field. */
N#define PDM_INTEN_END_Msk (0x1UL << PDM_INTEN_END_Pos) /*!< Bit mask of END field. */
N#define PDM_INTEN_END_Disabled (0UL) /*!< Disable */
N#define PDM_INTEN_END_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for STOPPED event */
N#define PDM_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define PDM_INTEN_STOPPED_Msk (0x1UL << PDM_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define PDM_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
N#define PDM_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
N
N/* Bit 0 : Enable or disable interrupt for STARTED event */
N#define PDM_INTEN_STARTED_Pos (0UL) /*!< Position of STARTED field. */
N#define PDM_INTEN_STARTED_Msk (0x1UL << PDM_INTEN_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define PDM_INTEN_STARTED_Disabled (0UL) /*!< Disable */
N#define PDM_INTEN_STARTED_Enabled (1UL) /*!< Enable */
N
N/* Register: PDM_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 2 : Write '1' to Enable interrupt for END event */
N#define PDM_INTENSET_END_Pos (2UL) /*!< Position of END field. */
N#define PDM_INTENSET_END_Msk (0x1UL << PDM_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define PDM_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
N#define PDM_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
N#define PDM_INTENSET_END_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
N#define PDM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define PDM_INTENSET_STOPPED_Msk (0x1UL << PDM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define PDM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define PDM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define PDM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for STARTED event */
N#define PDM_INTENSET_STARTED_Pos (0UL) /*!< Position of STARTED field. */
N#define PDM_INTENSET_STARTED_Msk (0x1UL << PDM_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define PDM_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
N#define PDM_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
N#define PDM_INTENSET_STARTED_Set (1UL) /*!< Enable */
N
N/* Register: PDM_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 2 : Write '1' to Disable interrupt for END event */
N#define PDM_INTENCLR_END_Pos (2UL) /*!< Position of END field. */
N#define PDM_INTENCLR_END_Msk (0x1UL << PDM_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define PDM_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
N#define PDM_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
N#define PDM_INTENCLR_END_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
N#define PDM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define PDM_INTENCLR_STOPPED_Msk (0x1UL << PDM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define PDM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define PDM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define PDM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for STARTED event */
N#define PDM_INTENCLR_STARTED_Pos (0UL) /*!< Position of STARTED field. */
N#define PDM_INTENCLR_STARTED_Msk (0x1UL << PDM_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define PDM_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
N#define PDM_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
N#define PDM_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
N
N/* Register: PDM_ENABLE */
N/* Description: PDM module enable register */
N
N/* Bit 0 : Enable or disable PDM module */
N#define PDM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define PDM_ENABLE_ENABLE_Msk (0x1UL << PDM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define PDM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
N#define PDM_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
N
N/* Register: PDM_PDMCLKCTRL */
N/* Description: PDM clock generator control */
N
N/* Bits 31..0 : PDM_CLK frequency */
N#define PDM_PDMCLKCTRL_FREQ_Pos (0UL) /*!< Position of FREQ field. */
N#define PDM_PDMCLKCTRL_FREQ_Msk (0xFFFFFFFFUL << PDM_PDMCLKCTRL_FREQ_Pos) /*!< Bit mask of FREQ field. */
N#define PDM_PDMCLKCTRL_FREQ_1000K (0x08000000UL) /*!< PDM_CLK = 32 MHz / 32 = 1.000 MHz */
N#define PDM_PDMCLKCTRL_FREQ_Default (0x08400000UL) /*!< PDM_CLK = 32 MHz / 31 = 1.032 MHz */
N#define PDM_PDMCLKCTRL_FREQ_1067K (0x08800000UL) /*!< PDM_CLK = 32 MHz / 30 = 1.067 MHz */
N
N/* Register: PDM_MODE */
N/* Description: Defines the routing of the connected PDM microphones' signals */
N
N/* Bit 1 : Defines on which PDM_CLK edge Left (or mono) is sampled */
N#define PDM_MODE_EDGE_Pos (1UL) /*!< Position of EDGE field. */
N#define PDM_MODE_EDGE_Msk (0x1UL << PDM_MODE_EDGE_Pos) /*!< Bit mask of EDGE field. */
N#define PDM_MODE_EDGE_LeftFalling (0UL) /*!< Left (or mono) is sampled on falling edge of PDM_CLK */
N#define PDM_MODE_EDGE_LeftRising (1UL) /*!< Left (or mono) is sampled on rising edge of PDM_CLK */
N
N/* Bit 0 : Mono or stereo operation */
N#define PDM_MODE_OPERATION_Pos (0UL) /*!< Position of OPERATION field. */
N#define PDM_MODE_OPERATION_Msk (0x1UL << PDM_MODE_OPERATION_Pos) /*!< Bit mask of OPERATION field. */
N#define PDM_MODE_OPERATION_Stereo (0UL) /*!< Sample and store one pair (Left + Right) of 16bit samples per RAM word R=[31:16]; L=[15:0] */
N#define PDM_MODE_OPERATION_Mono (1UL) /*!< Sample and store two successive Left samples (16 bit each) per RAM word L1=[31:16]; L0=[15:0] */
N
N/* Register: PDM_GAINL */
N/* Description: Left output gain adjustment */
N
N/* Bits 6..0 : Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00    -20 dB gain adjust 0x01  -19.5 dB gain adjust (...) 0x27   -0.5 dB gain adjust 0x28      0 dB gain adjust 0x29   +0.5 dB gain adjust (...) 0x4F  +19.5 dB gain adjust 0x50    +20 dB gain adjust */
N#define PDM_GAINL_GAINL_Pos (0UL) /*!< Position of GAINL field. */
N#define PDM_GAINL_GAINL_Msk (0x7FUL << PDM_GAINL_GAINL_Pos) /*!< Bit mask of GAINL field. */
N#define PDM_GAINL_GAINL_MinGain (0x00UL) /*!< -20dB gain adjustment (minimum) */
N#define PDM_GAINL_GAINL_DefaultGain (0x28UL) /*!< 0dB gain adjustment ('2500 RMS' requirement) */
N#define PDM_GAINL_GAINL_MaxGain (0x50UL) /*!< +20dB gain adjustment (maximum) */
N
N/* Register: PDM_GAINR */
N/* Description: Right output gain adjustment */
N
N/* Bits 7..0 : Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) */
N#define PDM_GAINR_GAINR_Pos (0UL) /*!< Position of GAINR field. */
N#define PDM_GAINR_GAINR_Msk (0xFFUL << PDM_GAINR_GAINR_Pos) /*!< Bit mask of GAINR field. */
N#define PDM_GAINR_GAINR_MinGain (0x00UL) /*!< -20dB gain adjustment (minimum) */
N#define PDM_GAINR_GAINR_DefaultGain (0x28UL) /*!< 0dB gain adjustment ('2500 RMS' requirement) */
N#define PDM_GAINR_GAINR_MaxGain (0x50UL) /*!< +20dB gain adjustment (maximum) */
N
N/* Register: PDM_PSEL_CLK */
N/* Description: Pin number configuration for PDM CLK signal */
N
N/* Bit 31 : Connection */
N#define PDM_PSEL_CLK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define PDM_PSEL_CLK_CONNECT_Msk (0x1UL << PDM_PSEL_CLK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define PDM_PSEL_CLK_CONNECT_Connected (0UL) /*!< Connect */
N#define PDM_PSEL_CLK_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define PDM_PSEL_CLK_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define PDM_PSEL_CLK_PIN_Msk (0x1FUL << PDM_PSEL_CLK_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: PDM_PSEL_DIN */
N/* Description: Pin number configuration for PDM DIN signal */
N
N/* Bit 31 : Connection */
N#define PDM_PSEL_DIN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define PDM_PSEL_DIN_CONNECT_Msk (0x1UL << PDM_PSEL_DIN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define PDM_PSEL_DIN_CONNECT_Connected (0UL) /*!< Connect */
N#define PDM_PSEL_DIN_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define PDM_PSEL_DIN_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define PDM_PSEL_DIN_PIN_Msk (0x1FUL << PDM_PSEL_DIN_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: PDM_SAMPLE_PTR */
N/* Description: RAM address pointer to write samples to with EasyDMA */
N
N/* Bits 31..0 : Address to write PDM samples to over DMA */
N#define PDM_SAMPLE_PTR_SAMPLEPTR_Pos (0UL) /*!< Position of SAMPLEPTR field. */
N#define PDM_SAMPLE_PTR_SAMPLEPTR_Msk (0xFFFFFFFFUL << PDM_SAMPLE_PTR_SAMPLEPTR_Pos) /*!< Bit mask of SAMPLEPTR field. */
N
N/* Register: PDM_SAMPLE_MAXCNT */
N/* Description: Number of samples to allocate memory for in EasyDMA mode */
N
N/* Bits 14..0 : Length of DMA RAM allocation in number of samples */
N#define PDM_SAMPLE_MAXCNT_BUFFSIZE_Pos (0UL) /*!< Position of BUFFSIZE field. */
N#define PDM_SAMPLE_MAXCNT_BUFFSIZE_Msk (0x7FFFUL << PDM_SAMPLE_MAXCNT_BUFFSIZE_Pos) /*!< Bit mask of BUFFSIZE field. */
N
N
N/* Peripheral: POWER */
N/* Description: Power control */
N
N/* Register: POWER_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 6 : Write '1' to Enable interrupt for SLEEPEXIT event */
N#define POWER_INTENSET_SLEEPEXIT_Pos (6UL) /*!< Position of SLEEPEXIT field. */
N#define POWER_INTENSET_SLEEPEXIT_Msk (0x1UL << POWER_INTENSET_SLEEPEXIT_Pos) /*!< Bit mask of SLEEPEXIT field. */
N#define POWER_INTENSET_SLEEPEXIT_Disabled (0UL) /*!< Read: Disabled */
N#define POWER_INTENSET_SLEEPEXIT_Enabled (1UL) /*!< Read: Enabled */
N#define POWER_INTENSET_SLEEPEXIT_Set (1UL) /*!< Enable */
N
N/* Bit 5 : Write '1' to Enable interrupt for SLEEPENTER event */
N#define POWER_INTENSET_SLEEPENTER_Pos (5UL) /*!< Position of SLEEPENTER field. */
N#define POWER_INTENSET_SLEEPENTER_Msk (0x1UL << POWER_INTENSET_SLEEPENTER_Pos) /*!< Bit mask of SLEEPENTER field. */
N#define POWER_INTENSET_SLEEPENTER_Disabled (0UL) /*!< Read: Disabled */
N#define POWER_INTENSET_SLEEPENTER_Enabled (1UL) /*!< Read: Enabled */
N#define POWER_INTENSET_SLEEPENTER_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for POFWARN event */
N#define POWER_INTENSET_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
N#define POWER_INTENSET_POFWARN_Msk (0x1UL << POWER_INTENSET_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
N#define POWER_INTENSET_POFWARN_Disabled (0UL) /*!< Read: Disabled */
N#define POWER_INTENSET_POFWARN_Enabled (1UL) /*!< Read: Enabled */
N#define POWER_INTENSET_POFWARN_Set (1UL) /*!< Enable */
N
N/* Register: POWER_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 6 : Write '1' to Disable interrupt for SLEEPEXIT event */
N#define POWER_INTENCLR_SLEEPEXIT_Pos (6UL) /*!< Position of SLEEPEXIT field. */
N#define POWER_INTENCLR_SLEEPEXIT_Msk (0x1UL << POWER_INTENCLR_SLEEPEXIT_Pos) /*!< Bit mask of SLEEPEXIT field. */
N#define POWER_INTENCLR_SLEEPEXIT_Disabled (0UL) /*!< Read: Disabled */
N#define POWER_INTENCLR_SLEEPEXIT_Enabled (1UL) /*!< Read: Enabled */
N#define POWER_INTENCLR_SLEEPEXIT_Clear (1UL) /*!< Disable */
N
N/* Bit 5 : Write '1' to Disable interrupt for SLEEPENTER event */
N#define POWER_INTENCLR_SLEEPENTER_Pos (5UL) /*!< Position of SLEEPENTER field. */
N#define POWER_INTENCLR_SLEEPENTER_Msk (0x1UL << POWER_INTENCLR_SLEEPENTER_Pos) /*!< Bit mask of SLEEPENTER field. */
N#define POWER_INTENCLR_SLEEPENTER_Disabled (0UL) /*!< Read: Disabled */
N#define POWER_INTENCLR_SLEEPENTER_Enabled (1UL) /*!< Read: Enabled */
N#define POWER_INTENCLR_SLEEPENTER_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for POFWARN event */
N#define POWER_INTENCLR_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
N#define POWER_INTENCLR_POFWARN_Msk (0x1UL << POWER_INTENCLR_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
N#define POWER_INTENCLR_POFWARN_Disabled (0UL) /*!< Read: Disabled */
N#define POWER_INTENCLR_POFWARN_Enabled (1UL) /*!< Read: Enabled */
N#define POWER_INTENCLR_POFWARN_Clear (1UL) /*!< Disable */
N
N/* Register: POWER_RESETREAS */
N/* Description: Reset reason */
N
N/* Bit 19 : Reset due to wake up from System OFF mode by NFC field detect */
N#define POWER_RESETREAS_NFC_Pos (19UL) /*!< Position of NFC field. */
N#define POWER_RESETREAS_NFC_Msk (0x1UL << POWER_RESETREAS_NFC_Pos) /*!< Bit mask of NFC field. */
N#define POWER_RESETREAS_NFC_NotDetected (0UL) /*!< Not detected */
N#define POWER_RESETREAS_NFC_Detected (1UL) /*!< Detected */
N
N/* Bit 18 : Reset due to wake up from System OFF mode when wakeup is triggered from entering into debug interface mode */
N#define POWER_RESETREAS_DIF_Pos (18UL) /*!< Position of DIF field. */
N#define POWER_RESETREAS_DIF_Msk (0x1UL << POWER_RESETREAS_DIF_Pos) /*!< Bit mask of DIF field. */
N#define POWER_RESETREAS_DIF_NotDetected (0UL) /*!< Not detected */
N#define POWER_RESETREAS_DIF_Detected (1UL) /*!< Detected */
N
N/* Bit 17 : Reset due to wake up from System OFF mode when wakeup is triggered from ANADETECT signal from LPCOMP */
N#define POWER_RESETREAS_LPCOMP_Pos (17UL) /*!< Position of LPCOMP field. */
N#define POWER_RESETREAS_LPCOMP_Msk (0x1UL << POWER_RESETREAS_LPCOMP_Pos) /*!< Bit mask of LPCOMP field. */
N#define POWER_RESETREAS_LPCOMP_NotDetected (0UL) /*!< Not detected */
N#define POWER_RESETREAS_LPCOMP_Detected (1UL) /*!< Detected */
N
N/* Bit 16 : Reset due to wake up from System OFF mode when wakeup is triggered from DETECT signal from GPIO */
N#define POWER_RESETREAS_OFF_Pos (16UL) /*!< Position of OFF field. */
N#define POWER_RESETREAS_OFF_Msk (0x1UL << POWER_RESETREAS_OFF_Pos) /*!< Bit mask of OFF field. */
N#define POWER_RESETREAS_OFF_NotDetected (0UL) /*!< Not detected */
N#define POWER_RESETREAS_OFF_Detected (1UL) /*!< Detected */
N
N/* Bit 3 : Reset from CPU lock-up detected */
N#define POWER_RESETREAS_LOCKUP_Pos (3UL) /*!< Position of LOCKUP field. */
N#define POWER_RESETREAS_LOCKUP_Msk (0x1UL << POWER_RESETREAS_LOCKUP_Pos) /*!< Bit mask of LOCKUP field. */
N#define POWER_RESETREAS_LOCKUP_NotDetected (0UL) /*!< Not detected */
N#define POWER_RESETREAS_LOCKUP_Detected (1UL) /*!< Detected */
N
N/* Bit 2 : Reset from soft reset detected */
N#define POWER_RESETREAS_SREQ_Pos (2UL) /*!< Position of SREQ field. */
N#define POWER_RESETREAS_SREQ_Msk (0x1UL << POWER_RESETREAS_SREQ_Pos) /*!< Bit mask of SREQ field. */
N#define POWER_RESETREAS_SREQ_NotDetected (0UL) /*!< Not detected */
N#define POWER_RESETREAS_SREQ_Detected (1UL) /*!< Detected */
N
N/* Bit 1 : Reset from watchdog detected */
N#define POWER_RESETREAS_DOG_Pos (1UL) /*!< Position of DOG field. */
N#define POWER_RESETREAS_DOG_Msk (0x1UL << POWER_RESETREAS_DOG_Pos) /*!< Bit mask of DOG field. */
N#define POWER_RESETREAS_DOG_NotDetected (0UL) /*!< Not detected */
N#define POWER_RESETREAS_DOG_Detected (1UL) /*!< Detected */
N
N/* Bit 0 : Reset from pin-reset detected */
N#define POWER_RESETREAS_RESETPIN_Pos (0UL) /*!< Position of RESETPIN field. */
N#define POWER_RESETREAS_RESETPIN_Msk (0x1UL << POWER_RESETREAS_RESETPIN_Pos) /*!< Bit mask of RESETPIN field. */
N#define POWER_RESETREAS_RESETPIN_NotDetected (0UL) /*!< Not detected */
N#define POWER_RESETREAS_RESETPIN_Detected (1UL) /*!< Detected */
N
N/* Register: POWER_RAMSTATUS */
N/* Description: Deprecated register -  RAM status register */
N
N/* Bit 3 : RAM block 3 is on or off/powering up */
N#define POWER_RAMSTATUS_RAMBLOCK3_Pos (3UL) /*!< Position of RAMBLOCK3 field. */
N#define POWER_RAMSTATUS_RAMBLOCK3_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK3_Pos) /*!< Bit mask of RAMBLOCK3 field. */
N#define POWER_RAMSTATUS_RAMBLOCK3_Off (0UL) /*!< Off */
N#define POWER_RAMSTATUS_RAMBLOCK3_On (1UL) /*!< On */
N
N/* Bit 2 : RAM block 2 is on or off/powering up */
N#define POWER_RAMSTATUS_RAMBLOCK2_Pos (2UL) /*!< Position of RAMBLOCK2 field. */
N#define POWER_RAMSTATUS_RAMBLOCK2_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK2_Pos) /*!< Bit mask of RAMBLOCK2 field. */
N#define POWER_RAMSTATUS_RAMBLOCK2_Off (0UL) /*!< Off */
N#define POWER_RAMSTATUS_RAMBLOCK2_On (1UL) /*!< On */
N
N/* Bit 1 : RAM block 1 is on or off/powering up */
N#define POWER_RAMSTATUS_RAMBLOCK1_Pos (1UL) /*!< Position of RAMBLOCK1 field. */
N#define POWER_RAMSTATUS_RAMBLOCK1_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK1_Pos) /*!< Bit mask of RAMBLOCK1 field. */
N#define POWER_RAMSTATUS_RAMBLOCK1_Off (0UL) /*!< Off */
N#define POWER_RAMSTATUS_RAMBLOCK1_On (1UL) /*!< On */
N
N/* Bit 0 : RAM block 0 is on or off/powering up */
N#define POWER_RAMSTATUS_RAMBLOCK0_Pos (0UL) /*!< Position of RAMBLOCK0 field. */
N#define POWER_RAMSTATUS_RAMBLOCK0_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK0_Pos) /*!< Bit mask of RAMBLOCK0 field. */
N#define POWER_RAMSTATUS_RAMBLOCK0_Off (0UL) /*!< Off */
N#define POWER_RAMSTATUS_RAMBLOCK0_On (1UL) /*!< On */
N
N/* Register: POWER_SYSTEMOFF */
N/* Description: System OFF register */
N
N/* Bit 0 : Enable System OFF mode */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Pos (0UL) /*!< Position of SYSTEMOFF field. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Msk (0x1UL << POWER_SYSTEMOFF_SYSTEMOFF_Pos) /*!< Bit mask of SYSTEMOFF field. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Enter (1UL) /*!< Enable System OFF mode */
N
N/* Register: POWER_POFCON */
N/* Description: Power failure comparator configuration */
N
N/* Bits 4..1 : Power failure comparator threshold setting */
N#define POWER_POFCON_THRESHOLD_Pos (1UL) /*!< Position of THRESHOLD field. */
N#define POWER_POFCON_THRESHOLD_Msk (0xFUL << POWER_POFCON_THRESHOLD_Pos) /*!< Bit mask of THRESHOLD field. */
N#define POWER_POFCON_THRESHOLD_V17 (4UL) /*!< Set threshold to 1.7 V */
N#define POWER_POFCON_THRESHOLD_V18 (5UL) /*!< Set threshold to 1.8 V */
N#define POWER_POFCON_THRESHOLD_V19 (6UL) /*!< Set threshold to 1.9 V */
N#define POWER_POFCON_THRESHOLD_V20 (7UL) /*!< Set threshold to 2.0 V */
N#define POWER_POFCON_THRESHOLD_V21 (8UL) /*!< Set threshold to 2.1 V */
N#define POWER_POFCON_THRESHOLD_V22 (9UL) /*!< Set threshold to 2.2 V */
N#define POWER_POFCON_THRESHOLD_V23 (10UL) /*!< Set threshold to 2.3 V */
N#define POWER_POFCON_THRESHOLD_V24 (11UL) /*!< Set threshold to 2.4 V */
N#define POWER_POFCON_THRESHOLD_V25 (12UL) /*!< Set threshold to 2.5 V */
N#define POWER_POFCON_THRESHOLD_V26 (13UL) /*!< Set threshold to 2.6 V */
N#define POWER_POFCON_THRESHOLD_V27 (14UL) /*!< Set threshold to 2.7 V */
N#define POWER_POFCON_THRESHOLD_V28 (15UL) /*!< Set threshold to 2.8 V */
N
N/* Bit 0 : Enable or disable power failure comparator */
N#define POWER_POFCON_POF_Pos (0UL) /*!< Position of POF field. */
N#define POWER_POFCON_POF_Msk (0x1UL << POWER_POFCON_POF_Pos) /*!< Bit mask of POF field. */
N#define POWER_POFCON_POF_Disabled (0UL) /*!< Disable */
N#define POWER_POFCON_POF_Enabled (1UL) /*!< Enable */
N
N/* Register: POWER_GPREGRET */
N/* Description: General purpose retention register */
N
N/* Bits 7..0 : General purpose retention register */
N#define POWER_GPREGRET_GPREGRET_Pos (0UL) /*!< Position of GPREGRET field. */
N#define POWER_GPREGRET_GPREGRET_Msk (0xFFUL << POWER_GPREGRET_GPREGRET_Pos) /*!< Bit mask of GPREGRET field. */
N
N/* Register: POWER_GPREGRET2 */
N/* Description: General purpose retention register */
N
N/* Bits 7..0 : General purpose retention register */
N#define POWER_GPREGRET2_GPREGRET_Pos (0UL) /*!< Position of GPREGRET field. */
N#define POWER_GPREGRET2_GPREGRET_Msk (0xFFUL << POWER_GPREGRET2_GPREGRET_Pos) /*!< Bit mask of GPREGRET field. */
N
N/* Register: POWER_RAMON */
N/* Description: Deprecated register -  RAM on/off register (this register is retained) */
N
N/* Bit 17 : Keep retention on RAM block 1 when RAM block is switched off */
N#define POWER_RAMON_OFFRAM1_Pos (17UL) /*!< Position of OFFRAM1 field. */
N#define POWER_RAMON_OFFRAM1_Msk (0x1UL << POWER_RAMON_OFFRAM1_Pos) /*!< Bit mask of OFFRAM1 field. */
N#define POWER_RAMON_OFFRAM1_RAM1Off (0UL) /*!< Off */
N#define POWER_RAMON_OFFRAM1_RAM1On (1UL) /*!< On */
N
N/* Bit 16 : Keep retention on RAM block 0 when RAM block is switched off */
N#define POWER_RAMON_OFFRAM0_Pos (16UL) /*!< Position of OFFRAM0 field. */
N#define POWER_RAMON_OFFRAM0_Msk (0x1UL << POWER_RAMON_OFFRAM0_Pos) /*!< Bit mask of OFFRAM0 field. */
N#define POWER_RAMON_OFFRAM0_RAM0Off (0UL) /*!< Off */
N#define POWER_RAMON_OFFRAM0_RAM0On (1UL) /*!< On */
N
N/* Bit 1 : Keep RAM block 1 on or off in system ON Mode */
N#define POWER_RAMON_ONRAM1_Pos (1UL) /*!< Position of ONRAM1 field. */
N#define POWER_RAMON_ONRAM1_Msk (0x1UL << POWER_RAMON_ONRAM1_Pos) /*!< Bit mask of ONRAM1 field. */
N#define POWER_RAMON_ONRAM1_RAM1Off (0UL) /*!< Off */
N#define POWER_RAMON_ONRAM1_RAM1On (1UL) /*!< On */
N
N/* Bit 0 : Keep RAM block 0 on or off in system ON Mode */
N#define POWER_RAMON_ONRAM0_Pos (0UL) /*!< Position of ONRAM0 field. */
N#define POWER_RAMON_ONRAM0_Msk (0x1UL << POWER_RAMON_ONRAM0_Pos) /*!< Bit mask of ONRAM0 field. */
N#define POWER_RAMON_ONRAM0_RAM0Off (0UL) /*!< Off */
N#define POWER_RAMON_ONRAM0_RAM0On (1UL) /*!< On */
N
N/* Register: POWER_RAMONB */
N/* Description: Deprecated register -  RAM on/off register (this register is retained) */
N
N/* Bit 17 : Keep retention on RAM block 3 when RAM block is switched off */
N#define POWER_RAMONB_OFFRAM3_Pos (17UL) /*!< Position of OFFRAM3 field. */
N#define POWER_RAMONB_OFFRAM3_Msk (0x1UL << POWER_RAMONB_OFFRAM3_Pos) /*!< Bit mask of OFFRAM3 field. */
N#define POWER_RAMONB_OFFRAM3_RAM3Off (0UL) /*!< Off */
N#define POWER_RAMONB_OFFRAM3_RAM3On (1UL) /*!< On */
N
N/* Bit 16 : Keep retention on RAM block 2 when RAM block is switched off */
N#define POWER_RAMONB_OFFRAM2_Pos (16UL) /*!< Position of OFFRAM2 field. */
N#define POWER_RAMONB_OFFRAM2_Msk (0x1UL << POWER_RAMONB_OFFRAM2_Pos) /*!< Bit mask of OFFRAM2 field. */
N#define POWER_RAMONB_OFFRAM2_RAM2Off (0UL) /*!< Off */
N#define POWER_RAMONB_OFFRAM2_RAM2On (1UL) /*!< On */
N
N/* Bit 1 : Keep RAM block 3 on or off in system ON Mode */
N#define POWER_RAMONB_ONRAM3_Pos (1UL) /*!< Position of ONRAM3 field. */
N#define POWER_RAMONB_ONRAM3_Msk (0x1UL << POWER_RAMONB_ONRAM3_Pos) /*!< Bit mask of ONRAM3 field. */
N#define POWER_RAMONB_ONRAM3_RAM3Off (0UL) /*!< Off */
N#define POWER_RAMONB_ONRAM3_RAM3On (1UL) /*!< On */
N
N/* Bit 0 : Keep RAM block 2 on or off in system ON Mode */
N#define POWER_RAMONB_ONRAM2_Pos (0UL) /*!< Position of ONRAM2 field. */
N#define POWER_RAMONB_ONRAM2_Msk (0x1UL << POWER_RAMONB_ONRAM2_Pos) /*!< Bit mask of ONRAM2 field. */
N#define POWER_RAMONB_ONRAM2_RAM2Off (0UL) /*!< Off */
N#define POWER_RAMONB_ONRAM2_RAM2On (1UL) /*!< On */
N
N/* Register: POWER_DCDCEN */
N/* Description: DC/DC enable register */
N
N/* Bit 0 : Enable or disable DC/DC converter */
N#define POWER_DCDCEN_DCDCEN_Pos (0UL) /*!< Position of DCDCEN field. */
N#define POWER_DCDCEN_DCDCEN_Msk (0x1UL << POWER_DCDCEN_DCDCEN_Pos) /*!< Bit mask of DCDCEN field. */
N#define POWER_DCDCEN_DCDCEN_Disabled (0UL) /*!< Disable */
N#define POWER_DCDCEN_DCDCEN_Enabled (1UL) /*!< Enable */
N
N/* Register: POWER_RAM_POWER */
N/* Description: Description cluster[0]:  RAM0 power control register */
N
N/* Bit 17 : Keep retention on RAM section S1 when RAM section is in OFF */
N#define POWER_RAM_POWER_S1RETENTION_Pos (17UL) /*!< Position of S1RETENTION field. */
N#define POWER_RAM_POWER_S1RETENTION_Msk (0x1UL << POWER_RAM_POWER_S1RETENTION_Pos) /*!< Bit mask of S1RETENTION field. */
N#define POWER_RAM_POWER_S1RETENTION_Off (0UL) /*!< Off */
N#define POWER_RAM_POWER_S1RETENTION_On (1UL) /*!< On */
N
N/* Bit 16 : Keep retention on RAM section S0 when RAM section is in OFF */
N#define POWER_RAM_POWER_S0RETENTION_Pos (16UL) /*!< Position of S0RETENTION field. */
N#define POWER_RAM_POWER_S0RETENTION_Msk (0x1UL << POWER_RAM_POWER_S0RETENTION_Pos) /*!< Bit mask of S0RETENTION field. */
N#define POWER_RAM_POWER_S0RETENTION_Off (0UL) /*!< Off */
N#define POWER_RAM_POWER_S0RETENTION_On (1UL) /*!< On */
N
N/* Bit 1 : Keep RAM section S1 ON or OFF in System ON mode. */
N#define POWER_RAM_POWER_S1POWER_Pos (1UL) /*!< Position of S1POWER field. */
N#define POWER_RAM_POWER_S1POWER_Msk (0x1UL << POWER_RAM_POWER_S1POWER_Pos) /*!< Bit mask of S1POWER field. */
N#define POWER_RAM_POWER_S1POWER_Off (0UL) /*!< Off */
N#define POWER_RAM_POWER_S1POWER_On (1UL) /*!< On */
N
N/* Bit 0 : Keep RAM section S0 ON or OFF in System ON mode. */
N#define POWER_RAM_POWER_S0POWER_Pos (0UL) /*!< Position of S0POWER field. */
N#define POWER_RAM_POWER_S0POWER_Msk (0x1UL << POWER_RAM_POWER_S0POWER_Pos) /*!< Bit mask of S0POWER field. */
N#define POWER_RAM_POWER_S0POWER_Off (0UL) /*!< Off */
N#define POWER_RAM_POWER_S0POWER_On (1UL) /*!< On */
N
N/* Register: POWER_RAM_POWERSET */
N/* Description: Description cluster[0]:  RAM0 power control set register */
N
N/* Bit 17 : Keep retention on RAM section S1 when RAM section is switched off */
N#define POWER_RAM_POWERSET_S1RETENTION_Pos (17UL) /*!< Position of S1RETENTION field. */
N#define POWER_RAM_POWERSET_S1RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S1RETENTION_Pos) /*!< Bit mask of S1RETENTION field. */
N#define POWER_RAM_POWERSET_S1RETENTION_On (1UL) /*!< On */
N
N/* Bit 16 : Keep retention on RAM section S0 when RAM section is switched off */
N#define POWER_RAM_POWERSET_S0RETENTION_Pos (16UL) /*!< Position of S0RETENTION field. */
N#define POWER_RAM_POWERSET_S0RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S0RETENTION_Pos) /*!< Bit mask of S0RETENTION field. */
N#define POWER_RAM_POWERSET_S0RETENTION_On (1UL) /*!< On */
N
N/* Bit 1 : Keep RAM section S1 of RAM0 on or off in System ON mode */
N#define POWER_RAM_POWERSET_S1POWER_Pos (1UL) /*!< Position of S1POWER field. */
N#define POWER_RAM_POWERSET_S1POWER_Msk (0x1UL << POWER_RAM_POWERSET_S1POWER_Pos) /*!< Bit mask of S1POWER field. */
N#define POWER_RAM_POWERSET_S1POWER_On (1UL) /*!< On */
N
N/* Bit 0 : Keep RAM section S0 of RAM0 on or off in System ON mode */
N#define POWER_RAM_POWERSET_S0POWER_Pos (0UL) /*!< Position of S0POWER field. */
N#define POWER_RAM_POWERSET_S0POWER_Msk (0x1UL << POWER_RAM_POWERSET_S0POWER_Pos) /*!< Bit mask of S0POWER field. */
N#define POWER_RAM_POWERSET_S0POWER_On (1UL) /*!< On */
N
N/* Register: POWER_RAM_POWERCLR */
N/* Description: Description cluster[0]:  RAM0 power control clear register */
N
N/* Bit 17 : Keep retention on RAM section S1 when RAM section is switched off */
N#define POWER_RAM_POWERCLR_S1RETENTION_Pos (17UL) /*!< Position of S1RETENTION field. */
N#define POWER_RAM_POWERCLR_S1RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S1RETENTION_Pos) /*!< Bit mask of S1RETENTION field. */
N#define POWER_RAM_POWERCLR_S1RETENTION_Off (1UL) /*!< Off */
N
N/* Bit 16 : Keep retention on RAM section S0 when RAM section is switched off */
N#define POWER_RAM_POWERCLR_S0RETENTION_Pos (16UL) /*!< Position of S0RETENTION field. */
N#define POWER_RAM_POWERCLR_S0RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S0RETENTION_Pos) /*!< Bit mask of S0RETENTION field. */
N#define POWER_RAM_POWERCLR_S0RETENTION_Off (1UL) /*!< Off */
N
N/* Bit 1 : Keep RAM section S1 of RAM0 on or off in System ON mode */
N#define POWER_RAM_POWERCLR_S1POWER_Pos (1UL) /*!< Position of S1POWER field. */
N#define POWER_RAM_POWERCLR_S1POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S1POWER_Pos) /*!< Bit mask of S1POWER field. */
N#define POWER_RAM_POWERCLR_S1POWER_Off (1UL) /*!< Off */
N
N/* Bit 0 : Keep RAM section S0 of RAM0 on or off in System ON mode */
N#define POWER_RAM_POWERCLR_S0POWER_Pos (0UL) /*!< Position of S0POWER field. */
N#define POWER_RAM_POWERCLR_S0POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S0POWER_Pos) /*!< Bit mask of S0POWER field. */
N#define POWER_RAM_POWERCLR_S0POWER_Off (1UL) /*!< Off */
N
N
N/* Peripheral: PPI */
N/* Description: Programmable Peripheral Interconnect */
N
N/* Register: PPI_CHEN */
N/* Description: Channel enable register */
N
N/* Bit 31 : Enable or disable channel 31 */
N#define PPI_CHEN_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHEN_CH31_Msk (0x1UL << PPI_CHEN_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHEN_CH31_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH31_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 30 : Enable or disable channel 30 */
N#define PPI_CHEN_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHEN_CH30_Msk (0x1UL << PPI_CHEN_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHEN_CH30_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH30_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 29 : Enable or disable channel 29 */
N#define PPI_CHEN_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHEN_CH29_Msk (0x1UL << PPI_CHEN_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHEN_CH29_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH29_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 28 : Enable or disable channel 28 */
N#define PPI_CHEN_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHEN_CH28_Msk (0x1UL << PPI_CHEN_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHEN_CH28_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH28_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 27 : Enable or disable channel 27 */
N#define PPI_CHEN_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHEN_CH27_Msk (0x1UL << PPI_CHEN_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHEN_CH27_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH27_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 26 : Enable or disable channel 26 */
N#define PPI_CHEN_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHEN_CH26_Msk (0x1UL << PPI_CHEN_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHEN_CH26_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH26_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 25 : Enable or disable channel 25 */
N#define PPI_CHEN_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHEN_CH25_Msk (0x1UL << PPI_CHEN_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHEN_CH25_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH25_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 24 : Enable or disable channel 24 */
N#define PPI_CHEN_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHEN_CH24_Msk (0x1UL << PPI_CHEN_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHEN_CH24_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH24_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 23 : Enable or disable channel 23 */
N#define PPI_CHEN_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHEN_CH23_Msk (0x1UL << PPI_CHEN_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHEN_CH23_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH23_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 22 : Enable or disable channel 22 */
N#define PPI_CHEN_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHEN_CH22_Msk (0x1UL << PPI_CHEN_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHEN_CH22_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH22_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 21 : Enable or disable channel 21 */
N#define PPI_CHEN_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHEN_CH21_Msk (0x1UL << PPI_CHEN_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHEN_CH21_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH21_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 20 : Enable or disable channel 20 */
N#define PPI_CHEN_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHEN_CH20_Msk (0x1UL << PPI_CHEN_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHEN_CH20_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH20_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 19 : Enable or disable channel 19 */
N#define PPI_CHEN_CH19_Pos (19UL) /*!< Position of CH19 field. */
N#define PPI_CHEN_CH19_Msk (0x1UL << PPI_CHEN_CH19_Pos) /*!< Bit mask of CH19 field. */
N#define PPI_CHEN_CH19_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH19_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 18 : Enable or disable channel 18 */
N#define PPI_CHEN_CH18_Pos (18UL) /*!< Position of CH18 field. */
N#define PPI_CHEN_CH18_Msk (0x1UL << PPI_CHEN_CH18_Pos) /*!< Bit mask of CH18 field. */
N#define PPI_CHEN_CH18_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH18_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 17 : Enable or disable channel 17 */
N#define PPI_CHEN_CH17_Pos (17UL) /*!< Position of CH17 field. */
N#define PPI_CHEN_CH17_Msk (0x1UL << PPI_CHEN_CH17_Pos) /*!< Bit mask of CH17 field. */
N#define PPI_CHEN_CH17_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH17_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 16 : Enable or disable channel 16 */
N#define PPI_CHEN_CH16_Pos (16UL) /*!< Position of CH16 field. */
N#define PPI_CHEN_CH16_Msk (0x1UL << PPI_CHEN_CH16_Pos) /*!< Bit mask of CH16 field. */
N#define PPI_CHEN_CH16_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH16_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 15 : Enable or disable channel 15 */
N#define PPI_CHEN_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHEN_CH15_Msk (0x1UL << PPI_CHEN_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHEN_CH15_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH15_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 14 : Enable or disable channel 14 */
N#define PPI_CHEN_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHEN_CH14_Msk (0x1UL << PPI_CHEN_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHEN_CH14_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH14_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 13 : Enable or disable channel 13 */
N#define PPI_CHEN_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHEN_CH13_Msk (0x1UL << PPI_CHEN_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHEN_CH13_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH13_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 12 : Enable or disable channel 12 */
N#define PPI_CHEN_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHEN_CH12_Msk (0x1UL << PPI_CHEN_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHEN_CH12_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH12_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 11 : Enable or disable channel 11 */
N#define PPI_CHEN_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHEN_CH11_Msk (0x1UL << PPI_CHEN_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHEN_CH11_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH11_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 10 : Enable or disable channel 10 */
N#define PPI_CHEN_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHEN_CH10_Msk (0x1UL << PPI_CHEN_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHEN_CH10_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH10_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 9 : Enable or disable channel 9 */
N#define PPI_CHEN_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHEN_CH9_Msk (0x1UL << PPI_CHEN_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHEN_CH9_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH9_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 8 : Enable or disable channel 8 */
N#define PPI_CHEN_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHEN_CH8_Msk (0x1UL << PPI_CHEN_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHEN_CH8_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH8_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 7 : Enable or disable channel 7 */
N#define PPI_CHEN_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHEN_CH7_Msk (0x1UL << PPI_CHEN_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHEN_CH7_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH7_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 6 : Enable or disable channel 6 */
N#define PPI_CHEN_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHEN_CH6_Msk (0x1UL << PPI_CHEN_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHEN_CH6_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH6_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 5 : Enable or disable channel 5 */
N#define PPI_CHEN_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHEN_CH5_Msk (0x1UL << PPI_CHEN_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHEN_CH5_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH5_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 4 : Enable or disable channel 4 */
N#define PPI_CHEN_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHEN_CH4_Msk (0x1UL << PPI_CHEN_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHEN_CH4_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH4_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 3 : Enable or disable channel 3 */
N#define PPI_CHEN_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHEN_CH3_Msk (0x1UL << PPI_CHEN_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHEN_CH3_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH3_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 2 : Enable or disable channel 2 */
N#define PPI_CHEN_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHEN_CH2_Msk (0x1UL << PPI_CHEN_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHEN_CH2_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH2_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 1 : Enable or disable channel 1 */
N#define PPI_CHEN_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHEN_CH1_Msk (0x1UL << PPI_CHEN_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHEN_CH1_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH1_Enabled (1UL) /*!< Enable channel */
N
N/* Bit 0 : Enable or disable channel 0 */
N#define PPI_CHEN_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHEN_CH0_Msk (0x1UL << PPI_CHEN_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHEN_CH0_Disabled (0UL) /*!< Disable channel */
N#define PPI_CHEN_CH0_Enabled (1UL) /*!< Enable channel */
N
N/* Register: PPI_CHENSET */
N/* Description: Channel enable set register */
N
N/* Bit 31 : Channel 31 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHENSET_CH31_Msk (0x1UL << PPI_CHENSET_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHENSET_CH31_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH31_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH31_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 30 : Channel 30 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHENSET_CH30_Msk (0x1UL << PPI_CHENSET_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHENSET_CH30_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH30_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH30_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 29 : Channel 29 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHENSET_CH29_Msk (0x1UL << PPI_CHENSET_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHENSET_CH29_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH29_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH29_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 28 : Channel 28 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHENSET_CH28_Msk (0x1UL << PPI_CHENSET_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHENSET_CH28_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH28_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH28_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 27 : Channel 27 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHENSET_CH27_Msk (0x1UL << PPI_CHENSET_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHENSET_CH27_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH27_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH27_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 26 : Channel 26 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHENSET_CH26_Msk (0x1UL << PPI_CHENSET_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHENSET_CH26_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH26_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH26_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 25 : Channel 25 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHENSET_CH25_Msk (0x1UL << PPI_CHENSET_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHENSET_CH25_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH25_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH25_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 24 : Channel 24 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHENSET_CH24_Msk (0x1UL << PPI_CHENSET_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHENSET_CH24_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH24_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH24_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 23 : Channel 23 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHENSET_CH23_Msk (0x1UL << PPI_CHENSET_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHENSET_CH23_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH23_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH23_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 22 : Channel 22 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHENSET_CH22_Msk (0x1UL << PPI_CHENSET_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHENSET_CH22_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH22_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH22_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 21 : Channel 21 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHENSET_CH21_Msk (0x1UL << PPI_CHENSET_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHENSET_CH21_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH21_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH21_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 20 : Channel 20 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHENSET_CH20_Msk (0x1UL << PPI_CHENSET_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHENSET_CH20_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH20_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH20_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 19 : Channel 19 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH19_Pos (19UL) /*!< Position of CH19 field. */
N#define PPI_CHENSET_CH19_Msk (0x1UL << PPI_CHENSET_CH19_Pos) /*!< Bit mask of CH19 field. */
N#define PPI_CHENSET_CH19_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH19_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH19_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 18 : Channel 18 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH18_Pos (18UL) /*!< Position of CH18 field. */
N#define PPI_CHENSET_CH18_Msk (0x1UL << PPI_CHENSET_CH18_Pos) /*!< Bit mask of CH18 field. */
N#define PPI_CHENSET_CH18_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH18_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH18_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 17 : Channel 17 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH17_Pos (17UL) /*!< Position of CH17 field. */
N#define PPI_CHENSET_CH17_Msk (0x1UL << PPI_CHENSET_CH17_Pos) /*!< Bit mask of CH17 field. */
N#define PPI_CHENSET_CH17_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH17_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH17_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 16 : Channel 16 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH16_Pos (16UL) /*!< Position of CH16 field. */
N#define PPI_CHENSET_CH16_Msk (0x1UL << PPI_CHENSET_CH16_Pos) /*!< Bit mask of CH16 field. */
N#define PPI_CHENSET_CH16_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH16_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH16_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 15 : Channel 15 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHENSET_CH15_Msk (0x1UL << PPI_CHENSET_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHENSET_CH15_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH15_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH15_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 14 : Channel 14 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHENSET_CH14_Msk (0x1UL << PPI_CHENSET_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHENSET_CH14_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH14_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH14_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 13 : Channel 13 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHENSET_CH13_Msk (0x1UL << PPI_CHENSET_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHENSET_CH13_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH13_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH13_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 12 : Channel 12 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHENSET_CH12_Msk (0x1UL << PPI_CHENSET_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHENSET_CH12_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH12_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH12_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 11 : Channel 11 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHENSET_CH11_Msk (0x1UL << PPI_CHENSET_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHENSET_CH11_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH11_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH11_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 10 : Channel 10 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHENSET_CH10_Msk (0x1UL << PPI_CHENSET_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHENSET_CH10_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH10_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH10_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 9 : Channel 9 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHENSET_CH9_Msk (0x1UL << PPI_CHENSET_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHENSET_CH9_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH9_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH9_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 8 : Channel 8 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHENSET_CH8_Msk (0x1UL << PPI_CHENSET_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHENSET_CH8_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH8_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH8_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 7 : Channel 7 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHENSET_CH7_Msk (0x1UL << PPI_CHENSET_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHENSET_CH7_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH7_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH7_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 6 : Channel 6 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHENSET_CH6_Msk (0x1UL << PPI_CHENSET_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHENSET_CH6_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH6_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH6_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 5 : Channel 5 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHENSET_CH5_Msk (0x1UL << PPI_CHENSET_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHENSET_CH5_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH5_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH5_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 4 : Channel 4 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHENSET_CH4_Msk (0x1UL << PPI_CHENSET_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHENSET_CH4_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH4_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH4_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 3 : Channel 3 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHENSET_CH3_Msk (0x1UL << PPI_CHENSET_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHENSET_CH3_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH3_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH3_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 2 : Channel 2 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHENSET_CH2_Msk (0x1UL << PPI_CHENSET_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHENSET_CH2_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH2_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH2_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 1 : Channel 1 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHENSET_CH1_Msk (0x1UL << PPI_CHENSET_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHENSET_CH1_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH1_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH1_Set (1UL) /*!< Write: Enable channel */
N
N/* Bit 0 : Channel 0 enable set register.  Writing '0' has no effect */
N#define PPI_CHENSET_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHENSET_CH0_Msk (0x1UL << PPI_CHENSET_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHENSET_CH0_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENSET_CH0_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENSET_CH0_Set (1UL) /*!< Write: Enable channel */
N
N/* Register: PPI_CHENCLR */
N/* Description: Channel enable clear register */
N
N/* Bit 31 : Channel 31 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHENCLR_CH31_Msk (0x1UL << PPI_CHENCLR_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHENCLR_CH31_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH31_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH31_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 30 : Channel 30 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHENCLR_CH30_Msk (0x1UL << PPI_CHENCLR_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHENCLR_CH30_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH30_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH30_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 29 : Channel 29 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHENCLR_CH29_Msk (0x1UL << PPI_CHENCLR_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHENCLR_CH29_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH29_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH29_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 28 : Channel 28 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHENCLR_CH28_Msk (0x1UL << PPI_CHENCLR_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHENCLR_CH28_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH28_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH28_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 27 : Channel 27 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHENCLR_CH27_Msk (0x1UL << PPI_CHENCLR_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHENCLR_CH27_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH27_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH27_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 26 : Channel 26 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHENCLR_CH26_Msk (0x1UL << PPI_CHENCLR_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHENCLR_CH26_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH26_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH26_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 25 : Channel 25 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHENCLR_CH25_Msk (0x1UL << PPI_CHENCLR_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHENCLR_CH25_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH25_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH25_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 24 : Channel 24 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHENCLR_CH24_Msk (0x1UL << PPI_CHENCLR_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHENCLR_CH24_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH24_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH24_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 23 : Channel 23 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHENCLR_CH23_Msk (0x1UL << PPI_CHENCLR_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHENCLR_CH23_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH23_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH23_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 22 : Channel 22 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHENCLR_CH22_Msk (0x1UL << PPI_CHENCLR_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHENCLR_CH22_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH22_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH22_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 21 : Channel 21 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHENCLR_CH21_Msk (0x1UL << PPI_CHENCLR_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHENCLR_CH21_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH21_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH21_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 20 : Channel 20 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHENCLR_CH20_Msk (0x1UL << PPI_CHENCLR_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHENCLR_CH20_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH20_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH20_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 19 : Channel 19 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH19_Pos (19UL) /*!< Position of CH19 field. */
N#define PPI_CHENCLR_CH19_Msk (0x1UL << PPI_CHENCLR_CH19_Pos) /*!< Bit mask of CH19 field. */
N#define PPI_CHENCLR_CH19_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH19_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH19_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 18 : Channel 18 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH18_Pos (18UL) /*!< Position of CH18 field. */
N#define PPI_CHENCLR_CH18_Msk (0x1UL << PPI_CHENCLR_CH18_Pos) /*!< Bit mask of CH18 field. */
N#define PPI_CHENCLR_CH18_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH18_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH18_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 17 : Channel 17 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH17_Pos (17UL) /*!< Position of CH17 field. */
N#define PPI_CHENCLR_CH17_Msk (0x1UL << PPI_CHENCLR_CH17_Pos) /*!< Bit mask of CH17 field. */
N#define PPI_CHENCLR_CH17_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH17_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH17_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 16 : Channel 16 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH16_Pos (16UL) /*!< Position of CH16 field. */
N#define PPI_CHENCLR_CH16_Msk (0x1UL << PPI_CHENCLR_CH16_Pos) /*!< Bit mask of CH16 field. */
N#define PPI_CHENCLR_CH16_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH16_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH16_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 15 : Channel 15 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHENCLR_CH15_Msk (0x1UL << PPI_CHENCLR_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHENCLR_CH15_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH15_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH15_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 14 : Channel 14 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHENCLR_CH14_Msk (0x1UL << PPI_CHENCLR_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHENCLR_CH14_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH14_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH14_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 13 : Channel 13 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHENCLR_CH13_Msk (0x1UL << PPI_CHENCLR_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHENCLR_CH13_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH13_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH13_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 12 : Channel 12 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHENCLR_CH12_Msk (0x1UL << PPI_CHENCLR_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHENCLR_CH12_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH12_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH12_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 11 : Channel 11 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHENCLR_CH11_Msk (0x1UL << PPI_CHENCLR_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHENCLR_CH11_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH11_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH11_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 10 : Channel 10 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHENCLR_CH10_Msk (0x1UL << PPI_CHENCLR_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHENCLR_CH10_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH10_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH10_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 9 : Channel 9 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHENCLR_CH9_Msk (0x1UL << PPI_CHENCLR_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHENCLR_CH9_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH9_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH9_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 8 : Channel 8 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHENCLR_CH8_Msk (0x1UL << PPI_CHENCLR_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHENCLR_CH8_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH8_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH8_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 7 : Channel 7 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHENCLR_CH7_Msk (0x1UL << PPI_CHENCLR_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHENCLR_CH7_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH7_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH7_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 6 : Channel 6 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHENCLR_CH6_Msk (0x1UL << PPI_CHENCLR_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHENCLR_CH6_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH6_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH6_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 5 : Channel 5 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHENCLR_CH5_Msk (0x1UL << PPI_CHENCLR_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHENCLR_CH5_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH5_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH5_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 4 : Channel 4 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHENCLR_CH4_Msk (0x1UL << PPI_CHENCLR_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHENCLR_CH4_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH4_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH4_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 3 : Channel 3 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHENCLR_CH3_Msk (0x1UL << PPI_CHENCLR_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHENCLR_CH3_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH3_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH3_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 2 : Channel 2 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHENCLR_CH2_Msk (0x1UL << PPI_CHENCLR_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHENCLR_CH2_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH2_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH2_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 1 : Channel 1 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHENCLR_CH1_Msk (0x1UL << PPI_CHENCLR_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHENCLR_CH1_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH1_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH1_Clear (1UL) /*!< Write: disable channel */
N
N/* Bit 0 : Channel 0 enable clear register.  Writing '0' has no effect */
N#define PPI_CHENCLR_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHENCLR_CH0_Msk (0x1UL << PPI_CHENCLR_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHENCLR_CH0_Disabled (0UL) /*!< Read: channel disabled */
N#define PPI_CHENCLR_CH0_Enabled (1UL) /*!< Read: channel enabled */
N#define PPI_CHENCLR_CH0_Clear (1UL) /*!< Write: disable channel */
N
N/* Register: PPI_CH_EEP */
N/* Description: Description cluster[0]:  Channel 0 event end-point */
N
N/* Bits 31..0 : Pointer to event register. Accepts only addresses to registers from the Event group. */
N#define PPI_CH_EEP_EEP_Pos (0UL) /*!< Position of EEP field. */
N#define PPI_CH_EEP_EEP_Msk (0xFFFFFFFFUL << PPI_CH_EEP_EEP_Pos) /*!< Bit mask of EEP field. */
N
N/* Register: PPI_CH_TEP */
N/* Description: Description cluster[0]:  Channel 0 task end-point */
N
N/* Bits 31..0 : Pointer to task register. Accepts only addresses to registers from the Task group. */
N#define PPI_CH_TEP_TEP_Pos (0UL) /*!< Position of TEP field. */
N#define PPI_CH_TEP_TEP_Msk (0xFFFFFFFFUL << PPI_CH_TEP_TEP_Pos) /*!< Bit mask of TEP field. */
N
N/* Register: PPI_CHG */
N/* Description: Description collection[0]:  Channel group 0 */
N
N/* Bit 31 : Include or exclude channel 31 */
N#define PPI_CHG_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHG_CH31_Msk (0x1UL << PPI_CHG_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHG_CH31_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH31_Included (1UL) /*!< Include */
N
N/* Bit 30 : Include or exclude channel 30 */
N#define PPI_CHG_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHG_CH30_Msk (0x1UL << PPI_CHG_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHG_CH30_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH30_Included (1UL) /*!< Include */
N
N/* Bit 29 : Include or exclude channel 29 */
N#define PPI_CHG_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHG_CH29_Msk (0x1UL << PPI_CHG_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHG_CH29_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH29_Included (1UL) /*!< Include */
N
N/* Bit 28 : Include or exclude channel 28 */
N#define PPI_CHG_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHG_CH28_Msk (0x1UL << PPI_CHG_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHG_CH28_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH28_Included (1UL) /*!< Include */
N
N/* Bit 27 : Include or exclude channel 27 */
N#define PPI_CHG_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHG_CH27_Msk (0x1UL << PPI_CHG_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHG_CH27_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH27_Included (1UL) /*!< Include */
N
N/* Bit 26 : Include or exclude channel 26 */
N#define PPI_CHG_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHG_CH26_Msk (0x1UL << PPI_CHG_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHG_CH26_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH26_Included (1UL) /*!< Include */
N
N/* Bit 25 : Include or exclude channel 25 */
N#define PPI_CHG_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHG_CH25_Msk (0x1UL << PPI_CHG_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHG_CH25_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH25_Included (1UL) /*!< Include */
N
N/* Bit 24 : Include or exclude channel 24 */
N#define PPI_CHG_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHG_CH24_Msk (0x1UL << PPI_CHG_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHG_CH24_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH24_Included (1UL) /*!< Include */
N
N/* Bit 23 : Include or exclude channel 23 */
N#define PPI_CHG_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHG_CH23_Msk (0x1UL << PPI_CHG_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHG_CH23_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH23_Included (1UL) /*!< Include */
N
N/* Bit 22 : Include or exclude channel 22 */
N#define PPI_CHG_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHG_CH22_Msk (0x1UL << PPI_CHG_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHG_CH22_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH22_Included (1UL) /*!< Include */
N
N/* Bit 21 : Include or exclude channel 21 */
N#define PPI_CHG_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHG_CH21_Msk (0x1UL << PPI_CHG_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHG_CH21_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH21_Included (1UL) /*!< Include */
N
N/* Bit 20 : Include or exclude channel 20 */
N#define PPI_CHG_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHG_CH20_Msk (0x1UL << PPI_CHG_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHG_CH20_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH20_Included (1UL) /*!< Include */
N
N/* Bit 19 : Include or exclude channel 19 */
N#define PPI_CHG_CH19_Pos (19UL) /*!< Position of CH19 field. */
N#define PPI_CHG_CH19_Msk (0x1UL << PPI_CHG_CH19_Pos) /*!< Bit mask of CH19 field. */
N#define PPI_CHG_CH19_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH19_Included (1UL) /*!< Include */
N
N/* Bit 18 : Include or exclude channel 18 */
N#define PPI_CHG_CH18_Pos (18UL) /*!< Position of CH18 field. */
N#define PPI_CHG_CH18_Msk (0x1UL << PPI_CHG_CH18_Pos) /*!< Bit mask of CH18 field. */
N#define PPI_CHG_CH18_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH18_Included (1UL) /*!< Include */
N
N/* Bit 17 : Include or exclude channel 17 */
N#define PPI_CHG_CH17_Pos (17UL) /*!< Position of CH17 field. */
N#define PPI_CHG_CH17_Msk (0x1UL << PPI_CHG_CH17_Pos) /*!< Bit mask of CH17 field. */
N#define PPI_CHG_CH17_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH17_Included (1UL) /*!< Include */
N
N/* Bit 16 : Include or exclude channel 16 */
N#define PPI_CHG_CH16_Pos (16UL) /*!< Position of CH16 field. */
N#define PPI_CHG_CH16_Msk (0x1UL << PPI_CHG_CH16_Pos) /*!< Bit mask of CH16 field. */
N#define PPI_CHG_CH16_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH16_Included (1UL) /*!< Include */
N
N/* Bit 15 : Include or exclude channel 15 */
N#define PPI_CHG_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHG_CH15_Msk (0x1UL << PPI_CHG_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHG_CH15_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH15_Included (1UL) /*!< Include */
N
N/* Bit 14 : Include or exclude channel 14 */
N#define PPI_CHG_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHG_CH14_Msk (0x1UL << PPI_CHG_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHG_CH14_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH14_Included (1UL) /*!< Include */
N
N/* Bit 13 : Include or exclude channel 13 */
N#define PPI_CHG_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHG_CH13_Msk (0x1UL << PPI_CHG_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHG_CH13_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH13_Included (1UL) /*!< Include */
N
N/* Bit 12 : Include or exclude channel 12 */
N#define PPI_CHG_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHG_CH12_Msk (0x1UL << PPI_CHG_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHG_CH12_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH12_Included (1UL) /*!< Include */
N
N/* Bit 11 : Include or exclude channel 11 */
N#define PPI_CHG_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHG_CH11_Msk (0x1UL << PPI_CHG_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHG_CH11_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH11_Included (1UL) /*!< Include */
N
N/* Bit 10 : Include or exclude channel 10 */
N#define PPI_CHG_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHG_CH10_Msk (0x1UL << PPI_CHG_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHG_CH10_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH10_Included (1UL) /*!< Include */
N
N/* Bit 9 : Include or exclude channel 9 */
N#define PPI_CHG_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHG_CH9_Msk (0x1UL << PPI_CHG_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHG_CH9_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH9_Included (1UL) /*!< Include */
N
N/* Bit 8 : Include or exclude channel 8 */
N#define PPI_CHG_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHG_CH8_Msk (0x1UL << PPI_CHG_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHG_CH8_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH8_Included (1UL) /*!< Include */
N
N/* Bit 7 : Include or exclude channel 7 */
N#define PPI_CHG_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHG_CH7_Msk (0x1UL << PPI_CHG_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHG_CH7_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH7_Included (1UL) /*!< Include */
N
N/* Bit 6 : Include or exclude channel 6 */
N#define PPI_CHG_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHG_CH6_Msk (0x1UL << PPI_CHG_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHG_CH6_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH6_Included (1UL) /*!< Include */
N
N/* Bit 5 : Include or exclude channel 5 */
N#define PPI_CHG_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHG_CH5_Msk (0x1UL << PPI_CHG_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHG_CH5_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH5_Included (1UL) /*!< Include */
N
N/* Bit 4 : Include or exclude channel 4 */
N#define PPI_CHG_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHG_CH4_Msk (0x1UL << PPI_CHG_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHG_CH4_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH4_Included (1UL) /*!< Include */
N
N/* Bit 3 : Include or exclude channel 3 */
N#define PPI_CHG_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHG_CH3_Msk (0x1UL << PPI_CHG_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHG_CH3_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH3_Included (1UL) /*!< Include */
N
N/* Bit 2 : Include or exclude channel 2 */
N#define PPI_CHG_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHG_CH2_Msk (0x1UL << PPI_CHG_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHG_CH2_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH2_Included (1UL) /*!< Include */
N
N/* Bit 1 : Include or exclude channel 1 */
N#define PPI_CHG_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHG_CH1_Msk (0x1UL << PPI_CHG_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHG_CH1_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH1_Included (1UL) /*!< Include */
N
N/* Bit 0 : Include or exclude channel 0 */
N#define PPI_CHG_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHG_CH0_Msk (0x1UL << PPI_CHG_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHG_CH0_Excluded (0UL) /*!< Exclude */
N#define PPI_CHG_CH0_Included (1UL) /*!< Include */
N
N/* Register: PPI_FORK_TEP */
N/* Description: Description cluster[0]:  Channel 0 task end-point */
N
N/* Bits 31..0 : Pointer to task register */
N#define PPI_FORK_TEP_TEP_Pos (0UL) /*!< Position of TEP field. */
N#define PPI_FORK_TEP_TEP_Msk (0xFFFFFFFFUL << PPI_FORK_TEP_TEP_Pos) /*!< Bit mask of TEP field. */
N
N
N/* Peripheral: PWM */
N/* Description: Pulse Width Modulation Unit 0 */
N
N/* Register: PWM_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 4 : Shortcut between LOOPSDONE event and STOP task */
N#define PWM_SHORTS_LOOPSDONE_STOP_Pos (4UL) /*!< Position of LOOPSDONE_STOP field. */
N#define PWM_SHORTS_LOOPSDONE_STOP_Msk (0x1UL << PWM_SHORTS_LOOPSDONE_STOP_Pos) /*!< Bit mask of LOOPSDONE_STOP field. */
N#define PWM_SHORTS_LOOPSDONE_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define PWM_SHORTS_LOOPSDONE_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 3 : Shortcut between LOOPSDONE event and SEQSTART[1] task */
N#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Pos (3UL) /*!< Position of LOOPSDONE_SEQSTART1 field. */
N#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Msk (0x1UL << PWM_SHORTS_LOOPSDONE_SEQSTART1_Pos) /*!< Bit mask of LOOPSDONE_SEQSTART1 field. */
N#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Disabled (0UL) /*!< Disable shortcut */
N#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 2 : Shortcut between LOOPSDONE event and SEQSTART[0] task */
N#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Pos (2UL) /*!< Position of LOOPSDONE_SEQSTART0 field. */
N#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Msk (0x1UL << PWM_SHORTS_LOOPSDONE_SEQSTART0_Pos) /*!< Bit mask of LOOPSDONE_SEQSTART0 field. */
N#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Disabled (0UL) /*!< Disable shortcut */
N#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 1 : Shortcut between SEQEND[1] event and STOP task */
N#define PWM_SHORTS_SEQEND1_STOP_Pos (1UL) /*!< Position of SEQEND1_STOP field. */
N#define PWM_SHORTS_SEQEND1_STOP_Msk (0x1UL << PWM_SHORTS_SEQEND1_STOP_Pos) /*!< Bit mask of SEQEND1_STOP field. */
N#define PWM_SHORTS_SEQEND1_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define PWM_SHORTS_SEQEND1_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 0 : Shortcut between SEQEND[0] event and STOP task */
N#define PWM_SHORTS_SEQEND0_STOP_Pos (0UL) /*!< Position of SEQEND0_STOP field. */
N#define PWM_SHORTS_SEQEND0_STOP_Msk (0x1UL << PWM_SHORTS_SEQEND0_STOP_Pos) /*!< Bit mask of SEQEND0_STOP field. */
N#define PWM_SHORTS_SEQEND0_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define PWM_SHORTS_SEQEND0_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: PWM_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 7 : Enable or disable interrupt for LOOPSDONE event */
N#define PWM_INTEN_LOOPSDONE_Pos (7UL) /*!< Position of LOOPSDONE field. */
N#define PWM_INTEN_LOOPSDONE_Msk (0x1UL << PWM_INTEN_LOOPSDONE_Pos) /*!< Bit mask of LOOPSDONE field. */
N#define PWM_INTEN_LOOPSDONE_Disabled (0UL) /*!< Disable */
N#define PWM_INTEN_LOOPSDONE_Enabled (1UL) /*!< Enable */
N
N/* Bit 6 : Enable or disable interrupt for PWMPERIODEND event */
N#define PWM_INTEN_PWMPERIODEND_Pos (6UL) /*!< Position of PWMPERIODEND field. */
N#define PWM_INTEN_PWMPERIODEND_Msk (0x1UL << PWM_INTEN_PWMPERIODEND_Pos) /*!< Bit mask of PWMPERIODEND field. */
N#define PWM_INTEN_PWMPERIODEND_Disabled (0UL) /*!< Disable */
N#define PWM_INTEN_PWMPERIODEND_Enabled (1UL) /*!< Enable */
N
N/* Bit 5 : Enable or disable interrupt for SEQEND[1] event */
N#define PWM_INTEN_SEQEND1_Pos (5UL) /*!< Position of SEQEND1 field. */
N#define PWM_INTEN_SEQEND1_Msk (0x1UL << PWM_INTEN_SEQEND1_Pos) /*!< Bit mask of SEQEND1 field. */
N#define PWM_INTEN_SEQEND1_Disabled (0UL) /*!< Disable */
N#define PWM_INTEN_SEQEND1_Enabled (1UL) /*!< Enable */
N
N/* Bit 4 : Enable or disable interrupt for SEQEND[0] event */
N#define PWM_INTEN_SEQEND0_Pos (4UL) /*!< Position of SEQEND0 field. */
N#define PWM_INTEN_SEQEND0_Msk (0x1UL << PWM_INTEN_SEQEND0_Pos) /*!< Bit mask of SEQEND0 field. */
N#define PWM_INTEN_SEQEND0_Disabled (0UL) /*!< Disable */
N#define PWM_INTEN_SEQEND0_Enabled (1UL) /*!< Enable */
N
N/* Bit 3 : Enable or disable interrupt for SEQSTARTED[1] event */
N#define PWM_INTEN_SEQSTARTED1_Pos (3UL) /*!< Position of SEQSTARTED1 field. */
N#define PWM_INTEN_SEQSTARTED1_Msk (0x1UL << PWM_INTEN_SEQSTARTED1_Pos) /*!< Bit mask of SEQSTARTED1 field. */
N#define PWM_INTEN_SEQSTARTED1_Disabled (0UL) /*!< Disable */
N#define PWM_INTEN_SEQSTARTED1_Enabled (1UL) /*!< Enable */
N
N/* Bit 2 : Enable or disable interrupt for SEQSTARTED[0] event */
N#define PWM_INTEN_SEQSTARTED0_Pos (2UL) /*!< Position of SEQSTARTED0 field. */
N#define PWM_INTEN_SEQSTARTED0_Msk (0x1UL << PWM_INTEN_SEQSTARTED0_Pos) /*!< Bit mask of SEQSTARTED0 field. */
N#define PWM_INTEN_SEQSTARTED0_Disabled (0UL) /*!< Disable */
N#define PWM_INTEN_SEQSTARTED0_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for STOPPED event */
N#define PWM_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define PWM_INTEN_STOPPED_Msk (0x1UL << PWM_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define PWM_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
N#define PWM_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
N
N/* Register: PWM_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 7 : Write '1' to Enable interrupt for LOOPSDONE event */
N#define PWM_INTENSET_LOOPSDONE_Pos (7UL) /*!< Position of LOOPSDONE field. */
N#define PWM_INTENSET_LOOPSDONE_Msk (0x1UL << PWM_INTENSET_LOOPSDONE_Pos) /*!< Bit mask of LOOPSDONE field. */
N#define PWM_INTENSET_LOOPSDONE_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENSET_LOOPSDONE_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENSET_LOOPSDONE_Set (1UL) /*!< Enable */
N
N/* Bit 6 : Write '1' to Enable interrupt for PWMPERIODEND event */
N#define PWM_INTENSET_PWMPERIODEND_Pos (6UL) /*!< Position of PWMPERIODEND field. */
N#define PWM_INTENSET_PWMPERIODEND_Msk (0x1UL << PWM_INTENSET_PWMPERIODEND_Pos) /*!< Bit mask of PWMPERIODEND field. */
N#define PWM_INTENSET_PWMPERIODEND_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENSET_PWMPERIODEND_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENSET_PWMPERIODEND_Set (1UL) /*!< Enable */
N
N/* Bit 5 : Write '1' to Enable interrupt for SEQEND[1] event */
N#define PWM_INTENSET_SEQEND1_Pos (5UL) /*!< Position of SEQEND1 field. */
N#define PWM_INTENSET_SEQEND1_Msk (0x1UL << PWM_INTENSET_SEQEND1_Pos) /*!< Bit mask of SEQEND1 field. */
N#define PWM_INTENSET_SEQEND1_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENSET_SEQEND1_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENSET_SEQEND1_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable interrupt for SEQEND[0] event */
N#define PWM_INTENSET_SEQEND0_Pos (4UL) /*!< Position of SEQEND0 field. */
N#define PWM_INTENSET_SEQEND0_Msk (0x1UL << PWM_INTENSET_SEQEND0_Pos) /*!< Bit mask of SEQEND0 field. */
N#define PWM_INTENSET_SEQEND0_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENSET_SEQEND0_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENSET_SEQEND0_Set (1UL) /*!< Enable */
N
N/* Bit 3 : Write '1' to Enable interrupt for SEQSTARTED[1] event */
N#define PWM_INTENSET_SEQSTARTED1_Pos (3UL) /*!< Position of SEQSTARTED1 field. */
N#define PWM_INTENSET_SEQSTARTED1_Msk (0x1UL << PWM_INTENSET_SEQSTARTED1_Pos) /*!< Bit mask of SEQSTARTED1 field. */
N#define PWM_INTENSET_SEQSTARTED1_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENSET_SEQSTARTED1_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENSET_SEQSTARTED1_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for SEQSTARTED[0] event */
N#define PWM_INTENSET_SEQSTARTED0_Pos (2UL) /*!< Position of SEQSTARTED0 field. */
N#define PWM_INTENSET_SEQSTARTED0_Msk (0x1UL << PWM_INTENSET_SEQSTARTED0_Pos) /*!< Bit mask of SEQSTARTED0 field. */
N#define PWM_INTENSET_SEQSTARTED0_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENSET_SEQSTARTED0_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENSET_SEQSTARTED0_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
N#define PWM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define PWM_INTENSET_STOPPED_Msk (0x1UL << PWM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define PWM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
N
N/* Register: PWM_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 7 : Write '1' to Disable interrupt for LOOPSDONE event */
N#define PWM_INTENCLR_LOOPSDONE_Pos (7UL) /*!< Position of LOOPSDONE field. */
N#define PWM_INTENCLR_LOOPSDONE_Msk (0x1UL << PWM_INTENCLR_LOOPSDONE_Pos) /*!< Bit mask of LOOPSDONE field. */
N#define PWM_INTENCLR_LOOPSDONE_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENCLR_LOOPSDONE_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENCLR_LOOPSDONE_Clear (1UL) /*!< Disable */
N
N/* Bit 6 : Write '1' to Disable interrupt for PWMPERIODEND event */
N#define PWM_INTENCLR_PWMPERIODEND_Pos (6UL) /*!< Position of PWMPERIODEND field. */
N#define PWM_INTENCLR_PWMPERIODEND_Msk (0x1UL << PWM_INTENCLR_PWMPERIODEND_Pos) /*!< Bit mask of PWMPERIODEND field. */
N#define PWM_INTENCLR_PWMPERIODEND_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENCLR_PWMPERIODEND_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENCLR_PWMPERIODEND_Clear (1UL) /*!< Disable */
N
N/* Bit 5 : Write '1' to Disable interrupt for SEQEND[1] event */
N#define PWM_INTENCLR_SEQEND1_Pos (5UL) /*!< Position of SEQEND1 field. */
N#define PWM_INTENCLR_SEQEND1_Msk (0x1UL << PWM_INTENCLR_SEQEND1_Pos) /*!< Bit mask of SEQEND1 field. */
N#define PWM_INTENCLR_SEQEND1_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENCLR_SEQEND1_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENCLR_SEQEND1_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable interrupt for SEQEND[0] event */
N#define PWM_INTENCLR_SEQEND0_Pos (4UL) /*!< Position of SEQEND0 field. */
N#define PWM_INTENCLR_SEQEND0_Msk (0x1UL << PWM_INTENCLR_SEQEND0_Pos) /*!< Bit mask of SEQEND0 field. */
N#define PWM_INTENCLR_SEQEND0_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENCLR_SEQEND0_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENCLR_SEQEND0_Clear (1UL) /*!< Disable */
N
N/* Bit 3 : Write '1' to Disable interrupt for SEQSTARTED[1] event */
N#define PWM_INTENCLR_SEQSTARTED1_Pos (3UL) /*!< Position of SEQSTARTED1 field. */
N#define PWM_INTENCLR_SEQSTARTED1_Msk (0x1UL << PWM_INTENCLR_SEQSTARTED1_Pos) /*!< Bit mask of SEQSTARTED1 field. */
N#define PWM_INTENCLR_SEQSTARTED1_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENCLR_SEQSTARTED1_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENCLR_SEQSTARTED1_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for SEQSTARTED[0] event */
N#define PWM_INTENCLR_SEQSTARTED0_Pos (2UL) /*!< Position of SEQSTARTED0 field. */
N#define PWM_INTENCLR_SEQSTARTED0_Msk (0x1UL << PWM_INTENCLR_SEQSTARTED0_Pos) /*!< Bit mask of SEQSTARTED0 field. */
N#define PWM_INTENCLR_SEQSTARTED0_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENCLR_SEQSTARTED0_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENCLR_SEQSTARTED0_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
N#define PWM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define PWM_INTENCLR_STOPPED_Msk (0x1UL << PWM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define PWM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define PWM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define PWM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
N
N/* Register: PWM_ENABLE */
N/* Description: PWM module enable register */
N
N/* Bit 0 : Enable or disable PWM module */
N#define PWM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define PWM_ENABLE_ENABLE_Msk (0x1UL << PWM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define PWM_ENABLE_ENABLE_Disabled (0UL) /*!< Disabled */
N#define PWM_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
N
N/* Register: PWM_MODE */
N/* Description: Selects operating mode of the wave counter */
N
N/* Bit 0 : Selects up or up and down as wave counter mode */
N#define PWM_MODE_UPDOWN_Pos (0UL) /*!< Position of UPDOWN field. */
N#define PWM_MODE_UPDOWN_Msk (0x1UL << PWM_MODE_UPDOWN_Pos) /*!< Bit mask of UPDOWN field. */
N#define PWM_MODE_UPDOWN_Up (0UL) /*!< Up counter - edge aligned PWM duty-cycle */
N#define PWM_MODE_UPDOWN_UpAndDown (1UL) /*!< Up and down counter - center aligned PWM duty cycle */
N
N/* Register: PWM_COUNTERTOP */
N/* Description: Value up to which the pulse generator counter counts */
N
N/* Bits 14..0 : Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM will be used. */
N#define PWM_COUNTERTOP_COUNTERTOP_Pos (0UL) /*!< Position of COUNTERTOP field. */
N#define PWM_COUNTERTOP_COUNTERTOP_Msk (0x7FFFUL << PWM_COUNTERTOP_COUNTERTOP_Pos) /*!< Bit mask of COUNTERTOP field. */
N
N/* Register: PWM_PRESCALER */
N/* Description: Configuration for PWM_CLK */
N
N/* Bits 2..0 : Pre-scaler of PWM_CLK */
N#define PWM_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define PWM_PRESCALER_PRESCALER_Msk (0x7UL << PWM_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N#define PWM_PRESCALER_PRESCALER_DIV_1 (0UL) /*!< Divide by   1 (16MHz) */
N#define PWM_PRESCALER_PRESCALER_DIV_2 (1UL) /*!< Divide by   2 ( 8MHz) */
N#define PWM_PRESCALER_PRESCALER_DIV_4 (2UL) /*!< Divide by   4 ( 4MHz) */
N#define PWM_PRESCALER_PRESCALER_DIV_8 (3UL) /*!< Divide by   8 ( 2MHz) */
N#define PWM_PRESCALER_PRESCALER_DIV_16 (4UL) /*!< Divide by  16 ( 1MHz) */
N#define PWM_PRESCALER_PRESCALER_DIV_32 (5UL) /*!< Divide by  32 ( 500kHz) */
N#define PWM_PRESCALER_PRESCALER_DIV_64 (6UL) /*!< Divide by  64 ( 250kHz) */
N#define PWM_PRESCALER_PRESCALER_DIV_128 (7UL) /*!< Divide by 128 ( 125kHz) */
N
N/* Register: PWM_DECODER */
N/* Description: Configuration of the decoder */
N
N/* Bit 8 : Selects source for advancing the active sequence */
N#define PWM_DECODER_MODE_Pos (8UL) /*!< Position of MODE field. */
N#define PWM_DECODER_MODE_Msk (0x1UL << PWM_DECODER_MODE_Pos) /*!< Bit mask of MODE field. */
N#define PWM_DECODER_MODE_RefreshCount (0UL) /*!< SEQ[n].REFRESH is used to determine loading internal compare registers */
N#define PWM_DECODER_MODE_NextStep (1UL) /*!< NEXTSTEP task causes a new value to be loaded to internal compare registers */
N
N/* Bits 2..0 : How a sequence is read from RAM and spread to the compare register */
N#define PWM_DECODER_LOAD_Pos (0UL) /*!< Position of LOAD field. */
N#define PWM_DECODER_LOAD_Msk (0x7UL << PWM_DECODER_LOAD_Pos) /*!< Bit mask of LOAD field. */
N#define PWM_DECODER_LOAD_Common (0UL) /*!< 1st half word (16-bit) used in all PWM channels 0..3 */
N#define PWM_DECODER_LOAD_Grouped (1UL) /*!< 1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3 */
N#define PWM_DECODER_LOAD_Individual (2UL) /*!< 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3 */
N#define PWM_DECODER_LOAD_WaveForm (3UL) /*!< 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP */
N
N/* Register: PWM_LOOP */
N/* Description: Amount of playback of a loop */
N
N/* Bits 15..0 : Amount of playback of pattern cycles */
N#define PWM_LOOP_CNT_Pos (0UL) /*!< Position of CNT field. */
N#define PWM_LOOP_CNT_Msk (0xFFFFUL << PWM_LOOP_CNT_Pos) /*!< Bit mask of CNT field. */
N#define PWM_LOOP_CNT_Disabled (0UL) /*!< Looping disabled (stop at the end of the sequence) */
N
N/* Register: PWM_SEQ_PTR */
N/* Description: Description cluster[0]:  Beginning address in Data RAM of this sequence */
N
N/* Bits 31..0 : Beginning address in Data RAM of this sequence */
N#define PWM_SEQ_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define PWM_SEQ_PTR_PTR_Msk (0xFFFFFFFFUL << PWM_SEQ_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: PWM_SEQ_CNT */
N/* Description: Description cluster[0]:  Amount of values (duty cycles) in this sequence */
N
N/* Bits 14..0 : Amount of values (duty cycles) in this sequence */
N#define PWM_SEQ_CNT_CNT_Pos (0UL) /*!< Position of CNT field. */
N#define PWM_SEQ_CNT_CNT_Msk (0x7FFFUL << PWM_SEQ_CNT_CNT_Pos) /*!< Bit mask of CNT field. */
N#define PWM_SEQ_CNT_CNT_Disabled (0UL) /*!< Sequence is disabled, and shall not be started as it is empty */
N
N/* Register: PWM_SEQ_REFRESH */
N/* Description: Description cluster[0]:  Amount of additional PWM periods between samples loaded into compare register */
N
N/* Bits 23..0 : Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods) */
N#define PWM_SEQ_REFRESH_CNT_Pos (0UL) /*!< Position of CNT field. */
N#define PWM_SEQ_REFRESH_CNT_Msk (0xFFFFFFUL << PWM_SEQ_REFRESH_CNT_Pos) /*!< Bit mask of CNT field. */
N#define PWM_SEQ_REFRESH_CNT_Continuous (0UL) /*!< Update every PWM period */
N
N/* Register: PWM_SEQ_ENDDELAY */
N/* Description: Description cluster[0]:  Time added after the sequence */
N
N/* Bits 23..0 : Time added after the sequence in PWM periods */
N#define PWM_SEQ_ENDDELAY_CNT_Pos (0UL) /*!< Position of CNT field. */
N#define PWM_SEQ_ENDDELAY_CNT_Msk (0xFFFFFFUL << PWM_SEQ_ENDDELAY_CNT_Pos) /*!< Bit mask of CNT field. */
N
N/* Register: PWM_PSEL_OUT */
N/* Description: Description collection[0]:  Output pin select for PWM channel 0 */
N
N/* Bit 31 : Connection */
N#define PWM_PSEL_OUT_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define PWM_PSEL_OUT_CONNECT_Msk (0x1UL << PWM_PSEL_OUT_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define PWM_PSEL_OUT_CONNECT_Connected (0UL) /*!< Connect */
N#define PWM_PSEL_OUT_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define PWM_PSEL_OUT_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define PWM_PSEL_OUT_PIN_Msk (0x1FUL << PWM_PSEL_OUT_PIN_Pos) /*!< Bit mask of PIN field. */
N
N
N/* Peripheral: QDEC */
N/* Description: Quadrature Decoder */
N
N/* Register: QDEC_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 6 : Shortcut between SAMPLERDY event and READCLRACC task */
N#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Pos (6UL) /*!< Position of SAMPLERDY_READCLRACC field. */
N#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_SAMPLERDY_READCLRACC_Pos) /*!< Bit mask of SAMPLERDY_READCLRACC field. */
N#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Disabled (0UL) /*!< Disable shortcut */
N#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 5 : Shortcut between DBLRDY event and STOP task */
N#define QDEC_SHORTS_DBLRDY_STOP_Pos (5UL) /*!< Position of DBLRDY_STOP field. */
N#define QDEC_SHORTS_DBLRDY_STOP_Msk (0x1UL << QDEC_SHORTS_DBLRDY_STOP_Pos) /*!< Bit mask of DBLRDY_STOP field. */
N#define QDEC_SHORTS_DBLRDY_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define QDEC_SHORTS_DBLRDY_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 4 : Shortcut between DBLRDY event and RDCLRDBL task */
N#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Pos (4UL) /*!< Position of DBLRDY_RDCLRDBL field. */
N#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Msk (0x1UL << QDEC_SHORTS_DBLRDY_RDCLRDBL_Pos) /*!< Bit mask of DBLRDY_RDCLRDBL field. */
N#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Disabled (0UL) /*!< Disable shortcut */
N#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 3 : Shortcut between REPORTRDY event and STOP task */
N#define QDEC_SHORTS_REPORTRDY_STOP_Pos (3UL) /*!< Position of REPORTRDY_STOP field. */
N#define QDEC_SHORTS_REPORTRDY_STOP_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_STOP_Pos) /*!< Bit mask of REPORTRDY_STOP field. */
N#define QDEC_SHORTS_REPORTRDY_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define QDEC_SHORTS_REPORTRDY_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 2 : Shortcut between REPORTRDY event and RDCLRACC task */
N#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Pos (2UL) /*!< Position of REPORTRDY_RDCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_RDCLRACC_Pos) /*!< Bit mask of REPORTRDY_RDCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Disabled (0UL) /*!< Disable shortcut */
N#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 1 : Shortcut between SAMPLERDY event and STOP task */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Pos (1UL) /*!< Position of SAMPLERDY_STOP field. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Msk (0x1UL << QDEC_SHORTS_SAMPLERDY_STOP_Pos) /*!< Bit mask of SAMPLERDY_STOP field. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 0 : Shortcut between REPORTRDY event and READCLRACC task */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Pos (0UL) /*!< Position of REPORTRDY_READCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_READCLRACC_Pos) /*!< Bit mask of REPORTRDY_READCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled (0UL) /*!< Disable shortcut */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: QDEC_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 4 : Write '1' to Enable interrupt for STOPPED event */
N#define QDEC_INTENSET_STOPPED_Pos (4UL) /*!< Position of STOPPED field. */
N#define QDEC_INTENSET_STOPPED_Msk (0x1UL << QDEC_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define QDEC_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define QDEC_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define QDEC_INTENSET_STOPPED_Set (1UL) /*!< Enable */
N
N/* Bit 3 : Write '1' to Enable interrupt for DBLRDY event */
N#define QDEC_INTENSET_DBLRDY_Pos (3UL) /*!< Position of DBLRDY field. */
N#define QDEC_INTENSET_DBLRDY_Msk (0x1UL << QDEC_INTENSET_DBLRDY_Pos) /*!< Bit mask of DBLRDY field. */
N#define QDEC_INTENSET_DBLRDY_Disabled (0UL) /*!< Read: Disabled */
N#define QDEC_INTENSET_DBLRDY_Enabled (1UL) /*!< Read: Enabled */
N#define QDEC_INTENSET_DBLRDY_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for ACCOF event */
N#define QDEC_INTENSET_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
N#define QDEC_INTENSET_ACCOF_Msk (0x1UL << QDEC_INTENSET_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
N#define QDEC_INTENSET_ACCOF_Disabled (0UL) /*!< Read: Disabled */
N#define QDEC_INTENSET_ACCOF_Enabled (1UL) /*!< Read: Enabled */
N#define QDEC_INTENSET_ACCOF_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for REPORTRDY event */
N#define QDEC_INTENSET_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
N#define QDEC_INTENSET_REPORTRDY_Msk (0x1UL << QDEC_INTENSET_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
N#define QDEC_INTENSET_REPORTRDY_Disabled (0UL) /*!< Read: Disabled */
N#define QDEC_INTENSET_REPORTRDY_Enabled (1UL) /*!< Read: Enabled */
N#define QDEC_INTENSET_REPORTRDY_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for SAMPLERDY event */
N#define QDEC_INTENSET_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
N#define QDEC_INTENSET_SAMPLERDY_Msk (0x1UL << QDEC_INTENSET_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
N#define QDEC_INTENSET_SAMPLERDY_Disabled (0UL) /*!< Read: Disabled */
N#define QDEC_INTENSET_SAMPLERDY_Enabled (1UL) /*!< Read: Enabled */
N#define QDEC_INTENSET_SAMPLERDY_Set (1UL) /*!< Enable */
N
N/* Register: QDEC_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 4 : Write '1' to Disable interrupt for STOPPED event */
N#define QDEC_INTENCLR_STOPPED_Pos (4UL) /*!< Position of STOPPED field. */
N#define QDEC_INTENCLR_STOPPED_Msk (0x1UL << QDEC_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define QDEC_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define QDEC_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define QDEC_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
N
N/* Bit 3 : Write '1' to Disable interrupt for DBLRDY event */
N#define QDEC_INTENCLR_DBLRDY_Pos (3UL) /*!< Position of DBLRDY field. */
N#define QDEC_INTENCLR_DBLRDY_Msk (0x1UL << QDEC_INTENCLR_DBLRDY_Pos) /*!< Bit mask of DBLRDY field. */
N#define QDEC_INTENCLR_DBLRDY_Disabled (0UL) /*!< Read: Disabled */
N#define QDEC_INTENCLR_DBLRDY_Enabled (1UL) /*!< Read: Enabled */
N#define QDEC_INTENCLR_DBLRDY_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for ACCOF event */
N#define QDEC_INTENCLR_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
N#define QDEC_INTENCLR_ACCOF_Msk (0x1UL << QDEC_INTENCLR_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
N#define QDEC_INTENCLR_ACCOF_Disabled (0UL) /*!< Read: Disabled */
N#define QDEC_INTENCLR_ACCOF_Enabled (1UL) /*!< Read: Enabled */
N#define QDEC_INTENCLR_ACCOF_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for REPORTRDY event */
N#define QDEC_INTENCLR_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
N#define QDEC_INTENCLR_REPORTRDY_Msk (0x1UL << QDEC_INTENCLR_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
N#define QDEC_INTENCLR_REPORTRDY_Disabled (0UL) /*!< Read: Disabled */
N#define QDEC_INTENCLR_REPORTRDY_Enabled (1UL) /*!< Read: Enabled */
N#define QDEC_INTENCLR_REPORTRDY_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for SAMPLERDY event */
N#define QDEC_INTENCLR_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
N#define QDEC_INTENCLR_SAMPLERDY_Msk (0x1UL << QDEC_INTENCLR_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
N#define QDEC_INTENCLR_SAMPLERDY_Disabled (0UL) /*!< Read: Disabled */
N#define QDEC_INTENCLR_SAMPLERDY_Enabled (1UL) /*!< Read: Enabled */
N#define QDEC_INTENCLR_SAMPLERDY_Clear (1UL) /*!< Disable */
N
N/* Register: QDEC_ENABLE */
N/* Description: Enable the quadrature decoder */
N
N/* Bit 0 : Enable or disable the quadrature decoder */
N#define QDEC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define QDEC_ENABLE_ENABLE_Msk (0x1UL << QDEC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define QDEC_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
N#define QDEC_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
N
N/* Register: QDEC_LEDPOL */
N/* Description: LED output pin polarity */
N
N/* Bit 0 : LED output pin polarity */
N#define QDEC_LEDPOL_LEDPOL_Pos (0UL) /*!< Position of LEDPOL field. */
N#define QDEC_LEDPOL_LEDPOL_Msk (0x1UL << QDEC_LEDPOL_LEDPOL_Pos) /*!< Bit mask of LEDPOL field. */
N#define QDEC_LEDPOL_LEDPOL_ActiveLow (0UL) /*!< Led active on output pin low */
N#define QDEC_LEDPOL_LEDPOL_ActiveHigh (1UL) /*!< Led active on output pin high */
N
N/* Register: QDEC_SAMPLEPER */
N/* Description: Sample period */
N
N/* Bits 3..0 : Sample period. The SAMPLE register will be updated for every new sample */
N#define QDEC_SAMPLEPER_SAMPLEPER_Pos (0UL) /*!< Position of SAMPLEPER field. */
N#define QDEC_SAMPLEPER_SAMPLEPER_Msk (0xFUL << QDEC_SAMPLEPER_SAMPLEPER_Pos) /*!< Bit mask of SAMPLEPER field. */
N#define QDEC_SAMPLEPER_SAMPLEPER_128us (0UL) /*!< 128 us */
N#define QDEC_SAMPLEPER_SAMPLEPER_256us (1UL) /*!< 256 us */
N#define QDEC_SAMPLEPER_SAMPLEPER_512us (2UL) /*!< 512 us */
N#define QDEC_SAMPLEPER_SAMPLEPER_1024us (3UL) /*!< 1024 us */
N#define QDEC_SAMPLEPER_SAMPLEPER_2048us (4UL) /*!< 2048 us */
N#define QDEC_SAMPLEPER_SAMPLEPER_4096us (5UL) /*!< 4096 us */
N#define QDEC_SAMPLEPER_SAMPLEPER_8192us (6UL) /*!< 8192 us */
N#define QDEC_SAMPLEPER_SAMPLEPER_16384us (7UL) /*!< 16384 us */
N#define QDEC_SAMPLEPER_SAMPLEPER_32ms (8UL) /*!< 32768 us */
N#define QDEC_SAMPLEPER_SAMPLEPER_65ms (9UL) /*!< 65536 us */
N#define QDEC_SAMPLEPER_SAMPLEPER_131ms (10UL) /*!< 131072 us */
N
N/* Register: QDEC_SAMPLE */
N/* Description: Motion sample value */
N
N/* Bits 31..0 : Last motion sample */
N#define QDEC_SAMPLE_SAMPLE_Pos (0UL) /*!< Position of SAMPLE field. */
N#define QDEC_SAMPLE_SAMPLE_Msk (0xFFFFFFFFUL << QDEC_SAMPLE_SAMPLE_Pos) /*!< Bit mask of SAMPLE field. */
N
N/* Register: QDEC_REPORTPER */
N/* Description: Number of samples to be taken before REPORTRDY and DBLRDY events can be generated */
N
N/* Bits 3..0 : Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated */
N#define QDEC_REPORTPER_REPORTPER_Pos (0UL) /*!< Position of REPORTPER field. */
N#define QDEC_REPORTPER_REPORTPER_Msk (0xFUL << QDEC_REPORTPER_REPORTPER_Pos) /*!< Bit mask of REPORTPER field. */
N#define QDEC_REPORTPER_REPORTPER_10Smpl (0UL) /*!< 10 samples / report */
N#define QDEC_REPORTPER_REPORTPER_40Smpl (1UL) /*!< 40 samples / report */
N#define QDEC_REPORTPER_REPORTPER_80Smpl (2UL) /*!< 80 samples / report */
N#define QDEC_REPORTPER_REPORTPER_120Smpl (3UL) /*!< 120 samples / report */
N#define QDEC_REPORTPER_REPORTPER_160Smpl (4UL) /*!< 160 samples / report */
N#define QDEC_REPORTPER_REPORTPER_200Smpl (5UL) /*!< 200 samples / report */
N#define QDEC_REPORTPER_REPORTPER_240Smpl (6UL) /*!< 240 samples / report */
N#define QDEC_REPORTPER_REPORTPER_280Smpl (7UL) /*!< 280 samples / report */
N#define QDEC_REPORTPER_REPORTPER_1Smpl (8UL) /*!< 1 sample / report */
N
N/* Register: QDEC_ACC */
N/* Description: Register accumulating the valid transitions */
N
N/* Bits 31..0 : Register accumulating all valid samples (not double transition) read from the SAMPLE register */
N#define QDEC_ACC_ACC_Pos (0UL) /*!< Position of ACC field. */
N#define QDEC_ACC_ACC_Msk (0xFFFFFFFFUL << QDEC_ACC_ACC_Pos) /*!< Bit mask of ACC field. */
N
N/* Register: QDEC_ACCREAD */
N/* Description: Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task */
N
N/* Bits 31..0 : Snapshot of the ACC register. */
N#define QDEC_ACCREAD_ACCREAD_Pos (0UL) /*!< Position of ACCREAD field. */
N#define QDEC_ACCREAD_ACCREAD_Msk (0xFFFFFFFFUL << QDEC_ACCREAD_ACCREAD_Pos) /*!< Bit mask of ACCREAD field. */
N
N/* Register: QDEC_PSEL_LED */
N/* Description: Pin select for LED signal */
N
N/* Bit 31 : Connection */
N#define QDEC_PSEL_LED_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define QDEC_PSEL_LED_CONNECT_Msk (0x1UL << QDEC_PSEL_LED_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define QDEC_PSEL_LED_CONNECT_Connected (0UL) /*!< Connect */
N#define QDEC_PSEL_LED_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define QDEC_PSEL_LED_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define QDEC_PSEL_LED_PIN_Msk (0x1FUL << QDEC_PSEL_LED_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: QDEC_PSEL_A */
N/* Description: Pin select for A signal */
N
N/* Bit 31 : Connection */
N#define QDEC_PSEL_A_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define QDEC_PSEL_A_CONNECT_Msk (0x1UL << QDEC_PSEL_A_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define QDEC_PSEL_A_CONNECT_Connected (0UL) /*!< Connect */
N#define QDEC_PSEL_A_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define QDEC_PSEL_A_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define QDEC_PSEL_A_PIN_Msk (0x1FUL << QDEC_PSEL_A_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: QDEC_PSEL_B */
N/* Description: Pin select for B signal */
N
N/* Bit 31 : Connection */
N#define QDEC_PSEL_B_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define QDEC_PSEL_B_CONNECT_Msk (0x1UL << QDEC_PSEL_B_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define QDEC_PSEL_B_CONNECT_Connected (0UL) /*!< Connect */
N#define QDEC_PSEL_B_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define QDEC_PSEL_B_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define QDEC_PSEL_B_PIN_Msk (0x1FUL << QDEC_PSEL_B_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: QDEC_DBFEN */
N/* Description: Enable input debounce filters */
N
N/* Bit 0 : Enable input debounce filters */
N#define QDEC_DBFEN_DBFEN_Pos (0UL) /*!< Position of DBFEN field. */
N#define QDEC_DBFEN_DBFEN_Msk (0x1UL << QDEC_DBFEN_DBFEN_Pos) /*!< Bit mask of DBFEN field. */
N#define QDEC_DBFEN_DBFEN_Disabled (0UL) /*!< Debounce input filters disabled */
N#define QDEC_DBFEN_DBFEN_Enabled (1UL) /*!< Debounce input filters enabled */
N
N/* Register: QDEC_LEDPRE */
N/* Description: Time period the LED is switched ON prior to sampling */
N
N/* Bits 8..0 : Period in us the LED is switched on prior to sampling */
N#define QDEC_LEDPRE_LEDPRE_Pos (0UL) /*!< Position of LEDPRE field. */
N#define QDEC_LEDPRE_LEDPRE_Msk (0x1FFUL << QDEC_LEDPRE_LEDPRE_Pos) /*!< Bit mask of LEDPRE field. */
N
N/* Register: QDEC_ACCDBL */
N/* Description: Register accumulating the number of detected double transitions */
N
N/* Bits 3..0 : Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 ). */
N#define QDEC_ACCDBL_ACCDBL_Pos (0UL) /*!< Position of ACCDBL field. */
N#define QDEC_ACCDBL_ACCDBL_Msk (0xFUL << QDEC_ACCDBL_ACCDBL_Pos) /*!< Bit mask of ACCDBL field. */
N
N/* Register: QDEC_ACCDBLREAD */
N/* Description: Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task */
N
N/* Bits 3..0 : Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered. */
N#define QDEC_ACCDBLREAD_ACCDBLREAD_Pos (0UL) /*!< Position of ACCDBLREAD field. */
N#define QDEC_ACCDBLREAD_ACCDBLREAD_Msk (0xFUL << QDEC_ACCDBLREAD_ACCDBLREAD_Pos) /*!< Bit mask of ACCDBLREAD field. */
N
N
N/* Peripheral: RADIO */
N/* Description: 2.4 GHz Radio */
N
N/* Register: RADIO_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 8 : Shortcut between DISABLED event and RSSISTOP task */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Pos (8UL) /*!< Position of DISABLED_RSSISTOP field. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Msk (0x1UL << RADIO_SHORTS_DISABLED_RSSISTOP_Pos) /*!< Bit mask of DISABLED_RSSISTOP field. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Disabled (0UL) /*!< Disable shortcut */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 6 : Shortcut between ADDRESS event and BCSTART task */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Pos (6UL) /*!< Position of ADDRESS_BCSTART field. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_BCSTART_Pos) /*!< Bit mask of ADDRESS_BCSTART field. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Disabled (0UL) /*!< Disable shortcut */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 5 : Shortcut between END event and START task */
N#define RADIO_SHORTS_END_START_Pos (5UL) /*!< Position of END_START field. */
N#define RADIO_SHORTS_END_START_Msk (0x1UL << RADIO_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
N#define RADIO_SHORTS_END_START_Disabled (0UL) /*!< Disable shortcut */
N#define RADIO_SHORTS_END_START_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 4 : Shortcut between ADDRESS event and RSSISTART task */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Pos (4UL) /*!< Position of ADDRESS_RSSISTART field. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_RSSISTART_Pos) /*!< Bit mask of ADDRESS_RSSISTART field. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Disabled (0UL) /*!< Disable shortcut */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 3 : Shortcut between DISABLED event and RXEN task */
N#define RADIO_SHORTS_DISABLED_RXEN_Pos (3UL) /*!< Position of DISABLED_RXEN field. */
N#define RADIO_SHORTS_DISABLED_RXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_RXEN_Pos) /*!< Bit mask of DISABLED_RXEN field. */
N#define RADIO_SHORTS_DISABLED_RXEN_Disabled (0UL) /*!< Disable shortcut */
N#define RADIO_SHORTS_DISABLED_RXEN_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 2 : Shortcut between DISABLED event and TXEN task */
N#define RADIO_SHORTS_DISABLED_TXEN_Pos (2UL) /*!< Position of DISABLED_TXEN field. */
N#define RADIO_SHORTS_DISABLED_TXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_TXEN_Pos) /*!< Bit mask of DISABLED_TXEN field. */
N#define RADIO_SHORTS_DISABLED_TXEN_Disabled (0UL) /*!< Disable shortcut */
N#define RADIO_SHORTS_DISABLED_TXEN_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 1 : Shortcut between END event and DISABLE task */
N#define RADIO_SHORTS_END_DISABLE_Pos (1UL) /*!< Position of END_DISABLE field. */
N#define RADIO_SHORTS_END_DISABLE_Msk (0x1UL << RADIO_SHORTS_END_DISABLE_Pos) /*!< Bit mask of END_DISABLE field. */
N#define RADIO_SHORTS_END_DISABLE_Disabled (0UL) /*!< Disable shortcut */
N#define RADIO_SHORTS_END_DISABLE_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 0 : Shortcut between READY event and START task */
N#define RADIO_SHORTS_READY_START_Pos (0UL) /*!< Position of READY_START field. */
N#define RADIO_SHORTS_READY_START_Msk (0x1UL << RADIO_SHORTS_READY_START_Pos) /*!< Bit mask of READY_START field. */
N#define RADIO_SHORTS_READY_START_Disabled (0UL) /*!< Disable shortcut */
N#define RADIO_SHORTS_READY_START_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: RADIO_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 13 : Write '1' to Enable interrupt for CRCERROR event */
N#define RADIO_INTENSET_CRCERROR_Pos (13UL) /*!< Position of CRCERROR field. */
N#define RADIO_INTENSET_CRCERROR_Msk (0x1UL << RADIO_INTENSET_CRCERROR_Pos) /*!< Bit mask of CRCERROR field. */
N#define RADIO_INTENSET_CRCERROR_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_CRCERROR_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_CRCERROR_Set (1UL) /*!< Enable */
N
N/* Bit 12 : Write '1' to Enable interrupt for CRCOK event */
N#define RADIO_INTENSET_CRCOK_Pos (12UL) /*!< Position of CRCOK field. */
N#define RADIO_INTENSET_CRCOK_Msk (0x1UL << RADIO_INTENSET_CRCOK_Pos) /*!< Bit mask of CRCOK field. */
N#define RADIO_INTENSET_CRCOK_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_CRCOK_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_CRCOK_Set (1UL) /*!< Enable */
N
N/* Bit 10 : Write '1' to Enable interrupt for BCMATCH event */
N#define RADIO_INTENSET_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
N#define RADIO_INTENSET_BCMATCH_Msk (0x1UL << RADIO_INTENSET_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
N#define RADIO_INTENSET_BCMATCH_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_BCMATCH_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_BCMATCH_Set (1UL) /*!< Enable */
N
N/* Bit 7 : Write '1' to Enable interrupt for RSSIEND event */
N#define RADIO_INTENSET_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
N#define RADIO_INTENSET_RSSIEND_Msk (0x1UL << RADIO_INTENSET_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
N#define RADIO_INTENSET_RSSIEND_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_RSSIEND_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_RSSIEND_Set (1UL) /*!< Enable */
N
N/* Bit 6 : Write '1' to Enable interrupt for DEVMISS event */
N#define RADIO_INTENSET_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
N#define RADIO_INTENSET_DEVMISS_Msk (0x1UL << RADIO_INTENSET_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
N#define RADIO_INTENSET_DEVMISS_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_DEVMISS_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_DEVMISS_Set (1UL) /*!< Enable */
N
N/* Bit 5 : Write '1' to Enable interrupt for DEVMATCH event */
N#define RADIO_INTENSET_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
N#define RADIO_INTENSET_DEVMATCH_Msk (0x1UL << RADIO_INTENSET_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
N#define RADIO_INTENSET_DEVMATCH_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_DEVMATCH_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_DEVMATCH_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable interrupt for DISABLED event */
N#define RADIO_INTENSET_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
N#define RADIO_INTENSET_DISABLED_Msk (0x1UL << RADIO_INTENSET_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
N#define RADIO_INTENSET_DISABLED_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_DISABLED_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_DISABLED_Set (1UL) /*!< Enable */
N
N/* Bit 3 : Write '1' to Enable interrupt for END event */
N#define RADIO_INTENSET_END_Pos (3UL) /*!< Position of END field. */
N#define RADIO_INTENSET_END_Msk (0x1UL << RADIO_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define RADIO_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_END_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for PAYLOAD event */
N#define RADIO_INTENSET_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
N#define RADIO_INTENSET_PAYLOAD_Msk (0x1UL << RADIO_INTENSET_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
N#define RADIO_INTENSET_PAYLOAD_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_PAYLOAD_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_PAYLOAD_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for ADDRESS event */
N#define RADIO_INTENSET_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
N#define RADIO_INTENSET_ADDRESS_Msk (0x1UL << RADIO_INTENSET_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N#define RADIO_INTENSET_ADDRESS_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_ADDRESS_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_ADDRESS_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for READY event */
N#define RADIO_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define RADIO_INTENSET_READY_Msk (0x1UL << RADIO_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define RADIO_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENSET_READY_Set (1UL) /*!< Enable */
N
N/* Register: RADIO_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 13 : Write '1' to Disable interrupt for CRCERROR event */
N#define RADIO_INTENCLR_CRCERROR_Pos (13UL) /*!< Position of CRCERROR field. */
N#define RADIO_INTENCLR_CRCERROR_Msk (0x1UL << RADIO_INTENCLR_CRCERROR_Pos) /*!< Bit mask of CRCERROR field. */
N#define RADIO_INTENCLR_CRCERROR_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_CRCERROR_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_CRCERROR_Clear (1UL) /*!< Disable */
N
N/* Bit 12 : Write '1' to Disable interrupt for CRCOK event */
N#define RADIO_INTENCLR_CRCOK_Pos (12UL) /*!< Position of CRCOK field. */
N#define RADIO_INTENCLR_CRCOK_Msk (0x1UL << RADIO_INTENCLR_CRCOK_Pos) /*!< Bit mask of CRCOK field. */
N#define RADIO_INTENCLR_CRCOK_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_CRCOK_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_CRCOK_Clear (1UL) /*!< Disable */
N
N/* Bit 10 : Write '1' to Disable interrupt for BCMATCH event */
N#define RADIO_INTENCLR_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
N#define RADIO_INTENCLR_BCMATCH_Msk (0x1UL << RADIO_INTENCLR_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
N#define RADIO_INTENCLR_BCMATCH_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_BCMATCH_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_BCMATCH_Clear (1UL) /*!< Disable */
N
N/* Bit 7 : Write '1' to Disable interrupt for RSSIEND event */
N#define RADIO_INTENCLR_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
N#define RADIO_INTENCLR_RSSIEND_Msk (0x1UL << RADIO_INTENCLR_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
N#define RADIO_INTENCLR_RSSIEND_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_RSSIEND_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_RSSIEND_Clear (1UL) /*!< Disable */
N
N/* Bit 6 : Write '1' to Disable interrupt for DEVMISS event */
N#define RADIO_INTENCLR_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
N#define RADIO_INTENCLR_DEVMISS_Msk (0x1UL << RADIO_INTENCLR_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
N#define RADIO_INTENCLR_DEVMISS_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_DEVMISS_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_DEVMISS_Clear (1UL) /*!< Disable */
N
N/* Bit 5 : Write '1' to Disable interrupt for DEVMATCH event */
N#define RADIO_INTENCLR_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
N#define RADIO_INTENCLR_DEVMATCH_Msk (0x1UL << RADIO_INTENCLR_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
N#define RADIO_INTENCLR_DEVMATCH_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_DEVMATCH_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_DEVMATCH_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable interrupt for DISABLED event */
N#define RADIO_INTENCLR_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
N#define RADIO_INTENCLR_DISABLED_Msk (0x1UL << RADIO_INTENCLR_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
N#define RADIO_INTENCLR_DISABLED_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_DISABLED_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_DISABLED_Clear (1UL) /*!< Disable */
N
N/* Bit 3 : Write '1' to Disable interrupt for END event */
N#define RADIO_INTENCLR_END_Pos (3UL) /*!< Position of END field. */
N#define RADIO_INTENCLR_END_Msk (0x1UL << RADIO_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define RADIO_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_END_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for PAYLOAD event */
N#define RADIO_INTENCLR_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
N#define RADIO_INTENCLR_PAYLOAD_Msk (0x1UL << RADIO_INTENCLR_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
N#define RADIO_INTENCLR_PAYLOAD_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_PAYLOAD_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_PAYLOAD_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for ADDRESS event */
N#define RADIO_INTENCLR_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
N#define RADIO_INTENCLR_ADDRESS_Msk (0x1UL << RADIO_INTENCLR_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N#define RADIO_INTENCLR_ADDRESS_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_ADDRESS_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_ADDRESS_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for READY event */
N#define RADIO_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define RADIO_INTENCLR_READY_Msk (0x1UL << RADIO_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define RADIO_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
N#define RADIO_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
N#define RADIO_INTENCLR_READY_Clear (1UL) /*!< Disable */
N
N/* Register: RADIO_CRCSTATUS */
N/* Description: CRC status */
N
N/* Bit 0 : CRC status of packet received */
N#define RADIO_CRCSTATUS_CRCSTATUS_Pos (0UL) /*!< Position of CRCSTATUS field. */
N#define RADIO_CRCSTATUS_CRCSTATUS_Msk (0x1UL << RADIO_CRCSTATUS_CRCSTATUS_Pos) /*!< Bit mask of CRCSTATUS field. */
N#define RADIO_CRCSTATUS_CRCSTATUS_CRCError (0UL) /*!< Packet received with CRC error */
N#define RADIO_CRCSTATUS_CRCSTATUS_CRCOk (1UL) /*!< Packet received with CRC ok */
N
N/* Register: RADIO_RXMATCH */
N/* Description: Received address */
N
N/* Bits 2..0 : Received address */
N#define RADIO_RXMATCH_RXMATCH_Pos (0UL) /*!< Position of RXMATCH field. */
N#define RADIO_RXMATCH_RXMATCH_Msk (0x7UL << RADIO_RXMATCH_RXMATCH_Pos) /*!< Bit mask of RXMATCH field. */
N
N/* Register: RADIO_RXCRC */
N/* Description: CRC field of previously received packet */
N
N/* Bits 23..0 : CRC field of previously received packet */
N#define RADIO_RXCRC_RXCRC_Pos (0UL) /*!< Position of RXCRC field. */
N#define RADIO_RXCRC_RXCRC_Msk (0xFFFFFFUL << RADIO_RXCRC_RXCRC_Pos) /*!< Bit mask of RXCRC field. */
N
N/* Register: RADIO_DAI */
N/* Description: Device address match index */
N
N/* Bits 2..0 : Device address match index */
N#define RADIO_DAI_DAI_Pos (0UL) /*!< Position of DAI field. */
N#define RADIO_DAI_DAI_Msk (0x7UL << RADIO_DAI_DAI_Pos) /*!< Bit mask of DAI field. */
N
N/* Register: RADIO_PACKETPTR */
N/* Description: Packet pointer */
N
N/* Bits 31..0 : Packet pointer */
N#define RADIO_PACKETPTR_PACKETPTR_Pos (0UL) /*!< Position of PACKETPTR field. */
N#define RADIO_PACKETPTR_PACKETPTR_Msk (0xFFFFFFFFUL << RADIO_PACKETPTR_PACKETPTR_Pos) /*!< Bit mask of PACKETPTR field. */
N
N/* Register: RADIO_FREQUENCY */
N/* Description: Frequency */
N
N/* Bit 8 : Channel map selection. */
N#define RADIO_FREQUENCY_MAP_Pos (8UL) /*!< Position of MAP field. */
N#define RADIO_FREQUENCY_MAP_Msk (0x1UL << RADIO_FREQUENCY_MAP_Pos) /*!< Bit mask of MAP field. */
N#define RADIO_FREQUENCY_MAP_Default (0UL) /*!< Channel map between 2400 MHZ .. 2500 MHz */
N#define RADIO_FREQUENCY_MAP_Low (1UL) /*!< Channel map between 2360 MHZ .. 2460 MHz */
N
N/* Bits 6..0 : Radio channel frequency */
N#define RADIO_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define RADIO_FREQUENCY_FREQUENCY_Msk (0x7FUL << RADIO_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N
N/* Register: RADIO_TXPOWER */
N/* Description: Output power */
N
N/* Bits 7..0 : RADIO output power. */
N#define RADIO_TXPOWER_TXPOWER_Pos (0UL) /*!< Position of TXPOWER field. */
N#define RADIO_TXPOWER_TXPOWER_Msk (0xFFUL << RADIO_TXPOWER_TXPOWER_Pos) /*!< Bit mask of TXPOWER field. */
N#define RADIO_TXPOWER_TXPOWER_0dBm (0x00UL) /*!< 0 dBm */
N#define RADIO_TXPOWER_TXPOWER_Pos3dBm (0x03UL) /*!< +3 dBm */
N#define RADIO_TXPOWER_TXPOWER_Pos4dBm (0x04UL) /*!< +4 dBm */
N#define RADIO_TXPOWER_TXPOWER_Neg30dBm (0xD8UL) /*!< Deprecated enumerator -  -40 dBm */
N#define RADIO_TXPOWER_TXPOWER_Neg40dBm (0xD8UL) /*!< -40 dBm */
N#define RADIO_TXPOWER_TXPOWER_Neg20dBm (0xECUL) /*!< -20 dBm */
N#define RADIO_TXPOWER_TXPOWER_Neg16dBm (0xF0UL) /*!< -16 dBm */
N#define RADIO_TXPOWER_TXPOWER_Neg12dBm (0xF4UL) /*!< -12 dBm */
N#define RADIO_TXPOWER_TXPOWER_Neg8dBm (0xF8UL) /*!< -8 dBm */
N#define RADIO_TXPOWER_TXPOWER_Neg4dBm (0xFCUL) /*!< -4 dBm */
N
N/* Register: RADIO_MODE */
N/* Description: Data rate and modulation */
N
N/* Bits 3..0 : Radio data rate and modulation setting. The radio supports Frequency-shift Keying (FSK) modulation. */
N#define RADIO_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define RADIO_MODE_MODE_Msk (0xFUL << RADIO_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define RADIO_MODE_MODE_Nrf_1Mbit (0UL) /*!< 1 Mbit/s Nordic proprietary radio mode */
N#define RADIO_MODE_MODE_Nrf_2Mbit (1UL) /*!< 2 Mbit/s Nordic proprietary radio mode */
N#define RADIO_MODE_MODE_Nrf_250Kbit (2UL) /*!< Deprecated enumerator -  250 kbit/s Nordic proprietary radio mode */
N#define RADIO_MODE_MODE_Ble_1Mbit (3UL) /*!< 1 Mbit/s Bluetooth Low Energy */
N
N/* Register: RADIO_PCNF0 */
N/* Description: Packet configuration register 0 */
N
N/* Bit 24 : Length of preamble on air. Decision point: TASKS_START task */
N#define RADIO_PCNF0_PLEN_Pos (24UL) /*!< Position of PLEN field. */
N#define RADIO_PCNF0_PLEN_Msk (0x1UL << RADIO_PCNF0_PLEN_Pos) /*!< Bit mask of PLEN field. */
N#define RADIO_PCNF0_PLEN_8bit (0UL) /*!< 8-bit preamble */
N#define RADIO_PCNF0_PLEN_16bit (1UL) /*!< 16-bit preamble */
N
N/* Bit 20 : Include or exclude S1 field in RAM */
N#define RADIO_PCNF0_S1INCL_Pos (20UL) /*!< Position of S1INCL field. */
N#define RADIO_PCNF0_S1INCL_Msk (0x1UL << RADIO_PCNF0_S1INCL_Pos) /*!< Bit mask of S1INCL field. */
N#define RADIO_PCNF0_S1INCL_Automatic (0UL) /*!< Include S1 field in RAM only if S1LEN &gt; 0 */
N#define RADIO_PCNF0_S1INCL_Include (1UL) /*!< Always include S1 field in RAM independent of S1LEN */
N
N/* Bits 19..16 : Length on air of S1 field in number of bits. */
N#define RADIO_PCNF0_S1LEN_Pos (16UL) /*!< Position of S1LEN field. */
N#define RADIO_PCNF0_S1LEN_Msk (0xFUL << RADIO_PCNF0_S1LEN_Pos) /*!< Bit mask of S1LEN field. */
N
N/* Bit 8 : Length on air of S0 field in number of bytes. */
N#define RADIO_PCNF0_S0LEN_Pos (8UL) /*!< Position of S0LEN field. */
N#define RADIO_PCNF0_S0LEN_Msk (0x1UL << RADIO_PCNF0_S0LEN_Pos) /*!< Bit mask of S0LEN field. */
N
N/* Bits 3..0 : Length on air of LENGTH field in number of bits. */
N#define RADIO_PCNF0_LFLEN_Pos (0UL) /*!< Position of LFLEN field. */
N#define RADIO_PCNF0_LFLEN_Msk (0xFUL << RADIO_PCNF0_LFLEN_Pos) /*!< Bit mask of LFLEN field. */
N
N/* Register: RADIO_PCNF1 */
N/* Description: Packet configuration register 1 */
N
N/* Bit 25 : Enable or disable packet whitening */
N#define RADIO_PCNF1_WHITEEN_Pos (25UL) /*!< Position of WHITEEN field. */
N#define RADIO_PCNF1_WHITEEN_Msk (0x1UL << RADIO_PCNF1_WHITEEN_Pos) /*!< Bit mask of WHITEEN field. */
N#define RADIO_PCNF1_WHITEEN_Disabled (0UL) /*!< Disable */
N#define RADIO_PCNF1_WHITEEN_Enabled (1UL) /*!< Enable */
N
N/* Bit 24 : On air endianness of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD fields. */
N#define RADIO_PCNF1_ENDIAN_Pos (24UL) /*!< Position of ENDIAN field. */
N#define RADIO_PCNF1_ENDIAN_Msk (0x1UL << RADIO_PCNF1_ENDIAN_Pos) /*!< Bit mask of ENDIAN field. */
N#define RADIO_PCNF1_ENDIAN_Little (0UL) /*!< Least Significant bit on air first */
N#define RADIO_PCNF1_ENDIAN_Big (1UL) /*!< Most significant bit on air first */
N
N/* Bits 18..16 : Base address length in number of bytes */
N#define RADIO_PCNF1_BALEN_Pos (16UL) /*!< Position of BALEN field. */
N#define RADIO_PCNF1_BALEN_Msk (0x7UL << RADIO_PCNF1_BALEN_Pos) /*!< Bit mask of BALEN field. */
N
N/* Bits 15..8 : Static length in number of bytes */
N#define RADIO_PCNF1_STATLEN_Pos (8UL) /*!< Position of STATLEN field. */
N#define RADIO_PCNF1_STATLEN_Msk (0xFFUL << RADIO_PCNF1_STATLEN_Pos) /*!< Bit mask of STATLEN field. */
N
N/* Bits 7..0 : Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN. */
N#define RADIO_PCNF1_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
N#define RADIO_PCNF1_MAXLEN_Msk (0xFFUL << RADIO_PCNF1_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
N
N/* Register: RADIO_BASE0 */
N/* Description: Base address 0 */
N
N/* Bits 31..0 : Base address 0 */
N#define RADIO_BASE0_BASE0_Pos (0UL) /*!< Position of BASE0 field. */
N#define RADIO_BASE0_BASE0_Msk (0xFFFFFFFFUL << RADIO_BASE0_BASE0_Pos) /*!< Bit mask of BASE0 field. */
N
N/* Register: RADIO_BASE1 */
N/* Description: Base address 1 */
N
N/* Bits 31..0 : Base address 1 */
N#define RADIO_BASE1_BASE1_Pos (0UL) /*!< Position of BASE1 field. */
N#define RADIO_BASE1_BASE1_Msk (0xFFFFFFFFUL << RADIO_BASE1_BASE1_Pos) /*!< Bit mask of BASE1 field. */
N
N/* Register: RADIO_PREFIX0 */
N/* Description: Prefixes bytes for logical addresses 0-3 */
N
N/* Bits 31..24 : Address prefix 3. */
N#define RADIO_PREFIX0_AP3_Pos (24UL) /*!< Position of AP3 field. */
N#define RADIO_PREFIX0_AP3_Msk (0xFFUL << RADIO_PREFIX0_AP3_Pos) /*!< Bit mask of AP3 field. */
N
N/* Bits 23..16 : Address prefix 2. */
N#define RADIO_PREFIX0_AP2_Pos (16UL) /*!< Position of AP2 field. */
N#define RADIO_PREFIX0_AP2_Msk (0xFFUL << RADIO_PREFIX0_AP2_Pos) /*!< Bit mask of AP2 field. */
N
N/* Bits 15..8 : Address prefix 1. */
N#define RADIO_PREFIX0_AP1_Pos (8UL) /*!< Position of AP1 field. */
N#define RADIO_PREFIX0_AP1_Msk (0xFFUL << RADIO_PREFIX0_AP1_Pos) /*!< Bit mask of AP1 field. */
N
N/* Bits 7..0 : Address prefix 0. */
N#define RADIO_PREFIX0_AP0_Pos (0UL) /*!< Position of AP0 field. */
N#define RADIO_PREFIX0_AP0_Msk (0xFFUL << RADIO_PREFIX0_AP0_Pos) /*!< Bit mask of AP0 field. */
N
N/* Register: RADIO_PREFIX1 */
N/* Description: Prefixes bytes for logical addresses 4-7 */
N
N/* Bits 31..24 : Address prefix 7. */
N#define RADIO_PREFIX1_AP7_Pos (24UL) /*!< Position of AP7 field. */
N#define RADIO_PREFIX1_AP7_Msk (0xFFUL << RADIO_PREFIX1_AP7_Pos) /*!< Bit mask of AP7 field. */
N
N/* Bits 23..16 : Address prefix 6. */
N#define RADIO_PREFIX1_AP6_Pos (16UL) /*!< Position of AP6 field. */
N#define RADIO_PREFIX1_AP6_Msk (0xFFUL << RADIO_PREFIX1_AP6_Pos) /*!< Bit mask of AP6 field. */
N
N/* Bits 15..8 : Address prefix 5. */
N#define RADIO_PREFIX1_AP5_Pos (8UL) /*!< Position of AP5 field. */
N#define RADIO_PREFIX1_AP5_Msk (0xFFUL << RADIO_PREFIX1_AP5_Pos) /*!< Bit mask of AP5 field. */
N
N/* Bits 7..0 : Address prefix 4. */
N#define RADIO_PREFIX1_AP4_Pos (0UL) /*!< Position of AP4 field. */
N#define RADIO_PREFIX1_AP4_Msk (0xFFUL << RADIO_PREFIX1_AP4_Pos) /*!< Bit mask of AP4 field. */
N
N/* Register: RADIO_TXADDRESS */
N/* Description: Transmit address select */
N
N/* Bits 2..0 : Transmit address select */
N#define RADIO_TXADDRESS_TXADDRESS_Pos (0UL) /*!< Position of TXADDRESS field. */
N#define RADIO_TXADDRESS_TXADDRESS_Msk (0x7UL << RADIO_TXADDRESS_TXADDRESS_Pos) /*!< Bit mask of TXADDRESS field. */
N
N/* Register: RADIO_RXADDRESSES */
N/* Description: Receive address select */
N
N/* Bit 7 : Enable or disable reception on logical address 7. */
N#define RADIO_RXADDRESSES_ADDR7_Pos (7UL) /*!< Position of ADDR7 field. */
N#define RADIO_RXADDRESSES_ADDR7_Msk (0x1UL << RADIO_RXADDRESSES_ADDR7_Pos) /*!< Bit mask of ADDR7 field. */
N#define RADIO_RXADDRESSES_ADDR7_Disabled (0UL) /*!< Disable */
N#define RADIO_RXADDRESSES_ADDR7_Enabled (1UL) /*!< Enable */
N
N/* Bit 6 : Enable or disable reception on logical address 6. */
N#define RADIO_RXADDRESSES_ADDR6_Pos (6UL) /*!< Position of ADDR6 field. */
N#define RADIO_RXADDRESSES_ADDR6_Msk (0x1UL << RADIO_RXADDRESSES_ADDR6_Pos) /*!< Bit mask of ADDR6 field. */
N#define RADIO_RXADDRESSES_ADDR6_Disabled (0UL) /*!< Disable */
N#define RADIO_RXADDRESSES_ADDR6_Enabled (1UL) /*!< Enable */
N
N/* Bit 5 : Enable or disable reception on logical address 5. */
N#define RADIO_RXADDRESSES_ADDR5_Pos (5UL) /*!< Position of ADDR5 field. */
N#define RADIO_RXADDRESSES_ADDR5_Msk (0x1UL << RADIO_RXADDRESSES_ADDR5_Pos) /*!< Bit mask of ADDR5 field. */
N#define RADIO_RXADDRESSES_ADDR5_Disabled (0UL) /*!< Disable */
N#define RADIO_RXADDRESSES_ADDR5_Enabled (1UL) /*!< Enable */
N
N/* Bit 4 : Enable or disable reception on logical address 4. */
N#define RADIO_RXADDRESSES_ADDR4_Pos (4UL) /*!< Position of ADDR4 field. */
N#define RADIO_RXADDRESSES_ADDR4_Msk (0x1UL << RADIO_RXADDRESSES_ADDR4_Pos) /*!< Bit mask of ADDR4 field. */
N#define RADIO_RXADDRESSES_ADDR4_Disabled (0UL) /*!< Disable */
N#define RADIO_RXADDRESSES_ADDR4_Enabled (1UL) /*!< Enable */
N
N/* Bit 3 : Enable or disable reception on logical address 3. */
N#define RADIO_RXADDRESSES_ADDR3_Pos (3UL) /*!< Position of ADDR3 field. */
N#define RADIO_RXADDRESSES_ADDR3_Msk (0x1UL << RADIO_RXADDRESSES_ADDR3_Pos) /*!< Bit mask of ADDR3 field. */
N#define RADIO_RXADDRESSES_ADDR3_Disabled (0UL) /*!< Disable */
N#define RADIO_RXADDRESSES_ADDR3_Enabled (1UL) /*!< Enable */
N
N/* Bit 2 : Enable or disable reception on logical address 2. */
N#define RADIO_RXADDRESSES_ADDR2_Pos (2UL) /*!< Position of ADDR2 field. */
N#define RADIO_RXADDRESSES_ADDR2_Msk (0x1UL << RADIO_RXADDRESSES_ADDR2_Pos) /*!< Bit mask of ADDR2 field. */
N#define RADIO_RXADDRESSES_ADDR2_Disabled (0UL) /*!< Disable */
N#define RADIO_RXADDRESSES_ADDR2_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable reception on logical address 1. */
N#define RADIO_RXADDRESSES_ADDR1_Pos (1UL) /*!< Position of ADDR1 field. */
N#define RADIO_RXADDRESSES_ADDR1_Msk (0x1UL << RADIO_RXADDRESSES_ADDR1_Pos) /*!< Bit mask of ADDR1 field. */
N#define RADIO_RXADDRESSES_ADDR1_Disabled (0UL) /*!< Disable */
N#define RADIO_RXADDRESSES_ADDR1_Enabled (1UL) /*!< Enable */
N
N/* Bit 0 : Enable or disable reception on logical address 0. */
N#define RADIO_RXADDRESSES_ADDR0_Pos (0UL) /*!< Position of ADDR0 field. */
N#define RADIO_RXADDRESSES_ADDR0_Msk (0x1UL << RADIO_RXADDRESSES_ADDR0_Pos) /*!< Bit mask of ADDR0 field. */
N#define RADIO_RXADDRESSES_ADDR0_Disabled (0UL) /*!< Disable */
N#define RADIO_RXADDRESSES_ADDR0_Enabled (1UL) /*!< Enable */
N
N/* Register: RADIO_CRCCNF */
N/* Description: CRC configuration */
N
N/* Bit 8 : Include or exclude packet address field out of CRC calculation. */
N#define RADIO_CRCCNF_SKIPADDR_Pos (8UL) /*!< Position of SKIPADDR field. */
N#define RADIO_CRCCNF_SKIPADDR_Msk (0x1UL << RADIO_CRCCNF_SKIPADDR_Pos) /*!< Bit mask of SKIPADDR field. */
N#define RADIO_CRCCNF_SKIPADDR_Include (0UL) /*!< CRC calculation includes address field */
N#define RADIO_CRCCNF_SKIPADDR_Skip (1UL) /*!< CRC calculation does not include address field. The CRC calculation will start at the first byte after the address. */
N
N/* Bits 1..0 : CRC length in number of bytes. */
N#define RADIO_CRCCNF_LEN_Pos (0UL) /*!< Position of LEN field. */
N#define RADIO_CRCCNF_LEN_Msk (0x3UL << RADIO_CRCCNF_LEN_Pos) /*!< Bit mask of LEN field. */
N#define RADIO_CRCCNF_LEN_Disabled (0UL) /*!< CRC length is zero and CRC calculation is disabled */
N#define RADIO_CRCCNF_LEN_One (1UL) /*!< CRC length is one byte and CRC calculation is enabled */
N#define RADIO_CRCCNF_LEN_Two (2UL) /*!< CRC length is two bytes and CRC calculation is enabled */
N#define RADIO_CRCCNF_LEN_Three (3UL) /*!< CRC length is three bytes and CRC calculation is enabled */
N
N/* Register: RADIO_CRCPOLY */
N/* Description: CRC polynomial */
N
N/* Bits 23..0 : CRC polynomial */
N#define RADIO_CRCPOLY_CRCPOLY_Pos (0UL) /*!< Position of CRCPOLY field. */
N#define RADIO_CRCPOLY_CRCPOLY_Msk (0xFFFFFFUL << RADIO_CRCPOLY_CRCPOLY_Pos) /*!< Bit mask of CRCPOLY field. */
N
N/* Register: RADIO_CRCINIT */
N/* Description: CRC initial value */
N
N/* Bits 23..0 : CRC initial value */
N#define RADIO_CRCINIT_CRCINIT_Pos (0UL) /*!< Position of CRCINIT field. */
N#define RADIO_CRCINIT_CRCINIT_Msk (0xFFFFFFUL << RADIO_CRCINIT_CRCINIT_Pos) /*!< Bit mask of CRCINIT field. */
N
N/* Register: RADIO_TIFS */
N/* Description: Inter Frame Spacing in us */
N
N/* Bits 7..0 : Inter Frame Spacing in us */
N#define RADIO_TIFS_TIFS_Pos (0UL) /*!< Position of TIFS field. */
N#define RADIO_TIFS_TIFS_Msk (0xFFUL << RADIO_TIFS_TIFS_Pos) /*!< Bit mask of TIFS field. */
N
N/* Register: RADIO_RSSISAMPLE */
N/* Description: RSSI sample */
N
N/* Bits 6..0 : RSSI sample */
N#define RADIO_RSSISAMPLE_RSSISAMPLE_Pos (0UL) /*!< Position of RSSISAMPLE field. */
N#define RADIO_RSSISAMPLE_RSSISAMPLE_Msk (0x7FUL << RADIO_RSSISAMPLE_RSSISAMPLE_Pos) /*!< Bit mask of RSSISAMPLE field. */
N
N/* Register: RADIO_STATE */
N/* Description: Current radio state */
N
N/* Bits 3..0 : Current radio state */
N#define RADIO_STATE_STATE_Pos (0UL) /*!< Position of STATE field. */
N#define RADIO_STATE_STATE_Msk (0xFUL << RADIO_STATE_STATE_Pos) /*!< Bit mask of STATE field. */
N#define RADIO_STATE_STATE_Disabled (0UL) /*!< RADIO is in the Disabled state */
N#define RADIO_STATE_STATE_RxRu (1UL) /*!< RADIO is in the RXRU state */
N#define RADIO_STATE_STATE_RxIdle (2UL) /*!< RADIO is in the RXIDLE state */
N#define RADIO_STATE_STATE_Rx (3UL) /*!< RADIO is in the RX state */
N#define RADIO_STATE_STATE_RxDisable (4UL) /*!< RADIO is in the RXDISABLED state */
N#define RADIO_STATE_STATE_TxRu (9UL) /*!< RADIO is in the TXRU state */
N#define RADIO_STATE_STATE_TxIdle (10UL) /*!< RADIO is in the TXIDLE state */
N#define RADIO_STATE_STATE_Tx (11UL) /*!< RADIO is in the TX state */
N#define RADIO_STATE_STATE_TxDisable (12UL) /*!< RADIO is in the TXDISABLED state */
N
N/* Register: RADIO_DATAWHITEIV */
N/* Description: Data whitening initial value */
N
N/* Bits 6..0 : Data whitening initial value. Bit 6 is hard-wired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'. */
N#define RADIO_DATAWHITEIV_DATAWHITEIV_Pos (0UL) /*!< Position of DATAWHITEIV field. */
N#define RADIO_DATAWHITEIV_DATAWHITEIV_Msk (0x7FUL << RADIO_DATAWHITEIV_DATAWHITEIV_Pos) /*!< Bit mask of DATAWHITEIV field. */
N
N/* Register: RADIO_BCC */
N/* Description: Bit counter compare */
N
N/* Bits 31..0 : Bit counter compare */
N#define RADIO_BCC_BCC_Pos (0UL) /*!< Position of BCC field. */
N#define RADIO_BCC_BCC_Msk (0xFFFFFFFFUL << RADIO_BCC_BCC_Pos) /*!< Bit mask of BCC field. */
N
N/* Register: RADIO_DAB */
N/* Description: Description collection[0]:  Device address base segment 0 */
N
N/* Bits 31..0 : Device address base segment 0 */
N#define RADIO_DAB_DAB_Pos (0UL) /*!< Position of DAB field. */
N#define RADIO_DAB_DAB_Msk (0xFFFFFFFFUL << RADIO_DAB_DAB_Pos) /*!< Bit mask of DAB field. */
N
N/* Register: RADIO_DAP */
N/* Description: Description collection[0]:  Device address prefix 0 */
N
N/* Bits 15..0 : Device address prefix 0 */
N#define RADIO_DAP_DAP_Pos (0UL) /*!< Position of DAP field. */
N#define RADIO_DAP_DAP_Msk (0xFFFFUL << RADIO_DAP_DAP_Pos) /*!< Bit mask of DAP field. */
N
N/* Register: RADIO_DACNF */
N/* Description: Device address match configuration */
N
N/* Bit 15 : TxAdd for device address 7 */
N#define RADIO_DACNF_TXADD7_Pos (15UL) /*!< Position of TXADD7 field. */
N#define RADIO_DACNF_TXADD7_Msk (0x1UL << RADIO_DACNF_TXADD7_Pos) /*!< Bit mask of TXADD7 field. */
N
N/* Bit 14 : TxAdd for device address 6 */
N#define RADIO_DACNF_TXADD6_Pos (14UL) /*!< Position of TXADD6 field. */
N#define RADIO_DACNF_TXADD6_Msk (0x1UL << RADIO_DACNF_TXADD6_Pos) /*!< Bit mask of TXADD6 field. */
N
N/* Bit 13 : TxAdd for device address 5 */
N#define RADIO_DACNF_TXADD5_Pos (13UL) /*!< Position of TXADD5 field. */
N#define RADIO_DACNF_TXADD5_Msk (0x1UL << RADIO_DACNF_TXADD5_Pos) /*!< Bit mask of TXADD5 field. */
N
N/* Bit 12 : TxAdd for device address 4 */
N#define RADIO_DACNF_TXADD4_Pos (12UL) /*!< Position of TXADD4 field. */
N#define RADIO_DACNF_TXADD4_Msk (0x1UL << RADIO_DACNF_TXADD4_Pos) /*!< Bit mask of TXADD4 field. */
N
N/* Bit 11 : TxAdd for device address 3 */
N#define RADIO_DACNF_TXADD3_Pos (11UL) /*!< Position of TXADD3 field. */
N#define RADIO_DACNF_TXADD3_Msk (0x1UL << RADIO_DACNF_TXADD3_Pos) /*!< Bit mask of TXADD3 field. */
N
N/* Bit 10 : TxAdd for device address 2 */
N#define RADIO_DACNF_TXADD2_Pos (10UL) /*!< Position of TXADD2 field. */
N#define RADIO_DACNF_TXADD2_Msk (0x1UL << RADIO_DACNF_TXADD2_Pos) /*!< Bit mask of TXADD2 field. */
N
N/* Bit 9 : TxAdd for device address 1 */
N#define RADIO_DACNF_TXADD1_Pos (9UL) /*!< Position of TXADD1 field. */
N#define RADIO_DACNF_TXADD1_Msk (0x1UL << RADIO_DACNF_TXADD1_Pos) /*!< Bit mask of TXADD1 field. */
N
N/* Bit 8 : TxAdd for device address 0 */
N#define RADIO_DACNF_TXADD0_Pos (8UL) /*!< Position of TXADD0 field. */
N#define RADIO_DACNF_TXADD0_Msk (0x1UL << RADIO_DACNF_TXADD0_Pos) /*!< Bit mask of TXADD0 field. */
N
N/* Bit 7 : Enable or disable device address matching using device address 7 */
N#define RADIO_DACNF_ENA7_Pos (7UL) /*!< Position of ENA7 field. */
N#define RADIO_DACNF_ENA7_Msk (0x1UL << RADIO_DACNF_ENA7_Pos) /*!< Bit mask of ENA7 field. */
N#define RADIO_DACNF_ENA7_Disabled (0UL) /*!< Disabled */
N#define RADIO_DACNF_ENA7_Enabled (1UL) /*!< Enabled */
N
N/* Bit 6 : Enable or disable device address matching using device address 6 */
N#define RADIO_DACNF_ENA6_Pos (6UL) /*!< Position of ENA6 field. */
N#define RADIO_DACNF_ENA6_Msk (0x1UL << RADIO_DACNF_ENA6_Pos) /*!< Bit mask of ENA6 field. */
N#define RADIO_DACNF_ENA6_Disabled (0UL) /*!< Disabled */
N#define RADIO_DACNF_ENA6_Enabled (1UL) /*!< Enabled */
N
N/* Bit 5 : Enable or disable device address matching using device address 5 */
N#define RADIO_DACNF_ENA5_Pos (5UL) /*!< Position of ENA5 field. */
N#define RADIO_DACNF_ENA5_Msk (0x1UL << RADIO_DACNF_ENA5_Pos) /*!< Bit mask of ENA5 field. */
N#define RADIO_DACNF_ENA5_Disabled (0UL) /*!< Disabled */
N#define RADIO_DACNF_ENA5_Enabled (1UL) /*!< Enabled */
N
N/* Bit 4 : Enable or disable device address matching using device address 4 */
N#define RADIO_DACNF_ENA4_Pos (4UL) /*!< Position of ENA4 field. */
N#define RADIO_DACNF_ENA4_Msk (0x1UL << RADIO_DACNF_ENA4_Pos) /*!< Bit mask of ENA4 field. */
N#define RADIO_DACNF_ENA4_Disabled (0UL) /*!< Disabled */
N#define RADIO_DACNF_ENA4_Enabled (1UL) /*!< Enabled */
N
N/* Bit 3 : Enable or disable device address matching using device address 3 */
N#define RADIO_DACNF_ENA3_Pos (3UL) /*!< Position of ENA3 field. */
N#define RADIO_DACNF_ENA3_Msk (0x1UL << RADIO_DACNF_ENA3_Pos) /*!< Bit mask of ENA3 field. */
N#define RADIO_DACNF_ENA3_Disabled (0UL) /*!< Disabled */
N#define RADIO_DACNF_ENA3_Enabled (1UL) /*!< Enabled */
N
N/* Bit 2 : Enable or disable device address matching using device address 2 */
N#define RADIO_DACNF_ENA2_Pos (2UL) /*!< Position of ENA2 field. */
N#define RADIO_DACNF_ENA2_Msk (0x1UL << RADIO_DACNF_ENA2_Pos) /*!< Bit mask of ENA2 field. */
N#define RADIO_DACNF_ENA2_Disabled (0UL) /*!< Disabled */
N#define RADIO_DACNF_ENA2_Enabled (1UL) /*!< Enabled */
N
N/* Bit 1 : Enable or disable device address matching using device address 1 */
N#define RADIO_DACNF_ENA1_Pos (1UL) /*!< Position of ENA1 field. */
N#define RADIO_DACNF_ENA1_Msk (0x1UL << RADIO_DACNF_ENA1_Pos) /*!< Bit mask of ENA1 field. */
N#define RADIO_DACNF_ENA1_Disabled (0UL) /*!< Disabled */
N#define RADIO_DACNF_ENA1_Enabled (1UL) /*!< Enabled */
N
N/* Bit 0 : Enable or disable device address matching using device address 0 */
N#define RADIO_DACNF_ENA0_Pos (0UL) /*!< Position of ENA0 field. */
N#define RADIO_DACNF_ENA0_Msk (0x1UL << RADIO_DACNF_ENA0_Pos) /*!< Bit mask of ENA0 field. */
N#define RADIO_DACNF_ENA0_Disabled (0UL) /*!< Disabled */
N#define RADIO_DACNF_ENA0_Enabled (1UL) /*!< Enabled */
N
N/* Register: RADIO_MODECNF0 */
N/* Description: Radio mode configuration register 0 */
N
N/* Bits 9..8 : Default TX value */
N#define RADIO_MODECNF0_DTX_Pos (8UL) /*!< Position of DTX field. */
N#define RADIO_MODECNF0_DTX_Msk (0x3UL << RADIO_MODECNF0_DTX_Pos) /*!< Bit mask of DTX field. */
N#define RADIO_MODECNF0_DTX_B1 (0UL) /*!< Transmit '1' */
N#define RADIO_MODECNF0_DTX_B0 (1UL) /*!< Transmit '0' */
N#define RADIO_MODECNF0_DTX_Center (2UL) /*!< Transmit center frequency */
N
N/* Bit 0 : Radio ramp-up time */
N#define RADIO_MODECNF0_RU_Pos (0UL) /*!< Position of RU field. */
N#define RADIO_MODECNF0_RU_Msk (0x1UL << RADIO_MODECNF0_RU_Pos) /*!< Bit mask of RU field. */
N#define RADIO_MODECNF0_RU_Default (0UL) /*!< Default ramp-up time (tRXEN), compatible with firmware written for nRF51 */
N#define RADIO_MODECNF0_RU_Fast (1UL) /*!< Fast ramp-up (tRXEN,FAST), see electrical specification for more information */
N
N/* Register: RADIO_POWER */
N/* Description: Peripheral power control */
N
N/* Bit 0 : Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again. */
N#define RADIO_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RADIO_POWER_POWER_Msk (0x1UL << RADIO_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RADIO_POWER_POWER_Disabled (0UL) /*!< Peripheral is powered off */
N#define RADIO_POWER_POWER_Enabled (1UL) /*!< Peripheral is powered on */
N
N
N/* Peripheral: RNG */
N/* Description: Random Number Generator */
N
N/* Register: RNG_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 0 : Shortcut between VALRDY event and STOP task */
N#define RNG_SHORTS_VALRDY_STOP_Pos (0UL) /*!< Position of VALRDY_STOP field. */
N#define RNG_SHORTS_VALRDY_STOP_Msk (0x1UL << RNG_SHORTS_VALRDY_STOP_Pos) /*!< Bit mask of VALRDY_STOP field. */
N#define RNG_SHORTS_VALRDY_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define RNG_SHORTS_VALRDY_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: RNG_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 0 : Write '1' to Enable interrupt for VALRDY event */
N#define RNG_INTENSET_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
N#define RNG_INTENSET_VALRDY_Msk (0x1UL << RNG_INTENSET_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
N#define RNG_INTENSET_VALRDY_Disabled (0UL) /*!< Read: Disabled */
N#define RNG_INTENSET_VALRDY_Enabled (1UL) /*!< Read: Enabled */
N#define RNG_INTENSET_VALRDY_Set (1UL) /*!< Enable */
N
N/* Register: RNG_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 0 : Write '1' to Disable interrupt for VALRDY event */
N#define RNG_INTENCLR_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
N#define RNG_INTENCLR_VALRDY_Msk (0x1UL << RNG_INTENCLR_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
N#define RNG_INTENCLR_VALRDY_Disabled (0UL) /*!< Read: Disabled */
N#define RNG_INTENCLR_VALRDY_Enabled (1UL) /*!< Read: Enabled */
N#define RNG_INTENCLR_VALRDY_Clear (1UL) /*!< Disable */
N
N/* Register: RNG_CONFIG */
N/* Description: Configuration register */
N
N/* Bit 0 : Bias correction */
N#define RNG_CONFIG_DERCEN_Pos (0UL) /*!< Position of DERCEN field. */
N#define RNG_CONFIG_DERCEN_Msk (0x1UL << RNG_CONFIG_DERCEN_Pos) /*!< Bit mask of DERCEN field. */
N#define RNG_CONFIG_DERCEN_Disabled (0UL) /*!< Disabled */
N#define RNG_CONFIG_DERCEN_Enabled (1UL) /*!< Enabled */
N
N/* Register: RNG_VALUE */
N/* Description: Output random number */
N
N/* Bits 7..0 : Generated random number */
N#define RNG_VALUE_VALUE_Pos (0UL) /*!< Position of VALUE field. */
N#define RNG_VALUE_VALUE_Msk (0xFFUL << RNG_VALUE_VALUE_Pos) /*!< Bit mask of VALUE field. */
N
N
N/* Peripheral: RTC */
N/* Description: Real time counter 0 */
N
N/* Register: RTC_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 19 : Write '1' to Enable interrupt for COMPARE[3] event */
N#define RTC_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_INTENSET_COMPARE3_Msk (0x1UL << RTC_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_INTENSET_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENSET_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENSET_COMPARE3_Set (1UL) /*!< Enable */
N
N/* Bit 18 : Write '1' to Enable interrupt for COMPARE[2] event */
N#define RTC_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_INTENSET_COMPARE2_Msk (0x1UL << RTC_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_INTENSET_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENSET_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENSET_COMPARE2_Set (1UL) /*!< Enable */
N
N/* Bit 17 : Write '1' to Enable interrupt for COMPARE[1] event */
N#define RTC_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_INTENSET_COMPARE1_Msk (0x1UL << RTC_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_INTENSET_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENSET_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENSET_COMPARE1_Set (1UL) /*!< Enable */
N
N/* Bit 16 : Write '1' to Enable interrupt for COMPARE[0] event */
N#define RTC_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_INTENSET_COMPARE0_Msk (0x1UL << RTC_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_INTENSET_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENSET_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENSET_COMPARE0_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for OVRFLW event */
N#define RTC_INTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_INTENSET_OVRFLW_Msk (0x1UL << RTC_INTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_INTENSET_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENSET_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENSET_OVRFLW_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for TICK event */
N#define RTC_INTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_INTENSET_TICK_Msk (0x1UL << RTC_INTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_INTENSET_TICK_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENSET_TICK_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENSET_TICK_Set (1UL) /*!< Enable */
N
N/* Register: RTC_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 19 : Write '1' to Disable interrupt for COMPARE[3] event */
N#define RTC_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_INTENCLR_COMPARE3_Msk (0x1UL << RTC_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_INTENCLR_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENCLR_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable */
N
N/* Bit 18 : Write '1' to Disable interrupt for COMPARE[2] event */
N#define RTC_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_INTENCLR_COMPARE2_Msk (0x1UL << RTC_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_INTENCLR_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENCLR_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable */
N
N/* Bit 17 : Write '1' to Disable interrupt for COMPARE[1] event */
N#define RTC_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_INTENCLR_COMPARE1_Msk (0x1UL << RTC_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_INTENCLR_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENCLR_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable */
N
N/* Bit 16 : Write '1' to Disable interrupt for COMPARE[0] event */
N#define RTC_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_INTENCLR_COMPARE0_Msk (0x1UL << RTC_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_INTENCLR_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENCLR_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for OVRFLW event */
N#define RTC_INTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_INTENCLR_OVRFLW_Msk (0x1UL << RTC_INTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_INTENCLR_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENCLR_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENCLR_OVRFLW_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for TICK event */
N#define RTC_INTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_INTENCLR_TICK_Msk (0x1UL << RTC_INTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_INTENCLR_TICK_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_INTENCLR_TICK_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_INTENCLR_TICK_Clear (1UL) /*!< Disable */
N
N/* Register: RTC_EVTEN */
N/* Description: Enable or disable event routing */
N
N/* Bit 19 : Enable or disable event routing for COMPARE[3] event */
N#define RTC_EVTEN_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTEN_COMPARE3_Msk (0x1UL << RTC_EVTEN_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTEN_COMPARE3_Disabled (0UL) /*!< Disable */
N#define RTC_EVTEN_COMPARE3_Enabled (1UL) /*!< Enable */
N
N/* Bit 18 : Enable or disable event routing for COMPARE[2] event */
N#define RTC_EVTEN_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTEN_COMPARE2_Msk (0x1UL << RTC_EVTEN_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTEN_COMPARE2_Disabled (0UL) /*!< Disable */
N#define RTC_EVTEN_COMPARE2_Enabled (1UL) /*!< Enable */
N
N/* Bit 17 : Enable or disable event routing for COMPARE[1] event */
N#define RTC_EVTEN_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTEN_COMPARE1_Msk (0x1UL << RTC_EVTEN_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTEN_COMPARE1_Disabled (0UL) /*!< Disable */
N#define RTC_EVTEN_COMPARE1_Enabled (1UL) /*!< Enable */
N
N/* Bit 16 : Enable or disable event routing for COMPARE[0] event */
N#define RTC_EVTEN_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTEN_COMPARE0_Msk (0x1UL << RTC_EVTEN_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTEN_COMPARE0_Disabled (0UL) /*!< Disable */
N#define RTC_EVTEN_COMPARE0_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable event routing for OVRFLW event */
N#define RTC_EVTEN_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTEN_OVRFLW_Msk (0x1UL << RTC_EVTEN_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTEN_OVRFLW_Disabled (0UL) /*!< Disable */
N#define RTC_EVTEN_OVRFLW_Enabled (1UL) /*!< Enable */
N
N/* Bit 0 : Enable or disable event routing for TICK event */
N#define RTC_EVTEN_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTEN_TICK_Msk (0x1UL << RTC_EVTEN_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTEN_TICK_Disabled (0UL) /*!< Disable */
N#define RTC_EVTEN_TICK_Enabled (1UL) /*!< Enable */
N
N/* Register: RTC_EVTENSET */
N/* Description: Enable event routing */
N
N/* Bit 19 : Write '1' to Enable event routing for COMPARE[3] event */
N#define RTC_EVTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTENSET_COMPARE3_Msk (0x1UL << RTC_EVTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTENSET_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENSET_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENSET_COMPARE3_Set (1UL) /*!< Enable */
N
N/* Bit 18 : Write '1' to Enable event routing for COMPARE[2] event */
N#define RTC_EVTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTENSET_COMPARE2_Msk (0x1UL << RTC_EVTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTENSET_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENSET_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENSET_COMPARE2_Set (1UL) /*!< Enable */
N
N/* Bit 17 : Write '1' to Enable event routing for COMPARE[1] event */
N#define RTC_EVTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTENSET_COMPARE1_Msk (0x1UL << RTC_EVTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTENSET_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENSET_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENSET_COMPARE1_Set (1UL) /*!< Enable */
N
N/* Bit 16 : Write '1' to Enable event routing for COMPARE[0] event */
N#define RTC_EVTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTENSET_COMPARE0_Msk (0x1UL << RTC_EVTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTENSET_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENSET_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENSET_COMPARE0_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable event routing for OVRFLW event */
N#define RTC_EVTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTENSET_OVRFLW_Msk (0x1UL << RTC_EVTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTENSET_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENSET_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENSET_OVRFLW_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable event routing for TICK event */
N#define RTC_EVTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTENSET_TICK_Msk (0x1UL << RTC_EVTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTENSET_TICK_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENSET_TICK_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENSET_TICK_Set (1UL) /*!< Enable */
N
N/* Register: RTC_EVTENCLR */
N/* Description: Disable event routing */
N
N/* Bit 19 : Write '1' to Disable event routing for COMPARE[3] event */
N#define RTC_EVTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTENCLR_COMPARE3_Msk (0x1UL << RTC_EVTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTENCLR_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENCLR_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENCLR_COMPARE3_Clear (1UL) /*!< Disable */
N
N/* Bit 18 : Write '1' to Disable event routing for COMPARE[2] event */
N#define RTC_EVTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTENCLR_COMPARE2_Msk (0x1UL << RTC_EVTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTENCLR_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENCLR_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENCLR_COMPARE2_Clear (1UL) /*!< Disable */
N
N/* Bit 17 : Write '1' to Disable event routing for COMPARE[1] event */
N#define RTC_EVTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTENCLR_COMPARE1_Msk (0x1UL << RTC_EVTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTENCLR_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENCLR_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENCLR_COMPARE1_Clear (1UL) /*!< Disable */
N
N/* Bit 16 : Write '1' to Disable event routing for COMPARE[0] event */
N#define RTC_EVTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTENCLR_COMPARE0_Msk (0x1UL << RTC_EVTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTENCLR_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENCLR_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENCLR_COMPARE0_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable event routing for OVRFLW event */
N#define RTC_EVTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTENCLR_OVRFLW_Msk (0x1UL << RTC_EVTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTENCLR_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENCLR_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENCLR_OVRFLW_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable event routing for TICK event */
N#define RTC_EVTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTENCLR_TICK_Msk (0x1UL << RTC_EVTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTENCLR_TICK_Disabled (0UL) /*!< Read: Disabled */
N#define RTC_EVTENCLR_TICK_Enabled (1UL) /*!< Read: Enabled */
N#define RTC_EVTENCLR_TICK_Clear (1UL) /*!< Disable */
N
N/* Register: RTC_COUNTER */
N/* Description: Current COUNTER value */
N
N/* Bits 23..0 : Counter value */
N#define RTC_COUNTER_COUNTER_Pos (0UL) /*!< Position of COUNTER field. */
N#define RTC_COUNTER_COUNTER_Msk (0xFFFFFFUL << RTC_COUNTER_COUNTER_Pos) /*!< Bit mask of COUNTER field. */
N
N/* Register: RTC_PRESCALER */
N/* Description: 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped */
N
N/* Bits 11..0 : Prescaler value */
N#define RTC_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define RTC_PRESCALER_PRESCALER_Msk (0xFFFUL << RTC_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N
N/* Register: RTC_CC */
N/* Description: Description collection[0]:  Compare register 0 */
N
N/* Bits 23..0 : Compare value */
N#define RTC_CC_COMPARE_Pos (0UL) /*!< Position of COMPARE field. */
N#define RTC_CC_COMPARE_Msk (0xFFFFFFUL << RTC_CC_COMPARE_Pos) /*!< Bit mask of COMPARE field. */
N
N
N/* Peripheral: SAADC */
N/* Description: Analog to Digital Converter */
N
N/* Register: SAADC_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 21 : Enable or disable interrupt for CH[7].LIMITL event */
N#define SAADC_INTEN_CH7LIMITL_Pos (21UL) /*!< Position of CH7LIMITL field. */
N#define SAADC_INTEN_CH7LIMITL_Msk (0x1UL << SAADC_INTEN_CH7LIMITL_Pos) /*!< Bit mask of CH7LIMITL field. */
N#define SAADC_INTEN_CH7LIMITL_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH7LIMITL_Enabled (1UL) /*!< Enable */
N
N/* Bit 20 : Enable or disable interrupt for CH[7].LIMITH event */
N#define SAADC_INTEN_CH7LIMITH_Pos (20UL) /*!< Position of CH7LIMITH field. */
N#define SAADC_INTEN_CH7LIMITH_Msk (0x1UL << SAADC_INTEN_CH7LIMITH_Pos) /*!< Bit mask of CH7LIMITH field. */
N#define SAADC_INTEN_CH7LIMITH_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH7LIMITH_Enabled (1UL) /*!< Enable */
N
N/* Bit 19 : Enable or disable interrupt for CH[6].LIMITL event */
N#define SAADC_INTEN_CH6LIMITL_Pos (19UL) /*!< Position of CH6LIMITL field. */
N#define SAADC_INTEN_CH6LIMITL_Msk (0x1UL << SAADC_INTEN_CH6LIMITL_Pos) /*!< Bit mask of CH6LIMITL field. */
N#define SAADC_INTEN_CH6LIMITL_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH6LIMITL_Enabled (1UL) /*!< Enable */
N
N/* Bit 18 : Enable or disable interrupt for CH[6].LIMITH event */
N#define SAADC_INTEN_CH6LIMITH_Pos (18UL) /*!< Position of CH6LIMITH field. */
N#define SAADC_INTEN_CH6LIMITH_Msk (0x1UL << SAADC_INTEN_CH6LIMITH_Pos) /*!< Bit mask of CH6LIMITH field. */
N#define SAADC_INTEN_CH6LIMITH_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH6LIMITH_Enabled (1UL) /*!< Enable */
N
N/* Bit 17 : Enable or disable interrupt for CH[5].LIMITL event */
N#define SAADC_INTEN_CH5LIMITL_Pos (17UL) /*!< Position of CH5LIMITL field. */
N#define SAADC_INTEN_CH5LIMITL_Msk (0x1UL << SAADC_INTEN_CH5LIMITL_Pos) /*!< Bit mask of CH5LIMITL field. */
N#define SAADC_INTEN_CH5LIMITL_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH5LIMITL_Enabled (1UL) /*!< Enable */
N
N/* Bit 16 : Enable or disable interrupt for CH[5].LIMITH event */
N#define SAADC_INTEN_CH5LIMITH_Pos (16UL) /*!< Position of CH5LIMITH field. */
N#define SAADC_INTEN_CH5LIMITH_Msk (0x1UL << SAADC_INTEN_CH5LIMITH_Pos) /*!< Bit mask of CH5LIMITH field. */
N#define SAADC_INTEN_CH5LIMITH_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH5LIMITH_Enabled (1UL) /*!< Enable */
N
N/* Bit 15 : Enable or disable interrupt for CH[4].LIMITL event */
N#define SAADC_INTEN_CH4LIMITL_Pos (15UL) /*!< Position of CH4LIMITL field. */
N#define SAADC_INTEN_CH4LIMITL_Msk (0x1UL << SAADC_INTEN_CH4LIMITL_Pos) /*!< Bit mask of CH4LIMITL field. */
N#define SAADC_INTEN_CH4LIMITL_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH4LIMITL_Enabled (1UL) /*!< Enable */
N
N/* Bit 14 : Enable or disable interrupt for CH[4].LIMITH event */
N#define SAADC_INTEN_CH4LIMITH_Pos (14UL) /*!< Position of CH4LIMITH field. */
N#define SAADC_INTEN_CH4LIMITH_Msk (0x1UL << SAADC_INTEN_CH4LIMITH_Pos) /*!< Bit mask of CH4LIMITH field. */
N#define SAADC_INTEN_CH4LIMITH_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH4LIMITH_Enabled (1UL) /*!< Enable */
N
N/* Bit 13 : Enable or disable interrupt for CH[3].LIMITL event */
N#define SAADC_INTEN_CH3LIMITL_Pos (13UL) /*!< Position of CH3LIMITL field. */
N#define SAADC_INTEN_CH3LIMITL_Msk (0x1UL << SAADC_INTEN_CH3LIMITL_Pos) /*!< Bit mask of CH3LIMITL field. */
N#define SAADC_INTEN_CH3LIMITL_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH3LIMITL_Enabled (1UL) /*!< Enable */
N
N/* Bit 12 : Enable or disable interrupt for CH[3].LIMITH event */
N#define SAADC_INTEN_CH3LIMITH_Pos (12UL) /*!< Position of CH3LIMITH field. */
N#define SAADC_INTEN_CH3LIMITH_Msk (0x1UL << SAADC_INTEN_CH3LIMITH_Pos) /*!< Bit mask of CH3LIMITH field. */
N#define SAADC_INTEN_CH3LIMITH_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH3LIMITH_Enabled (1UL) /*!< Enable */
N
N/* Bit 11 : Enable or disable interrupt for CH[2].LIMITL event */
N#define SAADC_INTEN_CH2LIMITL_Pos (11UL) /*!< Position of CH2LIMITL field. */
N#define SAADC_INTEN_CH2LIMITL_Msk (0x1UL << SAADC_INTEN_CH2LIMITL_Pos) /*!< Bit mask of CH2LIMITL field. */
N#define SAADC_INTEN_CH2LIMITL_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH2LIMITL_Enabled (1UL) /*!< Enable */
N
N/* Bit 10 : Enable or disable interrupt for CH[2].LIMITH event */
N#define SAADC_INTEN_CH2LIMITH_Pos (10UL) /*!< Position of CH2LIMITH field. */
N#define SAADC_INTEN_CH2LIMITH_Msk (0x1UL << SAADC_INTEN_CH2LIMITH_Pos) /*!< Bit mask of CH2LIMITH field. */
N#define SAADC_INTEN_CH2LIMITH_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH2LIMITH_Enabled (1UL) /*!< Enable */
N
N/* Bit 9 : Enable or disable interrupt for CH[1].LIMITL event */
N#define SAADC_INTEN_CH1LIMITL_Pos (9UL) /*!< Position of CH1LIMITL field. */
N#define SAADC_INTEN_CH1LIMITL_Msk (0x1UL << SAADC_INTEN_CH1LIMITL_Pos) /*!< Bit mask of CH1LIMITL field. */
N#define SAADC_INTEN_CH1LIMITL_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH1LIMITL_Enabled (1UL) /*!< Enable */
N
N/* Bit 8 : Enable or disable interrupt for CH[1].LIMITH event */
N#define SAADC_INTEN_CH1LIMITH_Pos (8UL) /*!< Position of CH1LIMITH field. */
N#define SAADC_INTEN_CH1LIMITH_Msk (0x1UL << SAADC_INTEN_CH1LIMITH_Pos) /*!< Bit mask of CH1LIMITH field. */
N#define SAADC_INTEN_CH1LIMITH_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH1LIMITH_Enabled (1UL) /*!< Enable */
N
N/* Bit 7 : Enable or disable interrupt for CH[0].LIMITL event */
N#define SAADC_INTEN_CH0LIMITL_Pos (7UL) /*!< Position of CH0LIMITL field. */
N#define SAADC_INTEN_CH0LIMITL_Msk (0x1UL << SAADC_INTEN_CH0LIMITL_Pos) /*!< Bit mask of CH0LIMITL field. */
N#define SAADC_INTEN_CH0LIMITL_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH0LIMITL_Enabled (1UL) /*!< Enable */
N
N/* Bit 6 : Enable or disable interrupt for CH[0].LIMITH event */
N#define SAADC_INTEN_CH0LIMITH_Pos (6UL) /*!< Position of CH0LIMITH field. */
N#define SAADC_INTEN_CH0LIMITH_Msk (0x1UL << SAADC_INTEN_CH0LIMITH_Pos) /*!< Bit mask of CH0LIMITH field. */
N#define SAADC_INTEN_CH0LIMITH_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CH0LIMITH_Enabled (1UL) /*!< Enable */
N
N/* Bit 5 : Enable or disable interrupt for STOPPED event */
N#define SAADC_INTEN_STOPPED_Pos (5UL) /*!< Position of STOPPED field. */
N#define SAADC_INTEN_STOPPED_Msk (0x1UL << SAADC_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define SAADC_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
N
N/* Bit 4 : Enable or disable interrupt for CALIBRATEDONE event */
N#define SAADC_INTEN_CALIBRATEDONE_Pos (4UL) /*!< Position of CALIBRATEDONE field. */
N#define SAADC_INTEN_CALIBRATEDONE_Msk (0x1UL << SAADC_INTEN_CALIBRATEDONE_Pos) /*!< Bit mask of CALIBRATEDONE field. */
N#define SAADC_INTEN_CALIBRATEDONE_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_CALIBRATEDONE_Enabled (1UL) /*!< Enable */
N
N/* Bit 3 : Enable or disable interrupt for RESULTDONE event */
N#define SAADC_INTEN_RESULTDONE_Pos (3UL) /*!< Position of RESULTDONE field. */
N#define SAADC_INTEN_RESULTDONE_Msk (0x1UL << SAADC_INTEN_RESULTDONE_Pos) /*!< Bit mask of RESULTDONE field. */
N#define SAADC_INTEN_RESULTDONE_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_RESULTDONE_Enabled (1UL) /*!< Enable */
N
N/* Bit 2 : Enable or disable interrupt for DONE event */
N#define SAADC_INTEN_DONE_Pos (2UL) /*!< Position of DONE field. */
N#define SAADC_INTEN_DONE_Msk (0x1UL << SAADC_INTEN_DONE_Pos) /*!< Bit mask of DONE field. */
N#define SAADC_INTEN_DONE_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_DONE_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for END event */
N#define SAADC_INTEN_END_Pos (1UL) /*!< Position of END field. */
N#define SAADC_INTEN_END_Msk (0x1UL << SAADC_INTEN_END_Pos) /*!< Bit mask of END field. */
N#define SAADC_INTEN_END_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_END_Enabled (1UL) /*!< Enable */
N
N/* Bit 0 : Enable or disable interrupt for STARTED event */
N#define SAADC_INTEN_STARTED_Pos (0UL) /*!< Position of STARTED field. */
N#define SAADC_INTEN_STARTED_Msk (0x1UL << SAADC_INTEN_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define SAADC_INTEN_STARTED_Disabled (0UL) /*!< Disable */
N#define SAADC_INTEN_STARTED_Enabled (1UL) /*!< Enable */
N
N/* Register: SAADC_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 21 : Write '1' to Enable interrupt for CH[7].LIMITL event */
N#define SAADC_INTENSET_CH7LIMITL_Pos (21UL) /*!< Position of CH7LIMITL field. */
N#define SAADC_INTENSET_CH7LIMITL_Msk (0x1UL << SAADC_INTENSET_CH7LIMITL_Pos) /*!< Bit mask of CH7LIMITL field. */
N#define SAADC_INTENSET_CH7LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH7LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH7LIMITL_Set (1UL) /*!< Enable */
N
N/* Bit 20 : Write '1' to Enable interrupt for CH[7].LIMITH event */
N#define SAADC_INTENSET_CH7LIMITH_Pos (20UL) /*!< Position of CH7LIMITH field. */
N#define SAADC_INTENSET_CH7LIMITH_Msk (0x1UL << SAADC_INTENSET_CH7LIMITH_Pos) /*!< Bit mask of CH7LIMITH field. */
N#define SAADC_INTENSET_CH7LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH7LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH7LIMITH_Set (1UL) /*!< Enable */
N
N/* Bit 19 : Write '1' to Enable interrupt for CH[6].LIMITL event */
N#define SAADC_INTENSET_CH6LIMITL_Pos (19UL) /*!< Position of CH6LIMITL field. */
N#define SAADC_INTENSET_CH6LIMITL_Msk (0x1UL << SAADC_INTENSET_CH6LIMITL_Pos) /*!< Bit mask of CH6LIMITL field. */
N#define SAADC_INTENSET_CH6LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH6LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH6LIMITL_Set (1UL) /*!< Enable */
N
N/* Bit 18 : Write '1' to Enable interrupt for CH[6].LIMITH event */
N#define SAADC_INTENSET_CH6LIMITH_Pos (18UL) /*!< Position of CH6LIMITH field. */
N#define SAADC_INTENSET_CH6LIMITH_Msk (0x1UL << SAADC_INTENSET_CH6LIMITH_Pos) /*!< Bit mask of CH6LIMITH field. */
N#define SAADC_INTENSET_CH6LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH6LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH6LIMITH_Set (1UL) /*!< Enable */
N
N/* Bit 17 : Write '1' to Enable interrupt for CH[5].LIMITL event */
N#define SAADC_INTENSET_CH5LIMITL_Pos (17UL) /*!< Position of CH5LIMITL field. */
N#define SAADC_INTENSET_CH5LIMITL_Msk (0x1UL << SAADC_INTENSET_CH5LIMITL_Pos) /*!< Bit mask of CH5LIMITL field. */
N#define SAADC_INTENSET_CH5LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH5LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH5LIMITL_Set (1UL) /*!< Enable */
N
N/* Bit 16 : Write '1' to Enable interrupt for CH[5].LIMITH event */
N#define SAADC_INTENSET_CH5LIMITH_Pos (16UL) /*!< Position of CH5LIMITH field. */
N#define SAADC_INTENSET_CH5LIMITH_Msk (0x1UL << SAADC_INTENSET_CH5LIMITH_Pos) /*!< Bit mask of CH5LIMITH field. */
N#define SAADC_INTENSET_CH5LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH5LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH5LIMITH_Set (1UL) /*!< Enable */
N
N/* Bit 15 : Write '1' to Enable interrupt for CH[4].LIMITL event */
N#define SAADC_INTENSET_CH4LIMITL_Pos (15UL) /*!< Position of CH4LIMITL field. */
N#define SAADC_INTENSET_CH4LIMITL_Msk (0x1UL << SAADC_INTENSET_CH4LIMITL_Pos) /*!< Bit mask of CH4LIMITL field. */
N#define SAADC_INTENSET_CH4LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH4LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH4LIMITL_Set (1UL) /*!< Enable */
N
N/* Bit 14 : Write '1' to Enable interrupt for CH[4].LIMITH event */
N#define SAADC_INTENSET_CH4LIMITH_Pos (14UL) /*!< Position of CH4LIMITH field. */
N#define SAADC_INTENSET_CH4LIMITH_Msk (0x1UL << SAADC_INTENSET_CH4LIMITH_Pos) /*!< Bit mask of CH4LIMITH field. */
N#define SAADC_INTENSET_CH4LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH4LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH4LIMITH_Set (1UL) /*!< Enable */
N
N/* Bit 13 : Write '1' to Enable interrupt for CH[3].LIMITL event */
N#define SAADC_INTENSET_CH3LIMITL_Pos (13UL) /*!< Position of CH3LIMITL field. */
N#define SAADC_INTENSET_CH3LIMITL_Msk (0x1UL << SAADC_INTENSET_CH3LIMITL_Pos) /*!< Bit mask of CH3LIMITL field. */
N#define SAADC_INTENSET_CH3LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH3LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH3LIMITL_Set (1UL) /*!< Enable */
N
N/* Bit 12 : Write '1' to Enable interrupt for CH[3].LIMITH event */
N#define SAADC_INTENSET_CH3LIMITH_Pos (12UL) /*!< Position of CH3LIMITH field. */
N#define SAADC_INTENSET_CH3LIMITH_Msk (0x1UL << SAADC_INTENSET_CH3LIMITH_Pos) /*!< Bit mask of CH3LIMITH field. */
N#define SAADC_INTENSET_CH3LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH3LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH3LIMITH_Set (1UL) /*!< Enable */
N
N/* Bit 11 : Write '1' to Enable interrupt for CH[2].LIMITL event */
N#define SAADC_INTENSET_CH2LIMITL_Pos (11UL) /*!< Position of CH2LIMITL field. */
N#define SAADC_INTENSET_CH2LIMITL_Msk (0x1UL << SAADC_INTENSET_CH2LIMITL_Pos) /*!< Bit mask of CH2LIMITL field. */
N#define SAADC_INTENSET_CH2LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH2LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH2LIMITL_Set (1UL) /*!< Enable */
N
N/* Bit 10 : Write '1' to Enable interrupt for CH[2].LIMITH event */
N#define SAADC_INTENSET_CH2LIMITH_Pos (10UL) /*!< Position of CH2LIMITH field. */
N#define SAADC_INTENSET_CH2LIMITH_Msk (0x1UL << SAADC_INTENSET_CH2LIMITH_Pos) /*!< Bit mask of CH2LIMITH field. */
N#define SAADC_INTENSET_CH2LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH2LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH2LIMITH_Set (1UL) /*!< Enable */
N
N/* Bit 9 : Write '1' to Enable interrupt for CH[1].LIMITL event */
N#define SAADC_INTENSET_CH1LIMITL_Pos (9UL) /*!< Position of CH1LIMITL field. */
N#define SAADC_INTENSET_CH1LIMITL_Msk (0x1UL << SAADC_INTENSET_CH1LIMITL_Pos) /*!< Bit mask of CH1LIMITL field. */
N#define SAADC_INTENSET_CH1LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH1LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH1LIMITL_Set (1UL) /*!< Enable */
N
N/* Bit 8 : Write '1' to Enable interrupt for CH[1].LIMITH event */
N#define SAADC_INTENSET_CH1LIMITH_Pos (8UL) /*!< Position of CH1LIMITH field. */
N#define SAADC_INTENSET_CH1LIMITH_Msk (0x1UL << SAADC_INTENSET_CH1LIMITH_Pos) /*!< Bit mask of CH1LIMITH field. */
N#define SAADC_INTENSET_CH1LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH1LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH1LIMITH_Set (1UL) /*!< Enable */
N
N/* Bit 7 : Write '1' to Enable interrupt for CH[0].LIMITL event */
N#define SAADC_INTENSET_CH0LIMITL_Pos (7UL) /*!< Position of CH0LIMITL field. */
N#define SAADC_INTENSET_CH0LIMITL_Msk (0x1UL << SAADC_INTENSET_CH0LIMITL_Pos) /*!< Bit mask of CH0LIMITL field. */
N#define SAADC_INTENSET_CH0LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH0LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH0LIMITL_Set (1UL) /*!< Enable */
N
N/* Bit 6 : Write '1' to Enable interrupt for CH[0].LIMITH event */
N#define SAADC_INTENSET_CH0LIMITH_Pos (6UL) /*!< Position of CH0LIMITH field. */
N#define SAADC_INTENSET_CH0LIMITH_Msk (0x1UL << SAADC_INTENSET_CH0LIMITH_Pos) /*!< Bit mask of CH0LIMITH field. */
N#define SAADC_INTENSET_CH0LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CH0LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CH0LIMITH_Set (1UL) /*!< Enable */
N
N/* Bit 5 : Write '1' to Enable interrupt for STOPPED event */
N#define SAADC_INTENSET_STOPPED_Pos (5UL) /*!< Position of STOPPED field. */
N#define SAADC_INTENSET_STOPPED_Msk (0x1UL << SAADC_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define SAADC_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_STOPPED_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable interrupt for CALIBRATEDONE event */
N#define SAADC_INTENSET_CALIBRATEDONE_Pos (4UL) /*!< Position of CALIBRATEDONE field. */
N#define SAADC_INTENSET_CALIBRATEDONE_Msk (0x1UL << SAADC_INTENSET_CALIBRATEDONE_Pos) /*!< Bit mask of CALIBRATEDONE field. */
N#define SAADC_INTENSET_CALIBRATEDONE_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_CALIBRATEDONE_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_CALIBRATEDONE_Set (1UL) /*!< Enable */
N
N/* Bit 3 : Write '1' to Enable interrupt for RESULTDONE event */
N#define SAADC_INTENSET_RESULTDONE_Pos (3UL) /*!< Position of RESULTDONE field. */
N#define SAADC_INTENSET_RESULTDONE_Msk (0x1UL << SAADC_INTENSET_RESULTDONE_Pos) /*!< Bit mask of RESULTDONE field. */
N#define SAADC_INTENSET_RESULTDONE_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_RESULTDONE_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_RESULTDONE_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for DONE event */
N#define SAADC_INTENSET_DONE_Pos (2UL) /*!< Position of DONE field. */
N#define SAADC_INTENSET_DONE_Msk (0x1UL << SAADC_INTENSET_DONE_Pos) /*!< Bit mask of DONE field. */
N#define SAADC_INTENSET_DONE_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_DONE_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_DONE_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for END event */
N#define SAADC_INTENSET_END_Pos (1UL) /*!< Position of END field. */
N#define SAADC_INTENSET_END_Msk (0x1UL << SAADC_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define SAADC_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_END_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for STARTED event */
N#define SAADC_INTENSET_STARTED_Pos (0UL) /*!< Position of STARTED field. */
N#define SAADC_INTENSET_STARTED_Msk (0x1UL << SAADC_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define SAADC_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENSET_STARTED_Set (1UL) /*!< Enable */
N
N/* Register: SAADC_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 21 : Write '1' to Disable interrupt for CH[7].LIMITL event */
N#define SAADC_INTENCLR_CH7LIMITL_Pos (21UL) /*!< Position of CH7LIMITL field. */
N#define SAADC_INTENCLR_CH7LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH7LIMITL_Pos) /*!< Bit mask of CH7LIMITL field. */
N#define SAADC_INTENCLR_CH7LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH7LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH7LIMITL_Clear (1UL) /*!< Disable */
N
N/* Bit 20 : Write '1' to Disable interrupt for CH[7].LIMITH event */
N#define SAADC_INTENCLR_CH7LIMITH_Pos (20UL) /*!< Position of CH7LIMITH field. */
N#define SAADC_INTENCLR_CH7LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH7LIMITH_Pos) /*!< Bit mask of CH7LIMITH field. */
N#define SAADC_INTENCLR_CH7LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH7LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH7LIMITH_Clear (1UL) /*!< Disable */
N
N/* Bit 19 : Write '1' to Disable interrupt for CH[6].LIMITL event */
N#define SAADC_INTENCLR_CH6LIMITL_Pos (19UL) /*!< Position of CH6LIMITL field. */
N#define SAADC_INTENCLR_CH6LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH6LIMITL_Pos) /*!< Bit mask of CH6LIMITL field. */
N#define SAADC_INTENCLR_CH6LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH6LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH6LIMITL_Clear (1UL) /*!< Disable */
N
N/* Bit 18 : Write '1' to Disable interrupt for CH[6].LIMITH event */
N#define SAADC_INTENCLR_CH6LIMITH_Pos (18UL) /*!< Position of CH6LIMITH field. */
N#define SAADC_INTENCLR_CH6LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH6LIMITH_Pos) /*!< Bit mask of CH6LIMITH field. */
N#define SAADC_INTENCLR_CH6LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH6LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH6LIMITH_Clear (1UL) /*!< Disable */
N
N/* Bit 17 : Write '1' to Disable interrupt for CH[5].LIMITL event */
N#define SAADC_INTENCLR_CH5LIMITL_Pos (17UL) /*!< Position of CH5LIMITL field. */
N#define SAADC_INTENCLR_CH5LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH5LIMITL_Pos) /*!< Bit mask of CH5LIMITL field. */
N#define SAADC_INTENCLR_CH5LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH5LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH5LIMITL_Clear (1UL) /*!< Disable */
N
N/* Bit 16 : Write '1' to Disable interrupt for CH[5].LIMITH event */
N#define SAADC_INTENCLR_CH5LIMITH_Pos (16UL) /*!< Position of CH5LIMITH field. */
N#define SAADC_INTENCLR_CH5LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH5LIMITH_Pos) /*!< Bit mask of CH5LIMITH field. */
N#define SAADC_INTENCLR_CH5LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH5LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH5LIMITH_Clear (1UL) /*!< Disable */
N
N/* Bit 15 : Write '1' to Disable interrupt for CH[4].LIMITL event */
N#define SAADC_INTENCLR_CH4LIMITL_Pos (15UL) /*!< Position of CH4LIMITL field. */
N#define SAADC_INTENCLR_CH4LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH4LIMITL_Pos) /*!< Bit mask of CH4LIMITL field. */
N#define SAADC_INTENCLR_CH4LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH4LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH4LIMITL_Clear (1UL) /*!< Disable */
N
N/* Bit 14 : Write '1' to Disable interrupt for CH[4].LIMITH event */
N#define SAADC_INTENCLR_CH4LIMITH_Pos (14UL) /*!< Position of CH4LIMITH field. */
N#define SAADC_INTENCLR_CH4LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH4LIMITH_Pos) /*!< Bit mask of CH4LIMITH field. */
N#define SAADC_INTENCLR_CH4LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH4LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH4LIMITH_Clear (1UL) /*!< Disable */
N
N/* Bit 13 : Write '1' to Disable interrupt for CH[3].LIMITL event */
N#define SAADC_INTENCLR_CH3LIMITL_Pos (13UL) /*!< Position of CH3LIMITL field. */
N#define SAADC_INTENCLR_CH3LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH3LIMITL_Pos) /*!< Bit mask of CH3LIMITL field. */
N#define SAADC_INTENCLR_CH3LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH3LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH3LIMITL_Clear (1UL) /*!< Disable */
N
N/* Bit 12 : Write '1' to Disable interrupt for CH[3].LIMITH event */
N#define SAADC_INTENCLR_CH3LIMITH_Pos (12UL) /*!< Position of CH3LIMITH field. */
N#define SAADC_INTENCLR_CH3LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH3LIMITH_Pos) /*!< Bit mask of CH3LIMITH field. */
N#define SAADC_INTENCLR_CH3LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH3LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH3LIMITH_Clear (1UL) /*!< Disable */
N
N/* Bit 11 : Write '1' to Disable interrupt for CH[2].LIMITL event */
N#define SAADC_INTENCLR_CH2LIMITL_Pos (11UL) /*!< Position of CH2LIMITL field. */
N#define SAADC_INTENCLR_CH2LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH2LIMITL_Pos) /*!< Bit mask of CH2LIMITL field. */
N#define SAADC_INTENCLR_CH2LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH2LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH2LIMITL_Clear (1UL) /*!< Disable */
N
N/* Bit 10 : Write '1' to Disable interrupt for CH[2].LIMITH event */
N#define SAADC_INTENCLR_CH2LIMITH_Pos (10UL) /*!< Position of CH2LIMITH field. */
N#define SAADC_INTENCLR_CH2LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH2LIMITH_Pos) /*!< Bit mask of CH2LIMITH field. */
N#define SAADC_INTENCLR_CH2LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH2LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH2LIMITH_Clear (1UL) /*!< Disable */
N
N/* Bit 9 : Write '1' to Disable interrupt for CH[1].LIMITL event */
N#define SAADC_INTENCLR_CH1LIMITL_Pos (9UL) /*!< Position of CH1LIMITL field. */
N#define SAADC_INTENCLR_CH1LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH1LIMITL_Pos) /*!< Bit mask of CH1LIMITL field. */
N#define SAADC_INTENCLR_CH1LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH1LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH1LIMITL_Clear (1UL) /*!< Disable */
N
N/* Bit 8 : Write '1' to Disable interrupt for CH[1].LIMITH event */
N#define SAADC_INTENCLR_CH1LIMITH_Pos (8UL) /*!< Position of CH1LIMITH field. */
N#define SAADC_INTENCLR_CH1LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH1LIMITH_Pos) /*!< Bit mask of CH1LIMITH field. */
N#define SAADC_INTENCLR_CH1LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH1LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH1LIMITH_Clear (1UL) /*!< Disable */
N
N/* Bit 7 : Write '1' to Disable interrupt for CH[0].LIMITL event */
N#define SAADC_INTENCLR_CH0LIMITL_Pos (7UL) /*!< Position of CH0LIMITL field. */
N#define SAADC_INTENCLR_CH0LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH0LIMITL_Pos) /*!< Bit mask of CH0LIMITL field. */
N#define SAADC_INTENCLR_CH0LIMITL_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH0LIMITL_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH0LIMITL_Clear (1UL) /*!< Disable */
N
N/* Bit 6 : Write '1' to Disable interrupt for CH[0].LIMITH event */
N#define SAADC_INTENCLR_CH0LIMITH_Pos (6UL) /*!< Position of CH0LIMITH field. */
N#define SAADC_INTENCLR_CH0LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH0LIMITH_Pos) /*!< Bit mask of CH0LIMITH field. */
N#define SAADC_INTENCLR_CH0LIMITH_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CH0LIMITH_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CH0LIMITH_Clear (1UL) /*!< Disable */
N
N/* Bit 5 : Write '1' to Disable interrupt for STOPPED event */
N#define SAADC_INTENCLR_STOPPED_Pos (5UL) /*!< Position of STOPPED field. */
N#define SAADC_INTENCLR_STOPPED_Msk (0x1UL << SAADC_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define SAADC_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable interrupt for CALIBRATEDONE event */
N#define SAADC_INTENCLR_CALIBRATEDONE_Pos (4UL) /*!< Position of CALIBRATEDONE field. */
N#define SAADC_INTENCLR_CALIBRATEDONE_Msk (0x1UL << SAADC_INTENCLR_CALIBRATEDONE_Pos) /*!< Bit mask of CALIBRATEDONE field. */
N#define SAADC_INTENCLR_CALIBRATEDONE_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_CALIBRATEDONE_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_CALIBRATEDONE_Clear (1UL) /*!< Disable */
N
N/* Bit 3 : Write '1' to Disable interrupt for RESULTDONE event */
N#define SAADC_INTENCLR_RESULTDONE_Pos (3UL) /*!< Position of RESULTDONE field. */
N#define SAADC_INTENCLR_RESULTDONE_Msk (0x1UL << SAADC_INTENCLR_RESULTDONE_Pos) /*!< Bit mask of RESULTDONE field. */
N#define SAADC_INTENCLR_RESULTDONE_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_RESULTDONE_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_RESULTDONE_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for DONE event */
N#define SAADC_INTENCLR_DONE_Pos (2UL) /*!< Position of DONE field. */
N#define SAADC_INTENCLR_DONE_Msk (0x1UL << SAADC_INTENCLR_DONE_Pos) /*!< Bit mask of DONE field. */
N#define SAADC_INTENCLR_DONE_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_DONE_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_DONE_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for END event */
N#define SAADC_INTENCLR_END_Pos (1UL) /*!< Position of END field. */
N#define SAADC_INTENCLR_END_Msk (0x1UL << SAADC_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define SAADC_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_END_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for STARTED event */
N#define SAADC_INTENCLR_STARTED_Pos (0UL) /*!< Position of STARTED field. */
N#define SAADC_INTENCLR_STARTED_Msk (0x1UL << SAADC_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define SAADC_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
N#define SAADC_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
N#define SAADC_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
N
N/* Register: SAADC_STATUS */
N/* Description: Status */
N
N/* Bit 0 : Status */
N#define SAADC_STATUS_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define SAADC_STATUS_STATUS_Msk (0x1UL << SAADC_STATUS_STATUS_Pos) /*!< Bit mask of STATUS field. */
N#define SAADC_STATUS_STATUS_Ready (0UL) /*!< ADC is ready. No on-going conversion. */
N#define SAADC_STATUS_STATUS_Busy (1UL) /*!< ADC is busy. Conversion in progress. */
N
N/* Register: SAADC_ENABLE */
N/* Description: Enable or disable ADC */
N
N/* Bit 0 : Enable or disable ADC */
N#define SAADC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SAADC_ENABLE_ENABLE_Msk (0x1UL << SAADC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SAADC_ENABLE_ENABLE_Disabled (0UL) /*!< Disable ADC */
N#define SAADC_ENABLE_ENABLE_Enabled (1UL) /*!< Enable ADC */
N
N/* Register: SAADC_CH_PSELP */
N/* Description: Description cluster[0]:  Input positive pin selection for CH[0] */
N
N/* Bits 4..0 : Analog positive input channel */
N#define SAADC_CH_PSELP_PSELP_Pos (0UL) /*!< Position of PSELP field. */
N#define SAADC_CH_PSELP_PSELP_Msk (0x1FUL << SAADC_CH_PSELP_PSELP_Pos) /*!< Bit mask of PSELP field. */
N#define SAADC_CH_PSELP_PSELP_NC (0UL) /*!< Not connected */
N#define SAADC_CH_PSELP_PSELP_AnalogInput0 (1UL) /*!< AIN0 */
N#define SAADC_CH_PSELP_PSELP_AnalogInput1 (2UL) /*!< AIN1 */
N#define SAADC_CH_PSELP_PSELP_AnalogInput2 (3UL) /*!< AIN2 */
N#define SAADC_CH_PSELP_PSELP_AnalogInput3 (4UL) /*!< AIN3 */
N#define SAADC_CH_PSELP_PSELP_AnalogInput4 (5UL) /*!< AIN4 */
N#define SAADC_CH_PSELP_PSELP_AnalogInput5 (6UL) /*!< AIN5 */
N#define SAADC_CH_PSELP_PSELP_AnalogInput6 (7UL) /*!< AIN6 */
N#define SAADC_CH_PSELP_PSELP_AnalogInput7 (8UL) /*!< AIN7 */
N#define SAADC_CH_PSELP_PSELP_VDD (9UL) /*!< VDD */
N
N/* Register: SAADC_CH_PSELN */
N/* Description: Description cluster[0]:  Input negative pin selection for CH[0] */
N
N/* Bits 4..0 : Analog negative input, enables differential channel */
N#define SAADC_CH_PSELN_PSELN_Pos (0UL) /*!< Position of PSELN field. */
N#define SAADC_CH_PSELN_PSELN_Msk (0x1FUL << SAADC_CH_PSELN_PSELN_Pos) /*!< Bit mask of PSELN field. */
N#define SAADC_CH_PSELN_PSELN_NC (0UL) /*!< Not connected */
N#define SAADC_CH_PSELN_PSELN_AnalogInput0 (1UL) /*!< AIN0 */
N#define SAADC_CH_PSELN_PSELN_AnalogInput1 (2UL) /*!< AIN1 */
N#define SAADC_CH_PSELN_PSELN_AnalogInput2 (3UL) /*!< AIN2 */
N#define SAADC_CH_PSELN_PSELN_AnalogInput3 (4UL) /*!< AIN3 */
N#define SAADC_CH_PSELN_PSELN_AnalogInput4 (5UL) /*!< AIN4 */
N#define SAADC_CH_PSELN_PSELN_AnalogInput5 (6UL) /*!< AIN5 */
N#define SAADC_CH_PSELN_PSELN_AnalogInput6 (7UL) /*!< AIN6 */
N#define SAADC_CH_PSELN_PSELN_AnalogInput7 (8UL) /*!< AIN7 */
N#define SAADC_CH_PSELN_PSELN_VDD (9UL) /*!< VDD */
N
N/* Register: SAADC_CH_CONFIG */
N/* Description: Description cluster[0]:  Input configuration for CH[0] */
N
N/* Bit 24 : Enable burst mode */
N#define SAADC_CH_CONFIG_BURST_Pos (24UL) /*!< Position of BURST field. */
N#define SAADC_CH_CONFIG_BURST_Msk (0x1UL << SAADC_CH_CONFIG_BURST_Pos) /*!< Bit mask of BURST field. */
N#define SAADC_CH_CONFIG_BURST_Disabled (0UL) /*!< Burst mode is disabled (normal operation) */
N#define SAADC_CH_CONFIG_BURST_Enabled (1UL) /*!< Burst mode is enabled. SAADC takes 2^OVERSAMPLE number of samples as fast as it can, and sends the average to Data RAM. */
N
N/* Bit 20 : Enable differential mode */
N#define SAADC_CH_CONFIG_MODE_Pos (20UL) /*!< Position of MODE field. */
N#define SAADC_CH_CONFIG_MODE_Msk (0x1UL << SAADC_CH_CONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
N#define SAADC_CH_CONFIG_MODE_SE (0UL) /*!< Single ended, PSELN will be ignored, negative input to ADC shorted to GND */
N#define SAADC_CH_CONFIG_MODE_Diff (1UL) /*!< Differential */
N
N/* Bits 18..16 : Acquisition time, the time the ADC uses to sample the input voltage */
N#define SAADC_CH_CONFIG_TACQ_Pos (16UL) /*!< Position of TACQ field. */
N#define SAADC_CH_CONFIG_TACQ_Msk (0x7UL << SAADC_CH_CONFIG_TACQ_Pos) /*!< Bit mask of TACQ field. */
N#define SAADC_CH_CONFIG_TACQ_3us (0UL) /*!< 3 us */
N#define SAADC_CH_CONFIG_TACQ_5us (1UL) /*!< 5 us */
N#define SAADC_CH_CONFIG_TACQ_10us (2UL) /*!< 10 us */
N#define SAADC_CH_CONFIG_TACQ_15us (3UL) /*!< 15 us */
N#define SAADC_CH_CONFIG_TACQ_20us (4UL) /*!< 20 us */
N#define SAADC_CH_CONFIG_TACQ_40us (5UL) /*!< 40 us */
N
N/* Bit 12 : Reference control */
N#define SAADC_CH_CONFIG_REFSEL_Pos (12UL) /*!< Position of REFSEL field. */
N#define SAADC_CH_CONFIG_REFSEL_Msk (0x1UL << SAADC_CH_CONFIG_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define SAADC_CH_CONFIG_REFSEL_Internal (0UL) /*!< Internal reference (0.6 V) */
N#define SAADC_CH_CONFIG_REFSEL_VDD1_4 (1UL) /*!< VDD/4 as reference */
N
N/* Bits 10..8 : Gain control */
N#define SAADC_CH_CONFIG_GAIN_Pos (8UL) /*!< Position of GAIN field. */
N#define SAADC_CH_CONFIG_GAIN_Msk (0x7UL << SAADC_CH_CONFIG_GAIN_Pos) /*!< Bit mask of GAIN field. */
N#define SAADC_CH_CONFIG_GAIN_Gain1_6 (0UL) /*!< 1/6 */
N#define SAADC_CH_CONFIG_GAIN_Gain1_5 (1UL) /*!< 1/5 */
N#define SAADC_CH_CONFIG_GAIN_Gain1_4 (2UL) /*!< 1/4 */
N#define SAADC_CH_CONFIG_GAIN_Gain1_3 (3UL) /*!< 1/3 */
N#define SAADC_CH_CONFIG_GAIN_Gain1_2 (4UL) /*!< 1/2 */
N#define SAADC_CH_CONFIG_GAIN_Gain1 (5UL) /*!< 1 */
N#define SAADC_CH_CONFIG_GAIN_Gain2 (6UL) /*!< 2 */
N#define SAADC_CH_CONFIG_GAIN_Gain4 (7UL) /*!< 4 */
N
N/* Bits 5..4 : Negative channel resistor control */
N#define SAADC_CH_CONFIG_RESN_Pos (4UL) /*!< Position of RESN field. */
N#define SAADC_CH_CONFIG_RESN_Msk (0x3UL << SAADC_CH_CONFIG_RESN_Pos) /*!< Bit mask of RESN field. */
N#define SAADC_CH_CONFIG_RESN_Bypass (0UL) /*!< Bypass resistor ladder */
N#define SAADC_CH_CONFIG_RESN_Pulldown (1UL) /*!< Pull-down to GND */
N#define SAADC_CH_CONFIG_RESN_Pullup (2UL) /*!< Pull-up to VDD */
N#define SAADC_CH_CONFIG_RESN_VDD1_2 (3UL) /*!< Set input at VDD/2 */
N
N/* Bits 1..0 : Positive channel resistor control */
N#define SAADC_CH_CONFIG_RESP_Pos (0UL) /*!< Position of RESP field. */
N#define SAADC_CH_CONFIG_RESP_Msk (0x3UL << SAADC_CH_CONFIG_RESP_Pos) /*!< Bit mask of RESP field. */
N#define SAADC_CH_CONFIG_RESP_Bypass (0UL) /*!< Bypass resistor ladder */
N#define SAADC_CH_CONFIG_RESP_Pulldown (1UL) /*!< Pull-down to GND */
N#define SAADC_CH_CONFIG_RESP_Pullup (2UL) /*!< Pull-up to VDD */
N#define SAADC_CH_CONFIG_RESP_VDD1_2 (3UL) /*!< Set input at VDD/2 */
N
N/* Register: SAADC_CH_LIMIT */
N/* Description: Description cluster[0]:  High/low limits for event monitoring a channel */
N
N/* Bits 31..16 : High level limit */
N#define SAADC_CH_LIMIT_HIGH_Pos (16UL) /*!< Position of HIGH field. */
N#define SAADC_CH_LIMIT_HIGH_Msk (0xFFFFUL << SAADC_CH_LIMIT_HIGH_Pos) /*!< Bit mask of HIGH field. */
N
N/* Bits 15..0 : Low level limit */
N#define SAADC_CH_LIMIT_LOW_Pos (0UL) /*!< Position of LOW field. */
N#define SAADC_CH_LIMIT_LOW_Msk (0xFFFFUL << SAADC_CH_LIMIT_LOW_Pos) /*!< Bit mask of LOW field. */
N
N/* Register: SAADC_RESOLUTION */
N/* Description: Resolution configuration */
N
N/* Bits 2..0 : Set the resolution */
N#define SAADC_RESOLUTION_VAL_Pos (0UL) /*!< Position of VAL field. */
N#define SAADC_RESOLUTION_VAL_Msk (0x7UL << SAADC_RESOLUTION_VAL_Pos) /*!< Bit mask of VAL field. */
N#define SAADC_RESOLUTION_VAL_8bit (0UL) /*!< 8 bit */
N#define SAADC_RESOLUTION_VAL_10bit (1UL) /*!< 10 bit */
N#define SAADC_RESOLUTION_VAL_12bit (2UL) /*!< 12 bit */
N#define SAADC_RESOLUTION_VAL_14bit (3UL) /*!< 14 bit */
N
N/* Register: SAADC_OVERSAMPLE */
N/* Description: Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used. */
N
N/* Bits 3..0 : Oversample control */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Pos (0UL) /*!< Position of OVERSAMPLE field. */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Msk (0xFUL << SAADC_OVERSAMPLE_OVERSAMPLE_Pos) /*!< Bit mask of OVERSAMPLE field. */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Bypass (0UL) /*!< Bypass oversampling */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Over2x (1UL) /*!< Oversample 2x */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Over4x (2UL) /*!< Oversample 4x */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Over8x (3UL) /*!< Oversample 8x */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Over16x (4UL) /*!< Oversample 16x */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Over32x (5UL) /*!< Oversample 32x */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Over64x (6UL) /*!< Oversample 64x */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Over128x (7UL) /*!< Oversample 128x */
N#define SAADC_OVERSAMPLE_OVERSAMPLE_Over256x (8UL) /*!< Oversample 256x */
N
N/* Register: SAADC_SAMPLERATE */
N/* Description: Controls normal or continuous sample rate */
N
N/* Bit 12 : Select mode for sample rate control */
N#define SAADC_SAMPLERATE_MODE_Pos (12UL) /*!< Position of MODE field. */
N#define SAADC_SAMPLERATE_MODE_Msk (0x1UL << SAADC_SAMPLERATE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define SAADC_SAMPLERATE_MODE_Task (0UL) /*!< Rate is controlled from SAMPLE task */
N#define SAADC_SAMPLERATE_MODE_Timers (1UL) /*!< Rate is controlled from local timer (use CC to control the rate) */
N
N/* Bits 10..0 : Capture and compare value. Sample rate is 16 MHz/CC */
N#define SAADC_SAMPLERATE_CC_Pos (0UL) /*!< Position of CC field. */
N#define SAADC_SAMPLERATE_CC_Msk (0x7FFUL << SAADC_SAMPLERATE_CC_Pos) /*!< Bit mask of CC field. */
N
N/* Register: SAADC_RESULT_PTR */
N/* Description: Data pointer */
N
N/* Bits 31..0 : Data pointer */
N#define SAADC_RESULT_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define SAADC_RESULT_PTR_PTR_Msk (0xFFFFFFFFUL << SAADC_RESULT_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: SAADC_RESULT_MAXCNT */
N/* Description: Maximum number of buffer words to transfer */
N
N/* Bits 14..0 : Maximum number of buffer words to transfer */
N#define SAADC_RESULT_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define SAADC_RESULT_MAXCNT_MAXCNT_Msk (0x7FFFUL << SAADC_RESULT_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: SAADC_RESULT_AMOUNT */
N/* Description: Number of buffer words transferred since last START */
N
N/* Bits 14..0 : Number of buffer words transferred since last START. This register can be read after an END or STOPPED event. */
N#define SAADC_RESULT_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define SAADC_RESULT_AMOUNT_AMOUNT_Msk (0x7FFFUL << SAADC_RESULT_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N
N/* Peripheral: SPI */
N/* Description: Serial Peripheral Interface 0 */
N
N/* Register: SPI_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 2 : Write '1' to Enable interrupt for READY event */
N#define SPI_INTENSET_READY_Pos (2UL) /*!< Position of READY field. */
N#define SPI_INTENSET_READY_Msk (0x1UL << SPI_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define SPI_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
N#define SPI_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
N#define SPI_INTENSET_READY_Set (1UL) /*!< Enable */
N
N/* Register: SPI_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 2 : Write '1' to Disable interrupt for READY event */
N#define SPI_INTENCLR_READY_Pos (2UL) /*!< Position of READY field. */
N#define SPI_INTENCLR_READY_Msk (0x1UL << SPI_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define SPI_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
N#define SPI_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
N#define SPI_INTENCLR_READY_Clear (1UL) /*!< Disable */
N
N/* Register: SPI_ENABLE */
N/* Description: Enable SPI */
N
N/* Bits 3..0 : Enable or disable SPI */
N#define SPI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPI_ENABLE_ENABLE_Msk (0xFUL << SPI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPI_ENABLE_ENABLE_Disabled (0UL) /*!< Disable SPI */
N#define SPI_ENABLE_ENABLE_Enabled (1UL) /*!< Enable SPI */
N
N/* Register: SPI_PSEL_SCK */
N/* Description: Pin select for SCK */
N
N/* Bits 31..0 : Pin number configuration for SPI SCK signal */
N#define SPI_PSEL_SCK_PSELSCK_Pos (0UL) /*!< Position of PSELSCK field. */
N#define SPI_PSEL_SCK_PSELSCK_Msk (0xFFFFFFFFUL << SPI_PSEL_SCK_PSELSCK_Pos) /*!< Bit mask of PSELSCK field. */
N#define SPI_PSEL_SCK_PSELSCK_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
N
N/* Register: SPI_PSEL_MOSI */
N/* Description: Pin select for MOSI */
N
N/* Bits 31..0 : Pin number configuration for SPI MOSI signal */
N#define SPI_PSEL_MOSI_PSELMOSI_Pos (0UL) /*!< Position of PSELMOSI field. */
N#define SPI_PSEL_MOSI_PSELMOSI_Msk (0xFFFFFFFFUL << SPI_PSEL_MOSI_PSELMOSI_Pos) /*!< Bit mask of PSELMOSI field. */
N#define SPI_PSEL_MOSI_PSELMOSI_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
N
N/* Register: SPI_PSEL_MISO */
N/* Description: Pin select for MISO */
N
N/* Bits 31..0 : Pin number configuration for SPI MISO signal */
N#define SPI_PSEL_MISO_PSELMISO_Pos (0UL) /*!< Position of PSELMISO field. */
N#define SPI_PSEL_MISO_PSELMISO_Msk (0xFFFFFFFFUL << SPI_PSEL_MISO_PSELMISO_Pos) /*!< Bit mask of PSELMISO field. */
N#define SPI_PSEL_MISO_PSELMISO_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
N
N/* Register: SPI_RXD */
N/* Description: RXD register */
N
N/* Bits 7..0 : RX data received. Double buffered */
N#define SPI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define SPI_RXD_RXD_Msk (0xFFUL << SPI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: SPI_TXD */
N/* Description: TXD register */
N
N/* Bits 7..0 : TX data to send. Double buffered */
N#define SPI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define SPI_TXD_TXD_Msk (0xFFUL << SPI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: SPI_FREQUENCY */
N/* Description: SPI frequency */
N
N/* Bits 31..0 : SPI master data rate */
N#define SPI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define SPI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << SPI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define SPI_FREQUENCY_FREQUENCY_K125 (0x02000000UL) /*!< 125 kbps */
N#define SPI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
N#define SPI_FREQUENCY_FREQUENCY_K500 (0x08000000UL) /*!< 500 kbps */
N#define SPI_FREQUENCY_FREQUENCY_M1 (0x10000000UL) /*!< 1 Mbps */
N#define SPI_FREQUENCY_FREQUENCY_M2 (0x20000000UL) /*!< 2 Mbps */
N#define SPI_FREQUENCY_FREQUENCY_M4 (0x40000000UL) /*!< 4 Mbps */
N#define SPI_FREQUENCY_FREQUENCY_M8 (0x80000000UL) /*!< 8 Mbps */
N
N/* Register: SPI_CONFIG */
N/* Description: Configuration register */
N
N/* Bit 2 : Serial clock (SCK) polarity */
N#define SPI_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPI_CONFIG_CPOL_Msk (0x1UL << SPI_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPI_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high */
N#define SPI_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low */
N
N/* Bit 1 : Serial clock (SCK) phase */
N#define SPI_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPI_CONFIG_CPHA_Msk (0x1UL << SPI_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPI_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of clock, shift serial data on trailing edge */
N#define SPI_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of clock, shift serial data on leading edge */
N
N/* Bit 0 : Bit order */
N#define SPI_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPI_CONFIG_ORDER_Msk (0x1UL << SPI_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPI_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit shifted out first */
N#define SPI_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit shifted out first */
N
N
N/* Peripheral: SPIM */
N/* Description: Serial Peripheral Interface Master with EasyDMA 0 */
N
N/* Register: SPIM_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 17 : Shortcut between END event and START task */
N#define SPIM_SHORTS_END_START_Pos (17UL) /*!< Position of END_START field. */
N#define SPIM_SHORTS_END_START_Msk (0x1UL << SPIM_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
N#define SPIM_SHORTS_END_START_Disabled (0UL) /*!< Disable shortcut */
N#define SPIM_SHORTS_END_START_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: SPIM_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 19 : Write '1' to Enable interrupt for STARTED event */
N#define SPIM_INTENSET_STARTED_Pos (19UL) /*!< Position of STARTED field. */
N#define SPIM_INTENSET_STARTED_Msk (0x1UL << SPIM_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define SPIM_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
N#define SPIM_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
N#define SPIM_INTENSET_STARTED_Set (1UL) /*!< Enable */
N
N/* Bit 8 : Write '1' to Enable interrupt for ENDTX event */
N#define SPIM_INTENSET_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
N#define SPIM_INTENSET_ENDTX_Msk (0x1UL << SPIM_INTENSET_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
N#define SPIM_INTENSET_ENDTX_Disabled (0UL) /*!< Read: Disabled */
N#define SPIM_INTENSET_ENDTX_Enabled (1UL) /*!< Read: Enabled */
N#define SPIM_INTENSET_ENDTX_Set (1UL) /*!< Enable */
N
N/* Bit 6 : Write '1' to Enable interrupt for END event */
N#define SPIM_INTENSET_END_Pos (6UL) /*!< Position of END field. */
N#define SPIM_INTENSET_END_Msk (0x1UL << SPIM_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define SPIM_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
N#define SPIM_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
N#define SPIM_INTENSET_END_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable interrupt for ENDRX event */
N#define SPIM_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define SPIM_INTENSET_ENDRX_Msk (0x1UL << SPIM_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define SPIM_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
N#define SPIM_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
N#define SPIM_INTENSET_ENDRX_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
N#define SPIM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define SPIM_INTENSET_STOPPED_Msk (0x1UL << SPIM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define SPIM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define SPIM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define SPIM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
N
N/* Register: SPIM_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 19 : Write '1' to Disable interrupt for STARTED event */
N#define SPIM_INTENCLR_STARTED_Pos (19UL) /*!< Position of STARTED field. */
N#define SPIM_INTENCLR_STARTED_Msk (0x1UL << SPIM_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
N#define SPIM_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
N#define SPIM_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
N#define SPIM_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
N
N/* Bit 8 : Write '1' to Disable interrupt for ENDTX event */
N#define SPIM_INTENCLR_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
N#define SPIM_INTENCLR_ENDTX_Msk (0x1UL << SPIM_INTENCLR_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
N#define SPIM_INTENCLR_ENDTX_Disabled (0UL) /*!< Read: Disabled */
N#define SPIM_INTENCLR_ENDTX_Enabled (1UL) /*!< Read: Enabled */
N#define SPIM_INTENCLR_ENDTX_Clear (1UL) /*!< Disable */
N
N/* Bit 6 : Write '1' to Disable interrupt for END event */
N#define SPIM_INTENCLR_END_Pos (6UL) /*!< Position of END field. */
N#define SPIM_INTENCLR_END_Msk (0x1UL << SPIM_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define SPIM_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
N#define SPIM_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
N#define SPIM_INTENCLR_END_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable interrupt for ENDRX event */
N#define SPIM_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define SPIM_INTENCLR_ENDRX_Msk (0x1UL << SPIM_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define SPIM_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
N#define SPIM_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
N#define SPIM_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
N#define SPIM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define SPIM_INTENCLR_STOPPED_Msk (0x1UL << SPIM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define SPIM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define SPIM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define SPIM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
N
N/* Register: SPIM_ENABLE */
N/* Description: Enable SPIM */
N
N/* Bits 3..0 : Enable or disable SPIM */
N#define SPIM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPIM_ENABLE_ENABLE_Msk (0xFUL << SPIM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPIM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable SPIM */
N#define SPIM_ENABLE_ENABLE_Enabled (7UL) /*!< Enable SPIM */
N
N/* Register: SPIM_PSEL_SCK */
N/* Description: Pin select for SCK */
N
N/* Bit 31 : Connection */
N#define SPIM_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define SPIM_PSEL_SCK_CONNECT_Msk (0x1UL << SPIM_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define SPIM_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
N#define SPIM_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define SPIM_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define SPIM_PSEL_SCK_PIN_Msk (0x1FUL << SPIM_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: SPIM_PSEL_MOSI */
N/* Description: Pin select for MOSI signal */
N
N/* Bit 31 : Connection */
N#define SPIM_PSEL_MOSI_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define SPIM_PSEL_MOSI_CONNECT_Msk (0x1UL << SPIM_PSEL_MOSI_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define SPIM_PSEL_MOSI_CONNECT_Connected (0UL) /*!< Connect */
N#define SPIM_PSEL_MOSI_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define SPIM_PSEL_MOSI_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define SPIM_PSEL_MOSI_PIN_Msk (0x1FUL << SPIM_PSEL_MOSI_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: SPIM_PSEL_MISO */
N/* Description: Pin select for MISO signal */
N
N/* Bit 31 : Connection */
N#define SPIM_PSEL_MISO_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define SPIM_PSEL_MISO_CONNECT_Msk (0x1UL << SPIM_PSEL_MISO_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define SPIM_PSEL_MISO_CONNECT_Connected (0UL) /*!< Connect */
N#define SPIM_PSEL_MISO_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define SPIM_PSEL_MISO_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define SPIM_PSEL_MISO_PIN_Msk (0x1FUL << SPIM_PSEL_MISO_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: SPIM_FREQUENCY */
N/* Description: SPI frequency */
N
N/* Bits 31..0 : SPI master data rate */
N#define SPIM_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define SPIM_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << SPIM_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define SPIM_FREQUENCY_FREQUENCY_K125 (0x02000000UL) /*!< 125 kbps */
N#define SPIM_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
N#define SPIM_FREQUENCY_FREQUENCY_K500 (0x08000000UL) /*!< 500 kbps */
N#define SPIM_FREQUENCY_FREQUENCY_M1 (0x10000000UL) /*!< 1 Mbps */
N#define SPIM_FREQUENCY_FREQUENCY_M2 (0x20000000UL) /*!< 2 Mbps */
N#define SPIM_FREQUENCY_FREQUENCY_M4 (0x40000000UL) /*!< 4 Mbps */
N#define SPIM_FREQUENCY_FREQUENCY_M8 (0x80000000UL) /*!< 8 Mbps */
N
N/* Register: SPIM_RXD_PTR */
N/* Description: Data pointer */
N
N/* Bits 31..0 : Data pointer */
N#define SPIM_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define SPIM_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIM_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: SPIM_RXD_MAXCNT */
N/* Description: Maximum number of bytes in receive buffer */
N
N/* Bits 7..0 : Maximum number of bytes in receive buffer */
N#define SPIM_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define SPIM_RXD_MAXCNT_MAXCNT_Msk (0xFFUL << SPIM_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: SPIM_RXD_AMOUNT */
N/* Description: Number of bytes transferred in the last transaction */
N
N/* Bits 7..0 : Number of bytes transferred in the last transaction */
N#define SPIM_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define SPIM_RXD_AMOUNT_AMOUNT_Msk (0xFFUL << SPIM_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N/* Register: SPIM_RXD_LIST */
N/* Description: EasyDMA list type */
N
N/* Bits 2..0 : List type */
N#define SPIM_RXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
N#define SPIM_RXD_LIST_LIST_Msk (0x7UL << SPIM_RXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
N#define SPIM_RXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
N#define SPIM_RXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
N
N/* Register: SPIM_TXD_PTR */
N/* Description: Data pointer */
N
N/* Bits 31..0 : Data pointer */
N#define SPIM_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define SPIM_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIM_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: SPIM_TXD_MAXCNT */
N/* Description: Maximum number of bytes in transmit buffer */
N
N/* Bits 7..0 : Maximum number of bytes in transmit buffer */
N#define SPIM_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define SPIM_TXD_MAXCNT_MAXCNT_Msk (0xFFUL << SPIM_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: SPIM_TXD_AMOUNT */
N/* Description: Number of bytes transferred in the last transaction */
N
N/* Bits 7..0 : Number of bytes transferred in the last transaction */
N#define SPIM_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define SPIM_TXD_AMOUNT_AMOUNT_Msk (0xFFUL << SPIM_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N/* Register: SPIM_TXD_LIST */
N/* Description: EasyDMA list type */
N
N/* Bits 2..0 : List type */
N#define SPIM_TXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
N#define SPIM_TXD_LIST_LIST_Msk (0x7UL << SPIM_TXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
N#define SPIM_TXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
N#define SPIM_TXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
N
N/* Register: SPIM_CONFIG */
N/* Description: Configuration register */
N
N/* Bit 2 : Serial clock (SCK) polarity */
N#define SPIM_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPIM_CONFIG_CPOL_Msk (0x1UL << SPIM_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPIM_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high */
N#define SPIM_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low */
N
N/* Bit 1 : Serial clock (SCK) phase */
N#define SPIM_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPIM_CONFIG_CPHA_Msk (0x1UL << SPIM_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPIM_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of clock, shift serial data on trailing edge */
N#define SPIM_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of clock, shift serial data on leading edge */
N
N/* Bit 0 : Bit order */
N#define SPIM_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPIM_CONFIG_ORDER_Msk (0x1UL << SPIM_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPIM_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit shifted out first */
N#define SPIM_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit shifted out first */
N
N/* Register: SPIM_ORC */
N/* Description: Over-read character. Character clocked out in case and over-read of the TXD buffer. */
N
N/* Bits 7..0 : Over-read character. Character clocked out in case and over-read of the TXD buffer. */
N#define SPIM_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
N#define SPIM_ORC_ORC_Msk (0xFFUL << SPIM_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
N
N
N/* Peripheral: SPIS */
N/* Description: SPI Slave 0 */
N
N/* Register: SPIS_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 2 : Shortcut between END event and ACQUIRE task */
N#define SPIS_SHORTS_END_ACQUIRE_Pos (2UL) /*!< Position of END_ACQUIRE field. */
N#define SPIS_SHORTS_END_ACQUIRE_Msk (0x1UL << SPIS_SHORTS_END_ACQUIRE_Pos) /*!< Bit mask of END_ACQUIRE field. */
N#define SPIS_SHORTS_END_ACQUIRE_Disabled (0UL) /*!< Disable shortcut */
N#define SPIS_SHORTS_END_ACQUIRE_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: SPIS_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 10 : Write '1' to Enable interrupt for ACQUIRED event */
N#define SPIS_INTENSET_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
N#define SPIS_INTENSET_ACQUIRED_Msk (0x1UL << SPIS_INTENSET_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
N#define SPIS_INTENSET_ACQUIRED_Disabled (0UL) /*!< Read: Disabled */
N#define SPIS_INTENSET_ACQUIRED_Enabled (1UL) /*!< Read: Enabled */
N#define SPIS_INTENSET_ACQUIRED_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable interrupt for ENDRX event */
N#define SPIS_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define SPIS_INTENSET_ENDRX_Msk (0x1UL << SPIS_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define SPIS_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
N#define SPIS_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
N#define SPIS_INTENSET_ENDRX_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for END event */
N#define SPIS_INTENSET_END_Pos (1UL) /*!< Position of END field. */
N#define SPIS_INTENSET_END_Msk (0x1UL << SPIS_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define SPIS_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
N#define SPIS_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
N#define SPIS_INTENSET_END_Set (1UL) /*!< Enable */
N
N/* Register: SPIS_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 10 : Write '1' to Disable interrupt for ACQUIRED event */
N#define SPIS_INTENCLR_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
N#define SPIS_INTENCLR_ACQUIRED_Msk (0x1UL << SPIS_INTENCLR_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
N#define SPIS_INTENCLR_ACQUIRED_Disabled (0UL) /*!< Read: Disabled */
N#define SPIS_INTENCLR_ACQUIRED_Enabled (1UL) /*!< Read: Enabled */
N#define SPIS_INTENCLR_ACQUIRED_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable interrupt for ENDRX event */
N#define SPIS_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define SPIS_INTENCLR_ENDRX_Msk (0x1UL << SPIS_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define SPIS_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
N#define SPIS_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
N#define SPIS_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for END event */
N#define SPIS_INTENCLR_END_Pos (1UL) /*!< Position of END field. */
N#define SPIS_INTENCLR_END_Msk (0x1UL << SPIS_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define SPIS_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
N#define SPIS_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
N#define SPIS_INTENCLR_END_Clear (1UL) /*!< Disable */
N
N/* Register: SPIS_SEMSTAT */
N/* Description: Semaphore status register */
N
N/* Bits 1..0 : Semaphore status */
N#define SPIS_SEMSTAT_SEMSTAT_Pos (0UL) /*!< Position of SEMSTAT field. */
N#define SPIS_SEMSTAT_SEMSTAT_Msk (0x3UL << SPIS_SEMSTAT_SEMSTAT_Pos) /*!< Bit mask of SEMSTAT field. */
N#define SPIS_SEMSTAT_SEMSTAT_Free (0UL) /*!< Semaphore is free */
N#define SPIS_SEMSTAT_SEMSTAT_CPU (1UL) /*!< Semaphore is assigned to CPU */
N#define SPIS_SEMSTAT_SEMSTAT_SPIS (2UL) /*!< Semaphore is assigned to SPI slave */
N#define SPIS_SEMSTAT_SEMSTAT_CPUPending (3UL) /*!< Semaphore is assigned to SPI but a handover to the CPU is pending */
N
N/* Register: SPIS_STATUS */
N/* Description: Status from last transaction */
N
N/* Bit 1 : RX buffer overflow detected, and prevented */
N#define SPIS_STATUS_OVERFLOW_Pos (1UL) /*!< Position of OVERFLOW field. */
N#define SPIS_STATUS_OVERFLOW_Msk (0x1UL << SPIS_STATUS_OVERFLOW_Pos) /*!< Bit mask of OVERFLOW field. */
N#define SPIS_STATUS_OVERFLOW_NotPresent (0UL) /*!< Read: error not present */
N#define SPIS_STATUS_OVERFLOW_Present (1UL) /*!< Read: error present */
N#define SPIS_STATUS_OVERFLOW_Clear (1UL) /*!< Write: clear error on writing '1' */
N
N/* Bit 0 : TX buffer over-read detected, and prevented */
N#define SPIS_STATUS_OVERREAD_Pos (0UL) /*!< Position of OVERREAD field. */
N#define SPIS_STATUS_OVERREAD_Msk (0x1UL << SPIS_STATUS_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
N#define SPIS_STATUS_OVERREAD_NotPresent (0UL) /*!< Read: error not present */
N#define SPIS_STATUS_OVERREAD_Present (1UL) /*!< Read: error present */
N#define SPIS_STATUS_OVERREAD_Clear (1UL) /*!< Write: clear error on writing '1' */
N
N/* Register: SPIS_ENABLE */
N/* Description: Enable SPI slave */
N
N/* Bits 3..0 : Enable or disable SPI slave */
N#define SPIS_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPIS_ENABLE_ENABLE_Msk (0xFUL << SPIS_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPIS_ENABLE_ENABLE_Disabled (0UL) /*!< Disable SPI slave */
N#define SPIS_ENABLE_ENABLE_Enabled (2UL) /*!< Enable SPI slave */
N
N/* Register: SPIS_PSEL_SCK */
N/* Description: Pin select for SCK */
N
N/* Bit 31 : Connection */
N#define SPIS_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define SPIS_PSEL_SCK_CONNECT_Msk (0x1UL << SPIS_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define SPIS_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
N#define SPIS_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define SPIS_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define SPIS_PSEL_SCK_PIN_Msk (0x1FUL << SPIS_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: SPIS_PSEL_MISO */
N/* Description: Pin select for MISO signal */
N
N/* Bit 31 : Connection */
N#define SPIS_PSEL_MISO_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define SPIS_PSEL_MISO_CONNECT_Msk (0x1UL << SPIS_PSEL_MISO_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define SPIS_PSEL_MISO_CONNECT_Connected (0UL) /*!< Connect */
N#define SPIS_PSEL_MISO_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define SPIS_PSEL_MISO_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define SPIS_PSEL_MISO_PIN_Msk (0x1FUL << SPIS_PSEL_MISO_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: SPIS_PSEL_MOSI */
N/* Description: Pin select for MOSI signal */
N
N/* Bit 31 : Connection */
N#define SPIS_PSEL_MOSI_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define SPIS_PSEL_MOSI_CONNECT_Msk (0x1UL << SPIS_PSEL_MOSI_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define SPIS_PSEL_MOSI_CONNECT_Connected (0UL) /*!< Connect */
N#define SPIS_PSEL_MOSI_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define SPIS_PSEL_MOSI_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define SPIS_PSEL_MOSI_PIN_Msk (0x1FUL << SPIS_PSEL_MOSI_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: SPIS_PSEL_CSN */
N/* Description: Pin select for CSN signal */
N
N/* Bit 31 : Connection */
N#define SPIS_PSEL_CSN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define SPIS_PSEL_CSN_CONNECT_Msk (0x1UL << SPIS_PSEL_CSN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define SPIS_PSEL_CSN_CONNECT_Connected (0UL) /*!< Connect */
N#define SPIS_PSEL_CSN_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define SPIS_PSEL_CSN_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define SPIS_PSEL_CSN_PIN_Msk (0x1FUL << SPIS_PSEL_CSN_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: SPIS_RXD_PTR */
N/* Description: RXD data pointer */
N
N/* Bits 31..0 : RXD data pointer */
N#define SPIS_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define SPIS_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIS_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: SPIS_RXD_MAXCNT */
N/* Description: Maximum number of bytes in receive buffer */
N
N/* Bits 7..0 : Maximum number of bytes in receive buffer */
N#define SPIS_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define SPIS_RXD_MAXCNT_MAXCNT_Msk (0xFFUL << SPIS_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: SPIS_RXD_AMOUNT */
N/* Description: Number of bytes received in last granted transaction */
N
N/* Bits 7..0 : Number of bytes received in the last granted transaction */
N#define SPIS_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define SPIS_RXD_AMOUNT_AMOUNT_Msk (0xFFUL << SPIS_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N/* Register: SPIS_TXD_PTR */
N/* Description: TXD data pointer */
N
N/* Bits 31..0 : TXD data pointer */
N#define SPIS_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define SPIS_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIS_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: SPIS_TXD_MAXCNT */
N/* Description: Maximum number of bytes in transmit buffer */
N
N/* Bits 7..0 : Maximum number of bytes in transmit buffer */
N#define SPIS_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define SPIS_TXD_MAXCNT_MAXCNT_Msk (0xFFUL << SPIS_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: SPIS_TXD_AMOUNT */
N/* Description: Number of bytes transmitted in last granted transaction */
N
N/* Bits 7..0 : Number of bytes transmitted in last granted transaction */
N#define SPIS_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define SPIS_TXD_AMOUNT_AMOUNT_Msk (0xFFUL << SPIS_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N/* Register: SPIS_CONFIG */
N/* Description: Configuration register */
N
N/* Bit 2 : Serial clock (SCK) polarity */
N#define SPIS_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPIS_CONFIG_CPOL_Msk (0x1UL << SPIS_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPIS_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high */
N#define SPIS_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low */
N
N/* Bit 1 : Serial clock (SCK) phase */
N#define SPIS_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPIS_CONFIG_CPHA_Msk (0x1UL << SPIS_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPIS_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of clock, shift serial data on trailing edge */
N#define SPIS_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of clock, shift serial data on leading edge */
N
N/* Bit 0 : Bit order */
N#define SPIS_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPIS_CONFIG_ORDER_Msk (0x1UL << SPIS_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPIS_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit shifted out first */
N#define SPIS_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit shifted out first */
N
N/* Register: SPIS_DEF */
N/* Description: Default character. Character clocked out in case of an ignored transaction. */
N
N/* Bits 7..0 : Default character. Character clocked out in case of an ignored transaction. */
N#define SPIS_DEF_DEF_Pos (0UL) /*!< Position of DEF field. */
N#define SPIS_DEF_DEF_Msk (0xFFUL << SPIS_DEF_DEF_Pos) /*!< Bit mask of DEF field. */
N
N/* Register: SPIS_ORC */
N/* Description: Over-read character */
N
N/* Bits 7..0 : Over-read character. Character clocked out after an over-read of the transmit buffer. */
N#define SPIS_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
N#define SPIS_ORC_ORC_Msk (0xFFUL << SPIS_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
N
N
N/* Peripheral: TEMP */
N/* Description: Temperature Sensor */
N
N/* Register: TEMP_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 0 : Write '1' to Enable interrupt for DATARDY event */
N#define TEMP_INTENSET_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
N#define TEMP_INTENSET_DATARDY_Msk (0x1UL << TEMP_INTENSET_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
N#define TEMP_INTENSET_DATARDY_Disabled (0UL) /*!< Read: Disabled */
N#define TEMP_INTENSET_DATARDY_Enabled (1UL) /*!< Read: Enabled */
N#define TEMP_INTENSET_DATARDY_Set (1UL) /*!< Enable */
N
N/* Register: TEMP_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 0 : Write '1' to Disable interrupt for DATARDY event */
N#define TEMP_INTENCLR_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
N#define TEMP_INTENCLR_DATARDY_Msk (0x1UL << TEMP_INTENCLR_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
N#define TEMP_INTENCLR_DATARDY_Disabled (0UL) /*!< Read: Disabled */
N#define TEMP_INTENCLR_DATARDY_Enabled (1UL) /*!< Read: Enabled */
N#define TEMP_INTENCLR_DATARDY_Clear (1UL) /*!< Disable */
N
N/* Register: TEMP_TEMP */
N/* Description: Temperature in degC (0.25deg steps) */
N
N/* Bits 31..0 : Temperature in degC (0.25deg steps) */
N#define TEMP_TEMP_TEMP_Pos (0UL) /*!< Position of TEMP field. */
N#define TEMP_TEMP_TEMP_Msk (0xFFFFFFFFUL << TEMP_TEMP_TEMP_Pos) /*!< Bit mask of TEMP field. */
N
N/* Register: TEMP_A0 */
N/* Description: Slope of 1st piece wise linear function */
N
N/* Bits 11..0 : Slope of 1st piece wise linear function */
N#define TEMP_A0_A0_Pos (0UL) /*!< Position of A0 field. */
N#define TEMP_A0_A0_Msk (0xFFFUL << TEMP_A0_A0_Pos) /*!< Bit mask of A0 field. */
N
N/* Register: TEMP_A1 */
N/* Description: Slope of 2nd piece wise linear function */
N
N/* Bits 11..0 : Slope of 2nd piece wise linear function */
N#define TEMP_A1_A1_Pos (0UL) /*!< Position of A1 field. */
N#define TEMP_A1_A1_Msk (0xFFFUL << TEMP_A1_A1_Pos) /*!< Bit mask of A1 field. */
N
N/* Register: TEMP_A2 */
N/* Description: Slope of 3rd piece wise linear function */
N
N/* Bits 11..0 : Slope of 3rd piece wise linear function */
N#define TEMP_A2_A2_Pos (0UL) /*!< Position of A2 field. */
N#define TEMP_A2_A2_Msk (0xFFFUL << TEMP_A2_A2_Pos) /*!< Bit mask of A2 field. */
N
N/* Register: TEMP_A3 */
N/* Description: Slope of 4th piece wise linear function */
N
N/* Bits 11..0 : Slope of 4th piece wise linear function */
N#define TEMP_A3_A3_Pos (0UL) /*!< Position of A3 field. */
N#define TEMP_A3_A3_Msk (0xFFFUL << TEMP_A3_A3_Pos) /*!< Bit mask of A3 field. */
N
N/* Register: TEMP_A4 */
N/* Description: Slope of 5th piece wise linear function */
N
N/* Bits 11..0 : Slope of 5th piece wise linear function */
N#define TEMP_A4_A4_Pos (0UL) /*!< Position of A4 field. */
N#define TEMP_A4_A4_Msk (0xFFFUL << TEMP_A4_A4_Pos) /*!< Bit mask of A4 field. */
N
N/* Register: TEMP_A5 */
N/* Description: Slope of 6th piece wise linear function */
N
N/* Bits 11..0 : Slope of 6th piece wise linear function */
N#define TEMP_A5_A5_Pos (0UL) /*!< Position of A5 field. */
N#define TEMP_A5_A5_Msk (0xFFFUL << TEMP_A5_A5_Pos) /*!< Bit mask of A5 field. */
N
N/* Register: TEMP_B0 */
N/* Description: y-intercept of 1st piece wise linear function */
N
N/* Bits 13..0 : y-intercept of 1st piece wise linear function */
N#define TEMP_B0_B0_Pos (0UL) /*!< Position of B0 field. */
N#define TEMP_B0_B0_Msk (0x3FFFUL << TEMP_B0_B0_Pos) /*!< Bit mask of B0 field. */
N
N/* Register: TEMP_B1 */
N/* Description: y-intercept of 2nd piece wise linear function */
N
N/* Bits 13..0 : y-intercept of 2nd piece wise linear function */
N#define TEMP_B1_B1_Pos (0UL) /*!< Position of B1 field. */
N#define TEMP_B1_B1_Msk (0x3FFFUL << TEMP_B1_B1_Pos) /*!< Bit mask of B1 field. */
N
N/* Register: TEMP_B2 */
N/* Description: y-intercept of 3rd piece wise linear function */
N
N/* Bits 13..0 : y-intercept of 3rd piece wise linear function */
N#define TEMP_B2_B2_Pos (0UL) /*!< Position of B2 field. */
N#define TEMP_B2_B2_Msk (0x3FFFUL << TEMP_B2_B2_Pos) /*!< Bit mask of B2 field. */
N
N/* Register: TEMP_B3 */
N/* Description: y-intercept of 4th piece wise linear function */
N
N/* Bits 13..0 : y-intercept of 4th piece wise linear function */
N#define TEMP_B3_B3_Pos (0UL) /*!< Position of B3 field. */
N#define TEMP_B3_B3_Msk (0x3FFFUL << TEMP_B3_B3_Pos) /*!< Bit mask of B3 field. */
N
N/* Register: TEMP_B4 */
N/* Description: y-intercept of 5th piece wise linear function */
N
N/* Bits 13..0 : y-intercept of 5th piece wise linear function */
N#define TEMP_B4_B4_Pos (0UL) /*!< Position of B4 field. */
N#define TEMP_B4_B4_Msk (0x3FFFUL << TEMP_B4_B4_Pos) /*!< Bit mask of B4 field. */
N
N/* Register: TEMP_B5 */
N/* Description: y-intercept of 6th piece wise linear function */
N
N/* Bits 13..0 : y-intercept of 6th piece wise linear function */
N#define TEMP_B5_B5_Pos (0UL) /*!< Position of B5 field. */
N#define TEMP_B5_B5_Msk (0x3FFFUL << TEMP_B5_B5_Pos) /*!< Bit mask of B5 field. */
N
N/* Register: TEMP_T0 */
N/* Description: End point of 1st piece wise linear function */
N
N/* Bits 7..0 : End point of 1st piece wise linear function */
N#define TEMP_T0_T0_Pos (0UL) /*!< Position of T0 field. */
N#define TEMP_T0_T0_Msk (0xFFUL << TEMP_T0_T0_Pos) /*!< Bit mask of T0 field. */
N
N/* Register: TEMP_T1 */
N/* Description: End point of 2nd piece wise linear function */
N
N/* Bits 7..0 : End point of 2nd piece wise linear function */
N#define TEMP_T1_T1_Pos (0UL) /*!< Position of T1 field. */
N#define TEMP_T1_T1_Msk (0xFFUL << TEMP_T1_T1_Pos) /*!< Bit mask of T1 field. */
N
N/* Register: TEMP_T2 */
N/* Description: End point of 3rd piece wise linear function */
N
N/* Bits 7..0 : End point of 3rd piece wise linear function */
N#define TEMP_T2_T2_Pos (0UL) /*!< Position of T2 field. */
N#define TEMP_T2_T2_Msk (0xFFUL << TEMP_T2_T2_Pos) /*!< Bit mask of T2 field. */
N
N/* Register: TEMP_T3 */
N/* Description: End point of 4th piece wise linear function */
N
N/* Bits 7..0 : End point of 4th piece wise linear function */
N#define TEMP_T3_T3_Pos (0UL) /*!< Position of T3 field. */
N#define TEMP_T3_T3_Msk (0xFFUL << TEMP_T3_T3_Pos) /*!< Bit mask of T3 field. */
N
N/* Register: TEMP_T4 */
N/* Description: End point of 5th piece wise linear function */
N
N/* Bits 7..0 : End point of 5th piece wise linear function */
N#define TEMP_T4_T4_Pos (0UL) /*!< Position of T4 field. */
N#define TEMP_T4_T4_Msk (0xFFUL << TEMP_T4_T4_Pos) /*!< Bit mask of T4 field. */
N
N
N/* Peripheral: TIMER */
N/* Description: Timer/Counter 0 */
N
N/* Register: TIMER_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 13 : Shortcut between COMPARE[5] event and STOP task */
N#define TIMER_SHORTS_COMPARE5_STOP_Pos (13UL) /*!< Position of COMPARE5_STOP field. */
N#define TIMER_SHORTS_COMPARE5_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE5_STOP_Pos) /*!< Bit mask of COMPARE5_STOP field. */
N#define TIMER_SHORTS_COMPARE5_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE5_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 12 : Shortcut between COMPARE[4] event and STOP task */
N#define TIMER_SHORTS_COMPARE4_STOP_Pos (12UL) /*!< Position of COMPARE4_STOP field. */
N#define TIMER_SHORTS_COMPARE4_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE4_STOP_Pos) /*!< Bit mask of COMPARE4_STOP field. */
N#define TIMER_SHORTS_COMPARE4_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE4_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 11 : Shortcut between COMPARE[3] event and STOP task */
N#define TIMER_SHORTS_COMPARE3_STOP_Pos (11UL) /*!< Position of COMPARE3_STOP field. */
N#define TIMER_SHORTS_COMPARE3_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE3_STOP_Pos) /*!< Bit mask of COMPARE3_STOP field. */
N#define TIMER_SHORTS_COMPARE3_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE3_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 10 : Shortcut between COMPARE[2] event and STOP task */
N#define TIMER_SHORTS_COMPARE2_STOP_Pos (10UL) /*!< Position of COMPARE2_STOP field. */
N#define TIMER_SHORTS_COMPARE2_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE2_STOP_Pos) /*!< Bit mask of COMPARE2_STOP field. */
N#define TIMER_SHORTS_COMPARE2_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE2_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 9 : Shortcut between COMPARE[1] event and STOP task */
N#define TIMER_SHORTS_COMPARE1_STOP_Pos (9UL) /*!< Position of COMPARE1_STOP field. */
N#define TIMER_SHORTS_COMPARE1_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE1_STOP_Pos) /*!< Bit mask of COMPARE1_STOP field. */
N#define TIMER_SHORTS_COMPARE1_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE1_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 8 : Shortcut between COMPARE[0] event and STOP task */
N#define TIMER_SHORTS_COMPARE0_STOP_Pos (8UL) /*!< Position of COMPARE0_STOP field. */
N#define TIMER_SHORTS_COMPARE0_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE0_STOP_Pos) /*!< Bit mask of COMPARE0_STOP field. */
N#define TIMER_SHORTS_COMPARE0_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE0_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 5 : Shortcut between COMPARE[5] event and CLEAR task */
N#define TIMER_SHORTS_COMPARE5_CLEAR_Pos (5UL) /*!< Position of COMPARE5_CLEAR field. */
N#define TIMER_SHORTS_COMPARE5_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE5_CLEAR_Pos) /*!< Bit mask of COMPARE5_CLEAR field. */
N#define TIMER_SHORTS_COMPARE5_CLEAR_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE5_CLEAR_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 4 : Shortcut between COMPARE[4] event and CLEAR task */
N#define TIMER_SHORTS_COMPARE4_CLEAR_Pos (4UL) /*!< Position of COMPARE4_CLEAR field. */
N#define TIMER_SHORTS_COMPARE4_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE4_CLEAR_Pos) /*!< Bit mask of COMPARE4_CLEAR field. */
N#define TIMER_SHORTS_COMPARE4_CLEAR_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE4_CLEAR_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 3 : Shortcut between COMPARE[3] event and CLEAR task */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Pos (3UL) /*!< Position of COMPARE3_CLEAR field. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE3_CLEAR_Pos) /*!< Bit mask of COMPARE3_CLEAR field. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 2 : Shortcut between COMPARE[2] event and CLEAR task */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Pos (2UL) /*!< Position of COMPARE2_CLEAR field. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE2_CLEAR_Pos) /*!< Bit mask of COMPARE2_CLEAR field. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 1 : Shortcut between COMPARE[1] event and CLEAR task */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Pos (1UL) /*!< Position of COMPARE1_CLEAR field. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE1_CLEAR_Pos) /*!< Bit mask of COMPARE1_CLEAR field. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 0 : Shortcut between COMPARE[0] event and CLEAR task */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Pos (0UL) /*!< Position of COMPARE0_CLEAR field. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE0_CLEAR_Pos) /*!< Bit mask of COMPARE0_CLEAR field. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Disabled (0UL) /*!< Disable shortcut */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: TIMER_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 21 : Write '1' to Enable interrupt for COMPARE[5] event */
N#define TIMER_INTENSET_COMPARE5_Pos (21UL) /*!< Position of COMPARE5 field. */
N#define TIMER_INTENSET_COMPARE5_Msk (0x1UL << TIMER_INTENSET_COMPARE5_Pos) /*!< Bit mask of COMPARE5 field. */
N#define TIMER_INTENSET_COMPARE5_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENSET_COMPARE5_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENSET_COMPARE5_Set (1UL) /*!< Enable */
N
N/* Bit 20 : Write '1' to Enable interrupt for COMPARE[4] event */
N#define TIMER_INTENSET_COMPARE4_Pos (20UL) /*!< Position of COMPARE4 field. */
N#define TIMER_INTENSET_COMPARE4_Msk (0x1UL << TIMER_INTENSET_COMPARE4_Pos) /*!< Bit mask of COMPARE4 field. */
N#define TIMER_INTENSET_COMPARE4_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENSET_COMPARE4_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENSET_COMPARE4_Set (1UL) /*!< Enable */
N
N/* Bit 19 : Write '1' to Enable interrupt for COMPARE[3] event */
N#define TIMER_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define TIMER_INTENSET_COMPARE3_Msk (0x1UL << TIMER_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define TIMER_INTENSET_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENSET_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENSET_COMPARE3_Set (1UL) /*!< Enable */
N
N/* Bit 18 : Write '1' to Enable interrupt for COMPARE[2] event */
N#define TIMER_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define TIMER_INTENSET_COMPARE2_Msk (0x1UL << TIMER_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define TIMER_INTENSET_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENSET_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENSET_COMPARE2_Set (1UL) /*!< Enable */
N
N/* Bit 17 : Write '1' to Enable interrupt for COMPARE[1] event */
N#define TIMER_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define TIMER_INTENSET_COMPARE1_Msk (0x1UL << TIMER_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define TIMER_INTENSET_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENSET_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENSET_COMPARE1_Set (1UL) /*!< Enable */
N
N/* Bit 16 : Write '1' to Enable interrupt for COMPARE[0] event */
N#define TIMER_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define TIMER_INTENSET_COMPARE0_Msk (0x1UL << TIMER_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define TIMER_INTENSET_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENSET_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENSET_COMPARE0_Set (1UL) /*!< Enable */
N
N/* Register: TIMER_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 21 : Write '1' to Disable interrupt for COMPARE[5] event */
N#define TIMER_INTENCLR_COMPARE5_Pos (21UL) /*!< Position of COMPARE5 field. */
N#define TIMER_INTENCLR_COMPARE5_Msk (0x1UL << TIMER_INTENCLR_COMPARE5_Pos) /*!< Bit mask of COMPARE5 field. */
N#define TIMER_INTENCLR_COMPARE5_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENCLR_COMPARE5_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENCLR_COMPARE5_Clear (1UL) /*!< Disable */
N
N/* Bit 20 : Write '1' to Disable interrupt for COMPARE[4] event */
N#define TIMER_INTENCLR_COMPARE4_Pos (20UL) /*!< Position of COMPARE4 field. */
N#define TIMER_INTENCLR_COMPARE4_Msk (0x1UL << TIMER_INTENCLR_COMPARE4_Pos) /*!< Bit mask of COMPARE4 field. */
N#define TIMER_INTENCLR_COMPARE4_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENCLR_COMPARE4_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENCLR_COMPARE4_Clear (1UL) /*!< Disable */
N
N/* Bit 19 : Write '1' to Disable interrupt for COMPARE[3] event */
N#define TIMER_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define TIMER_INTENCLR_COMPARE3_Msk (0x1UL << TIMER_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define TIMER_INTENCLR_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENCLR_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable */
N
N/* Bit 18 : Write '1' to Disable interrupt for COMPARE[2] event */
N#define TIMER_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define TIMER_INTENCLR_COMPARE2_Msk (0x1UL << TIMER_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define TIMER_INTENCLR_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENCLR_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable */
N
N/* Bit 17 : Write '1' to Disable interrupt for COMPARE[1] event */
N#define TIMER_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define TIMER_INTENCLR_COMPARE1_Msk (0x1UL << TIMER_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define TIMER_INTENCLR_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENCLR_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable */
N
N/* Bit 16 : Write '1' to Disable interrupt for COMPARE[0] event */
N#define TIMER_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define TIMER_INTENCLR_COMPARE0_Msk (0x1UL << TIMER_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define TIMER_INTENCLR_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
N#define TIMER_INTENCLR_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
N#define TIMER_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable */
N
N/* Register: TIMER_MODE */
N/* Description: Timer mode selection */
N
N/* Bits 1..0 : Timer mode */
N#define TIMER_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define TIMER_MODE_MODE_Msk (0x3UL << TIMER_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define TIMER_MODE_MODE_Timer (0UL) /*!< Select Timer mode */
N#define TIMER_MODE_MODE_Counter (1UL) /*!< Deprecated enumerator -  Select Counter mode */
N#define TIMER_MODE_MODE_LowPowerCounter (2UL) /*!< Select Low Power Counter mode */
N
N/* Register: TIMER_BITMODE */
N/* Description: Configure the number of bits used by the TIMER */
N
N/* Bits 1..0 : Timer bit width */
N#define TIMER_BITMODE_BITMODE_Pos (0UL) /*!< Position of BITMODE field. */
N#define TIMER_BITMODE_BITMODE_Msk (0x3UL << TIMER_BITMODE_BITMODE_Pos) /*!< Bit mask of BITMODE field. */
N#define TIMER_BITMODE_BITMODE_16Bit (0UL) /*!< 16 bit timer bit width */
N#define TIMER_BITMODE_BITMODE_08Bit (1UL) /*!< 8 bit timer bit width */
N#define TIMER_BITMODE_BITMODE_24Bit (2UL) /*!< 24 bit timer bit width */
N#define TIMER_BITMODE_BITMODE_32Bit (3UL) /*!< 32 bit timer bit width */
N
N/* Register: TIMER_PRESCALER */
N/* Description: Timer prescaler register */
N
N/* Bits 3..0 : Prescaler value */
N#define TIMER_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define TIMER_PRESCALER_PRESCALER_Msk (0xFUL << TIMER_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N
N/* Register: TIMER_CC */
N/* Description: Description collection[0]:  Capture/Compare register 0 */
N
N/* Bits 31..0 : Capture/Compare value */
N#define TIMER_CC_CC_Pos (0UL) /*!< Position of CC field. */
N#define TIMER_CC_CC_Msk (0xFFFFFFFFUL << TIMER_CC_CC_Pos) /*!< Bit mask of CC field. */
N
N
N/* Peripheral: TWI */
N/* Description: I2C compatible Two-Wire Interface 0 */
N
N/* Register: TWI_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 1 : Shortcut between BB event and STOP task */
N#define TWI_SHORTS_BB_STOP_Pos (1UL) /*!< Position of BB_STOP field. */
N#define TWI_SHORTS_BB_STOP_Msk (0x1UL << TWI_SHORTS_BB_STOP_Pos) /*!< Bit mask of BB_STOP field. */
N#define TWI_SHORTS_BB_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define TWI_SHORTS_BB_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 0 : Shortcut between BB event and SUSPEND task */
N#define TWI_SHORTS_BB_SUSPEND_Pos (0UL) /*!< Position of BB_SUSPEND field. */
N#define TWI_SHORTS_BB_SUSPEND_Msk (0x1UL << TWI_SHORTS_BB_SUSPEND_Pos) /*!< Bit mask of BB_SUSPEND field. */
N#define TWI_SHORTS_BB_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
N#define TWI_SHORTS_BB_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: TWI_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 18 : Write '1' to Enable interrupt for SUSPENDED event */
N#define TWI_INTENSET_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
N#define TWI_INTENSET_SUSPENDED_Msk (0x1UL << TWI_INTENSET_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
N#define TWI_INTENSET_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENSET_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENSET_SUSPENDED_Set (1UL) /*!< Enable */
N
N/* Bit 14 : Write '1' to Enable interrupt for BB event */
N#define TWI_INTENSET_BB_Pos (14UL) /*!< Position of BB field. */
N#define TWI_INTENSET_BB_Msk (0x1UL << TWI_INTENSET_BB_Pos) /*!< Bit mask of BB field. */
N#define TWI_INTENSET_BB_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENSET_BB_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENSET_BB_Set (1UL) /*!< Enable */
N
N/* Bit 9 : Write '1' to Enable interrupt for ERROR event */
N#define TWI_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWI_INTENSET_ERROR_Msk (0x1UL << TWI_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWI_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENSET_ERROR_Set (1UL) /*!< Enable */
N
N/* Bit 7 : Write '1' to Enable interrupt for TXDSENT event */
N#define TWI_INTENSET_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
N#define TWI_INTENSET_TXDSENT_Msk (0x1UL << TWI_INTENSET_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
N#define TWI_INTENSET_TXDSENT_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENSET_TXDSENT_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENSET_TXDSENT_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for RXDREADY event */
N#define TWI_INTENSET_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
N#define TWI_INTENSET_RXDREADY_Msk (0x1UL << TWI_INTENSET_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
N#define TWI_INTENSET_RXDREADY_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENSET_RXDREADY_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENSET_RXDREADY_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
N#define TWI_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWI_INTENSET_STOPPED_Msk (0x1UL << TWI_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWI_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENSET_STOPPED_Set (1UL) /*!< Enable */
N
N/* Register: TWI_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 18 : Write '1' to Disable interrupt for SUSPENDED event */
N#define TWI_INTENCLR_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
N#define TWI_INTENCLR_SUSPENDED_Msk (0x1UL << TWI_INTENCLR_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
N#define TWI_INTENCLR_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENCLR_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENCLR_SUSPENDED_Clear (1UL) /*!< Disable */
N
N/* Bit 14 : Write '1' to Disable interrupt for BB event */
N#define TWI_INTENCLR_BB_Pos (14UL) /*!< Position of BB field. */
N#define TWI_INTENCLR_BB_Msk (0x1UL << TWI_INTENCLR_BB_Pos) /*!< Bit mask of BB field. */
N#define TWI_INTENCLR_BB_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENCLR_BB_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENCLR_BB_Clear (1UL) /*!< Disable */
N
N/* Bit 9 : Write '1' to Disable interrupt for ERROR event */
N#define TWI_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWI_INTENCLR_ERROR_Msk (0x1UL << TWI_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWI_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
N
N/* Bit 7 : Write '1' to Disable interrupt for TXDSENT event */
N#define TWI_INTENCLR_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
N#define TWI_INTENCLR_TXDSENT_Msk (0x1UL << TWI_INTENCLR_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
N#define TWI_INTENCLR_TXDSENT_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENCLR_TXDSENT_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENCLR_TXDSENT_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for RXDREADY event */
N#define TWI_INTENCLR_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
N#define TWI_INTENCLR_RXDREADY_Msk (0x1UL << TWI_INTENCLR_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
N#define TWI_INTENCLR_RXDREADY_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENCLR_RXDREADY_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENCLR_RXDREADY_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
N#define TWI_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWI_INTENCLR_STOPPED_Msk (0x1UL << TWI_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWI_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define TWI_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define TWI_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
N
N/* Register: TWI_ERRORSRC */
N/* Description: Error source */
N
N/* Bit 2 : NACK received after sending a data byte (write '1' to clear) */
N#define TWI_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
N#define TWI_ERRORSRC_DNACK_Msk (0x1UL << TWI_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
N#define TWI_ERRORSRC_DNACK_NotPresent (0UL) /*!< Read: error not present */
N#define TWI_ERRORSRC_DNACK_Present (1UL) /*!< Read: error present */
N
N/* Bit 1 : NACK received after sending the address (write '1' to clear) */
N#define TWI_ERRORSRC_ANACK_Pos (1UL) /*!< Position of ANACK field. */
N#define TWI_ERRORSRC_ANACK_Msk (0x1UL << TWI_ERRORSRC_ANACK_Pos) /*!< Bit mask of ANACK field. */
N#define TWI_ERRORSRC_ANACK_NotPresent (0UL) /*!< Read: error not present */
N#define TWI_ERRORSRC_ANACK_Present (1UL) /*!< Read: error present */
N
N/* Bit 0 : Overrun error */
N#define TWI_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
N#define TWI_ERRORSRC_OVERRUN_Msk (0x1UL << TWI_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
N#define TWI_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Read: no overrun occured */
N#define TWI_ERRORSRC_OVERRUN_Present (1UL) /*!< Read: overrun occured */
N
N/* Register: TWI_ENABLE */
N/* Description: Enable TWI */
N
N/* Bits 3..0 : Enable or disable TWI */
N#define TWI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define TWI_ENABLE_ENABLE_Msk (0xFUL << TWI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define TWI_ENABLE_ENABLE_Disabled (0UL) /*!< Disable TWI */
N#define TWI_ENABLE_ENABLE_Enabled (5UL) /*!< Enable TWI */
N
N/* Register: TWI_PSELSCL */
N/* Description: Pin select for SCL */
N
N/* Bits 31..0 : Pin number configuration for TWI SCL signal */
N#define TWI_PSELSCL_PSELSCL_Pos (0UL) /*!< Position of PSELSCL field. */
N#define TWI_PSELSCL_PSELSCL_Msk (0xFFFFFFFFUL << TWI_PSELSCL_PSELSCL_Pos) /*!< Bit mask of PSELSCL field. */
N#define TWI_PSELSCL_PSELSCL_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
N
N/* Register: TWI_PSELSDA */
N/* Description: Pin select for SDA */
N
N/* Bits 31..0 : Pin number configuration for TWI SDA signal */
N#define TWI_PSELSDA_PSELSDA_Pos (0UL) /*!< Position of PSELSDA field. */
N#define TWI_PSELSDA_PSELSDA_Msk (0xFFFFFFFFUL << TWI_PSELSDA_PSELSDA_Pos) /*!< Bit mask of PSELSDA field. */
N#define TWI_PSELSDA_PSELSDA_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
N
N/* Register: TWI_RXD */
N/* Description: RXD register */
N
N/* Bits 7..0 : RXD register */
N#define TWI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define TWI_RXD_RXD_Msk (0xFFUL << TWI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: TWI_TXD */
N/* Description: TXD register */
N
N/* Bits 7..0 : TXD register */
N#define TWI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define TWI_TXD_TXD_Msk (0xFFUL << TWI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: TWI_FREQUENCY */
N/* Description: TWI frequency */
N
N/* Bits 31..0 : TWI master clock frequency */
N#define TWI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define TWI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << TWI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define TWI_FREQUENCY_FREQUENCY_K100 (0x01980000UL) /*!< 100 kbps */
N#define TWI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
N#define TWI_FREQUENCY_FREQUENCY_K400 (0x06680000UL) /*!< 400 kbps (actual rate 410.256 kbps) */
N
N/* Register: TWI_ADDRESS */
N/* Description: Address used in the TWI transfer */
N
N/* Bits 6..0 : Address used in the TWI transfer */
N#define TWI_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
N#define TWI_ADDRESS_ADDRESS_Msk (0x7FUL << TWI_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N
N
N/* Peripheral: TWIM */
N/* Description: I2C compatible Two-Wire Master Interface with EasyDMA 0 */
N
N/* Register: TWIM_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 12 : Shortcut between LASTRX event and STOP task */
N#define TWIM_SHORTS_LASTRX_STOP_Pos (12UL) /*!< Position of LASTRX_STOP field. */
N#define TWIM_SHORTS_LASTRX_STOP_Msk (0x1UL << TWIM_SHORTS_LASTRX_STOP_Pos) /*!< Bit mask of LASTRX_STOP field. */
N#define TWIM_SHORTS_LASTRX_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define TWIM_SHORTS_LASTRX_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 10 : Shortcut between LASTRX event and STARTTX task */
N#define TWIM_SHORTS_LASTRX_STARTTX_Pos (10UL) /*!< Position of LASTRX_STARTTX field. */
N#define TWIM_SHORTS_LASTRX_STARTTX_Msk (0x1UL << TWIM_SHORTS_LASTRX_STARTTX_Pos) /*!< Bit mask of LASTRX_STARTTX field. */
N#define TWIM_SHORTS_LASTRX_STARTTX_Disabled (0UL) /*!< Disable shortcut */
N#define TWIM_SHORTS_LASTRX_STARTTX_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 9 : Shortcut between LASTTX event and STOP task */
N#define TWIM_SHORTS_LASTTX_STOP_Pos (9UL) /*!< Position of LASTTX_STOP field. */
N#define TWIM_SHORTS_LASTTX_STOP_Msk (0x1UL << TWIM_SHORTS_LASTTX_STOP_Pos) /*!< Bit mask of LASTTX_STOP field. */
N#define TWIM_SHORTS_LASTTX_STOP_Disabled (0UL) /*!< Disable shortcut */
N#define TWIM_SHORTS_LASTTX_STOP_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 8 : Shortcut between LASTTX event and SUSPEND task */
N#define TWIM_SHORTS_LASTTX_SUSPEND_Pos (8UL) /*!< Position of LASTTX_SUSPEND field. */
N#define TWIM_SHORTS_LASTTX_SUSPEND_Msk (0x1UL << TWIM_SHORTS_LASTTX_SUSPEND_Pos) /*!< Bit mask of LASTTX_SUSPEND field. */
N#define TWIM_SHORTS_LASTTX_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
N#define TWIM_SHORTS_LASTTX_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 7 : Shortcut between LASTTX event and STARTRX task */
N#define TWIM_SHORTS_LASTTX_STARTRX_Pos (7UL) /*!< Position of LASTTX_STARTRX field. */
N#define TWIM_SHORTS_LASTTX_STARTRX_Msk (0x1UL << TWIM_SHORTS_LASTTX_STARTRX_Pos) /*!< Bit mask of LASTTX_STARTRX field. */
N#define TWIM_SHORTS_LASTTX_STARTRX_Disabled (0UL) /*!< Disable shortcut */
N#define TWIM_SHORTS_LASTTX_STARTRX_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: TWIM_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 24 : Enable or disable interrupt for LASTTX event */
N#define TWIM_INTEN_LASTTX_Pos (24UL) /*!< Position of LASTTX field. */
N#define TWIM_INTEN_LASTTX_Msk (0x1UL << TWIM_INTEN_LASTTX_Pos) /*!< Bit mask of LASTTX field. */
N#define TWIM_INTEN_LASTTX_Disabled (0UL) /*!< Disable */
N#define TWIM_INTEN_LASTTX_Enabled (1UL) /*!< Enable */
N
N/* Bit 23 : Enable or disable interrupt for LASTRX event */
N#define TWIM_INTEN_LASTRX_Pos (23UL) /*!< Position of LASTRX field. */
N#define TWIM_INTEN_LASTRX_Msk (0x1UL << TWIM_INTEN_LASTRX_Pos) /*!< Bit mask of LASTRX field. */
N#define TWIM_INTEN_LASTRX_Disabled (0UL) /*!< Disable */
N#define TWIM_INTEN_LASTRX_Enabled (1UL) /*!< Enable */
N
N/* Bit 20 : Enable or disable interrupt for TXSTARTED event */
N#define TWIM_INTEN_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
N#define TWIM_INTEN_TXSTARTED_Msk (0x1UL << TWIM_INTEN_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
N#define TWIM_INTEN_TXSTARTED_Disabled (0UL) /*!< Disable */
N#define TWIM_INTEN_TXSTARTED_Enabled (1UL) /*!< Enable */
N
N/* Bit 19 : Enable or disable interrupt for RXSTARTED event */
N#define TWIM_INTEN_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
N#define TWIM_INTEN_RXSTARTED_Msk (0x1UL << TWIM_INTEN_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
N#define TWIM_INTEN_RXSTARTED_Disabled (0UL) /*!< Disable */
N#define TWIM_INTEN_RXSTARTED_Enabled (1UL) /*!< Enable */
N
N/* Bit 18 : Enable or disable interrupt for SUSPENDED event */
N#define TWIM_INTEN_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
N#define TWIM_INTEN_SUSPENDED_Msk (0x1UL << TWIM_INTEN_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
N#define TWIM_INTEN_SUSPENDED_Disabled (0UL) /*!< Disable */
N#define TWIM_INTEN_SUSPENDED_Enabled (1UL) /*!< Enable */
N
N/* Bit 9 : Enable or disable interrupt for ERROR event */
N#define TWIM_INTEN_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWIM_INTEN_ERROR_Msk (0x1UL << TWIM_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWIM_INTEN_ERROR_Disabled (0UL) /*!< Disable */
N#define TWIM_INTEN_ERROR_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for STOPPED event */
N#define TWIM_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWIM_INTEN_STOPPED_Msk (0x1UL << TWIM_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWIM_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
N#define TWIM_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
N
N/* Register: TWIM_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 24 : Write '1' to Enable interrupt for LASTTX event */
N#define TWIM_INTENSET_LASTTX_Pos (24UL) /*!< Position of LASTTX field. */
N#define TWIM_INTENSET_LASTTX_Msk (0x1UL << TWIM_INTENSET_LASTTX_Pos) /*!< Bit mask of LASTTX field. */
N#define TWIM_INTENSET_LASTTX_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENSET_LASTTX_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENSET_LASTTX_Set (1UL) /*!< Enable */
N
N/* Bit 23 : Write '1' to Enable interrupt for LASTRX event */
N#define TWIM_INTENSET_LASTRX_Pos (23UL) /*!< Position of LASTRX field. */
N#define TWIM_INTENSET_LASTRX_Msk (0x1UL << TWIM_INTENSET_LASTRX_Pos) /*!< Bit mask of LASTRX field. */
N#define TWIM_INTENSET_LASTRX_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENSET_LASTRX_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENSET_LASTRX_Set (1UL) /*!< Enable */
N
N/* Bit 20 : Write '1' to Enable interrupt for TXSTARTED event */
N#define TWIM_INTENSET_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
N#define TWIM_INTENSET_TXSTARTED_Msk (0x1UL << TWIM_INTENSET_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
N#define TWIM_INTENSET_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENSET_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENSET_TXSTARTED_Set (1UL) /*!< Enable */
N
N/* Bit 19 : Write '1' to Enable interrupt for RXSTARTED event */
N#define TWIM_INTENSET_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
N#define TWIM_INTENSET_RXSTARTED_Msk (0x1UL << TWIM_INTENSET_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
N#define TWIM_INTENSET_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENSET_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENSET_RXSTARTED_Set (1UL) /*!< Enable */
N
N/* Bit 18 : Write '1' to Enable interrupt for SUSPENDED event */
N#define TWIM_INTENSET_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
N#define TWIM_INTENSET_SUSPENDED_Msk (0x1UL << TWIM_INTENSET_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
N#define TWIM_INTENSET_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENSET_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENSET_SUSPENDED_Set (1UL) /*!< Enable */
N
N/* Bit 9 : Write '1' to Enable interrupt for ERROR event */
N#define TWIM_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWIM_INTENSET_ERROR_Msk (0x1UL << TWIM_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWIM_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENSET_ERROR_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
N#define TWIM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWIM_INTENSET_STOPPED_Msk (0x1UL << TWIM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWIM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
N
N/* Register: TWIM_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 24 : Write '1' to Disable interrupt for LASTTX event */
N#define TWIM_INTENCLR_LASTTX_Pos (24UL) /*!< Position of LASTTX field. */
N#define TWIM_INTENCLR_LASTTX_Msk (0x1UL << TWIM_INTENCLR_LASTTX_Pos) /*!< Bit mask of LASTTX field. */
N#define TWIM_INTENCLR_LASTTX_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENCLR_LASTTX_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENCLR_LASTTX_Clear (1UL) /*!< Disable */
N
N/* Bit 23 : Write '1' to Disable interrupt for LASTRX event */
N#define TWIM_INTENCLR_LASTRX_Pos (23UL) /*!< Position of LASTRX field. */
N#define TWIM_INTENCLR_LASTRX_Msk (0x1UL << TWIM_INTENCLR_LASTRX_Pos) /*!< Bit mask of LASTRX field. */
N#define TWIM_INTENCLR_LASTRX_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENCLR_LASTRX_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENCLR_LASTRX_Clear (1UL) /*!< Disable */
N
N/* Bit 20 : Write '1' to Disable interrupt for TXSTARTED event */
N#define TWIM_INTENCLR_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
N#define TWIM_INTENCLR_TXSTARTED_Msk (0x1UL << TWIM_INTENCLR_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
N#define TWIM_INTENCLR_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENCLR_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENCLR_TXSTARTED_Clear (1UL) /*!< Disable */
N
N/* Bit 19 : Write '1' to Disable interrupt for RXSTARTED event */
N#define TWIM_INTENCLR_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
N#define TWIM_INTENCLR_RXSTARTED_Msk (0x1UL << TWIM_INTENCLR_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
N#define TWIM_INTENCLR_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENCLR_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENCLR_RXSTARTED_Clear (1UL) /*!< Disable */
N
N/* Bit 18 : Write '1' to Disable interrupt for SUSPENDED event */
N#define TWIM_INTENCLR_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
N#define TWIM_INTENCLR_SUSPENDED_Msk (0x1UL << TWIM_INTENCLR_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
N#define TWIM_INTENCLR_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENCLR_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENCLR_SUSPENDED_Clear (1UL) /*!< Disable */
N
N/* Bit 9 : Write '1' to Disable interrupt for ERROR event */
N#define TWIM_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWIM_INTENCLR_ERROR_Msk (0x1UL << TWIM_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWIM_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
N#define TWIM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWIM_INTENCLR_STOPPED_Msk (0x1UL << TWIM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWIM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
N
N/* Register: TWIM_ERRORSRC */
N/* Description: Error source */
N
N/* Bit 2 : NACK received after sending a data byte (write '1' to clear) */
N#define TWIM_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
N#define TWIM_ERRORSRC_DNACK_Msk (0x1UL << TWIM_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
N#define TWIM_ERRORSRC_DNACK_NotReceived (0UL) /*!< Error did not occur */
N#define TWIM_ERRORSRC_DNACK_Received (1UL) /*!< Error occurred */
N
N/* Bit 1 : NACK received after sending the address (write '1' to clear) */
N#define TWIM_ERRORSRC_ANACK_Pos (1UL) /*!< Position of ANACK field. */
N#define TWIM_ERRORSRC_ANACK_Msk (0x1UL << TWIM_ERRORSRC_ANACK_Pos) /*!< Bit mask of ANACK field. */
N#define TWIM_ERRORSRC_ANACK_NotReceived (0UL) /*!< Error did not occur */
N#define TWIM_ERRORSRC_ANACK_Received (1UL) /*!< Error occurred */
N
N/* Register: TWIM_ENABLE */
N/* Description: Enable TWIM */
N
N/* Bits 3..0 : Enable or disable TWIM */
N#define TWIM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define TWIM_ENABLE_ENABLE_Msk (0xFUL << TWIM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define TWIM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable TWIM */
N#define TWIM_ENABLE_ENABLE_Enabled (6UL) /*!< Enable TWIM */
N
N/* Register: TWIM_PSEL_SCL */
N/* Description: Pin select for SCL signal */
N
N/* Bit 31 : Connection */
N#define TWIM_PSEL_SCL_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define TWIM_PSEL_SCL_CONNECT_Msk (0x1UL << TWIM_PSEL_SCL_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define TWIM_PSEL_SCL_CONNECT_Connected (0UL) /*!< Connect */
N#define TWIM_PSEL_SCL_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define TWIM_PSEL_SCL_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define TWIM_PSEL_SCL_PIN_Msk (0x1FUL << TWIM_PSEL_SCL_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: TWIM_PSEL_SDA */
N/* Description: Pin select for SDA signal */
N
N/* Bit 31 : Connection */
N#define TWIM_PSEL_SDA_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define TWIM_PSEL_SDA_CONNECT_Msk (0x1UL << TWIM_PSEL_SDA_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define TWIM_PSEL_SDA_CONNECT_Connected (0UL) /*!< Connect */
N#define TWIM_PSEL_SDA_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define TWIM_PSEL_SDA_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define TWIM_PSEL_SDA_PIN_Msk (0x1FUL << TWIM_PSEL_SDA_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: TWIM_FREQUENCY */
N/* Description: TWI frequency */
N
N/* Bits 31..0 : TWI master clock frequency */
N#define TWIM_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define TWIM_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << TWIM_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define TWIM_FREQUENCY_FREQUENCY_K100 (0x01980000UL) /*!< 100 kbps */
N#define TWIM_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
N#define TWIM_FREQUENCY_FREQUENCY_K400 (0x06400000UL) /*!< 400 kbps */
N
N/* Register: TWIM_RXD_PTR */
N/* Description: Data pointer */
N
N/* Bits 31..0 : Data pointer */
N#define TWIM_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define TWIM_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIM_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: TWIM_RXD_MAXCNT */
N/* Description: Maximum number of bytes in receive buffer */
N
N/* Bits 7..0 : Maximum number of bytes in receive buffer */
N#define TWIM_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define TWIM_RXD_MAXCNT_MAXCNT_Msk (0xFFUL << TWIM_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: TWIM_RXD_AMOUNT */
N/* Description: Number of bytes transferred in the last transaction */
N
N/* Bits 7..0 : Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte. */
N#define TWIM_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define TWIM_RXD_AMOUNT_AMOUNT_Msk (0xFFUL << TWIM_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N/* Register: TWIM_RXD_LIST */
N/* Description: EasyDMA list type */
N
N/* Bits 2..0 : List type */
N#define TWIM_RXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
N#define TWIM_RXD_LIST_LIST_Msk (0x7UL << TWIM_RXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
N#define TWIM_RXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
N#define TWIM_RXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
N
N/* Register: TWIM_TXD_PTR */
N/* Description: Data pointer */
N
N/* Bits 31..0 : Data pointer */
N#define TWIM_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define TWIM_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIM_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: TWIM_TXD_MAXCNT */
N/* Description: Maximum number of bytes in transmit buffer */
N
N/* Bits 7..0 : Maximum number of bytes in transmit buffer */
N#define TWIM_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define TWIM_TXD_MAXCNT_MAXCNT_Msk (0xFFUL << TWIM_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: TWIM_TXD_AMOUNT */
N/* Description: Number of bytes transferred in the last transaction */
N
N/* Bits 7..0 : Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte. */
N#define TWIM_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define TWIM_TXD_AMOUNT_AMOUNT_Msk (0xFFUL << TWIM_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N/* Register: TWIM_TXD_LIST */
N/* Description: EasyDMA list type */
N
N/* Bits 2..0 : List type */
N#define TWIM_TXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
N#define TWIM_TXD_LIST_LIST_Msk (0x7UL << TWIM_TXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
N#define TWIM_TXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
N#define TWIM_TXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
N
N/* Register: TWIM_ADDRESS */
N/* Description: Address used in the TWI transfer */
N
N/* Bits 6..0 : Address used in the TWI transfer */
N#define TWIM_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
N#define TWIM_ADDRESS_ADDRESS_Msk (0x7FUL << TWIM_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N
N
N/* Peripheral: TWIS */
N/* Description: I2C compatible Two-Wire Slave Interface with EasyDMA 0 */
N
N/* Register: TWIS_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 14 : Shortcut between READ event and SUSPEND task */
N#define TWIS_SHORTS_READ_SUSPEND_Pos (14UL) /*!< Position of READ_SUSPEND field. */
N#define TWIS_SHORTS_READ_SUSPEND_Msk (0x1UL << TWIS_SHORTS_READ_SUSPEND_Pos) /*!< Bit mask of READ_SUSPEND field. */
N#define TWIS_SHORTS_READ_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
N#define TWIS_SHORTS_READ_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 13 : Shortcut between WRITE event and SUSPEND task */
N#define TWIS_SHORTS_WRITE_SUSPEND_Pos (13UL) /*!< Position of WRITE_SUSPEND field. */
N#define TWIS_SHORTS_WRITE_SUSPEND_Msk (0x1UL << TWIS_SHORTS_WRITE_SUSPEND_Pos) /*!< Bit mask of WRITE_SUSPEND field. */
N#define TWIS_SHORTS_WRITE_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
N#define TWIS_SHORTS_WRITE_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: TWIS_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 26 : Enable or disable interrupt for READ event */
N#define TWIS_INTEN_READ_Pos (26UL) /*!< Position of READ field. */
N#define TWIS_INTEN_READ_Msk (0x1UL << TWIS_INTEN_READ_Pos) /*!< Bit mask of READ field. */
N#define TWIS_INTEN_READ_Disabled (0UL) /*!< Disable */
N#define TWIS_INTEN_READ_Enabled (1UL) /*!< Enable */
N
N/* Bit 25 : Enable or disable interrupt for WRITE event */
N#define TWIS_INTEN_WRITE_Pos (25UL) /*!< Position of WRITE field. */
N#define TWIS_INTEN_WRITE_Msk (0x1UL << TWIS_INTEN_WRITE_Pos) /*!< Bit mask of WRITE field. */
N#define TWIS_INTEN_WRITE_Disabled (0UL) /*!< Disable */
N#define TWIS_INTEN_WRITE_Enabled (1UL) /*!< Enable */
N
N/* Bit 20 : Enable or disable interrupt for TXSTARTED event */
N#define TWIS_INTEN_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
N#define TWIS_INTEN_TXSTARTED_Msk (0x1UL << TWIS_INTEN_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
N#define TWIS_INTEN_TXSTARTED_Disabled (0UL) /*!< Disable */
N#define TWIS_INTEN_TXSTARTED_Enabled (1UL) /*!< Enable */
N
N/* Bit 19 : Enable or disable interrupt for RXSTARTED event */
N#define TWIS_INTEN_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
N#define TWIS_INTEN_RXSTARTED_Msk (0x1UL << TWIS_INTEN_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
N#define TWIS_INTEN_RXSTARTED_Disabled (0UL) /*!< Disable */
N#define TWIS_INTEN_RXSTARTED_Enabled (1UL) /*!< Enable */
N
N/* Bit 9 : Enable or disable interrupt for ERROR event */
N#define TWIS_INTEN_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWIS_INTEN_ERROR_Msk (0x1UL << TWIS_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWIS_INTEN_ERROR_Disabled (0UL) /*!< Disable */
N#define TWIS_INTEN_ERROR_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for STOPPED event */
N#define TWIS_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWIS_INTEN_STOPPED_Msk (0x1UL << TWIS_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWIS_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
N#define TWIS_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
N
N/* Register: TWIS_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 26 : Write '1' to Enable interrupt for READ event */
N#define TWIS_INTENSET_READ_Pos (26UL) /*!< Position of READ field. */
N#define TWIS_INTENSET_READ_Msk (0x1UL << TWIS_INTENSET_READ_Pos) /*!< Bit mask of READ field. */
N#define TWIS_INTENSET_READ_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENSET_READ_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENSET_READ_Set (1UL) /*!< Enable */
N
N/* Bit 25 : Write '1' to Enable interrupt for WRITE event */
N#define TWIS_INTENSET_WRITE_Pos (25UL) /*!< Position of WRITE field. */
N#define TWIS_INTENSET_WRITE_Msk (0x1UL << TWIS_INTENSET_WRITE_Pos) /*!< Bit mask of WRITE field. */
N#define TWIS_INTENSET_WRITE_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENSET_WRITE_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENSET_WRITE_Set (1UL) /*!< Enable */
N
N/* Bit 20 : Write '1' to Enable interrupt for TXSTARTED event */
N#define TWIS_INTENSET_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
N#define TWIS_INTENSET_TXSTARTED_Msk (0x1UL << TWIS_INTENSET_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
N#define TWIS_INTENSET_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENSET_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENSET_TXSTARTED_Set (1UL) /*!< Enable */
N
N/* Bit 19 : Write '1' to Enable interrupt for RXSTARTED event */
N#define TWIS_INTENSET_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
N#define TWIS_INTENSET_RXSTARTED_Msk (0x1UL << TWIS_INTENSET_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
N#define TWIS_INTENSET_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENSET_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENSET_RXSTARTED_Set (1UL) /*!< Enable */
N
N/* Bit 9 : Write '1' to Enable interrupt for ERROR event */
N#define TWIS_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWIS_INTENSET_ERROR_Msk (0x1UL << TWIS_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWIS_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENSET_ERROR_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
N#define TWIS_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWIS_INTENSET_STOPPED_Msk (0x1UL << TWIS_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWIS_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENSET_STOPPED_Set (1UL) /*!< Enable */
N
N/* Register: TWIS_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 26 : Write '1' to Disable interrupt for READ event */
N#define TWIS_INTENCLR_READ_Pos (26UL) /*!< Position of READ field. */
N#define TWIS_INTENCLR_READ_Msk (0x1UL << TWIS_INTENCLR_READ_Pos) /*!< Bit mask of READ field. */
N#define TWIS_INTENCLR_READ_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENCLR_READ_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENCLR_READ_Clear (1UL) /*!< Disable */
N
N/* Bit 25 : Write '1' to Disable interrupt for WRITE event */
N#define TWIS_INTENCLR_WRITE_Pos (25UL) /*!< Position of WRITE field. */
N#define TWIS_INTENCLR_WRITE_Msk (0x1UL << TWIS_INTENCLR_WRITE_Pos) /*!< Bit mask of WRITE field. */
N#define TWIS_INTENCLR_WRITE_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENCLR_WRITE_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENCLR_WRITE_Clear (1UL) /*!< Disable */
N
N/* Bit 20 : Write '1' to Disable interrupt for TXSTARTED event */
N#define TWIS_INTENCLR_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
N#define TWIS_INTENCLR_TXSTARTED_Msk (0x1UL << TWIS_INTENCLR_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
N#define TWIS_INTENCLR_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENCLR_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENCLR_TXSTARTED_Clear (1UL) /*!< Disable */
N
N/* Bit 19 : Write '1' to Disable interrupt for RXSTARTED event */
N#define TWIS_INTENCLR_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
N#define TWIS_INTENCLR_RXSTARTED_Msk (0x1UL << TWIS_INTENCLR_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
N#define TWIS_INTENCLR_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENCLR_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENCLR_RXSTARTED_Clear (1UL) /*!< Disable */
N
N/* Bit 9 : Write '1' to Disable interrupt for ERROR event */
N#define TWIS_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWIS_INTENCLR_ERROR_Msk (0x1UL << TWIS_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWIS_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
N#define TWIS_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWIS_INTENCLR_STOPPED_Msk (0x1UL << TWIS_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWIS_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define TWIS_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define TWIS_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
N
N/* Register: TWIS_ERRORSRC */
N/* Description: Error source */
N
N/* Bit 3 : TX buffer over-read detected, and prevented */
N#define TWIS_ERRORSRC_OVERREAD_Pos (3UL) /*!< Position of OVERREAD field. */
N#define TWIS_ERRORSRC_OVERREAD_Msk (0x1UL << TWIS_ERRORSRC_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
N#define TWIS_ERRORSRC_OVERREAD_NotDetected (0UL) /*!< Error did not occur */
N#define TWIS_ERRORSRC_OVERREAD_Detected (1UL) /*!< Error occurred */
N
N/* Bit 2 : NACK sent after receiving a data byte */
N#define TWIS_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
N#define TWIS_ERRORSRC_DNACK_Msk (0x1UL << TWIS_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
N#define TWIS_ERRORSRC_DNACK_NotReceived (0UL) /*!< Error did not occur */
N#define TWIS_ERRORSRC_DNACK_Received (1UL) /*!< Error occurred */
N
N/* Bit 0 : RX buffer overflow detected, and prevented */
N#define TWIS_ERRORSRC_OVERFLOW_Pos (0UL) /*!< Position of OVERFLOW field. */
N#define TWIS_ERRORSRC_OVERFLOW_Msk (0x1UL << TWIS_ERRORSRC_OVERFLOW_Pos) /*!< Bit mask of OVERFLOW field. */
N#define TWIS_ERRORSRC_OVERFLOW_NotDetected (0UL) /*!< Error did not occur */
N#define TWIS_ERRORSRC_OVERFLOW_Detected (1UL) /*!< Error occurred */
N
N/* Register: TWIS_MATCH */
N/* Description: Status register indicating which address had a match */
N
N/* Bit 0 : Which of the addresses in {ADDRESS} matched the incoming address */
N#define TWIS_MATCH_MATCH_Pos (0UL) /*!< Position of MATCH field. */
N#define TWIS_MATCH_MATCH_Msk (0x1UL << TWIS_MATCH_MATCH_Pos) /*!< Bit mask of MATCH field. */
N
N/* Register: TWIS_ENABLE */
N/* Description: Enable TWIS */
N
N/* Bits 3..0 : Enable or disable TWIS */
N#define TWIS_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define TWIS_ENABLE_ENABLE_Msk (0xFUL << TWIS_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define TWIS_ENABLE_ENABLE_Disabled (0UL) /*!< Disable TWIS */
N#define TWIS_ENABLE_ENABLE_Enabled (9UL) /*!< Enable TWIS */
N
N/* Register: TWIS_PSEL_SCL */
N/* Description: Pin select for SCL signal */
N
N/* Bit 31 : Connection */
N#define TWIS_PSEL_SCL_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define TWIS_PSEL_SCL_CONNECT_Msk (0x1UL << TWIS_PSEL_SCL_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define TWIS_PSEL_SCL_CONNECT_Connected (0UL) /*!< Connect */
N#define TWIS_PSEL_SCL_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define TWIS_PSEL_SCL_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define TWIS_PSEL_SCL_PIN_Msk (0x1FUL << TWIS_PSEL_SCL_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: TWIS_PSEL_SDA */
N/* Description: Pin select for SDA signal */
N
N/* Bit 31 : Connection */
N#define TWIS_PSEL_SDA_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define TWIS_PSEL_SDA_CONNECT_Msk (0x1UL << TWIS_PSEL_SDA_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define TWIS_PSEL_SDA_CONNECT_Connected (0UL) /*!< Connect */
N#define TWIS_PSEL_SDA_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define TWIS_PSEL_SDA_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define TWIS_PSEL_SDA_PIN_Msk (0x1FUL << TWIS_PSEL_SDA_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: TWIS_RXD_PTR */
N/* Description: RXD Data pointer */
N
N/* Bits 31..0 : RXD Data pointer */
N#define TWIS_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define TWIS_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIS_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: TWIS_RXD_MAXCNT */
N/* Description: Maximum number of bytes in RXD buffer */
N
N/* Bits 7..0 : Maximum number of bytes in RXD buffer */
N#define TWIS_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define TWIS_RXD_MAXCNT_MAXCNT_Msk (0xFFUL << TWIS_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: TWIS_RXD_AMOUNT */
N/* Description: Number of bytes transferred in the last RXD transaction */
N
N/* Bits 7..0 : Number of bytes transferred in the last RXD transaction */
N#define TWIS_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define TWIS_RXD_AMOUNT_AMOUNT_Msk (0xFFUL << TWIS_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N/* Register: TWIS_TXD_PTR */
N/* Description: TXD Data pointer */
N
N/* Bits 31..0 : TXD Data pointer */
N#define TWIS_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define TWIS_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIS_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: TWIS_TXD_MAXCNT */
N/* Description: Maximum number of bytes in TXD buffer */
N
N/* Bits 7..0 : Maximum number of bytes in TXD buffer */
N#define TWIS_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define TWIS_TXD_MAXCNT_MAXCNT_Msk (0xFFUL << TWIS_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: TWIS_TXD_AMOUNT */
N/* Description: Number of bytes transferred in the last TXD transaction */
N
N/* Bits 7..0 : Number of bytes transferred in the last TXD transaction */
N#define TWIS_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define TWIS_TXD_AMOUNT_AMOUNT_Msk (0xFFUL << TWIS_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N/* Register: TWIS_ADDRESS */
N/* Description: Description collection[0]:  TWI slave address 0 */
N
N/* Bits 6..0 : TWI slave address */
N#define TWIS_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
N#define TWIS_ADDRESS_ADDRESS_Msk (0x7FUL << TWIS_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N
N/* Register: TWIS_CONFIG */
N/* Description: Configuration register for the address match mechanism */
N
N/* Bit 1 : Enable or disable address matching on ADDRESS[1] */
N#define TWIS_CONFIG_ADDRESS1_Pos (1UL) /*!< Position of ADDRESS1 field. */
N#define TWIS_CONFIG_ADDRESS1_Msk (0x1UL << TWIS_CONFIG_ADDRESS1_Pos) /*!< Bit mask of ADDRESS1 field. */
N#define TWIS_CONFIG_ADDRESS1_Disabled (0UL) /*!< Disabled */
N#define TWIS_CONFIG_ADDRESS1_Enabled (1UL) /*!< Enabled */
N
N/* Bit 0 : Enable or disable address matching on ADDRESS[0] */
N#define TWIS_CONFIG_ADDRESS0_Pos (0UL) /*!< Position of ADDRESS0 field. */
N#define TWIS_CONFIG_ADDRESS0_Msk (0x1UL << TWIS_CONFIG_ADDRESS0_Pos) /*!< Bit mask of ADDRESS0 field. */
N#define TWIS_CONFIG_ADDRESS0_Disabled (0UL) /*!< Disabled */
N#define TWIS_CONFIG_ADDRESS0_Enabled (1UL) /*!< Enabled */
N
N/* Register: TWIS_ORC */
N/* Description: Over-read character. Character sent out in case of an over-read of the transmit buffer. */
N
N/* Bits 7..0 : Over-read character. Character sent out in case of an over-read of the transmit buffer. */
N#define TWIS_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
N#define TWIS_ORC_ORC_Msk (0xFFUL << TWIS_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
N
N
N/* Peripheral: UART */
N/* Description: Universal Asynchronous Receiver/Transmitter */
N
N/* Register: UART_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 4 : Shortcut between NCTS event and STOPRX task */
N#define UART_SHORTS_NCTS_STOPRX_Pos (4UL) /*!< Position of NCTS_STOPRX field. */
N#define UART_SHORTS_NCTS_STOPRX_Msk (0x1UL << UART_SHORTS_NCTS_STOPRX_Pos) /*!< Bit mask of NCTS_STOPRX field. */
N#define UART_SHORTS_NCTS_STOPRX_Disabled (0UL) /*!< Disable shortcut */
N#define UART_SHORTS_NCTS_STOPRX_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 3 : Shortcut between CTS event and STARTRX task */
N#define UART_SHORTS_CTS_STARTRX_Pos (3UL) /*!< Position of CTS_STARTRX field. */
N#define UART_SHORTS_CTS_STARTRX_Msk (0x1UL << UART_SHORTS_CTS_STARTRX_Pos) /*!< Bit mask of CTS_STARTRX field. */
N#define UART_SHORTS_CTS_STARTRX_Disabled (0UL) /*!< Disable shortcut */
N#define UART_SHORTS_CTS_STARTRX_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: UART_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 17 : Write '1' to Enable interrupt for RXTO event */
N#define UART_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UART_INTENSET_RXTO_Msk (0x1UL << UART_INTENSET_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UART_INTENSET_RXTO_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENSET_RXTO_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENSET_RXTO_Set (1UL) /*!< Enable */
N
N/* Bit 9 : Write '1' to Enable interrupt for ERROR event */
N#define UART_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UART_INTENSET_ERROR_Msk (0x1UL << UART_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UART_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENSET_ERROR_Set (1UL) /*!< Enable */
N
N/* Bit 7 : Write '1' to Enable interrupt for TXDRDY event */
N#define UART_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UART_INTENSET_TXDRDY_Msk (0x1UL << UART_INTENSET_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UART_INTENSET_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENSET_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENSET_TXDRDY_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for RXDRDY event */
N#define UART_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UART_INTENSET_RXDRDY_Msk (0x1UL << UART_INTENSET_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UART_INTENSET_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENSET_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENSET_RXDRDY_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for NCTS event */
N#define UART_INTENSET_NCTS_Pos (1UL) /*!< Position of NCTS field. */
N#define UART_INTENSET_NCTS_Msk (0x1UL << UART_INTENSET_NCTS_Pos) /*!< Bit mask of NCTS field. */
N#define UART_INTENSET_NCTS_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENSET_NCTS_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENSET_NCTS_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for CTS event */
N#define UART_INTENSET_CTS_Pos (0UL) /*!< Position of CTS field. */
N#define UART_INTENSET_CTS_Msk (0x1UL << UART_INTENSET_CTS_Pos) /*!< Bit mask of CTS field. */
N#define UART_INTENSET_CTS_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENSET_CTS_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENSET_CTS_Set (1UL) /*!< Enable */
N
N/* Register: UART_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 17 : Write '1' to Disable interrupt for RXTO event */
N#define UART_INTENCLR_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UART_INTENCLR_RXTO_Msk (0x1UL << UART_INTENCLR_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UART_INTENCLR_RXTO_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENCLR_RXTO_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENCLR_RXTO_Clear (1UL) /*!< Disable */
N
N/* Bit 9 : Write '1' to Disable interrupt for ERROR event */
N#define UART_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UART_INTENCLR_ERROR_Msk (0x1UL << UART_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UART_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
N
N/* Bit 7 : Write '1' to Disable interrupt for TXDRDY event */
N#define UART_INTENCLR_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UART_INTENCLR_TXDRDY_Msk (0x1UL << UART_INTENCLR_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UART_INTENCLR_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENCLR_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENCLR_TXDRDY_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for RXDRDY event */
N#define UART_INTENCLR_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UART_INTENCLR_RXDRDY_Msk (0x1UL << UART_INTENCLR_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UART_INTENCLR_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENCLR_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENCLR_RXDRDY_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for NCTS event */
N#define UART_INTENCLR_NCTS_Pos (1UL) /*!< Position of NCTS field. */
N#define UART_INTENCLR_NCTS_Msk (0x1UL << UART_INTENCLR_NCTS_Pos) /*!< Bit mask of NCTS field. */
N#define UART_INTENCLR_NCTS_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENCLR_NCTS_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENCLR_NCTS_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for CTS event */
N#define UART_INTENCLR_CTS_Pos (0UL) /*!< Position of CTS field. */
N#define UART_INTENCLR_CTS_Msk (0x1UL << UART_INTENCLR_CTS_Pos) /*!< Bit mask of CTS field. */
N#define UART_INTENCLR_CTS_Disabled (0UL) /*!< Read: Disabled */
N#define UART_INTENCLR_CTS_Enabled (1UL) /*!< Read: Enabled */
N#define UART_INTENCLR_CTS_Clear (1UL) /*!< Disable */
N
N/* Register: UART_ERRORSRC */
N/* Description: Error source */
N
N/* Bit 3 : Break condition */
N#define UART_ERRORSRC_BREAK_Pos (3UL) /*!< Position of BREAK field. */
N#define UART_ERRORSRC_BREAK_Msk (0x1UL << UART_ERRORSRC_BREAK_Pos) /*!< Bit mask of BREAK field. */
N#define UART_ERRORSRC_BREAK_NotPresent (0UL) /*!< Read: error not present */
N#define UART_ERRORSRC_BREAK_Present (1UL) /*!< Read: error present */
N
N/* Bit 2 : Framing error occurred */
N#define UART_ERRORSRC_FRAMING_Pos (2UL) /*!< Position of FRAMING field. */
N#define UART_ERRORSRC_FRAMING_Msk (0x1UL << UART_ERRORSRC_FRAMING_Pos) /*!< Bit mask of FRAMING field. */
N#define UART_ERRORSRC_FRAMING_NotPresent (0UL) /*!< Read: error not present */
N#define UART_ERRORSRC_FRAMING_Present (1UL) /*!< Read: error present */
N
N/* Bit 1 : Parity error */
N#define UART_ERRORSRC_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UART_ERRORSRC_PARITY_Msk (0x1UL << UART_ERRORSRC_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UART_ERRORSRC_PARITY_NotPresent (0UL) /*!< Read: error not present */
N#define UART_ERRORSRC_PARITY_Present (1UL) /*!< Read: error present */
N
N/* Bit 0 : Overrun error */
N#define UART_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
N#define UART_ERRORSRC_OVERRUN_Msk (0x1UL << UART_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
N#define UART_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Read: error not present */
N#define UART_ERRORSRC_OVERRUN_Present (1UL) /*!< Read: error present */
N
N/* Register: UART_ENABLE */
N/* Description: Enable UART */
N
N/* Bits 3..0 : Enable or disable UART */
N#define UART_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define UART_ENABLE_ENABLE_Msk (0xFUL << UART_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define UART_ENABLE_ENABLE_Disabled (0UL) /*!< Disable UART */
N#define UART_ENABLE_ENABLE_Enabled (4UL) /*!< Enable UART */
N
N/* Register: UART_PSELRTS */
N/* Description: Pin select for RTS */
N
N/* Bits 31..0 : Pin number configuration for UART RTS signal */
N#define UART_PSELRTS_PSELRTS_Pos (0UL) /*!< Position of PSELRTS field. */
N#define UART_PSELRTS_PSELRTS_Msk (0xFFFFFFFFUL << UART_PSELRTS_PSELRTS_Pos) /*!< Bit mask of PSELRTS field. */
N#define UART_PSELRTS_PSELRTS_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
N
N/* Register: UART_PSELTXD */
N/* Description: Pin select for TXD */
N
N/* Bits 31..0 : Pin number configuration for UART TXD signal */
N#define UART_PSELTXD_PSELTXD_Pos (0UL) /*!< Position of PSELTXD field. */
N#define UART_PSELTXD_PSELTXD_Msk (0xFFFFFFFFUL << UART_PSELTXD_PSELTXD_Pos) /*!< Bit mask of PSELTXD field. */
N#define UART_PSELTXD_PSELTXD_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
N
N/* Register: UART_PSELCTS */
N/* Description: Pin select for CTS */
N
N/* Bits 31..0 : Pin number configuration for UART CTS signal */
N#define UART_PSELCTS_PSELCTS_Pos (0UL) /*!< Position of PSELCTS field. */
N#define UART_PSELCTS_PSELCTS_Msk (0xFFFFFFFFUL << UART_PSELCTS_PSELCTS_Pos) /*!< Bit mask of PSELCTS field. */
N#define UART_PSELCTS_PSELCTS_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
N
N/* Register: UART_PSELRXD */
N/* Description: Pin select for RXD */
N
N/* Bits 31..0 : Pin number configuration for UART RXD signal */
N#define UART_PSELRXD_PSELRXD_Pos (0UL) /*!< Position of PSELRXD field. */
N#define UART_PSELRXD_PSELRXD_Msk (0xFFFFFFFFUL << UART_PSELRXD_PSELRXD_Pos) /*!< Bit mask of PSELRXD field. */
N#define UART_PSELRXD_PSELRXD_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
N
N/* Register: UART_RXD */
N/* Description: RXD register */
N
N/* Bits 7..0 : RX data received in previous transfers, double buffered */
N#define UART_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define UART_RXD_RXD_Msk (0xFFUL << UART_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: UART_TXD */
N/* Description: TXD register */
N
N/* Bits 7..0 : TX data to be transferred */
N#define UART_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define UART_TXD_TXD_Msk (0xFFUL << UART_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: UART_BAUDRATE */
N/* Description: Baud rate */
N
N/* Bits 31..0 : Baud rate */
N#define UART_BAUDRATE_BAUDRATE_Pos (0UL) /*!< Position of BAUDRATE field. */
N#define UART_BAUDRATE_BAUDRATE_Msk (0xFFFFFFFFUL << UART_BAUDRATE_BAUDRATE_Pos) /*!< Bit mask of BAUDRATE field. */
N#define UART_BAUDRATE_BAUDRATE_Baud1200 (0x0004F000UL) /*!< 1200 baud (actual rate: 1205) */
N#define UART_BAUDRATE_BAUDRATE_Baud2400 (0x0009D000UL) /*!< 2400 baud (actual rate: 2396) */
N#define UART_BAUDRATE_BAUDRATE_Baud4800 (0x0013B000UL) /*!< 4800 baud (actual rate: 4808) */
N#define UART_BAUDRATE_BAUDRATE_Baud9600 (0x00275000UL) /*!< 9600 baud (actual rate: 9598) */
N#define UART_BAUDRATE_BAUDRATE_Baud14400 (0x003B0000UL) /*!< 14400 baud (actual rate: 14414) */
N#define UART_BAUDRATE_BAUDRATE_Baud19200 (0x004EA000UL) /*!< 19200 baud (actual rate: 19208) */
N#define UART_BAUDRATE_BAUDRATE_Baud28800 (0x0075F000UL) /*!< 28800 baud (actual rate: 28829) */
N#define UART_BAUDRATE_BAUDRATE_Baud38400 (0x009D5000UL) /*!< 38400 baud (actual rate: 38462) */
N#define UART_BAUDRATE_BAUDRATE_Baud56000 (0x00E50000UL) /*!< 56000 baud (actual rate: 55944) */
N#define UART_BAUDRATE_BAUDRATE_Baud57600 (0x00EBF000UL) /*!< 57600 baud (actual rate: 57762) */
N#define UART_BAUDRATE_BAUDRATE_Baud76800 (0x013A9000UL) /*!< 76800 baud (actual rate: 76923) */
N#define UART_BAUDRATE_BAUDRATE_Baud115200 (0x01D7E000UL) /*!< 115200 baud (actual rate: 115942) */
N#define UART_BAUDRATE_BAUDRATE_Baud230400 (0x03AFB000UL) /*!< 230400 baud (actual rate: 231884) */
N#define UART_BAUDRATE_BAUDRATE_Baud250000 (0x04000000UL) /*!< 250000 baud */
N#define UART_BAUDRATE_BAUDRATE_Baud460800 (0x075F7000UL) /*!< 460800 baud (actual rate: 470588) */
N#define UART_BAUDRATE_BAUDRATE_Baud921600 (0x0EBED000UL) /*!< 921600 baud (actual rate: 941176) */
N#define UART_BAUDRATE_BAUDRATE_Baud1M (0x10000000UL) /*!< 1Mega baud */
N
N/* Register: UART_CONFIG */
N/* Description: Configuration of parity and hardware flow control */
N
N/* Bits 3..1 : Parity */
N#define UART_CONFIG_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UART_CONFIG_PARITY_Msk (0x7UL << UART_CONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UART_CONFIG_PARITY_Excluded (0x0UL) /*!< Exclude parity bit */
N#define UART_CONFIG_PARITY_Included (0x7UL) /*!< Include parity bit */
N
N/* Bit 0 : Hardware flow control */
N#define UART_CONFIG_HWFC_Pos (0UL) /*!< Position of HWFC field. */
N#define UART_CONFIG_HWFC_Msk (0x1UL << UART_CONFIG_HWFC_Pos) /*!< Bit mask of HWFC field. */
N#define UART_CONFIG_HWFC_Disabled (0UL) /*!< Disabled */
N#define UART_CONFIG_HWFC_Enabled (1UL) /*!< Enabled */
N
N
N/* Peripheral: UARTE */
N/* Description: UART with EasyDMA */
N
N/* Register: UARTE_SHORTS */
N/* Description: Shortcut register */
N
N/* Bit 6 : Shortcut between ENDRX event and STOPRX task */
N#define UARTE_SHORTS_ENDRX_STOPRX_Pos (6UL) /*!< Position of ENDRX_STOPRX field. */
N#define UARTE_SHORTS_ENDRX_STOPRX_Msk (0x1UL << UARTE_SHORTS_ENDRX_STOPRX_Pos) /*!< Bit mask of ENDRX_STOPRX field. */
N#define UARTE_SHORTS_ENDRX_STOPRX_Disabled (0UL) /*!< Disable shortcut */
N#define UARTE_SHORTS_ENDRX_STOPRX_Enabled (1UL) /*!< Enable shortcut */
N
N/* Bit 5 : Shortcut between ENDRX event and STARTRX task */
N#define UARTE_SHORTS_ENDRX_STARTRX_Pos (5UL) /*!< Position of ENDRX_STARTRX field. */
N#define UARTE_SHORTS_ENDRX_STARTRX_Msk (0x1UL << UARTE_SHORTS_ENDRX_STARTRX_Pos) /*!< Bit mask of ENDRX_STARTRX field. */
N#define UARTE_SHORTS_ENDRX_STARTRX_Disabled (0UL) /*!< Disable shortcut */
N#define UARTE_SHORTS_ENDRX_STARTRX_Enabled (1UL) /*!< Enable shortcut */
N
N/* Register: UARTE_INTEN */
N/* Description: Enable or disable interrupt */
N
N/* Bit 22 : Enable or disable interrupt for TXSTOPPED event */
N#define UARTE_INTEN_TXSTOPPED_Pos (22UL) /*!< Position of TXSTOPPED field. */
N#define UARTE_INTEN_TXSTOPPED_Msk (0x1UL << UARTE_INTEN_TXSTOPPED_Pos) /*!< Bit mask of TXSTOPPED field. */
N#define UARTE_INTEN_TXSTOPPED_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_TXSTOPPED_Enabled (1UL) /*!< Enable */
N
N/* Bit 20 : Enable or disable interrupt for TXSTARTED event */
N#define UARTE_INTEN_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
N#define UARTE_INTEN_TXSTARTED_Msk (0x1UL << UARTE_INTEN_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
N#define UARTE_INTEN_TXSTARTED_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_TXSTARTED_Enabled (1UL) /*!< Enable */
N
N/* Bit 19 : Enable or disable interrupt for RXSTARTED event */
N#define UARTE_INTEN_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
N#define UARTE_INTEN_RXSTARTED_Msk (0x1UL << UARTE_INTEN_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
N#define UARTE_INTEN_RXSTARTED_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_RXSTARTED_Enabled (1UL) /*!< Enable */
N
N/* Bit 17 : Enable or disable interrupt for RXTO event */
N#define UARTE_INTEN_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UARTE_INTEN_RXTO_Msk (0x1UL << UARTE_INTEN_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UARTE_INTEN_RXTO_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_RXTO_Enabled (1UL) /*!< Enable */
N
N/* Bit 9 : Enable or disable interrupt for ERROR event */
N#define UARTE_INTEN_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UARTE_INTEN_ERROR_Msk (0x1UL << UARTE_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UARTE_INTEN_ERROR_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_ERROR_Enabled (1UL) /*!< Enable */
N
N/* Bit 8 : Enable or disable interrupt for ENDTX event */
N#define UARTE_INTEN_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
N#define UARTE_INTEN_ENDTX_Msk (0x1UL << UARTE_INTEN_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
N#define UARTE_INTEN_ENDTX_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_ENDTX_Enabled (1UL) /*!< Enable */
N
N/* Bit 7 : Enable or disable interrupt for TXDRDY event */
N#define UARTE_INTEN_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UARTE_INTEN_TXDRDY_Msk (0x1UL << UARTE_INTEN_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UARTE_INTEN_TXDRDY_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_TXDRDY_Enabled (1UL) /*!< Enable */
N
N/* Bit 4 : Enable or disable interrupt for ENDRX event */
N#define UARTE_INTEN_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define UARTE_INTEN_ENDRX_Msk (0x1UL << UARTE_INTEN_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define UARTE_INTEN_ENDRX_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_ENDRX_Enabled (1UL) /*!< Enable */
N
N/* Bit 2 : Enable or disable interrupt for RXDRDY event */
N#define UARTE_INTEN_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UARTE_INTEN_RXDRDY_Msk (0x1UL << UARTE_INTEN_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UARTE_INTEN_RXDRDY_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_RXDRDY_Enabled (1UL) /*!< Enable */
N
N/* Bit 1 : Enable or disable interrupt for NCTS event */
N#define UARTE_INTEN_NCTS_Pos (1UL) /*!< Position of NCTS field. */
N#define UARTE_INTEN_NCTS_Msk (0x1UL << UARTE_INTEN_NCTS_Pos) /*!< Bit mask of NCTS field. */
N#define UARTE_INTEN_NCTS_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_NCTS_Enabled (1UL) /*!< Enable */
N
N/* Bit 0 : Enable or disable interrupt for CTS event */
N#define UARTE_INTEN_CTS_Pos (0UL) /*!< Position of CTS field. */
N#define UARTE_INTEN_CTS_Msk (0x1UL << UARTE_INTEN_CTS_Pos) /*!< Bit mask of CTS field. */
N#define UARTE_INTEN_CTS_Disabled (0UL) /*!< Disable */
N#define UARTE_INTEN_CTS_Enabled (1UL) /*!< Enable */
N
N/* Register: UARTE_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 22 : Write '1' to Enable interrupt for TXSTOPPED event */
N#define UARTE_INTENSET_TXSTOPPED_Pos (22UL) /*!< Position of TXSTOPPED field. */
N#define UARTE_INTENSET_TXSTOPPED_Msk (0x1UL << UARTE_INTENSET_TXSTOPPED_Pos) /*!< Bit mask of TXSTOPPED field. */
N#define UARTE_INTENSET_TXSTOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_TXSTOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_TXSTOPPED_Set (1UL) /*!< Enable */
N
N/* Bit 20 : Write '1' to Enable interrupt for TXSTARTED event */
N#define UARTE_INTENSET_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
N#define UARTE_INTENSET_TXSTARTED_Msk (0x1UL << UARTE_INTENSET_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
N#define UARTE_INTENSET_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_TXSTARTED_Set (1UL) /*!< Enable */
N
N/* Bit 19 : Write '1' to Enable interrupt for RXSTARTED event */
N#define UARTE_INTENSET_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
N#define UARTE_INTENSET_RXSTARTED_Msk (0x1UL << UARTE_INTENSET_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
N#define UARTE_INTENSET_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_RXSTARTED_Set (1UL) /*!< Enable */
N
N/* Bit 17 : Write '1' to Enable interrupt for RXTO event */
N#define UARTE_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UARTE_INTENSET_RXTO_Msk (0x1UL << UARTE_INTENSET_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UARTE_INTENSET_RXTO_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_RXTO_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_RXTO_Set (1UL) /*!< Enable */
N
N/* Bit 9 : Write '1' to Enable interrupt for ERROR event */
N#define UARTE_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UARTE_INTENSET_ERROR_Msk (0x1UL << UARTE_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UARTE_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_ERROR_Set (1UL) /*!< Enable */
N
N/* Bit 8 : Write '1' to Enable interrupt for ENDTX event */
N#define UARTE_INTENSET_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
N#define UARTE_INTENSET_ENDTX_Msk (0x1UL << UARTE_INTENSET_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
N#define UARTE_INTENSET_ENDTX_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_ENDTX_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_ENDTX_Set (1UL) /*!< Enable */
N
N/* Bit 7 : Write '1' to Enable interrupt for TXDRDY event */
N#define UARTE_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UARTE_INTENSET_TXDRDY_Msk (0x1UL << UARTE_INTENSET_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UARTE_INTENSET_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_TXDRDY_Set (1UL) /*!< Enable */
N
N/* Bit 4 : Write '1' to Enable interrupt for ENDRX event */
N#define UARTE_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define UARTE_INTENSET_ENDRX_Msk (0x1UL << UARTE_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define UARTE_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_ENDRX_Set (1UL) /*!< Enable */
N
N/* Bit 2 : Write '1' to Enable interrupt for RXDRDY event */
N#define UARTE_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UARTE_INTENSET_RXDRDY_Msk (0x1UL << UARTE_INTENSET_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UARTE_INTENSET_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_RXDRDY_Set (1UL) /*!< Enable */
N
N/* Bit 1 : Write '1' to Enable interrupt for NCTS event */
N#define UARTE_INTENSET_NCTS_Pos (1UL) /*!< Position of NCTS field. */
N#define UARTE_INTENSET_NCTS_Msk (0x1UL << UARTE_INTENSET_NCTS_Pos) /*!< Bit mask of NCTS field. */
N#define UARTE_INTENSET_NCTS_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_NCTS_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_NCTS_Set (1UL) /*!< Enable */
N
N/* Bit 0 : Write '1' to Enable interrupt for CTS event */
N#define UARTE_INTENSET_CTS_Pos (0UL) /*!< Position of CTS field. */
N#define UARTE_INTENSET_CTS_Msk (0x1UL << UARTE_INTENSET_CTS_Pos) /*!< Bit mask of CTS field. */
N#define UARTE_INTENSET_CTS_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENSET_CTS_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENSET_CTS_Set (1UL) /*!< Enable */
N
N/* Register: UARTE_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 22 : Write '1' to Disable interrupt for TXSTOPPED event */
N#define UARTE_INTENCLR_TXSTOPPED_Pos (22UL) /*!< Position of TXSTOPPED field. */
N#define UARTE_INTENCLR_TXSTOPPED_Msk (0x1UL << UARTE_INTENCLR_TXSTOPPED_Pos) /*!< Bit mask of TXSTOPPED field. */
N#define UARTE_INTENCLR_TXSTOPPED_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_TXSTOPPED_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_TXSTOPPED_Clear (1UL) /*!< Disable */
N
N/* Bit 20 : Write '1' to Disable interrupt for TXSTARTED event */
N#define UARTE_INTENCLR_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
N#define UARTE_INTENCLR_TXSTARTED_Msk (0x1UL << UARTE_INTENCLR_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
N#define UARTE_INTENCLR_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_TXSTARTED_Clear (1UL) /*!< Disable */
N
N/* Bit 19 : Write '1' to Disable interrupt for RXSTARTED event */
N#define UARTE_INTENCLR_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
N#define UARTE_INTENCLR_RXSTARTED_Msk (0x1UL << UARTE_INTENCLR_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
N#define UARTE_INTENCLR_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_RXSTARTED_Clear (1UL) /*!< Disable */
N
N/* Bit 17 : Write '1' to Disable interrupt for RXTO event */
N#define UARTE_INTENCLR_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UARTE_INTENCLR_RXTO_Msk (0x1UL << UARTE_INTENCLR_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UARTE_INTENCLR_RXTO_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_RXTO_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_RXTO_Clear (1UL) /*!< Disable */
N
N/* Bit 9 : Write '1' to Disable interrupt for ERROR event */
N#define UARTE_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UARTE_INTENCLR_ERROR_Msk (0x1UL << UARTE_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UARTE_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
N
N/* Bit 8 : Write '1' to Disable interrupt for ENDTX event */
N#define UARTE_INTENCLR_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
N#define UARTE_INTENCLR_ENDTX_Msk (0x1UL << UARTE_INTENCLR_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
N#define UARTE_INTENCLR_ENDTX_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_ENDTX_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_ENDTX_Clear (1UL) /*!< Disable */
N
N/* Bit 7 : Write '1' to Disable interrupt for TXDRDY event */
N#define UARTE_INTENCLR_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UARTE_INTENCLR_TXDRDY_Msk (0x1UL << UARTE_INTENCLR_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UARTE_INTENCLR_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_TXDRDY_Clear (1UL) /*!< Disable */
N
N/* Bit 4 : Write '1' to Disable interrupt for ENDRX event */
N#define UARTE_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define UARTE_INTENCLR_ENDRX_Msk (0x1UL << UARTE_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define UARTE_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
N
N/* Bit 2 : Write '1' to Disable interrupt for RXDRDY event */
N#define UARTE_INTENCLR_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UARTE_INTENCLR_RXDRDY_Msk (0x1UL << UARTE_INTENCLR_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UARTE_INTENCLR_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_RXDRDY_Clear (1UL) /*!< Disable */
N
N/* Bit 1 : Write '1' to Disable interrupt for NCTS event */
N#define UARTE_INTENCLR_NCTS_Pos (1UL) /*!< Position of NCTS field. */
N#define UARTE_INTENCLR_NCTS_Msk (0x1UL << UARTE_INTENCLR_NCTS_Pos) /*!< Bit mask of NCTS field. */
N#define UARTE_INTENCLR_NCTS_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_NCTS_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_NCTS_Clear (1UL) /*!< Disable */
N
N/* Bit 0 : Write '1' to Disable interrupt for CTS event */
N#define UARTE_INTENCLR_CTS_Pos (0UL) /*!< Position of CTS field. */
N#define UARTE_INTENCLR_CTS_Msk (0x1UL << UARTE_INTENCLR_CTS_Pos) /*!< Bit mask of CTS field. */
N#define UARTE_INTENCLR_CTS_Disabled (0UL) /*!< Read: Disabled */
N#define UARTE_INTENCLR_CTS_Enabled (1UL) /*!< Read: Enabled */
N#define UARTE_INTENCLR_CTS_Clear (1UL) /*!< Disable */
N
N/* Register: UARTE_ERRORSRC */
N/* Description: Error source */
N
N/* Bit 3 : Break condition */
N#define UARTE_ERRORSRC_BREAK_Pos (3UL) /*!< Position of BREAK field. */
N#define UARTE_ERRORSRC_BREAK_Msk (0x1UL << UARTE_ERRORSRC_BREAK_Pos) /*!< Bit mask of BREAK field. */
N#define UARTE_ERRORSRC_BREAK_NotPresent (0UL) /*!< Read: error not present */
N#define UARTE_ERRORSRC_BREAK_Present (1UL) /*!< Read: error present */
N
N/* Bit 2 : Framing error occurred */
N#define UARTE_ERRORSRC_FRAMING_Pos (2UL) /*!< Position of FRAMING field. */
N#define UARTE_ERRORSRC_FRAMING_Msk (0x1UL << UARTE_ERRORSRC_FRAMING_Pos) /*!< Bit mask of FRAMING field. */
N#define UARTE_ERRORSRC_FRAMING_NotPresent (0UL) /*!< Read: error not present */
N#define UARTE_ERRORSRC_FRAMING_Present (1UL) /*!< Read: error present */
N
N/* Bit 1 : Parity error */
N#define UARTE_ERRORSRC_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UARTE_ERRORSRC_PARITY_Msk (0x1UL << UARTE_ERRORSRC_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UARTE_ERRORSRC_PARITY_NotPresent (0UL) /*!< Read: error not present */
N#define UARTE_ERRORSRC_PARITY_Present (1UL) /*!< Read: error present */
N
N/* Bit 0 : Overrun error */
N#define UARTE_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
N#define UARTE_ERRORSRC_OVERRUN_Msk (0x1UL << UARTE_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
N#define UARTE_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Read: error not present */
N#define UARTE_ERRORSRC_OVERRUN_Present (1UL) /*!< Read: error present */
N
N/* Register: UARTE_ENABLE */
N/* Description: Enable UART */
N
N/* Bits 3..0 : Enable or disable UARTE */
N#define UARTE_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define UARTE_ENABLE_ENABLE_Msk (0xFUL << UARTE_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define UARTE_ENABLE_ENABLE_Disabled (0UL) /*!< Disable UARTE */
N#define UARTE_ENABLE_ENABLE_Enabled (8UL) /*!< Enable UARTE */
N
N/* Register: UARTE_PSEL_RTS */
N/* Description: Pin select for RTS signal */
N
N/* Bit 31 : Connection */
N#define UARTE_PSEL_RTS_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define UARTE_PSEL_RTS_CONNECT_Msk (0x1UL << UARTE_PSEL_RTS_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define UARTE_PSEL_RTS_CONNECT_Connected (0UL) /*!< Connect */
N#define UARTE_PSEL_RTS_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define UARTE_PSEL_RTS_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define UARTE_PSEL_RTS_PIN_Msk (0x1FUL << UARTE_PSEL_RTS_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: UARTE_PSEL_TXD */
N/* Description: Pin select for TXD signal */
N
N/* Bit 31 : Connection */
N#define UARTE_PSEL_TXD_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define UARTE_PSEL_TXD_CONNECT_Msk (0x1UL << UARTE_PSEL_TXD_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define UARTE_PSEL_TXD_CONNECT_Connected (0UL) /*!< Connect */
N#define UARTE_PSEL_TXD_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define UARTE_PSEL_TXD_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define UARTE_PSEL_TXD_PIN_Msk (0x1FUL << UARTE_PSEL_TXD_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: UARTE_PSEL_CTS */
N/* Description: Pin select for CTS signal */
N
N/* Bit 31 : Connection */
N#define UARTE_PSEL_CTS_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define UARTE_PSEL_CTS_CONNECT_Msk (0x1UL << UARTE_PSEL_CTS_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define UARTE_PSEL_CTS_CONNECT_Connected (0UL) /*!< Connect */
N#define UARTE_PSEL_CTS_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define UARTE_PSEL_CTS_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define UARTE_PSEL_CTS_PIN_Msk (0x1FUL << UARTE_PSEL_CTS_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: UARTE_PSEL_RXD */
N/* Description: Pin select for RXD signal */
N
N/* Bit 31 : Connection */
N#define UARTE_PSEL_RXD_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define UARTE_PSEL_RXD_CONNECT_Msk (0x1UL << UARTE_PSEL_RXD_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define UARTE_PSEL_RXD_CONNECT_Connected (0UL) /*!< Connect */
N#define UARTE_PSEL_RXD_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : Pin number */
N#define UARTE_PSEL_RXD_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define UARTE_PSEL_RXD_PIN_Msk (0x1FUL << UARTE_PSEL_RXD_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: UARTE_BAUDRATE */
N/* Description: Baud rate. Accuracy depends on the HFCLK source selected. */
N
N/* Bits 31..0 : Baud rate */
N#define UARTE_BAUDRATE_BAUDRATE_Pos (0UL) /*!< Position of BAUDRATE field. */
N#define UARTE_BAUDRATE_BAUDRATE_Msk (0xFFFFFFFFUL << UARTE_BAUDRATE_BAUDRATE_Pos) /*!< Bit mask of BAUDRATE field. */
N#define UARTE_BAUDRATE_BAUDRATE_Baud1200 (0x0004F000UL) /*!< 1200 baud (actual rate: 1205) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud2400 (0x0009D000UL) /*!< 2400 baud (actual rate: 2396) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud4800 (0x0013B000UL) /*!< 4800 baud (actual rate: 4808) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud9600 (0x00275000UL) /*!< 9600 baud (actual rate: 9598) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud14400 (0x003AF000UL) /*!< 14400 baud (actual rate: 14401) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud19200 (0x004EA000UL) /*!< 19200 baud (actual rate: 19208) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud28800 (0x0075C000UL) /*!< 28800 baud (actual rate: 28777) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud38400 (0x009D0000UL) /*!< 38400 baud (actual rate: 38369) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud56000 (0x00E50000UL) /*!< 56000 baud (actual rate: 55944) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud57600 (0x00EB0000UL) /*!< 57600 baud (actual rate: 57554) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud76800 (0x013A9000UL) /*!< 76800 baud (actual rate: 76923) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud115200 (0x01D60000UL) /*!< 115200 baud (actual rate: 115108) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud230400 (0x03B00000UL) /*!< 230400 baud (actual rate: 231884) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud250000 (0x04000000UL) /*!< 250000 baud */
N#define UARTE_BAUDRATE_BAUDRATE_Baud460800 (0x07400000UL) /*!< 460800 baud (actual rate: 457143) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud921600 (0x0F000000UL) /*!< 921600 baud (actual rate: 941176) */
N#define UARTE_BAUDRATE_BAUDRATE_Baud1M (0x10000000UL) /*!< 1Mega baud */
N
N/* Register: UARTE_RXD_PTR */
N/* Description: Data pointer */
N
N/* Bits 31..0 : Data pointer */
N#define UARTE_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define UARTE_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << UARTE_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: UARTE_RXD_MAXCNT */
N/* Description: Maximum number of bytes in receive buffer */
N
N/* Bits 7..0 : Maximum number of bytes in receive buffer */
N#define UARTE_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define UARTE_RXD_MAXCNT_MAXCNT_Msk (0xFFUL << UARTE_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: UARTE_RXD_AMOUNT */
N/* Description: Number of bytes transferred in the last transaction */
N
N/* Bits 7..0 : Number of bytes transferred in the last transaction */
N#define UARTE_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define UARTE_RXD_AMOUNT_AMOUNT_Msk (0xFFUL << UARTE_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N/* Register: UARTE_TXD_PTR */
N/* Description: Data pointer */
N
N/* Bits 31..0 : Data pointer */
N#define UARTE_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
N#define UARTE_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << UARTE_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
N
N/* Register: UARTE_TXD_MAXCNT */
N/* Description: Maximum number of bytes in transmit buffer */
N
N/* Bits 7..0 : Maximum number of bytes in transmit buffer */
N#define UARTE_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
N#define UARTE_TXD_MAXCNT_MAXCNT_Msk (0xFFUL << UARTE_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
N
N/* Register: UARTE_TXD_AMOUNT */
N/* Description: Number of bytes transferred in the last transaction */
N
N/* Bits 7..0 : Number of bytes transferred in the last transaction */
N#define UARTE_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
N#define UARTE_TXD_AMOUNT_AMOUNT_Msk (0xFFUL << UARTE_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
N
N/* Register: UARTE_CONFIG */
N/* Description: Configuration of parity and hardware flow control */
N
N/* Bits 3..1 : Parity */
N#define UARTE_CONFIG_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UARTE_CONFIG_PARITY_Msk (0x7UL << UARTE_CONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UARTE_CONFIG_PARITY_Excluded (0x0UL) /*!< Exclude parity bit */
N#define UARTE_CONFIG_PARITY_Included (0x7UL) /*!< Include parity bit */
N
N/* Bit 0 : Hardware flow control */
N#define UARTE_CONFIG_HWFC_Pos (0UL) /*!< Position of HWFC field. */
N#define UARTE_CONFIG_HWFC_Msk (0x1UL << UARTE_CONFIG_HWFC_Pos) /*!< Bit mask of HWFC field. */
N#define UARTE_CONFIG_HWFC_Disabled (0UL) /*!< Disabled */
N#define UARTE_CONFIG_HWFC_Enabled (1UL) /*!< Enabled */
N
N
N/* Peripheral: UICR */
N/* Description: User Information Configuration Registers */
N
N/* Register: UICR_NRFFW */
N/* Description: Description collection[0]:  Reserved for Nordic firmware design */
N
N/* Bits 31..0 : Reserved for Nordic firmware design */
N#define UICR_NRFFW_NRFFW_Pos (0UL) /*!< Position of NRFFW field. */
N#define UICR_NRFFW_NRFFW_Msk (0xFFFFFFFFUL << UICR_NRFFW_NRFFW_Pos) /*!< Bit mask of NRFFW field. */
N
N/* Register: UICR_NRFHW */
N/* Description: Description collection[0]:  Reserved for Nordic hardware design */
N
N/* Bits 31..0 : Reserved for Nordic hardware design */
N#define UICR_NRFHW_NRFHW_Pos (0UL) /*!< Position of NRFHW field. */
N#define UICR_NRFHW_NRFHW_Msk (0xFFFFFFFFUL << UICR_NRFHW_NRFHW_Pos) /*!< Bit mask of NRFHW field. */
N
N/* Register: UICR_CUSTOMER */
N/* Description: Description collection[0]:  Reserved for customer */
N
N/* Bits 31..0 : Reserved for customer */
N#define UICR_CUSTOMER_CUSTOMER_Pos (0UL) /*!< Position of CUSTOMER field. */
N#define UICR_CUSTOMER_CUSTOMER_Msk (0xFFFFFFFFUL << UICR_CUSTOMER_CUSTOMER_Pos) /*!< Bit mask of CUSTOMER field. */
N
N/* Register: UICR_PSELRESET */
N/* Description: Description collection[0]:  Mapping of the nRESET function (see POWER chapter for details) */
N
N/* Bit 31 : Connection */
N#define UICR_PSELRESET_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
N#define UICR_PSELRESET_CONNECT_Msk (0x1UL << UICR_PSELRESET_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
N#define UICR_PSELRESET_CONNECT_Connected (0UL) /*!< Connect */
N#define UICR_PSELRESET_CONNECT_Disconnected (1UL) /*!< Disconnect */
N
N/* Bits 4..0 : GPIO number P0.n onto which Reset is exposed */
N#define UICR_PSELRESET_PIN_Pos (0UL) /*!< Position of PIN field. */
N#define UICR_PSELRESET_PIN_Msk (0x1FUL << UICR_PSELRESET_PIN_Pos) /*!< Bit mask of PIN field. */
N
N/* Register: UICR_APPROTECT */
N/* Description: Access Port protection */
N
N/* Bits 7..0 : Enable or disable Access Port protection. Any other value than 0xFF being written to this field will enable protection. */
N#define UICR_APPROTECT_PALL_Pos (0UL) /*!< Position of PALL field. */
N#define UICR_APPROTECT_PALL_Msk (0xFFUL << UICR_APPROTECT_PALL_Pos) /*!< Bit mask of PALL field. */
N#define UICR_APPROTECT_PALL_Enabled (0x00UL) /*!< Enable */
N#define UICR_APPROTECT_PALL_Disabled (0xFFUL) /*!< Disable */
N
N/* Register: UICR_NFCPINS */
N/* Description: Setting of pins dedicated to NFC functionality: NFC antenna or GPIO */
N
N/* Bit 0 : Setting of pins dedicated to NFC functionality */
N#define UICR_NFCPINS_PROTECT_Pos (0UL) /*!< Position of PROTECT field. */
N#define UICR_NFCPINS_PROTECT_Msk (0x1UL << UICR_NFCPINS_PROTECT_Pos) /*!< Bit mask of PROTECT field. */
N#define UICR_NFCPINS_PROTECT_Disabled (0UL) /*!< Operation as GPIO pins. Same protection as normal GPIO pins */
N#define UICR_NFCPINS_PROTECT_NFC (1UL) /*!< Operation as NFC antenna pins. Configures the protection for NFC operation */
N
N
N/* Peripheral: WDT */
N/* Description: Watchdog Timer */
N
N/* Register: WDT_INTENSET */
N/* Description: Enable interrupt */
N
N/* Bit 0 : Write '1' to Enable interrupt for TIMEOUT event */
N#define WDT_INTENSET_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
N#define WDT_INTENSET_TIMEOUT_Msk (0x1UL << WDT_INTENSET_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
N#define WDT_INTENSET_TIMEOUT_Disabled (0UL) /*!< Read: Disabled */
N#define WDT_INTENSET_TIMEOUT_Enabled (1UL) /*!< Read: Enabled */
N#define WDT_INTENSET_TIMEOUT_Set (1UL) /*!< Enable */
N
N/* Register: WDT_INTENCLR */
N/* Description: Disable interrupt */
N
N/* Bit 0 : Write '1' to Disable interrupt for TIMEOUT event */
N#define WDT_INTENCLR_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
N#define WDT_INTENCLR_TIMEOUT_Msk (0x1UL << WDT_INTENCLR_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
N#define WDT_INTENCLR_TIMEOUT_Disabled (0UL) /*!< Read: Disabled */
N#define WDT_INTENCLR_TIMEOUT_Enabled (1UL) /*!< Read: Enabled */
N#define WDT_INTENCLR_TIMEOUT_Clear (1UL) /*!< Disable */
N
N/* Register: WDT_RUNSTATUS */
N/* Description: Run status */
N
N/* Bit 0 : Indicates whether or not the watchdog is running */
N#define WDT_RUNSTATUS_RUNSTATUS_Pos (0UL) /*!< Position of RUNSTATUS field. */
N#define WDT_RUNSTATUS_RUNSTATUS_Msk (0x1UL << WDT_RUNSTATUS_RUNSTATUS_Pos) /*!< Bit mask of RUNSTATUS field. */
N#define WDT_RUNSTATUS_RUNSTATUS_NotRunning (0UL) /*!< Watchdog not running */
N#define WDT_RUNSTATUS_RUNSTATUS_Running (1UL) /*!< Watchdog is running */
N
N/* Register: WDT_REQSTATUS */
N/* Description: Request status */
N
N/* Bit 7 : Request status for RR[7] register */
N#define WDT_REQSTATUS_RR7_Pos (7UL) /*!< Position of RR7 field. */
N#define WDT_REQSTATUS_RR7_Msk (0x1UL << WDT_REQSTATUS_RR7_Pos) /*!< Bit mask of RR7 field. */
N#define WDT_REQSTATUS_RR7_DisabledOrRequested (0UL) /*!< RR[7] register is not enabled, or are already requesting reload */
N#define WDT_REQSTATUS_RR7_EnabledAndUnrequested (1UL) /*!< RR[7] register is enabled, and are not yet requesting reload */
N
N/* Bit 6 : Request status for RR[6] register */
N#define WDT_REQSTATUS_RR6_Pos (6UL) /*!< Position of RR6 field. */
N#define WDT_REQSTATUS_RR6_Msk (0x1UL << WDT_REQSTATUS_RR6_Pos) /*!< Bit mask of RR6 field. */
N#define WDT_REQSTATUS_RR6_DisabledOrRequested (0UL) /*!< RR[6] register is not enabled, or are already requesting reload */
N#define WDT_REQSTATUS_RR6_EnabledAndUnrequested (1UL) /*!< RR[6] register is enabled, and are not yet requesting reload */
N
N/* Bit 5 : Request status for RR[5] register */
N#define WDT_REQSTATUS_RR5_Pos (5UL) /*!< Position of RR5 field. */
N#define WDT_REQSTATUS_RR5_Msk (0x1UL << WDT_REQSTATUS_RR5_Pos) /*!< Bit mask of RR5 field. */
N#define WDT_REQSTATUS_RR5_DisabledOrRequested (0UL) /*!< RR[5] register is not enabled, or are already requesting reload */
N#define WDT_REQSTATUS_RR5_EnabledAndUnrequested (1UL) /*!< RR[5] register is enabled, and are not yet requesting reload */
N
N/* Bit 4 : Request status for RR[4] register */
N#define WDT_REQSTATUS_RR4_Pos (4UL) /*!< Position of RR4 field. */
N#define WDT_REQSTATUS_RR4_Msk (0x1UL << WDT_REQSTATUS_RR4_Pos) /*!< Bit mask of RR4 field. */
N#define WDT_REQSTATUS_RR4_DisabledOrRequested (0UL) /*!< RR[4] register is not enabled, or are already requesting reload */
N#define WDT_REQSTATUS_RR4_EnabledAndUnrequested (1UL) /*!< RR[4] register is enabled, and are not yet requesting reload */
N
N/* Bit 3 : Request status for RR[3] register */
N#define WDT_REQSTATUS_RR3_Pos (3UL) /*!< Position of RR3 field. */
N#define WDT_REQSTATUS_RR3_Msk (0x1UL << WDT_REQSTATUS_RR3_Pos) /*!< Bit mask of RR3 field. */
N#define WDT_REQSTATUS_RR3_DisabledOrRequested (0UL) /*!< RR[3] register is not enabled, or are already requesting reload */
N#define WDT_REQSTATUS_RR3_EnabledAndUnrequested (1UL) /*!< RR[3] register is enabled, and are not yet requesting reload */
N
N/* Bit 2 : Request status for RR[2] register */
N#define WDT_REQSTATUS_RR2_Pos (2UL) /*!< Position of RR2 field. */
N#define WDT_REQSTATUS_RR2_Msk (0x1UL << WDT_REQSTATUS_RR2_Pos) /*!< Bit mask of RR2 field. */
N#define WDT_REQSTATUS_RR2_DisabledOrRequested (0UL) /*!< RR[2] register is not enabled, or are already requesting reload */
N#define WDT_REQSTATUS_RR2_EnabledAndUnrequested (1UL) /*!< RR[2] register is enabled, and are not yet requesting reload */
N
N/* Bit 1 : Request status for RR[1] register */
N#define WDT_REQSTATUS_RR1_Pos (1UL) /*!< Position of RR1 field. */
N#define WDT_REQSTATUS_RR1_Msk (0x1UL << WDT_REQSTATUS_RR1_Pos) /*!< Bit mask of RR1 field. */
N#define WDT_REQSTATUS_RR1_DisabledOrRequested (0UL) /*!< RR[1] register is not enabled, or are already requesting reload */
N#define WDT_REQSTATUS_RR1_EnabledAndUnrequested (1UL) /*!< RR[1] register is enabled, and are not yet requesting reload */
N
N/* Bit 0 : Request status for RR[0] register */
N#define WDT_REQSTATUS_RR0_Pos (0UL) /*!< Position of RR0 field. */
N#define WDT_REQSTATUS_RR0_Msk (0x1UL << WDT_REQSTATUS_RR0_Pos) /*!< Bit mask of RR0 field. */
N#define WDT_REQSTATUS_RR0_DisabledOrRequested (0UL) /*!< RR[0] register is not enabled, or are already requesting reload */
N#define WDT_REQSTATUS_RR0_EnabledAndUnrequested (1UL) /*!< RR[0] register is enabled, and are not yet requesting reload */
N
N/* Register: WDT_CRV */
N/* Description: Counter reload value */
N
N/* Bits 31..0 : Counter reload value in number of cycles of the 32.768 kHz clock */
N#define WDT_CRV_CRV_Pos (0UL) /*!< Position of CRV field. */
N#define WDT_CRV_CRV_Msk (0xFFFFFFFFUL << WDT_CRV_CRV_Pos) /*!< Bit mask of CRV field. */
N
N/* Register: WDT_RREN */
N/* Description: Enable register for reload request registers */
N
N/* Bit 7 : Enable or disable RR[7] register */
N#define WDT_RREN_RR7_Pos (7UL) /*!< Position of RR7 field. */
N#define WDT_RREN_RR7_Msk (0x1UL << WDT_RREN_RR7_Pos) /*!< Bit mask of RR7 field. */
N#define WDT_RREN_RR7_Disabled (0UL) /*!< Disable RR[7] register */
N#define WDT_RREN_RR7_Enabled (1UL) /*!< Enable RR[7] register */
N
N/* Bit 6 : Enable or disable RR[6] register */
N#define WDT_RREN_RR6_Pos (6UL) /*!< Position of RR6 field. */
N#define WDT_RREN_RR6_Msk (0x1UL << WDT_RREN_RR6_Pos) /*!< Bit mask of RR6 field. */
N#define WDT_RREN_RR6_Disabled (0UL) /*!< Disable RR[6] register */
N#define WDT_RREN_RR6_Enabled (1UL) /*!< Enable RR[6] register */
N
N/* Bit 5 : Enable or disable RR[5] register */
N#define WDT_RREN_RR5_Pos (5UL) /*!< Position of RR5 field. */
N#define WDT_RREN_RR5_Msk (0x1UL << WDT_RREN_RR5_Pos) /*!< Bit mask of RR5 field. */
N#define WDT_RREN_RR5_Disabled (0UL) /*!< Disable RR[5] register */
N#define WDT_RREN_RR5_Enabled (1UL) /*!< Enable RR[5] register */
N
N/* Bit 4 : Enable or disable RR[4] register */
N#define WDT_RREN_RR4_Pos (4UL) /*!< Position of RR4 field. */
N#define WDT_RREN_RR4_Msk (0x1UL << WDT_RREN_RR4_Pos) /*!< Bit mask of RR4 field. */
N#define WDT_RREN_RR4_Disabled (0UL) /*!< Disable RR[4] register */
N#define WDT_RREN_RR4_Enabled (1UL) /*!< Enable RR[4] register */
N
N/* Bit 3 : Enable or disable RR[3] register */
N#define WDT_RREN_RR3_Pos (3UL) /*!< Position of RR3 field. */
N#define WDT_RREN_RR3_Msk (0x1UL << WDT_RREN_RR3_Pos) /*!< Bit mask of RR3 field. */
N#define WDT_RREN_RR3_Disabled (0UL) /*!< Disable RR[3] register */
N#define WDT_RREN_RR3_Enabled (1UL) /*!< Enable RR[3] register */
N
N/* Bit 2 : Enable or disable RR[2] register */
N#define WDT_RREN_RR2_Pos (2UL) /*!< Position of RR2 field. */
N#define WDT_RREN_RR2_Msk (0x1UL << WDT_RREN_RR2_Pos) /*!< Bit mask of RR2 field. */
N#define WDT_RREN_RR2_Disabled (0UL) /*!< Disable RR[2] register */
N#define WDT_RREN_RR2_Enabled (1UL) /*!< Enable RR[2] register */
N
N/* Bit 1 : Enable or disable RR[1] register */
N#define WDT_RREN_RR1_Pos (1UL) /*!< Position of RR1 field. */
N#define WDT_RREN_RR1_Msk (0x1UL << WDT_RREN_RR1_Pos) /*!< Bit mask of RR1 field. */
N#define WDT_RREN_RR1_Disabled (0UL) /*!< Disable RR[1] register */
N#define WDT_RREN_RR1_Enabled (1UL) /*!< Enable RR[1] register */
N
N/* Bit 0 : Enable or disable RR[0] register */
N#define WDT_RREN_RR0_Pos (0UL) /*!< Position of RR0 field. */
N#define WDT_RREN_RR0_Msk (0x1UL << WDT_RREN_RR0_Pos) /*!< Bit mask of RR0 field. */
N#define WDT_RREN_RR0_Disabled (0UL) /*!< Disable RR[0] register */
N#define WDT_RREN_RR0_Enabled (1UL) /*!< Enable RR[0] register */
N
N/* Register: WDT_CONFIG */
N/* Description: Configuration register */
N
N/* Bit 3 : Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger */
N#define WDT_CONFIG_HALT_Pos (3UL) /*!< Position of HALT field. */
N#define WDT_CONFIG_HALT_Msk (0x1UL << WDT_CONFIG_HALT_Pos) /*!< Bit mask of HALT field. */
N#define WDT_CONFIG_HALT_Pause (0UL) /*!< Pause watchdog while the CPU is halted by the debugger */
N#define WDT_CONFIG_HALT_Run (1UL) /*!< Keep the watchdog running while the CPU is halted by the debugger */
N
N/* Bit 0 : Configure the watchdog to either be paused, or kept running, while the CPU is sleeping */
N#define WDT_CONFIG_SLEEP_Pos (0UL) /*!< Position of SLEEP field. */
N#define WDT_CONFIG_SLEEP_Msk (0x1UL << WDT_CONFIG_SLEEP_Pos) /*!< Bit mask of SLEEP field. */
N#define WDT_CONFIG_SLEEP_Pause (0UL) /*!< Pause watchdog while the CPU is sleeping */
N#define WDT_CONFIG_SLEEP_Run (1UL) /*!< Keep the watchdog running while the CPU is sleeping */
N
N/* Register: WDT_RR */
N/* Description: Description collection[0]:  Reload request 0 */
N
N/* Bits 31..0 : Reload request register */
N#define WDT_RR_RR_Pos (0UL) /*!< Position of RR field. */
N#define WDT_RR_RR_Msk (0xFFFFFFFFUL << WDT_RR_RR_Pos) /*!< Bit mask of RR field. */
N#define WDT_RR_RR_Reload (0x6E524635UL) /*!< Value to request a reload of the watchdog timer */
N
N
N/*lint --flb "Leave library region" */
N#endif
L 55 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf.h" 2
N        #include "nrf51_to_nrf52.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf51_to_nrf52.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef NRF51_TO_NRF52_H
N#define NRF51_TO_NRF52_H
N
N/*lint ++flb "Enter library region */
N
N/* This file is given to prevent your SW from not compiling with the name changes between nRF51 and nRF52 devices.
N * It redefines the old nRF51 names into the new ones as long as the functionality is still supported. If the
N * functionality is gone, there old names are not defined, so compilation will fail. Note that also includes macros
N * from the nrf51_deprecated.h file. */
N
N
N/* IRQ */
N/* Several peripherals have been added to several indexes. Names of IRQ handlers and IRQ numbers have changed. */
N#define UART0_IRQHandler        UARTE0_UART0_IRQHandler
N#define SPI0_TWI0_IRQHandler    SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
N#define SPI1_TWI1_IRQHandler    SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
N#define ADC_IRQHandler          SAADC_IRQHandler
N#define LPCOMP_IRQHandler       COMP_LPCOMP_IRQHandler
N#define SWI0_IRQHandler         SWI0_EGU0_IRQHandler
N#define SWI1_IRQHandler         SWI1_EGU1_IRQHandler
N#define SWI2_IRQHandler         SWI2_EGU2_IRQHandler
N#define SWI3_IRQHandler         SWI3_EGU3_IRQHandler
N#define SWI4_IRQHandler         SWI4_EGU4_IRQHandler
N#define SWI5_IRQHandler         SWI5_EGU5_IRQHandler
N
N#define UART0_IRQn              UARTE0_UART0_IRQn
N#define SPI0_TWI0_IRQn          SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQn
N#define SPI1_TWI1_IRQn          SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQn
N#define ADC_IRQn                SAADC_IRQn
N#define LPCOMP_IRQn             COMP_LPCOMP_IRQn
N#define SWI0_IRQn               SWI0_EGU0_IRQn
N#define SWI1_IRQn               SWI1_EGU1_IRQn
N#define SWI2_IRQn               SWI2_EGU2_IRQn
N#define SWI3_IRQn               SWI3_EGU3_IRQn
N#define SWI4_IRQn               SWI4_EGU4_IRQn
N#define SWI5_IRQn               SWI5_EGU5_IRQn
N
N
N/* UICR */
N/* Register RBPCONF was renamed to APPROTECT. */
N#define RBPCONF     APPROTECT
N
N#define UICR_RBPCONF_PALL_Pos           UICR_APPROTECT_PALL_Pos
N#define UICR_RBPCONF_PALL_Msk           UICR_APPROTECT_PALL_Msk
N#define UICR_RBPCONF_PALL_Enabled       UICR_APPROTECT_PALL_Enabled
N#define UICR_RBPCONF_PALL_Disabled      UICR_APPROTECT_PALL_Disabled
N
N
N/* GPIO */
N/* GPIO port was renamed to P0. */
N#define NRF_GPIO        NRF_P0
N#define NRF_GPIO_BASE   NRF_P0_BASE
N
N
N/* QDEC */
N/* The registers PSELA, PSELB and PSELLED were restructured into a struct. */
N#define PSELLED     PSEL.LED
N#define PSELA       PSEL.A
N#define PSELB       PSEL.B
N
N
N/* SPIS */
N/* The registers PSELSCK, PSELMISO, PSELMOSI, PSELCSN were restructured into a struct. */
N#define PSELSCK       PSEL.SCK
N#define PSELMISO      PSEL.MISO
N#define PSELMOSI      PSEL.MOSI
N#define PSELCSN       PSEL.CSN
N
N/* The registers RXDPTR, MAXRX, AMOUNTRX were restructured into a struct */
N#define RXDPTR        RXD.PTR
N#define MAXRX         RXD.MAXCNT
N#define AMOUNTRX      RXD.AMOUNT
N
N#define SPIS_MAXRX_MAXRX_Pos        SPIS_RXD_MAXCNT_MAXCNT_Pos
N#define SPIS_MAXRX_MAXRX_Msk        SPIS_RXD_MAXCNT_MAXCNT_Msk
N
N#define SPIS_AMOUNTRX_AMOUNTRX_Pos  SPIS_RXD_AMOUNT_AMOUNT_Pos
N#define SPIS_AMOUNTRX_AMOUNTRX_Msk  SPIS_RXD_AMOUNT_AMOUNT_Msk
N
N/* The registers TXDPTR, MAXTX, AMOUNTTX were restructured into a struct */
N#define TXDPTR        TXD.PTR
N#define MAXTX         TXD.MAXCNT
N#define AMOUNTTX      TXD.AMOUNT
N
N#define SPIS_MAXTX_MAXTX_Pos        SPIS_TXD_MAXCNT_MAXCNT_Pos
N#define SPIS_MAXTX_MAXTX_Msk        SPIS_TXD_MAXCNT_MAXCNT_Msk
N
N#define SPIS_AMOUNTTX_AMOUNTTX_Pos  SPIS_TXD_AMOUNT_AMOUNT_Pos
N#define SPIS_AMOUNTTX_AMOUNTTX_Msk  SPIS_TXD_AMOUNT_AMOUNT_Msk
N
N
N/* MPU */
N/* Part of MPU module was renamed BPROT, while the rest was eliminated. */
N#define NRF_MPU     NRF_BPROT
N
N/* Register DISABLEINDEBUG macros were affected. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos       BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Pos
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Msk       BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Msk
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Enabled   BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Enabled
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Disabled  BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Disabled
N
N/* Registers PROTENSET0 and PROTENSET1 were affected and renamed as CONFIG0 and CONFIG1. */
N#define PROTENSET0  CONFIG0
N#define PROTENSET1  CONFIG1
N
N#define MPU_PROTENSET1_PROTREG63_Pos        BPROT_CONFIG1_REGION63_Pos
N#define MPU_PROTENSET1_PROTREG63_Msk        BPROT_CONFIG1_REGION63_Msk
N#define MPU_PROTENSET1_PROTREG63_Disabled   BPROT_CONFIG1_REGION63_Disabled
N#define MPU_PROTENSET1_PROTREG63_Enabled    BPROT_CONFIG1_REGION63_Enabled
N#define MPU_PROTENSET1_PROTREG63_Set        BPROT_CONFIG1_REGION63_Enabled
N
N#define MPU_PROTENSET1_PROTREG62_Pos        BPROT_CONFIG1_REGION62_Pos
N#define MPU_PROTENSET1_PROTREG62_Msk        BPROT_CONFIG1_REGION62_Msk
N#define MPU_PROTENSET1_PROTREG62_Disabled   BPROT_CONFIG1_REGION62_Disabled
N#define MPU_PROTENSET1_PROTREG62_Enabled    BPROT_CONFIG1_REGION62_Enabled
N#define MPU_PROTENSET1_PROTREG62_Set        BPROT_CONFIG1_REGION62_Enabled
N
N#define MPU_PROTENSET1_PROTREG61_Pos        BPROT_CONFIG1_REGION61_Pos
N#define MPU_PROTENSET1_PROTREG61_Msk        BPROT_CONFIG1_REGION61_Msk
N#define MPU_PROTENSET1_PROTREG61_Disabled   BPROT_CONFIG1_REGION61_Disabled
N#define MPU_PROTENSET1_PROTREG61_Enabled    BPROT_CONFIG1_REGION61_Enabled
N#define MPU_PROTENSET1_PROTREG61_Set        BPROT_CONFIG1_REGION61_Enabled
N
N#define MPU_PROTENSET1_PROTREG60_Pos        BPROT_CONFIG1_REGION60_Pos
N#define MPU_PROTENSET1_PROTREG60_Msk        BPROT_CONFIG1_REGION60_Msk
N#define MPU_PROTENSET1_PROTREG60_Disabled   BPROT_CONFIG1_REGION60_Disabled
N#define MPU_PROTENSET1_PROTREG60_Enabled    BPROT_CONFIG1_REGION60_Enabled
N#define MPU_PROTENSET1_PROTREG60_Set        BPROT_CONFIG1_REGION60_Enabled
N
N#define MPU_PROTENSET1_PROTREG59_Pos        BPROT_CONFIG1_REGION59_Pos
N#define MPU_PROTENSET1_PROTREG59_Msk        BPROT_CONFIG1_REGION59_Msk
N#define MPU_PROTENSET1_PROTREG59_Disabled   BPROT_CONFIG1_REGION59_Disabled
N#define MPU_PROTENSET1_PROTREG59_Enabled    BPROT_CONFIG1_REGION59_Enabled
N#define MPU_PROTENSET1_PROTREG59_Set        BPROT_CONFIG1_REGION59_Enabled
N
N#define MPU_PROTENSET1_PROTREG58_Pos        BPROT_CONFIG1_REGION58_Pos
N#define MPU_PROTENSET1_PROTREG58_Msk        BPROT_CONFIG1_REGION58_Msk
N#define MPU_PROTENSET1_PROTREG58_Disabled   BPROT_CONFIG1_REGION58_Disabled
N#define MPU_PROTENSET1_PROTREG58_Enabled    BPROT_CONFIG1_REGION58_Enabled
N#define MPU_PROTENSET1_PROTREG58_Set        BPROT_CONFIG1_REGION58_Enabled
N
N#define MPU_PROTENSET1_PROTREG57_Pos        BPROT_CONFIG1_REGION57_Pos
N#define MPU_PROTENSET1_PROTREG57_Msk        BPROT_CONFIG1_REGION57_Msk
N#define MPU_PROTENSET1_PROTREG57_Disabled   BPROT_CONFIG1_REGION57_Disabled
N#define MPU_PROTENSET1_PROTREG57_Enabled    BPROT_CONFIG1_REGION57_Enabled
N#define MPU_PROTENSET1_PROTREG57_Set        BPROT_CONFIG1_REGION57_Enabled
N
N#define MPU_PROTENSET1_PROTREG56_Pos        BPROT_CONFIG1_REGION56_Pos
N#define MPU_PROTENSET1_PROTREG56_Msk        BPROT_CONFIG1_REGION56_Msk
N#define MPU_PROTENSET1_PROTREG56_Disabled   BPROT_CONFIG1_REGION56_Disabled
N#define MPU_PROTENSET1_PROTREG56_Enabled    BPROT_CONFIG1_REGION56_Enabled
N#define MPU_PROTENSET1_PROTREG56_Set        BPROT_CONFIG1_REGION56_Enabled
N
N#define MPU_PROTENSET1_PROTREG55_Pos        BPROT_CONFIG1_REGION55_Pos
N#define MPU_PROTENSET1_PROTREG55_Msk        BPROT_CONFIG1_REGION55_Msk
N#define MPU_PROTENSET1_PROTREG55_Disabled   BPROT_CONFIG1_REGION55_Disabled
N#define MPU_PROTENSET1_PROTREG55_Enabled    BPROT_CONFIG1_REGION55_Enabled
N#define MPU_PROTENSET1_PROTREG55_Set        BPROT_CONFIG1_REGION55_Enabled
N
N#define MPU_PROTENSET1_PROTREG54_Pos        BPROT_CONFIG1_REGION54_Pos
N#define MPU_PROTENSET1_PROTREG54_Msk        BPROT_CONFIG1_REGION54_Msk
N#define MPU_PROTENSET1_PROTREG54_Disabled   BPROT_CONFIG1_REGION54_Disabled
N#define MPU_PROTENSET1_PROTREG54_Enabled    BPROT_CONFIG1_REGION54_Enabled
N#define MPU_PROTENSET1_PROTREG54_Set        BPROT_CONFIG1_REGION54_Enabled
N
N#define MPU_PROTENSET1_PROTREG53_Pos        BPROT_CONFIG1_REGION53_Pos
N#define MPU_PROTENSET1_PROTREG53_Msk        BPROT_CONFIG1_REGION53_Msk
N#define MPU_PROTENSET1_PROTREG53_Disabled   BPROT_CONFIG1_REGION53_Disabled
N#define MPU_PROTENSET1_PROTREG53_Enabled    BPROT_CONFIG1_REGION53_Enabled
N#define MPU_PROTENSET1_PROTREG53_Set        BPROT_CONFIG1_REGION53_Enabled
N
N#define MPU_PROTENSET1_PROTREG52_Pos        BPROT_CONFIG1_REGION52_Pos
N#define MPU_PROTENSET1_PROTREG52_Msk        BPROT_CONFIG1_REGION52_Msk
N#define MPU_PROTENSET1_PROTREG52_Disabled   BPROT_CONFIG1_REGION52_Disabled
N#define MPU_PROTENSET1_PROTREG52_Enabled    BPROT_CONFIG1_REGION52_Enabled
N#define MPU_PROTENSET1_PROTREG52_Set        BPROT_CONFIG1_REGION52_Enabled
N
N#define MPU_PROTENSET1_PROTREG51_Pos        BPROT_CONFIG1_REGION51_Pos
N#define MPU_PROTENSET1_PROTREG51_Msk        BPROT_CONFIG1_REGION51_Msk
N#define MPU_PROTENSET1_PROTREG51_Disabled   BPROT_CONFIG1_REGION51_Disabled
N#define MPU_PROTENSET1_PROTREG51_Enabled    BPROT_CONFIG1_REGION51_Enabled
N#define MPU_PROTENSET1_PROTREG51_Set        BPROT_CONFIG1_REGION51_Enabled
N
N#define MPU_PROTENSET1_PROTREG50_Pos        BPROT_CONFIG1_REGION50_Pos
N#define MPU_PROTENSET1_PROTREG50_Msk        BPROT_CONFIG1_REGION50_Msk
N#define MPU_PROTENSET1_PROTREG50_Disabled   BPROT_CONFIG1_REGION50_Disabled
N#define MPU_PROTENSET1_PROTREG50_Enabled    BPROT_CONFIG1_REGION50_Enabled
N#define MPU_PROTENSET1_PROTREG50_Set        BPROT_CONFIG1_REGION50_Enabled
N
N#define MPU_PROTENSET1_PROTREG49_Pos        BPROT_CONFIG1_REGION49_Pos
N#define MPU_PROTENSET1_PROTREG49_Msk        BPROT_CONFIG1_REGION49_Msk
N#define MPU_PROTENSET1_PROTREG49_Disabled   BPROT_CONFIG1_REGION49_Disabled
N#define MPU_PROTENSET1_PROTREG49_Enabled    BPROT_CONFIG1_REGION49_Enabled
N#define MPU_PROTENSET1_PROTREG49_Set        BPROT_CONFIG1_REGION49_Enabled
N
N#define MPU_PROTENSET1_PROTREG48_Pos        BPROT_CONFIG1_REGION48_Pos
N#define MPU_PROTENSET1_PROTREG48_Msk        BPROT_CONFIG1_REGION48_Msk
N#define MPU_PROTENSET1_PROTREG48_Disabled   BPROT_CONFIG1_REGION48_Disabled
N#define MPU_PROTENSET1_PROTREG48_Enabled    BPROT_CONFIG1_REGION48_Enabled
N#define MPU_PROTENSET1_PROTREG48_Set        BPROT_CONFIG1_REGION48_Enabled
N
N#define MPU_PROTENSET1_PROTREG47_Pos        BPROT_CONFIG1_REGION47_Pos
N#define MPU_PROTENSET1_PROTREG47_Msk        BPROT_CONFIG1_REGION47_Msk
N#define MPU_PROTENSET1_PROTREG47_Disabled   BPROT_CONFIG1_REGION47_Disabled
N#define MPU_PROTENSET1_PROTREG47_Enabled    BPROT_CONFIG1_REGION47_Enabled
N#define MPU_PROTENSET1_PROTREG47_Set        BPROT_CONFIG1_REGION47_Enabled
N
N#define MPU_PROTENSET1_PROTREG46_Pos        BPROT_CONFIG1_REGION46_Pos
N#define MPU_PROTENSET1_PROTREG46_Msk        BPROT_CONFIG1_REGION46_Msk
N#define MPU_PROTENSET1_PROTREG46_Disabled   BPROT_CONFIG1_REGION46_Disabled
N#define MPU_PROTENSET1_PROTREG46_Enabled    BPROT_CONFIG1_REGION46_Enabled
N#define MPU_PROTENSET1_PROTREG46_Set        BPROT_CONFIG1_REGION46_Enabled
N
N#define MPU_PROTENSET1_PROTREG45_Pos        BPROT_CONFIG1_REGION45_Pos
N#define MPU_PROTENSET1_PROTREG45_Msk        BPROT_CONFIG1_REGION45_Msk
N#define MPU_PROTENSET1_PROTREG45_Disabled   BPROT_CONFIG1_REGION45_Disabled
N#define MPU_PROTENSET1_PROTREG45_Enabled    BPROT_CONFIG1_REGION45_Enabled
N#define MPU_PROTENSET1_PROTREG45_Set        BPROT_CONFIG1_REGION45_Enabled
N
N#define MPU_PROTENSET1_PROTREG44_Pos        BPROT_CONFIG1_REGION44_Pos
N#define MPU_PROTENSET1_PROTREG44_Msk        BPROT_CONFIG1_REGION44_Msk
N#define MPU_PROTENSET1_PROTREG44_Disabled   BPROT_CONFIG1_REGION44_Disabled
N#define MPU_PROTENSET1_PROTREG44_Enabled    BPROT_CONFIG1_REGION44_Enabled
N#define MPU_PROTENSET1_PROTREG44_Set        BPROT_CONFIG1_REGION44_Enabled
N
N#define MPU_PROTENSET1_PROTREG43_Pos        BPROT_CONFIG1_REGION43_Pos
N#define MPU_PROTENSET1_PROTREG43_Msk        BPROT_CONFIG1_REGION43_Msk
N#define MPU_PROTENSET1_PROTREG43_Disabled   BPROT_CONFIG1_REGION43_Disabled
N#define MPU_PROTENSET1_PROTREG43_Enabled    BPROT_CONFIG1_REGION43_Enabled
N#define MPU_PROTENSET1_PROTREG43_Set        BPROT_CONFIG1_REGION43_Enabled
N
N#define MPU_PROTENSET1_PROTREG42_Pos        BPROT_CONFIG1_REGION42_Pos
N#define MPU_PROTENSET1_PROTREG42_Msk        BPROT_CONFIG1_REGION42_Msk
N#define MPU_PROTENSET1_PROTREG42_Disabled   BPROT_CONFIG1_REGION42_Disabled
N#define MPU_PROTENSET1_PROTREG42_Enabled    BPROT_CONFIG1_REGION42_Enabled
N#define MPU_PROTENSET1_PROTREG42_Set        BPROT_CONFIG1_REGION42_Enabled
N
N#define MPU_PROTENSET1_PROTREG41_Pos        BPROT_CONFIG1_REGION41_Pos
N#define MPU_PROTENSET1_PROTREG41_Msk        BPROT_CONFIG1_REGION41_Msk
N#define MPU_PROTENSET1_PROTREG41_Disabled   BPROT_CONFIG1_REGION41_Disabled
N#define MPU_PROTENSET1_PROTREG41_Enabled    BPROT_CONFIG1_REGION41_Enabled
N#define MPU_PROTENSET1_PROTREG41_Set        BPROT_CONFIG1_REGION41_Enabled
N
N#define MPU_PROTENSET1_PROTREG40_Pos        BPROT_CONFIG1_REGION40_Pos
N#define MPU_PROTENSET1_PROTREG40_Msk        BPROT_CONFIG1_REGION40_Msk
N#define MPU_PROTENSET1_PROTREG40_Disabled   BPROT_CONFIG1_REGION40_Disabled
N#define MPU_PROTENSET1_PROTREG40_Enabled    BPROT_CONFIG1_REGION40_Enabled
N#define MPU_PROTENSET1_PROTREG40_Set        BPROT_CONFIG1_REGION40_Enabled
N
N#define MPU_PROTENSET1_PROTREG39_Pos        BPROT_CONFIG1_REGION39_Pos
N#define MPU_PROTENSET1_PROTREG39_Msk        BPROT_CONFIG1_REGION39_Msk
N#define MPU_PROTENSET1_PROTREG39_Disabled   BPROT_CONFIG1_REGION39_Disabled
N#define MPU_PROTENSET1_PROTREG39_Enabled    BPROT_CONFIG1_REGION39_Enabled
N#define MPU_PROTENSET1_PROTREG39_Set        BPROT_CONFIG1_REGION39_Enabled
N
N#define MPU_PROTENSET1_PROTREG38_Pos        BPROT_CONFIG1_REGION38_Pos
N#define MPU_PROTENSET1_PROTREG38_Msk        BPROT_CONFIG1_REGION38_Msk
N#define MPU_PROTENSET1_PROTREG38_Disabled   BPROT_CONFIG1_REGION38_Disabled
N#define MPU_PROTENSET1_PROTREG38_Enabled    BPROT_CONFIG1_REGION38_Enabled
N#define MPU_PROTENSET1_PROTREG38_Set        BPROT_CONFIG1_REGION38_Enabled
N
N#define MPU_PROTENSET1_PROTREG37_Pos        BPROT_CONFIG1_REGION37_Pos
N#define MPU_PROTENSET1_PROTREG37_Msk        BPROT_CONFIG1_REGION37_Msk
N#define MPU_PROTENSET1_PROTREG37_Disabled   BPROT_CONFIG1_REGION37_Disabled
N#define MPU_PROTENSET1_PROTREG37_Enabled    BPROT_CONFIG1_REGION37_Enabled
N#define MPU_PROTENSET1_PROTREG37_Set        BPROT_CONFIG1_REGION37_Enabled
N
N#define MPU_PROTENSET1_PROTREG36_Pos        BPROT_CONFIG1_REGION36_Pos
N#define MPU_PROTENSET1_PROTREG36_Msk        BPROT_CONFIG1_REGION36_Msk
N#define MPU_PROTENSET1_PROTREG36_Disabled   BPROT_CONFIG1_REGION36_Disabled
N#define MPU_PROTENSET1_PROTREG36_Enabled    BPROT_CONFIG1_REGION36_Enabled
N#define MPU_PROTENSET1_PROTREG36_Set        BPROT_CONFIG1_REGION36_Enabled
N
N#define MPU_PROTENSET1_PROTREG35_Pos        BPROT_CONFIG1_REGION35_Pos
N#define MPU_PROTENSET1_PROTREG35_Msk        BPROT_CONFIG1_REGION35_Msk
N#define MPU_PROTENSET1_PROTREG35_Disabled   BPROT_CONFIG1_REGION35_Disabled
N#define MPU_PROTENSET1_PROTREG35_Enabled    BPROT_CONFIG1_REGION35_Enabled
N#define MPU_PROTENSET1_PROTREG35_Set        BPROT_CONFIG1_REGION35_Enabled
N
N#define MPU_PROTENSET1_PROTREG34_Pos        BPROT_CONFIG1_REGION34_Pos
N#define MPU_PROTENSET1_PROTREG34_Msk        BPROT_CONFIG1_REGION34_Msk
N#define MPU_PROTENSET1_PROTREG34_Disabled   BPROT_CONFIG1_REGION34_Disabled
N#define MPU_PROTENSET1_PROTREG34_Enabled    BPROT_CONFIG1_REGION34_Enabled
N#define MPU_PROTENSET1_PROTREG34_Set        BPROT_CONFIG1_REGION34_Enabled
N
N#define MPU_PROTENSET1_PROTREG33_Pos        BPROT_CONFIG1_REGION33_Pos
N#define MPU_PROTENSET1_PROTREG33_Msk        BPROT_CONFIG1_REGION33_Msk
N#define MPU_PROTENSET1_PROTREG33_Disabled   BPROT_CONFIG1_REGION33_Disabled
N#define MPU_PROTENSET1_PROTREG33_Enabled    BPROT_CONFIG1_REGION33_Enabled
N#define MPU_PROTENSET1_PROTREG33_Set        BPROT_CONFIG1_REGION33_Enabled
N
N#define MPU_PROTENSET1_PROTREG32_Pos        BPROT_CONFIG1_REGION32_Pos
N#define MPU_PROTENSET1_PROTREG32_Msk        BPROT_CONFIG1_REGION32_Msk
N#define MPU_PROTENSET1_PROTREG32_Disabled   BPROT_CONFIG1_REGION32_Disabled
N#define MPU_PROTENSET1_PROTREG32_Enabled    BPROT_CONFIG1_REGION32_Enabled
N#define MPU_PROTENSET1_PROTREG32_Set        BPROT_CONFIG1_REGION32_Enabled
N
N#define MPU_PROTENSET0_PROTREG31_Pos        BPROT_CONFIG0_REGION31_Pos
N#define MPU_PROTENSET0_PROTREG31_Msk        BPROT_CONFIG0_REGION31_Msk
N#define MPU_PROTENSET0_PROTREG31_Disabled   BPROT_CONFIG0_REGION31_Disabled
N#define MPU_PROTENSET0_PROTREG31_Enabled    BPROT_CONFIG0_REGION31_Enabled
N#define MPU_PROTENSET0_PROTREG31_Set        BPROT_CONFIG0_REGION31_Enabled
N
N#define MPU_PROTENSET0_PROTREG30_Pos        BPROT_CONFIG0_REGION30_Pos
N#define MPU_PROTENSET0_PROTREG30_Msk        BPROT_CONFIG0_REGION30_Msk
N#define MPU_PROTENSET0_PROTREG30_Disabled   BPROT_CONFIG0_REGION30_Disabled
N#define MPU_PROTENSET0_PROTREG30_Enabled    BPROT_CONFIG0_REGION30_Enabled
N#define MPU_PROTENSET0_PROTREG30_Set        BPROT_CONFIG0_REGION30_Enabled
N
N#define MPU_PROTENSET0_PROTREG29_Pos        BPROT_CONFIG0_REGION29_Pos
N#define MPU_PROTENSET0_PROTREG29_Msk        BPROT_CONFIG0_REGION29_Msk
N#define MPU_PROTENSET0_PROTREG29_Disabled   BPROT_CONFIG0_REGION29_Disabled
N#define MPU_PROTENSET0_PROTREG29_Enabled    BPROT_CONFIG0_REGION29_Enabled
N#define MPU_PROTENSET0_PROTREG29_Set        BPROT_CONFIG0_REGION29_Enabled
N
N#define MPU_PROTENSET0_PROTREG28_Pos        BPROT_CONFIG0_REGION28_Pos
N#define MPU_PROTENSET0_PROTREG28_Msk        BPROT_CONFIG0_REGION28_Msk
N#define MPU_PROTENSET0_PROTREG28_Disabled   BPROT_CONFIG0_REGION28_Disabled
N#define MPU_PROTENSET0_PROTREG28_Enabled    BPROT_CONFIG0_REGION28_Enabled
N#define MPU_PROTENSET0_PROTREG28_Set        BPROT_CONFIG0_REGION28_Enabled
N
N#define MPU_PROTENSET0_PROTREG27_Pos        BPROT_CONFIG0_REGION27_Pos
N#define MPU_PROTENSET0_PROTREG27_Msk        BPROT_CONFIG0_REGION27_Msk
N#define MPU_PROTENSET0_PROTREG27_Disabled   BPROT_CONFIG0_REGION27_Disabled
N#define MPU_PROTENSET0_PROTREG27_Enabled    BPROT_CONFIG0_REGION27_Enabled
N#define MPU_PROTENSET0_PROTREG27_Set        BPROT_CONFIG0_REGION27_Enabled
N
N#define MPU_PROTENSET0_PROTREG26_Pos        BPROT_CONFIG0_REGION26_Pos
N#define MPU_PROTENSET0_PROTREG26_Msk        BPROT_CONFIG0_REGION26_Msk
N#define MPU_PROTENSET0_PROTREG26_Disabled   BPROT_CONFIG0_REGION26_Disabled
N#define MPU_PROTENSET0_PROTREG26_Enabled    BPROT_CONFIG0_REGION26_Enabled
N#define MPU_PROTENSET0_PROTREG26_Set        BPROT_CONFIG0_REGION26_Enabled
N
N#define MPU_PROTENSET0_PROTREG25_Pos        BPROT_CONFIG0_REGION25_Pos
N#define MPU_PROTENSET0_PROTREG25_Msk        BPROT_CONFIG0_REGION25_Msk
N#define MPU_PROTENSET0_PROTREG25_Disabled   BPROT_CONFIG0_REGION25_Disabled
N#define MPU_PROTENSET0_PROTREG25_Enabled    BPROT_CONFIG0_REGION25_Enabled
N#define MPU_PROTENSET0_PROTREG25_Set        BPROT_CONFIG0_REGION25_Enabled
N
N#define MPU_PROTENSET0_PROTREG24_Pos        BPROT_CONFIG0_REGION24_Pos
N#define MPU_PROTENSET0_PROTREG24_Msk        BPROT_CONFIG0_REGION24_Msk
N#define MPU_PROTENSET0_PROTREG24_Disabled   BPROT_CONFIG0_REGION24_Disabled
N#define MPU_PROTENSET0_PROTREG24_Enabled    BPROT_CONFIG0_REGION24_Enabled
N#define MPU_PROTENSET0_PROTREG24_Set        BPROT_CONFIG0_REGION24_Enabled
N
N#define MPU_PROTENSET0_PROTREG23_Pos        BPROT_CONFIG0_REGION23_Pos
N#define MPU_PROTENSET0_PROTREG23_Msk        BPROT_CONFIG0_REGION23_Msk
N#define MPU_PROTENSET0_PROTREG23_Disabled   BPROT_CONFIG0_REGION23_Disabled
N#define MPU_PROTENSET0_PROTREG23_Enabled    BPROT_CONFIG0_REGION23_Enabled
N#define MPU_PROTENSET0_PROTREG23_Set        BPROT_CONFIG0_REGION23_Enabled
N
N#define MPU_PROTENSET0_PROTREG22_Pos        BPROT_CONFIG0_REGION22_Pos
N#define MPU_PROTENSET0_PROTREG22_Msk        BPROT_CONFIG0_REGION22_Msk
N#define MPU_PROTENSET0_PROTREG22_Disabled   BPROT_CONFIG0_REGION22_Disabled
N#define MPU_PROTENSET0_PROTREG22_Enabled    BPROT_CONFIG0_REGION22_Enabled
N#define MPU_PROTENSET0_PROTREG22_Set        BPROT_CONFIG0_REGION22_Enabled
N
N#define MPU_PROTENSET0_PROTREG21_Pos        BPROT_CONFIG0_REGION21_Pos
N#define MPU_PROTENSET0_PROTREG21_Msk        BPROT_CONFIG0_REGION21_Msk
N#define MPU_PROTENSET0_PROTREG21_Disabled   BPROT_CONFIG0_REGION21_Disabled
N#define MPU_PROTENSET0_PROTREG21_Enabled    BPROT_CONFIG0_REGION21_Enabled
N#define MPU_PROTENSET0_PROTREG21_Set        BPROT_CONFIG0_REGION21_Enabled
N
N#define MPU_PROTENSET0_PROTREG20_Pos        BPROT_CONFIG0_REGION20_Pos
N#define MPU_PROTENSET0_PROTREG20_Msk        BPROT_CONFIG0_REGION20_Msk
N#define MPU_PROTENSET0_PROTREG20_Disabled   BPROT_CONFIG0_REGION20_Disabled
N#define MPU_PROTENSET0_PROTREG20_Enabled    BPROT_CONFIG0_REGION20_Enabled
N#define MPU_PROTENSET0_PROTREG20_Set        BPROT_CONFIG0_REGION20_Enabled
N
N#define MPU_PROTENSET0_PROTREG19_Pos        BPROT_CONFIG0_REGION19_Pos
N#define MPU_PROTENSET0_PROTREG19_Msk        BPROT_CONFIG0_REGION19_Msk
N#define MPU_PROTENSET0_PROTREG19_Disabled   BPROT_CONFIG0_REGION19_Disabled
N#define MPU_PROTENSET0_PROTREG19_Enabled    BPROT_CONFIG0_REGION19_Enabled
N#define MPU_PROTENSET0_PROTREG19_Set        BPROT_CONFIG0_REGION19_Enabled
N
N#define MPU_PROTENSET0_PROTREG18_Pos        BPROT_CONFIG0_REGION18_Pos
N#define MPU_PROTENSET0_PROTREG18_Msk        BPROT_CONFIG0_REGION18_Msk
N#define MPU_PROTENSET0_PROTREG18_Disabled   BPROT_CONFIG0_REGION18_Disabled
N#define MPU_PROTENSET0_PROTREG18_Enabled    BPROT_CONFIG0_REGION18_Enabled
N#define MPU_PROTENSET0_PROTREG18_Set        BPROT_CONFIG0_REGION18_Enabled
N
N#define MPU_PROTENSET0_PROTREG17_Pos        BPROT_CONFIG0_REGION17_Pos
N#define MPU_PROTENSET0_PROTREG17_Msk        BPROT_CONFIG0_REGION17_Msk
N#define MPU_PROTENSET0_PROTREG17_Disabled   BPROT_CONFIG0_REGION17_Disabled
N#define MPU_PROTENSET0_PROTREG17_Enabled    BPROT_CONFIG0_REGION17_Enabled
N#define MPU_PROTENSET0_PROTREG17_Set        BPROT_CONFIG0_REGION17_Enabled
N
N#define MPU_PROTENSET0_PROTREG16_Pos        BPROT_CONFIG0_REGION16_Pos
N#define MPU_PROTENSET0_PROTREG16_Msk        BPROT_CONFIG0_REGION16_Msk
N#define MPU_PROTENSET0_PROTREG16_Disabled   BPROT_CONFIG0_REGION16_Disabled
N#define MPU_PROTENSET0_PROTREG16_Enabled    BPROT_CONFIG0_REGION16_Enabled
N#define MPU_PROTENSET0_PROTREG16_Set        BPROT_CONFIG0_REGION16_Enabled
N
N#define MPU_PROTENSET0_PROTREG15_Pos        BPROT_CONFIG0_REGION15_Pos
N#define MPU_PROTENSET0_PROTREG15_Msk        BPROT_CONFIG0_REGION15_Msk
N#define MPU_PROTENSET0_PROTREG15_Disabled   BPROT_CONFIG0_REGION15_Disabled
N#define MPU_PROTENSET0_PROTREG15_Enabled    BPROT_CONFIG0_REGION15_Enabled
N#define MPU_PROTENSET0_PROTREG15_Set        BPROT_CONFIG0_REGION15_Enabled
N
N#define MPU_PROTENSET0_PROTREG14_Pos        BPROT_CONFIG0_REGION14_Pos
N#define MPU_PROTENSET0_PROTREG14_Msk        BPROT_CONFIG0_REGION14_Msk
N#define MPU_PROTENSET0_PROTREG14_Disabled   BPROT_CONFIG0_REGION14_Disabled
N#define MPU_PROTENSET0_PROTREG14_Enabled    BPROT_CONFIG0_REGION14_Enabled
N#define MPU_PROTENSET0_PROTREG14_Set        BPROT_CONFIG0_REGION14_Enabled
N
N#define MPU_PROTENSET0_PROTREG13_Pos        BPROT_CONFIG0_REGION13_Pos
N#define MPU_PROTENSET0_PROTREG13_Msk        BPROT_CONFIG0_REGION13_Msk
N#define MPU_PROTENSET0_PROTREG13_Disabled   BPROT_CONFIG0_REGION13_Disabled
N#define MPU_PROTENSET0_PROTREG13_Enabled    BPROT_CONFIG0_REGION13_Enabled
N#define MPU_PROTENSET0_PROTREG13_Set        BPROT_CONFIG0_REGION13_Enabled
N
N#define MPU_PROTENSET0_PROTREG12_Pos        BPROT_CONFIG0_REGION12_Pos
N#define MPU_PROTENSET0_PROTREG12_Msk        BPROT_CONFIG0_REGION12_Msk
N#define MPU_PROTENSET0_PROTREG12_Disabled   BPROT_CONFIG0_REGION12_Disabled
N#define MPU_PROTENSET0_PROTREG12_Enabled    BPROT_CONFIG0_REGION12_Enabled
N#define MPU_PROTENSET0_PROTREG12_Set        BPROT_CONFIG0_REGION12_Enabled
N
N#define MPU_PROTENSET0_PROTREG11_Pos        BPROT_CONFIG0_REGION11_Pos
N#define MPU_PROTENSET0_PROTREG11_Msk        BPROT_CONFIG0_REGION11_Msk
N#define MPU_PROTENSET0_PROTREG11_Disabled   BPROT_CONFIG0_REGION11_Disabled
N#define MPU_PROTENSET0_PROTREG11_Enabled    BPROT_CONFIG0_REGION11_Enabled
N#define MPU_PROTENSET0_PROTREG11_Set        BPROT_CONFIG0_REGION11_Enabled
N
N#define MPU_PROTENSET0_PROTREG10_Pos        BPROT_CONFIG0_REGION10_Pos
N#define MPU_PROTENSET0_PROTREG10_Msk        BPROT_CONFIG0_REGION10_Msk
N#define MPU_PROTENSET0_PROTREG10_Disabled   BPROT_CONFIG0_REGION10_Disabled
N#define MPU_PROTENSET0_PROTREG10_Enabled    BPROT_CONFIG0_REGION10_Enabled
N#define MPU_PROTENSET0_PROTREG10_Set        BPROT_CONFIG0_REGION10_Enabled
N
N#define MPU_PROTENSET0_PROTREG9_Pos        BPROT_CONFIG0_REGION9_Pos
N#define MPU_PROTENSET0_PROTREG9_Msk        BPROT_CONFIG0_REGION9_Msk
N#define MPU_PROTENSET0_PROTREG9_Disabled   BPROT_CONFIG0_REGION9_Disabled
N#define MPU_PROTENSET0_PROTREG9_Enabled    BPROT_CONFIG0_REGION9_Enabled
N#define MPU_PROTENSET0_PROTREG9_Set        BPROT_CONFIG0_REGION9_Enabled
N
N#define MPU_PROTENSET0_PROTREG8_Pos        BPROT_CONFIG0_REGION8_Pos
N#define MPU_PROTENSET0_PROTREG8_Msk        BPROT_CONFIG0_REGION8_Msk
N#define MPU_PROTENSET0_PROTREG8_Disabled   BPROT_CONFIG0_REGION8_Disabled
N#define MPU_PROTENSET0_PROTREG8_Enabled    BPROT_CONFIG0_REGION8_Enabled
N#define MPU_PROTENSET0_PROTREG8_Set        BPROT_CONFIG0_REGION8_Enabled
N
N#define MPU_PROTENSET0_PROTREG7_Pos        BPROT_CONFIG0_REGION7_Pos
N#define MPU_PROTENSET0_PROTREG7_Msk        BPROT_CONFIG0_REGION7_Msk
N#define MPU_PROTENSET0_PROTREG7_Disabled   BPROT_CONFIG0_REGION7_Disabled
N#define MPU_PROTENSET0_PROTREG7_Enabled    BPROT_CONFIG0_REGION7_Enabled
N#define MPU_PROTENSET0_PROTREG7_Set        BPROT_CONFIG0_REGION7_Enabled
N
N#define MPU_PROTENSET0_PROTREG6_Pos        BPROT_CONFIG0_REGION6_Pos
N#define MPU_PROTENSET0_PROTREG6_Msk        BPROT_CONFIG0_REGION6_Msk
N#define MPU_PROTENSET0_PROTREG6_Disabled   BPROT_CONFIG0_REGION6_Disabled
N#define MPU_PROTENSET0_PROTREG6_Enabled    BPROT_CONFIG0_REGION6_Enabled
N#define MPU_PROTENSET0_PROTREG6_Set        BPROT_CONFIG0_REGION6_Enabled
N
N#define MPU_PROTENSET0_PROTREG5_Pos        BPROT_CONFIG0_REGION5_Pos
N#define MPU_PROTENSET0_PROTREG5_Msk        BPROT_CONFIG0_REGION5_Msk
N#define MPU_PROTENSET0_PROTREG5_Disabled   BPROT_CONFIG0_REGION5_Disabled
N#define MPU_PROTENSET0_PROTREG5_Enabled    BPROT_CONFIG0_REGION5_Enabled
N#define MPU_PROTENSET0_PROTREG5_Set        BPROT_CONFIG0_REGION5_Enabled
N
N#define MPU_PROTENSET0_PROTREG4_Pos        BPROT_CONFIG0_REGION4_Pos
N#define MPU_PROTENSET0_PROTREG4_Msk        BPROT_CONFIG0_REGION4_Msk
N#define MPU_PROTENSET0_PROTREG4_Disabled   BPROT_CONFIG0_REGION4_Disabled
N#define MPU_PROTENSET0_PROTREG4_Enabled    BPROT_CONFIG0_REGION4_Enabled
N#define MPU_PROTENSET0_PROTREG4_Set        BPROT_CONFIG0_REGION4_Enabled
N
N#define MPU_PROTENSET0_PROTREG3_Pos        BPROT_CONFIG0_REGION3_Pos
N#define MPU_PROTENSET0_PROTREG3_Msk        BPROT_CONFIG0_REGION3_Msk
N#define MPU_PROTENSET0_PROTREG3_Disabled   BPROT_CONFIG0_REGION3_Disabled
N#define MPU_PROTENSET0_PROTREG3_Enabled    BPROT_CONFIG0_REGION3_Enabled
N#define MPU_PROTENSET0_PROTREG3_Set        BPROT_CONFIG0_REGION3_Enabled
N
N#define MPU_PROTENSET0_PROTREG2_Pos        BPROT_CONFIG0_REGION2_Pos
N#define MPU_PROTENSET0_PROTREG2_Msk        BPROT_CONFIG0_REGION2_Msk
N#define MPU_PROTENSET0_PROTREG2_Disabled   BPROT_CONFIG0_REGION2_Disabled
N#define MPU_PROTENSET0_PROTREG2_Enabled    BPROT_CONFIG0_REGION2_Enabled
N#define MPU_PROTENSET0_PROTREG2_Set        BPROT_CONFIG0_REGION2_Enabled
N
N#define MPU_PROTENSET0_PROTREG1_Pos        BPROT_CONFIG0_REGION1_Pos
N#define MPU_PROTENSET0_PROTREG1_Msk        BPROT_CONFIG0_REGION1_Msk
N#define MPU_PROTENSET0_PROTREG1_Disabled   BPROT_CONFIG0_REGION1_Disabled
N#define MPU_PROTENSET0_PROTREG1_Enabled    BPROT_CONFIG0_REGION1_Enabled
N#define MPU_PROTENSET0_PROTREG1_Set        BPROT_CONFIG0_REGION1_Enabled
N
N#define MPU_PROTENSET0_PROTREG0_Pos        BPROT_CONFIG0_REGION0_Pos
N#define MPU_PROTENSET0_PROTREG0_Msk        BPROT_CONFIG0_REGION0_Msk
N#define MPU_PROTENSET0_PROTREG0_Disabled   BPROT_CONFIG0_REGION0_Disabled
N#define MPU_PROTENSET0_PROTREG0_Enabled    BPROT_CONFIG0_REGION0_Enabled
N#define MPU_PROTENSET0_PROTREG0_Set        BPROT_CONFIG0_REGION0_Enabled
N
N
N/* From nrf51_deprecated.h */
N
N/* NVMC */
N/* The register ERASEPROTECTEDPAGE changed name to ERASEPCR0 in the documentation. */
N#define ERASEPROTECTEDPAGE      ERASEPCR0
N
N
N/* IRQ */
N/* COMP module was eliminated. Adapted to nrf52 headers. */
N#define LPCOMP_COMP_IRQHandler  COMP_LPCOMP_IRQHandler
N#define LPCOMP_COMP_IRQn        COMP_LPCOMP_IRQn
N
N
N/* REFSEL register redefined enumerated values and added some more. */
N#define LPCOMP_REFSEL_REFSEL_SupplyOneEighthPrescaling          LPCOMP_REFSEL_REFSEL_Ref1_8Vdd
N#define LPCOMP_REFSEL_REFSEL_SupplyTwoEighthsPrescaling         LPCOMP_REFSEL_REFSEL_Ref2_8Vdd
N#define LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling       LPCOMP_REFSEL_REFSEL_Ref3_8Vdd
N#define LPCOMP_REFSEL_REFSEL_SupplyFourEighthsPrescaling        LPCOMP_REFSEL_REFSEL_Ref4_8Vdd
N#define LPCOMP_REFSEL_REFSEL_SupplyFiveEighthsPrescaling        LPCOMP_REFSEL_REFSEL_Ref5_8Vdd
N#define LPCOMP_REFSEL_REFSEL_SupplySixEighthsPrescaling         LPCOMP_REFSEL_REFSEL_Ref6_8Vdd
N#define LPCOMP_REFSEL_REFSEL_SupplySevenEighthsPrescaling       LPCOMP_REFSEL_REFSEL_Ref7_8Vdd
N
N
N/* RADIO */
N/* The name of the field SKIPADDR was corrected. Old macros added for compatibility. */
N#define RADIO_CRCCNF_SKIP_ADDR_Pos      RADIO_CRCCNF_SKIPADDR_Pos
N#define RADIO_CRCCNF_SKIP_ADDR_Msk      RADIO_CRCCNF_SKIPADDR_Msk
N#define RADIO_CRCCNF_SKIP_ADDR_Include  RADIO_CRCCNF_SKIPADDR_Include
N#define RADIO_CRCCNF_SKIP_ADDR_Skip     RADIO_CRCCNF_SKIPADDR_Skip
N
N
N/* FICR */
N/* The registers FICR.DEVICEID0 and FICR.DEVICEID1 were renamed into an array. */
N#define DEVICEID0       DEVICEID[0]
N#define DEVICEID1       DEVICEID[1]
N
N/* The registers FICR.ER0, FICR.ER1, FICR.ER2 and FICR.ER3 were renamed into an array. */
N#define ER0             ER[0]
N#define ER1             ER[1]
N#define ER2             ER[2]
N#define ER3             ER[3]
N
N/* The registers FICR.IR0, FICR.IR1, FICR.IR2 and FICR.IR3 were renamed into an array. */
N#define IR0             IR[0]
N#define IR1             IR[1]
N#define IR2             IR[2]
N#define IR3             IR[3]
N
N/* The registers FICR.DEVICEADDR0 and FICR.DEVICEADDR1 were renamed into an array. */
N#define DEVICEADDR0     DEVICEADDR[0]
N#define DEVICEADDR1     DEVICEADDR[1]
N
N
N/* PPI */
N/* The tasks PPI.TASKS_CHGxEN and PPI.TASKS_CHGxDIS were renamed into an array of structs. */
N#define TASKS_CHG0EN     TASKS_CHG[0].EN
N#define TASKS_CHG0DIS    TASKS_CHG[0].DIS
N#define TASKS_CHG1EN     TASKS_CHG[1].EN
N#define TASKS_CHG1DIS    TASKS_CHG[1].DIS
N#define TASKS_CHG2EN     TASKS_CHG[2].EN
N#define TASKS_CHG2DIS    TASKS_CHG[2].DIS
N#define TASKS_CHG3EN     TASKS_CHG[3].EN
N#define TASKS_CHG3DIS    TASKS_CHG[3].DIS
N
N/* The registers PPI.CHx_EEP and PPI.CHx_TEP were renamed into an array of structs. */
N#define CH0_EEP          CH[0].EEP
N#define CH0_TEP          CH[0].TEP
N#define CH1_EEP          CH[1].EEP
N#define CH1_TEP          CH[1].TEP
N#define CH2_EEP          CH[2].EEP
N#define CH2_TEP          CH[2].TEP
N#define CH3_EEP          CH[3].EEP
N#define CH3_TEP          CH[3].TEP
N#define CH4_EEP          CH[4].EEP
N#define CH4_TEP          CH[4].TEP
N#define CH5_EEP          CH[5].EEP
N#define CH5_TEP          CH[5].TEP
N#define CH6_EEP          CH[6].EEP
N#define CH6_TEP          CH[6].TEP
N#define CH7_EEP          CH[7].EEP
N#define CH7_TEP          CH[7].TEP
N#define CH8_EEP          CH[8].EEP
N#define CH8_TEP          CH[8].TEP
N#define CH9_EEP          CH[9].EEP
N#define CH9_TEP          CH[9].TEP
N#define CH10_EEP         CH[10].EEP
N#define CH10_TEP         CH[10].TEP
N#define CH11_EEP         CH[11].EEP
N#define CH11_TEP         CH[11].TEP
N#define CH12_EEP         CH[12].EEP
N#define CH12_TEP         CH[12].TEP
N#define CH13_EEP         CH[13].EEP
N#define CH13_TEP         CH[13].TEP
N#define CH14_EEP         CH[14].EEP
N#define CH14_TEP         CH[14].TEP
N#define CH15_EEP         CH[15].EEP
N#define CH15_TEP         CH[15].TEP
N
N/* The registers PPI.CHG0, PPI.CHG1, PPI.CHG2 and PPI.CHG3 were renamed into an array. */
N#define CHG0             CHG[0]
N#define CHG1             CHG[1]
N#define CHG2             CHG[2]
N#define CHG3             CHG[3]
N
N/* All bitfield macros for the CHGx registers therefore changed name. */
N#define PPI_CHG0_CH15_Pos       PPI_CHG_CH15_Pos
N#define PPI_CHG0_CH15_Msk       PPI_CHG_CH15_Msk
N#define PPI_CHG0_CH15_Excluded  PPI_CHG_CH15_Excluded
N#define PPI_CHG0_CH15_Included  PPI_CHG_CH15_Included
N
N#define PPI_CHG0_CH14_Pos       PPI_CHG_CH14_Pos
N#define PPI_CHG0_CH14_Msk       PPI_CHG_CH14_Msk
N#define PPI_CHG0_CH14_Excluded  PPI_CHG_CH14_Excluded
N#define PPI_CHG0_CH14_Included  PPI_CHG_CH14_Included
N
N#define PPI_CHG0_CH13_Pos       PPI_CHG_CH13_Pos
N#define PPI_CHG0_CH13_Msk       PPI_CHG_CH13_Msk
N#define PPI_CHG0_CH13_Excluded  PPI_CHG_CH13_Excluded
N#define PPI_CHG0_CH13_Included  PPI_CHG_CH13_Included
N
N#define PPI_CHG0_CH12_Pos       PPI_CHG_CH12_Pos
N#define PPI_CHG0_CH12_Msk       PPI_CHG_CH12_Msk
N#define PPI_CHG0_CH12_Excluded  PPI_CHG_CH12_Excluded
N#define PPI_CHG0_CH12_Included  PPI_CHG_CH12_Included
N
N#define PPI_CHG0_CH11_Pos       PPI_CHG_CH11_Pos
N#define PPI_CHG0_CH11_Msk       PPI_CHG_CH11_Msk
N#define PPI_CHG0_CH11_Excluded  PPI_CHG_CH11_Excluded
N#define PPI_CHG0_CH11_Included  PPI_CHG_CH11_Included
N
N#define PPI_CHG0_CH10_Pos       PPI_CHG_CH10_Pos
N#define PPI_CHG0_CH10_Msk       PPI_CHG_CH10_Msk
N#define PPI_CHG0_CH10_Excluded  PPI_CHG_CH10_Excluded
N#define PPI_CHG0_CH10_Included  PPI_CHG_CH10_Included
N
N#define PPI_CHG0_CH9_Pos        PPI_CHG_CH9_Pos
N#define PPI_CHG0_CH9_Msk        PPI_CHG_CH9_Msk
N#define PPI_CHG0_CH9_Excluded   PPI_CHG_CH9_Excluded
N#define PPI_CHG0_CH9_Included   PPI_CHG_CH9_Included
N
N#define PPI_CHG0_CH8_Pos        PPI_CHG_CH8_Pos
N#define PPI_CHG0_CH8_Msk        PPI_CHG_CH8_Msk
N#define PPI_CHG0_CH8_Excluded   PPI_CHG_CH8_Excluded
N#define PPI_CHG0_CH8_Included   PPI_CHG_CH8_Included
N
N#define PPI_CHG0_CH7_Pos        PPI_CHG_CH7_Pos
N#define PPI_CHG0_CH7_Msk        PPI_CHG_CH7_Msk
N#define PPI_CHG0_CH7_Excluded   PPI_CHG_CH7_Excluded
N#define PPI_CHG0_CH7_Included   PPI_CHG_CH7_Included
N
N#define PPI_CHG0_CH6_Pos        PPI_CHG_CH6_Pos
N#define PPI_CHG0_CH6_Msk        PPI_CHG_CH6_Msk
N#define PPI_CHG0_CH6_Excluded   PPI_CHG_CH6_Excluded
N#define PPI_CHG0_CH6_Included   PPI_CHG_CH6_Included
N
N#define PPI_CHG0_CH5_Pos        PPI_CHG_CH5_Pos
N#define PPI_CHG0_CH5_Msk        PPI_CHG_CH5_Msk
N#define PPI_CHG0_CH5_Excluded   PPI_CHG_CH5_Excluded
N#define PPI_CHG0_CH5_Included   PPI_CHG_CH5_Included
N
N#define PPI_CHG0_CH4_Pos        PPI_CHG_CH4_Pos
N#define PPI_CHG0_CH4_Msk        PPI_CHG_CH4_Msk
N#define PPI_CHG0_CH4_Excluded   PPI_CHG_CH4_Excluded
N#define PPI_CHG0_CH4_Included   PPI_CHG_CH4_Included
N
N#define PPI_CHG0_CH3_Pos        PPI_CHG_CH3_Pos
N#define PPI_CHG0_CH3_Msk        PPI_CHG_CH3_Msk
N#define PPI_CHG0_CH3_Excluded   PPI_CHG_CH3_Excluded
N#define PPI_CHG0_CH3_Included   PPI_CHG_CH3_Included
N
N#define PPI_CHG0_CH2_Pos        PPI_CHG_CH2_Pos
N#define PPI_CHG0_CH2_Msk        PPI_CHG_CH2_Msk
N#define PPI_CHG0_CH2_Excluded   PPI_CHG_CH2_Excluded
N#define PPI_CHG0_CH2_Included   PPI_CHG_CH2_Included
N
N#define PPI_CHG0_CH1_Pos        PPI_CHG_CH1_Pos
N#define PPI_CHG0_CH1_Msk        PPI_CHG_CH1_Msk
N#define PPI_CHG0_CH1_Excluded   PPI_CHG_CH1_Excluded
N#define PPI_CHG0_CH1_Included   PPI_CHG_CH1_Included
N
N#define PPI_CHG0_CH0_Pos        PPI_CHG_CH0_Pos
N#define PPI_CHG0_CH0_Msk        PPI_CHG_CH0_Msk
N#define PPI_CHG0_CH0_Excluded   PPI_CHG_CH0_Excluded
N#define PPI_CHG0_CH0_Included   PPI_CHG_CH0_Included
N
N#define PPI_CHG1_CH15_Pos       PPI_CHG_CH15_Pos
N#define PPI_CHG1_CH15_Msk       PPI_CHG_CH15_Msk
N#define PPI_CHG1_CH15_Excluded  PPI_CHG_CH15_Excluded
N#define PPI_CHG1_CH15_Included  PPI_CHG_CH15_Included
N
N#define PPI_CHG1_CH14_Pos       PPI_CHG_CH14_Pos
N#define PPI_CHG1_CH14_Msk       PPI_CHG_CH14_Msk
N#define PPI_CHG1_CH14_Excluded  PPI_CHG_CH14_Excluded
N#define PPI_CHG1_CH14_Included  PPI_CHG_CH14_Included
N
N#define PPI_CHG1_CH13_Pos       PPI_CHG_CH13_Pos
N#define PPI_CHG1_CH13_Msk       PPI_CHG_CH13_Msk
N#define PPI_CHG1_CH13_Excluded  PPI_CHG_CH13_Excluded
N#define PPI_CHG1_CH13_Included  PPI_CHG_CH13_Included
N
N#define PPI_CHG1_CH12_Pos       PPI_CHG_CH12_Pos
N#define PPI_CHG1_CH12_Msk       PPI_CHG_CH12_Msk
N#define PPI_CHG1_CH12_Excluded  PPI_CHG_CH12_Excluded
N#define PPI_CHG1_CH12_Included  PPI_CHG_CH12_Included
N
N#define PPI_CHG1_CH11_Pos       PPI_CHG_CH11_Pos
N#define PPI_CHG1_CH11_Msk       PPI_CHG_CH11_Msk
N#define PPI_CHG1_CH11_Excluded  PPI_CHG_CH11_Excluded
N#define PPI_CHG1_CH11_Included  PPI_CHG_CH11_Included
N
N#define PPI_CHG1_CH10_Pos       PPI_CHG_CH10_Pos
N#define PPI_CHG1_CH10_Msk       PPI_CHG_CH10_Msk
N#define PPI_CHG1_CH10_Excluded  PPI_CHG_CH10_Excluded
N#define PPI_CHG1_CH10_Included  PPI_CHG_CH10_Included
N
N#define PPI_CHG1_CH9_Pos        PPI_CHG_CH9_Pos
N#define PPI_CHG1_CH9_Msk        PPI_CHG_CH9_Msk
N#define PPI_CHG1_CH9_Excluded   PPI_CHG_CH9_Excluded
N#define PPI_CHG1_CH9_Included   PPI_CHG_CH9_Included
N
N#define PPI_CHG1_CH8_Pos        PPI_CHG_CH8_Pos
N#define PPI_CHG1_CH8_Msk        PPI_CHG_CH8_Msk
N#define PPI_CHG1_CH8_Excluded   PPI_CHG_CH8_Excluded
N#define PPI_CHG1_CH8_Included   PPI_CHG_CH8_Included
N
N#define PPI_CHG1_CH7_Pos        PPI_CHG_CH7_Pos
N#define PPI_CHG1_CH7_Msk        PPI_CHG_CH7_Msk
N#define PPI_CHG1_CH7_Excluded   PPI_CHG_CH7_Excluded
N#define PPI_CHG1_CH7_Included   PPI_CHG_CH7_Included
N
N#define PPI_CHG1_CH6_Pos        PPI_CHG_CH6_Pos
N#define PPI_CHG1_CH6_Msk        PPI_CHG_CH6_Msk
N#define PPI_CHG1_CH6_Excluded   PPI_CHG_CH6_Excluded
N#define PPI_CHG1_CH6_Included   PPI_CHG_CH6_Included
N
N#define PPI_CHG1_CH5_Pos        PPI_CHG_CH5_Pos
N#define PPI_CHG1_CH5_Msk        PPI_CHG_CH5_Msk
N#define PPI_CHG1_CH5_Excluded   PPI_CHG_CH5_Excluded
N#define PPI_CHG1_CH5_Included   PPI_CHG_CH5_Included
N
N#define PPI_CHG1_CH4_Pos        PPI_CHG_CH4_Pos
N#define PPI_CHG1_CH4_Msk        PPI_CHG_CH4_Msk
N#define PPI_CHG1_CH4_Excluded   PPI_CHG_CH4_Excluded
N#define PPI_CHG1_CH4_Included   PPI_CHG_CH4_Included
N
N#define PPI_CHG1_CH3_Pos        PPI_CHG_CH3_Pos
N#define PPI_CHG1_CH3_Msk        PPI_CHG_CH3_Msk
N#define PPI_CHG1_CH3_Excluded   PPI_CHG_CH3_Excluded
N#define PPI_CHG1_CH3_Included   PPI_CHG_CH3_Included
N
N#define PPI_CHG1_CH2_Pos        PPI_CHG_CH2_Pos
N#define PPI_CHG1_CH2_Msk        PPI_CHG_CH2_Msk
N#define PPI_CHG1_CH2_Excluded   PPI_CHG_CH2_Excluded
N#define PPI_CHG1_CH2_Included   PPI_CHG_CH2_Included
N
N#define PPI_CHG1_CH1_Pos        PPI_CHG_CH1_Pos
N#define PPI_CHG1_CH1_Msk        PPI_CHG_CH1_Msk
N#define PPI_CHG1_CH1_Excluded   PPI_CHG_CH1_Excluded
N#define PPI_CHG1_CH1_Included   PPI_CHG_CH1_Included
N
N#define PPI_CHG1_CH0_Pos        PPI_CHG_CH0_Pos
N#define PPI_CHG1_CH0_Msk        PPI_CHG_CH0_Msk
N#define PPI_CHG1_CH0_Excluded   PPI_CHG_CH0_Excluded
N#define PPI_CHG1_CH0_Included   PPI_CHG_CH0_Included
N
N#define PPI_CHG2_CH15_Pos       PPI_CHG_CH15_Pos
N#define PPI_CHG2_CH15_Msk       PPI_CHG_CH15_Msk
N#define PPI_CHG2_CH15_Excluded  PPI_CHG_CH15_Excluded
N#define PPI_CHG2_CH15_Included  PPI_CHG_CH15_Included
N
N#define PPI_CHG2_CH14_Pos       PPI_CHG_CH14_Pos
N#define PPI_CHG2_CH14_Msk       PPI_CHG_CH14_Msk
N#define PPI_CHG2_CH14_Excluded  PPI_CHG_CH14_Excluded
N#define PPI_CHG2_CH14_Included  PPI_CHG_CH14_Included
N
N#define PPI_CHG2_CH13_Pos       PPI_CHG_CH13_Pos
N#define PPI_CHG2_CH13_Msk       PPI_CHG_CH13_Msk
N#define PPI_CHG2_CH13_Excluded  PPI_CHG_CH13_Excluded
N#define PPI_CHG2_CH13_Included  PPI_CHG_CH13_Included
N
N#define PPI_CHG2_CH12_Pos       PPI_CHG_CH12_Pos
N#define PPI_CHG2_CH12_Msk       PPI_CHG_CH12_Msk
N#define PPI_CHG2_CH12_Excluded  PPI_CHG_CH12_Excluded
N#define PPI_CHG2_CH12_Included  PPI_CHG_CH12_Included
N
N#define PPI_CHG2_CH11_Pos       PPI_CHG_CH11_Pos
N#define PPI_CHG2_CH11_Msk       PPI_CHG_CH11_Msk
N#define PPI_CHG2_CH11_Excluded  PPI_CHG_CH11_Excluded
N#define PPI_CHG2_CH11_Included  PPI_CHG_CH11_Included
N
N#define PPI_CHG2_CH10_Pos       PPI_CHG_CH10_Pos
N#define PPI_CHG2_CH10_Msk       PPI_CHG_CH10_Msk
N#define PPI_CHG2_CH10_Excluded  PPI_CHG_CH10_Excluded
N#define PPI_CHG2_CH10_Included  PPI_CHG_CH10_Included
N
N#define PPI_CHG2_CH9_Pos        PPI_CHG_CH9_Pos
N#define PPI_CHG2_CH9_Msk        PPI_CHG_CH9_Msk
N#define PPI_CHG2_CH9_Excluded   PPI_CHG_CH9_Excluded
N#define PPI_CHG2_CH9_Included   PPI_CHG_CH9_Included
N
N#define PPI_CHG2_CH8_Pos        PPI_CHG_CH8_Pos
N#define PPI_CHG2_CH8_Msk        PPI_CHG_CH8_Msk
N#define PPI_CHG2_CH8_Excluded   PPI_CHG_CH8_Excluded
N#define PPI_CHG2_CH8_Included   PPI_CHG_CH8_Included
N
N#define PPI_CHG2_CH7_Pos        PPI_CHG_CH7_Pos
N#define PPI_CHG2_CH7_Msk        PPI_CHG_CH7_Msk
N#define PPI_CHG2_CH7_Excluded   PPI_CHG_CH7_Excluded
N#define PPI_CHG2_CH7_Included   PPI_CHG_CH7_Included
N
N#define PPI_CHG2_CH6_Pos        PPI_CHG_CH6_Pos
N#define PPI_CHG2_CH6_Msk        PPI_CHG_CH6_Msk
N#define PPI_CHG2_CH6_Excluded   PPI_CHG_CH6_Excluded
N#define PPI_CHG2_CH6_Included   PPI_CHG_CH6_Included
N
N#define PPI_CHG2_CH5_Pos        PPI_CHG_CH5_Pos
N#define PPI_CHG2_CH5_Msk        PPI_CHG_CH5_Msk
N#define PPI_CHG2_CH5_Excluded   PPI_CHG_CH5_Excluded
N#define PPI_CHG2_CH5_Included   PPI_CHG_CH5_Included
N
N#define PPI_CHG2_CH4_Pos        PPI_CHG_CH4_Pos
N#define PPI_CHG2_CH4_Msk        PPI_CHG_CH4_Msk
N#define PPI_CHG2_CH4_Excluded   PPI_CHG_CH4_Excluded
N#define PPI_CHG2_CH4_Included   PPI_CHG_CH4_Included
N
N#define PPI_CHG2_CH3_Pos        PPI_CHG_CH3_Pos
N#define PPI_CHG2_CH3_Msk        PPI_CHG_CH3_Msk
N#define PPI_CHG2_CH3_Excluded   PPI_CHG_CH3_Excluded
N#define PPI_CHG2_CH3_Included   PPI_CHG_CH3_Included
N
N#define PPI_CHG2_CH2_Pos        PPI_CHG_CH2_Pos
N#define PPI_CHG2_CH2_Msk        PPI_CHG_CH2_Msk
N#define PPI_CHG2_CH2_Excluded   PPI_CHG_CH2_Excluded
N#define PPI_CHG2_CH2_Included   PPI_CHG_CH2_Included
N
N#define PPI_CHG2_CH1_Pos        PPI_CHG_CH1_Pos
N#define PPI_CHG2_CH1_Msk        PPI_CHG_CH1_Msk
N#define PPI_CHG2_CH1_Excluded   PPI_CHG_CH1_Excluded
N#define PPI_CHG2_CH1_Included   PPI_CHG_CH1_Included
N
N#define PPI_CHG2_CH0_Pos        PPI_CHG_CH0_Pos
N#define PPI_CHG2_CH0_Msk        PPI_CHG_CH0_Msk
N#define PPI_CHG2_CH0_Excluded   PPI_CHG_CH0_Excluded
N#define PPI_CHG2_CH0_Included   PPI_CHG_CH0_Included
N
N#define PPI_CHG3_CH15_Pos       PPI_CHG_CH15_Pos
N#define PPI_CHG3_CH15_Msk       PPI_CHG_CH15_Msk
N#define PPI_CHG3_CH15_Excluded  PPI_CHG_CH15_Excluded
N#define PPI_CHG3_CH15_Included  PPI_CHG_CH15_Included
N
N#define PPI_CHG3_CH14_Pos       PPI_CHG_CH14_Pos
N#define PPI_CHG3_CH14_Msk       PPI_CHG_CH14_Msk
N#define PPI_CHG3_CH14_Excluded  PPI_CHG_CH14_Excluded
N#define PPI_CHG3_CH14_Included  PPI_CHG_CH14_Included
N
N#define PPI_CHG3_CH13_Pos       PPI_CHG_CH13_Pos
N#define PPI_CHG3_CH13_Msk       PPI_CHG_CH13_Msk
N#define PPI_CHG3_CH13_Excluded  PPI_CHG_CH13_Excluded
N#define PPI_CHG3_CH13_Included  PPI_CHG_CH13_Included
N
N#define PPI_CHG3_CH12_Pos       PPI_CHG_CH12_Pos
N#define PPI_CHG3_CH12_Msk       PPI_CHG_CH12_Msk
N#define PPI_CHG3_CH12_Excluded  PPI_CHG_CH12_Excluded
N#define PPI_CHG3_CH12_Included  PPI_CHG_CH12_Included
N
N#define PPI_CHG3_CH11_Pos       PPI_CHG_CH11_Pos
N#define PPI_CHG3_CH11_Msk       PPI_CHG_CH11_Msk
N#define PPI_CHG3_CH11_Excluded  PPI_CHG_CH11_Excluded
N#define PPI_CHG3_CH11_Included  PPI_CHG_CH11_Included
N
N#define PPI_CHG3_CH10_Pos       PPI_CHG_CH10_Pos
N#define PPI_CHG3_CH10_Msk       PPI_CHG_CH10_Msk
N#define PPI_CHG3_CH10_Excluded  PPI_CHG_CH10_Excluded
N#define PPI_CHG3_CH10_Included  PPI_CHG_CH10_Included
N
N#define PPI_CHG3_CH9_Pos        PPI_CHG_CH9_Pos
N#define PPI_CHG3_CH9_Msk        PPI_CHG_CH9_Msk
N#define PPI_CHG3_CH9_Excluded   PPI_CHG_CH9_Excluded
N#define PPI_CHG3_CH9_Included   PPI_CHG_CH9_Included
N
N#define PPI_CHG3_CH8_Pos        PPI_CHG_CH8_Pos
N#define PPI_CHG3_CH8_Msk        PPI_CHG_CH8_Msk
N#define PPI_CHG3_CH8_Excluded   PPI_CHG_CH8_Excluded
N#define PPI_CHG3_CH8_Included   PPI_CHG_CH8_Included
N
N#define PPI_CHG3_CH7_Pos        PPI_CHG_CH7_Pos
N#define PPI_CHG3_CH7_Msk        PPI_CHG_CH7_Msk
N#define PPI_CHG3_CH7_Excluded   PPI_CHG_CH7_Excluded
N#define PPI_CHG3_CH7_Included   PPI_CHG_CH7_Included
N
N#define PPI_CHG3_CH6_Pos        PPI_CHG_CH6_Pos
N#define PPI_CHG3_CH6_Msk        PPI_CHG_CH6_Msk
N#define PPI_CHG3_CH6_Excluded   PPI_CHG_CH6_Excluded
N#define PPI_CHG3_CH6_Included   PPI_CHG_CH6_Included
N
N#define PPI_CHG3_CH5_Pos        PPI_CHG_CH5_Pos
N#define PPI_CHG3_CH5_Msk        PPI_CHG_CH5_Msk
N#define PPI_CHG3_CH5_Excluded   PPI_CHG_CH5_Excluded
N#define PPI_CHG3_CH5_Included   PPI_CHG_CH5_Included
N
N#define PPI_CHG3_CH4_Pos        PPI_CHG_CH4_Pos
N#define PPI_CHG3_CH4_Msk        PPI_CHG_CH4_Msk
N#define PPI_CHG3_CH4_Excluded   PPI_CHG_CH4_Excluded
N#define PPI_CHG3_CH4_Included   PPI_CHG_CH4_Included
N
N#define PPI_CHG3_CH3_Pos        PPI_CHG_CH3_Pos
N#define PPI_CHG3_CH3_Msk        PPI_CHG_CH3_Msk
N#define PPI_CHG3_CH3_Excluded   PPI_CHG_CH3_Excluded
N#define PPI_CHG3_CH3_Included   PPI_CHG_CH3_Included
N
N#define PPI_CHG3_CH2_Pos        PPI_CHG_CH2_Pos
N#define PPI_CHG3_CH2_Msk        PPI_CHG_CH2_Msk
N#define PPI_CHG3_CH2_Excluded   PPI_CHG_CH2_Excluded
N#define PPI_CHG3_CH2_Included   PPI_CHG_CH2_Included
N
N#define PPI_CHG3_CH1_Pos        PPI_CHG_CH1_Pos
N#define PPI_CHG3_CH1_Msk        PPI_CHG_CH1_Msk
N#define PPI_CHG3_CH1_Excluded   PPI_CHG_CH1_Excluded
N#define PPI_CHG3_CH1_Included   PPI_CHG_CH1_Included
N
N#define PPI_CHG3_CH0_Pos        PPI_CHG_CH0_Pos
N#define PPI_CHG3_CH0_Msk        PPI_CHG_CH0_Msk
N#define PPI_CHG3_CH0_Excluded   PPI_CHG_CH0_Excluded
N#define PPI_CHG3_CH0_Included   PPI_CHG_CH0_Included
N
N
N
N
N/*lint --flb "Leave library region" */
N
N#endif /* NRF51_TO_NRF52_H */
N
L 56 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf.h" 2
N        #include "nrf52_name_change.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf52_name_change.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef NRF52_NAME_CHANGE_H
N#define NRF52_NAME_CHANGE_H
N
N/*lint ++flb "Enter library region */
N
N/* This file is given to prevent your SW from not compiling with the updates made to nrf52.h and 
N * nrf52_bitfields.h. The macros defined in this file were available previously. Do not use these
N * macros on purpose. Use the ones defined in nrf52.h and nrf52_bitfields.h instead.
N */
N
N/* I2S */
N/* Several enumerations changed case. Adding old macros to keep compilation compatibility. */
N#define I2S_ENABLE_ENABLE_DISABLE           I2S_ENABLE_ENABLE_Disabled
N#define I2S_ENABLE_ENABLE_ENABLE            I2S_ENABLE_ENABLE_Enabled
N#define I2S_CONFIG_MODE_MODE_MASTER         I2S_CONFIG_MODE_MODE_Master
N#define I2S_CONFIG_MODE_MODE_SLAVE          I2S_CONFIG_MODE_MODE_Slave
N#define I2S_CONFIG_RXEN_RXEN_DISABLE        I2S_CONFIG_RXEN_RXEN_Disabled
N#define I2S_CONFIG_RXEN_RXEN_ENABLE         I2S_CONFIG_RXEN_RXEN_Enabled
N#define I2S_CONFIG_TXEN_TXEN_DISABLE        I2S_CONFIG_TXEN_TXEN_Disabled
N#define I2S_CONFIG_TXEN_TXEN_ENABLE         I2S_CONFIG_TXEN_TXEN_Enabled
N#define I2S_CONFIG_MCKEN_MCKEN_DISABLE      I2S_CONFIG_MCKEN_MCKEN_Disabled
N#define I2S_CONFIG_MCKEN_MCKEN_ENABLE       I2S_CONFIG_MCKEN_MCKEN_Enabled
N#define I2S_CONFIG_SWIDTH_SWIDTH_8BIT       I2S_CONFIG_SWIDTH_SWIDTH_8Bit
N#define I2S_CONFIG_SWIDTH_SWIDTH_16BIT      I2S_CONFIG_SWIDTH_SWIDTH_16Bit
N#define I2S_CONFIG_SWIDTH_SWIDTH_24BIT      I2S_CONFIG_SWIDTH_SWIDTH_24Bit
N#define I2S_CONFIG_ALIGN_ALIGN_LEFT         I2S_CONFIG_ALIGN_ALIGN_Left
N#define I2S_CONFIG_ALIGN_ALIGN_RIGHT        I2S_CONFIG_ALIGN_ALIGN_Right
N#define I2S_CONFIG_FORMAT_FORMAT_ALIGNED    I2S_CONFIG_FORMAT_FORMAT_Aligned
N#define I2S_CONFIG_CHANNELS_CHANNELS_STEREO I2S_CONFIG_CHANNELS_CHANNELS_Stereo
N#define I2S_CONFIG_CHANNELS_CHANNELS_LEFT   I2S_CONFIG_CHANNELS_CHANNELS_Left
N#define I2S_CONFIG_CHANNELS_CHANNELS_RIGHT  I2S_CONFIG_CHANNELS_CHANNELS_Right
N
N/* LPCOMP */
N/* Corrected typo in RESULT register. */
N#define LPCOMP_RESULT_RESULT_Bellow         LPCOMP_RESULT_RESULT_Below
N
N/* FICR */
N/* Renamed name of the package. */
N#define FICR_INFO_PACKAGE_PACKAGE_CH        FICR_INFO_PACKAGE_PACKAGE_CI
N
N
N/*lint --flb "Leave library region" */
N
N#endif /* NRF52_NAME_CHANGE_H */
N
L 57 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf.h" 2
N    #else
S        #error "Device family must be defined. See nrf.h."
N    #endif /* NRF51, NRF52 */
N
N    #include "compiler_abstraction.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\compiler_abstraction.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef _COMPILER_ABSTRACTION_H
N#define _COMPILER_ABSTRACTION_H
N
N/*lint ++flb "Enter library region" */
N
N#if defined ( __CC_ARM )
X#if 1L
N
N    #ifndef __ASM
S        #define __ASM               __asm
N    #endif
N
N    #ifndef __INLINE
S        #define __INLINE            __inline
N    #endif
N
N    #ifndef __WEAK
N        #define __WEAK              __weak
N    #endif
N
N    #ifndef __ALIGN
N        #define __ALIGN(n)          __align(n)
N    #endif
N
N    #ifndef __PACKED
N        #define __PACKED            __packed
N    #endif
N
N    #define GET_SP()                __current_sp()
N
N#elif defined ( __ICCARM__ )
S
S    #ifndef __ASM
S        #define __ASM               __asm
S    #endif
S
S    #ifndef __INLINE
S        #define __INLINE            inline
S    #endif
S
S    #ifndef __WEAK
S        #define __WEAK              __weak
S    #endif
S
S    #ifndef __ALIGN
S        #define STRING_PRAGMA(x) _Pragma(#x)
S        #define __ALIGN(n) STRING_PRAGMA(data_alignment = n)
S    #endif
S
S    #ifndef __PACKED
S        #define __PACKED            __packed
S    #endif
S    
S    #define GET_SP()                __get_SP()
S
S#elif defined   ( __GNUC__ )
S
S    #ifndef __ASM
S        #define __ASM               __asm
S    #endif
S
S    #ifndef __INLINE
S        #define __INLINE            inline
S    #endif
S
S    #ifndef __WEAK
S        #define __WEAK              __attribute__((weak))
S    #endif
S
S    #ifndef __ALIGN
S        #define __ALIGN(n)          __attribute__((aligned(n)))
S    #endif
S
S    #ifndef __PACKED
S        #define __PACKED           __attribute__((packed)) 
S    #endif
S
S    #define GET_SP()                gcc_current_sp()
S
S    static inline unsigned int gcc_current_sp(void)
S    {
S        register unsigned sp __ASM("sp");
S        return sp;
S    }
S
S#elif defined   ( __TASKING__ )
S
S    #ifndef __ASM
S        #define __ASM               __asm
S    #endif
S
S    #ifndef __INLINE
S        #define __INLINE            inline
S    #endif
S
S    #ifndef __WEAK
S        #define __WEAK              __attribute__((weak))
S    #endif
S
S    #ifndef __ALIGN
S        #define __ALIGN(n)          __align(n)
S    #endif
S    
S    /* Not defined for TASKING. */
S    #ifndef __PACKED
S        #define __PACKED
S    #endif
S
S    #define GET_SP()                __get_MSP()
S
N#endif
N
N/*lint --flb "Leave library region" */
N
N#endif
L 62 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf.h" 2
N
N#endif /* _WIN32 || __unix || __APPLE__ */
N
N#endif /* NRF_H */
N
L 33 "..\..\..\main.c" 2
N#include "app_error.h"
L 1 "..\..\..\..\..\..\components\libraries\util\app_error.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup app_error Common application error handler
N * @{
N * @ingroup app_common
N *
N * @brief Common application error handler and macros for utilizing a common error handler.
N */
N
N#ifndef APP_ERROR_H__
N#define APP_ERROR_H__
N
N#include <stdint.h>
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060016
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 27 "..\..\..\..\..\..\components\libraries\util\app_error.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060016
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 28 "..\..\..\..\..\..\components\libraries\util\app_error.h" 2
N#include "nrf.h"
N#include "sdk_errors.h"
L 1 "..\..\..\..\..\..\components\libraries\util\sdk_errors.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**@file
N *
N * @defgroup sdk_error SDK Error codes
N * @{
N * @ingroup app_common
N * @{
N * @details Error codes are 32-bit unsigned integers with the most significant 16-bit reserved for
N *          identifying the module where the error occurred while the least least significant LSB
N *          are used to provide the cause or nature of error. Each module is assigned a 16-bit
N *          unsigned integer. Which it will use to identify all errors that occurred in it. 16-bit
N *          LSB range is with module id as the MSB in the 32-bit error code is reserved for the
N *          module. As an example, if 0x8800 identifies a certain SDK module, all values from
N *          0x88000000 - 0x8800FFFF are reserved for this module.
N *          It should be noted that common error reasons have been assigned values to make it
N *          possible to decode error reason easily. As an example, lets module uninitialized has
N *          been assigned an error code 0x000A0. Then, if application encounters an error code
N *          0xZZZZ00A0, it knows that it accessing a certain module without initializing it.
N *          Apart from this, each module is allowed to define error codes that are not covered by
N *          the common ones, however, these values are defined in a range that does not conflict
N *          with common error values. For module, specific error however, it is possible that the
N *          same error value is used by two different modules to indicated errors of very different
N *          nature. If error is already defined by the NRF common error codes, these are reused.
N *          A range is reserved for application as well, it can use this range for defining
N *          application specific errors.
N *
N * @note Success code, NRF_SUCCESS, does not include any module identifier.
N
N */
N
N#ifndef SDK_ERRORS_H__
N#define SDK_ERRORS_H__
N
N#include <stdint.h>
N#include "nrf_error.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\nrf_error.h" 1
N/* 
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N * 
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N * 
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N * 
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N * 
N * 
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */ 
N /**
N  @defgroup nrf_error SoftDevice Global Error Codes
N  @{
N   
N  @brief Global Error definitions
N*/
N
N/* Header guard */
N#ifndef NRF_ERROR_H__
N#define NRF_ERROR_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup NRF_ERRORS_BASE Error Codes Base number definitions
N * @{ */
N#define NRF_ERROR_BASE_NUM      (0x0)       ///< Global error base
N#define NRF_ERROR_SDM_BASE_NUM  (0x1000)    ///< SDM error base
N#define NRF_ERROR_SOC_BASE_NUM  (0x2000)    ///< SoC error base
N#define NRF_ERROR_STK_BASE_NUM  (0x3000)    ///< STK error base
N/** @} */
N
N#define NRF_SUCCESS                           (NRF_ERROR_BASE_NUM + 0)  ///< Successful command
N#define NRF_ERROR_SVC_HANDLER_MISSING         (NRF_ERROR_BASE_NUM + 1)  ///< SVC handler is missing
N#define NRF_ERROR_SOFTDEVICE_NOT_ENABLED      (NRF_ERROR_BASE_NUM + 2)  ///< SoftDevice has not been enabled
N#define NRF_ERROR_INTERNAL                    (NRF_ERROR_BASE_NUM + 3)  ///< Internal Error
N#define NRF_ERROR_NO_MEM                      (NRF_ERROR_BASE_NUM + 4)  ///< No Memory for operation
N#define NRF_ERROR_NOT_FOUND                   (NRF_ERROR_BASE_NUM + 5)  ///< Not found
N#define NRF_ERROR_NOT_SUPPORTED               (NRF_ERROR_BASE_NUM + 6)  ///< Not supported
N#define NRF_ERROR_INVALID_PARAM               (NRF_ERROR_BASE_NUM + 7)  ///< Invalid Parameter
N#define NRF_ERROR_INVALID_STATE               (NRF_ERROR_BASE_NUM + 8)  ///< Invalid state, operation disallowed in this state
N#define NRF_ERROR_INVALID_LENGTH              (NRF_ERROR_BASE_NUM + 9)  ///< Invalid Length
N#define NRF_ERROR_INVALID_FLAGS               (NRF_ERROR_BASE_NUM + 10) ///< Invalid Flags
N#define NRF_ERROR_INVALID_DATA                (NRF_ERROR_BASE_NUM + 11) ///< Invalid Data
N#define NRF_ERROR_DATA_SIZE                   (NRF_ERROR_BASE_NUM + 12) ///< Invalid Data size
N#define NRF_ERROR_TIMEOUT                     (NRF_ERROR_BASE_NUM + 13) ///< Operation timed out
N#define NRF_ERROR_NULL                        (NRF_ERROR_BASE_NUM + 14) ///< Null Pointer
N#define NRF_ERROR_FORBIDDEN                   (NRF_ERROR_BASE_NUM + 15) ///< Forbidden Operation
N#define NRF_ERROR_INVALID_ADDR                (NRF_ERROR_BASE_NUM + 16) ///< Bad Memory Address
N#define NRF_ERROR_BUSY                        (NRF_ERROR_BASE_NUM + 17) ///< Busy
N#define NRF_ERROR_CONN_COUNT                  (NRF_ERROR_BASE_NUM + 18) ///< Maximum connection count exceeded.
N#define NRF_ERROR_RESOURCES                   (NRF_ERROR_BASE_NUM + 19) ///< Not enough resources for operation
N
N#ifdef __cplusplus
S}
N#endif
N#endif // NRF_ERROR_H__
N
N/**
N  @}
N*/
L 47 "..\..\..\..\..\..\components\libraries\util\sdk_errors.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @defgroup sdk_err_base Base defined for SDK Modules
N * @{
N */
N#define SDK_ERROR_BASE         (NRF_ERROR_BASE_NUM + 0x8000)   /**< Base value defined for SDK module identifiers. */
N#define SDK_COMMON_ERROR_BASE  (NRF_ERROR_BASE_NUM + 0x0080)   /**< Base error value to be used for SDK error values. */
N/* @} */
N
N/**
N * @defgroup sdk_module_codes Codes reserved as identification for module where the error occurred.
N * @{
N */
N#define MEMORY_MANAGER_ERR_BASE   (0x8100)
N#define PERIPH_DRIVERS_ERR_BASE   (0x8200)
N#define GAZELLE_ERR_BASE          (0x8300)
N/* @} */
N
N
N/**
N * @defgroup sdk_iot_errors Codes reserved as identification for IoT errors.
N * @{
N */
N#define IOT_ERR_BASE_START        (0xA000)
N#define IOT_ERR_BASE_STOP         (0xAFFF)
N/* @} */
N
N
N/**
N * @defgroup sdk_common_errors Codes reserved as identification for common errors.
N * @{
N */
N#define MODULE_NOT_INITIALZED      (SDK_COMMON_ERROR_BASE + 0x0000)
N#define MUTEX_INIT_FAILED          (SDK_COMMON_ERROR_BASE + 0x0001)
N#define MUTEX_LOCK_FAILED          (SDK_COMMON_ERROR_BASE + 0x0002)
N#define MUTEX_UNLOCK_FAILED        (SDK_COMMON_ERROR_BASE + 0x0003)
N#define MUTEX_COND_INIT_FAILED     (SDK_COMMON_ERROR_BASE + 0x0004)
N#define MODULE_ALREADY_INITIALIZED (SDK_COMMON_ERROR_BASE + 0x0005)
N#define API_NOT_IMPLEMENTED        (SDK_COMMON_ERROR_BASE + 0x0010)
N#define FEATURE_NOT_ENABLED        (SDK_COMMON_ERROR_BASE + 0x0011)
N/* @} */
N
N
N/**
N * @defgroup drv_specific_errors Error / status codes specific to drivers.
N * @{
N */
N#define DRV_TWI_ERR_OVERRUN              (PERIPH_DRIVERS_ERR_BASE + 0x0000)
N#define DRV_TWI_ERR_ANACK                (PERIPH_DRIVERS_ERR_BASE + 0x0001)
N#define DRV_TWI_ERR_DNACK                (PERIPH_DRIVERS_ERR_BASE + 0x0002)
N/* @} */
N
N/**
N * @brief API Result.
N *
N * @details Indicates success or failure of an API procedure. In case of failure, a comprehensive
N *          error code indicating cause or reason for failure is provided.
N *
N *          Though called an API result, it could used in Asynchronous notifications callback along
N *          with asynchronous callback as event result. This mechanism is employed when an event
N *          marks the end of procedure initiated using API. API result, in this case, will only be
N *          an indicative of whether the procedure has been requested successfully.
N */
Ntypedef uint32_t ret_code_t;
N/** @} */
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // SDK_ERRORS_H__
N
L 30 "..\..\..\..\..\..\components\libraries\util\app_error.h" 2
N#include "nordic_common.h"
N#include "app_error_weak.h"
L 1 "..\..\..\..\..\..\components\libraries\util\app_error_weak.h" 1
N/* Copyright (c) 2016 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#ifndef APP_ERROR_WEAK_H__
N#define APP_ERROR_WEAK_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @file
N *
N * @defgroup app_error Common application error handler
N * @{
N * @ingroup app_common
N *
N * @brief Common application error handler.
N */
N
N/**@brief       Callback function for errors, asserts, and faults.
N *
N * @details     This function is called every time an error is raised in app_error, nrf_assert, or
N *              in the SoftDevice. Information about the error can be found in the @p info
N *              parameter.
N *
N *              See also @ref nrf_fault_handler_t for more details.
N *
N * @note        The function is implemented as weak so that it can be redefined by a custom error
N *              handler when needed.
N *
N * @param[in] id    Fault identifier. See @ref NRF_FAULT_IDS.
N * @param[in] pc    The program counter of the instruction that triggered the fault, or 0 if
N *                  unavailable.
N * @param[in] info  Optional additional information regarding the fault. The value of the @p id
N *                  parameter dictates how to interpret this parameter. Refer to the documentation
N *                  for each fault identifier (@ref NRF_FAULT_IDS and @ref APP_ERROR_FAULT_IDS) for
N *                  details about interpreting @p info.
N */
Nvoid app_error_fault_handler(uint32_t id, uint32_t pc, uint32_t info);
N
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_ERROR_WEAK_H__
L 32 "..\..\..\..\..\..\components\libraries\util\app_error.h" 2
N#ifdef ANT_STACK_SUPPORT_REQD
S#include "ant_error.h"
N#endif // ANT_STACK_SUPPORT_REQD
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define NRF_FAULT_ID_SDK_RANGE_START 0x00004000 /**< The start of the range of error IDs defined in the SDK. */
N
N/**@defgroup APP_ERROR_FAULT_IDS Fault ID types
N * @{ */
N#define NRF_FAULT_ID_SDK_ERROR       NRF_FAULT_ID_SDK_RANGE_START + 1 /**< An error stemming from a call to @ref APP_ERROR_CHECK or @ref APP_ERROR_CHECK_BOOL. The info parameter is a pointer to an @ref error_info_t variable. */
N#define NRF_FAULT_ID_SDK_ASSERT      NRF_FAULT_ID_SDK_RANGE_START + 2 /**< An error stemming from a call to ASSERT (nrf_assert.h). The info parameter is a pointer to an @ref assert_info_t variable. */
N/**@} */
N
N/**@brief Structure containing info about an error of the type @ref NRF_FAULT_ID_SDK_ERROR.
N */
Ntypedef struct
N{
N    uint16_t        line_num;    /**< The line number where the error occurred. */
N    uint8_t const * p_file_name; /**< The file in which the error occurred. */
N    uint32_t        err_code;    /**< The error code representing the error that occurred. */
N} error_info_t;
N
N/**@brief Structure containing info about an error of the type @ref NRF_FAULT_ID_SDK_ASSERT.
N */
Ntypedef struct
N{
N    uint16_t        line_num;    /**< The line number where the error occurred. */
N    uint8_t const * p_file_name; /**< The file in which the error occurred. */
N} assert_info_t;
N
N/**@brief Function for error handling, which is called when an error has occurred.
N *
N * @param[in] error_code  Error code supplied to the handler.
N * @param[in] line_num    Line number where the handler is called.
N * @param[in] p_file_name Pointer to the file name.
N */
Nvoid app_error_handler(uint32_t error_code, uint32_t line_num, const uint8_t * p_file_name);
N
N/**@brief Function for error handling, which is called when an error has occurred.
N *
N * @param[in] error_code  Error code supplied to the handler.
N */
Nvoid app_error_handler_bare(ret_code_t error_code);
N
N/**@brief       Function for saving the parameters and entering an eternal loop, for debug purposes.
N *
N * @param[in] id    Fault identifier. See @ref NRF_FAULT_IDS.
N * @param[in] pc    The program counter of the instruction that triggered the fault, or 0 if
N *                  unavailable.
N * @param[in] info  Optional additional information regarding the fault. Refer to each fault
N *                  identifier for details.
N */
Nvoid app_error_save_and_stop(uint32_t id, uint32_t pc, uint32_t info);
N
N/**@brief       Function for printing all error info (using nrf_log).
N *
N * @details     Nrf_log library must be initialized using NRF_LOG_INIT macro before calling
N *              this function.
N *
N * @param[in] id    Fault identifier. See @ref NRF_FAULT_IDS.
N * @param[in] pc    The program counter of the instruction that triggered the fault, or 0 if
N *                  unavailable.
N * @param[in] info  Optional additional information regarding the fault. Refer to each fault
N *                  identifier for details.
N */
Nstatic __INLINE void app_error_log(uint32_t id, uint32_t pc, uint32_t info)
Xstatic __inline void app_error_log(uint32_t id, uint32_t pc, uint32_t info)
N{
N    switch (id)
N    {
N        case NRF_FAULT_ID_SDK_ASSERT:
X        case 0x00004000 + 2:
N            //NRF_LOG_INFO(NRF_LOG_COLOR_RED "\r\n*** ASSERTION FAILED ***\r\n");
N            if (((assert_info_t *)(info))->p_file_name)
N            {
N               // NRF_LOG_INFO(NRF_LOG_COLOR_WHITE "Line Number: %u\r\n", (unsigned int) ((assert_info_t *)(info))->line_num);
N                //NRF_LOG_INFO("File Name:   %s\r\n", ((assert_info_t *)(info))->p_file_name);
N            }
N            //NRF_LOG_INFO(NRF_LOG_COLOR_DEFAULT "\r\n");
N            break;
N
N        case NRF_FAULT_ID_SDK_ERROR:
X        case 0x00004000 + 1:
N            //NRF_LOG_INFO(NRF_LOG_COLOR_RED "\r\n*** APPLICATION ERROR *** \r\n" NRF_LOG_COLOR_WHITE);
N            if (((error_info_t *)(info))->p_file_name)
N            {
N                //NRF_LOG_INFO("Line Number: %u\r\n", (unsigned int) ((error_info_t *)(info))->line_num);
N                //NRF_LOG_INFO("File Name:   %s\r\n", ((error_info_t *)(info))->p_file_name);
N            }
N            //NRF_LOG_INFO("Error Code:  0x%X\r\n" NRF_LOG_COLOR_DEFAULT "\r\n", (unsigned int) ((error_info_t *)(info))->err_code);
N            break;
N    }
N}
N
N/**@brief       Function for printing all error info (using printf).
N *
N * @param[in] id    Fault identifier. See @ref NRF_FAULT_IDS.
N * @param[in] pc    The program counter of the instruction that triggered the fault, or 0 if
N *                  unavailable.
N * @param[in] info  Optional additional information regarding the fault. Refer to each fault
N *                  identifier for details.
N */
N//lint -save -e438
Nstatic __INLINE void app_error_print(uint32_t id, uint32_t pc, uint32_t info)
Xstatic __inline void app_error_print(uint32_t id, uint32_t pc, uint32_t info)
N{
N    unsigned int tmp = id;
N    printf("app_error_print():\r\n");
N    printf("Fault identifier:  0x%X\r\n", tmp);
N    printf("Program counter:   0x%X\r\n", tmp = pc);
N    printf("Fault information: 0x%X\r\n", tmp = info);
N
N    switch (id)
N    {
N        case NRF_FAULT_ID_SDK_ASSERT:
X        case 0x00004000 + 2:
N            printf("Line Number: %u\r\n", tmp = ((assert_info_t *)(info))->line_num);
N            printf("File Name:   %s\r\n",       ((assert_info_t *)(info))->p_file_name);
N            break;
N
N        case NRF_FAULT_ID_SDK_ERROR:
X        case 0x00004000 + 1:
N            printf("Line Number: %u\r\n",   tmp = ((error_info_t *)(info))->line_num);
N            printf("File Name:   %s\r\n",         ((error_info_t *)(info))->p_file_name);
N            printf("Error Code:  0x%X\r\n", tmp = ((error_info_t *)(info))->err_code);
N            break;
N    }
N}
N//lint -restore
N
N
N/**@brief Macro for calling error handler function.
N *
N * @param[in] ERR_CODE Error code supplied to the error handler.
N */
N#ifdef DEBUG
S#define APP_ERROR_HANDLER(ERR_CODE)                                    \
S    do                                                                 \
S    {                                                                  \
S        app_error_handler((ERR_CODE), __LINE__, (uint8_t*) __FILE__);  \
S    } while (0)
X#define APP_ERROR_HANDLER(ERR_CODE)                                        do                                                                     {                                                                          app_error_handler((ERR_CODE), __LINE__, (uint8_t*) __FILE__);      } while (0)
N#else
N#define APP_ERROR_HANDLER(ERR_CODE)                                    \
N    do                                                                 \
N    {                                                                  \
N        app_error_handler_bare((ERR_CODE));                            \
N    } while (0)
X#define APP_ERROR_HANDLER(ERR_CODE)                                        do                                                                     {                                                                          app_error_handler_bare((ERR_CODE));                                } while (0)
N#endif
N/**@brief Macro for calling error handler function if supplied error code any other than NRF_SUCCESS.
N *
N * @param[in] ERR_CODE Error code supplied to the error handler.
N */
N#define APP_ERROR_CHECK(ERR_CODE)                           \
N    do                                                      \
N    {                                                       \
N        const uint32_t LOCAL_ERR_CODE = (ERR_CODE);         \
N        if (LOCAL_ERR_CODE != NRF_SUCCESS)                  \
N        {                                                   \
N            APP_ERROR_HANDLER(LOCAL_ERR_CODE);              \
N        }                                                   \
N    } while (0)
X#define APP_ERROR_CHECK(ERR_CODE)                               do                                                          {                                                               const uint32_t LOCAL_ERR_CODE = (ERR_CODE);                 if (LOCAL_ERR_CODE != NRF_SUCCESS)                          {                                                               APP_ERROR_HANDLER(LOCAL_ERR_CODE);                      }                                                       } while (0)
N
N/**@brief Macro for calling error handler function if supplied boolean value is false.
N *
N * @param[in] BOOLEAN_VALUE Boolean value to be evaluated.
N */
N#define APP_ERROR_CHECK_BOOL(BOOLEAN_VALUE)                   \
N    do                                                        \
N    {                                                         \
N        const uint32_t LOCAL_BOOLEAN_VALUE = (BOOLEAN_VALUE); \
N        if (!LOCAL_BOOLEAN_VALUE)                             \
N        {                                                     \
N            APP_ERROR_HANDLER(0);                             \
N        }                                                     \
N    } while (0)
X#define APP_ERROR_CHECK_BOOL(BOOLEAN_VALUE)                       do                                                            {                                                                 const uint32_t LOCAL_BOOLEAN_VALUE = (BOOLEAN_VALUE);         if (!LOCAL_BOOLEAN_VALUE)                                     {                                                                 APP_ERROR_HANDLER(0);                                     }                                                         } while (0)
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_ERROR_H__
N
N/** @} */
L 34 "..\..\..\main.c" 2
N#include "ble.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\ble.h" 1
N/*
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N *
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N *
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N *
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N
N/**
N  @addtogroup BLE_COMMON BLE SoftDevice Common
N  @{
N  @defgroup ble_api Events, type definitions and API calls
N  @{
N
N  @brief Module independent events, type definitions and API calls for the BLE SoftDevice.
N
N */
N
N#ifndef BLE_H__
N#define BLE_H__
N
N#include "ble_ranges.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_ranges.h" 1
N/* 
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N * 
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N * 
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N * 
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N * 
N * 
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/**
N  @addtogroup BLE_COMMON
N  @{
N  @defgroup ble_ranges Module specific SVC, event and option number subranges
N  @{
N
N  @brief Definition of SVC, event and option number subranges for each API module.
N
N  @note
N  SVCs, event and option numbers are split into subranges for each API module.
N  Each module receives its entire allocated range of SVC calls, whether implemented or not,
N  but return BLE_ERROR_NOT_SUPPORTED for unimplemented or undefined calls in its range.
N
N  Note that the symbols BLE_<module>_SVC_LAST is the end of the allocated SVC range,
N  rather than the last SVC function call actually defined and implemented.
N
N  Specific SVC, event and option values are defined in each module's ble_<module>.h file,
N  which defines names of each individual SVC code based on the range start value.
N*/
N
N#ifndef BLE_RANGES_H__
N#define BLE_RANGES_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define BLE_SVC_BASE           0x60       /**< Common BLE SVC base. */
N#define BLE_SVC_LAST           0x6B       /**< Common BLE SVC last. */
N
N
N#define BLE_GAP_SVC_BASE       0x6C       /**< GAP BLE SVC base. */
N#define BLE_GAP_SVC_LAST       0x93       /**< GAP BLE SVC last. */
N
N
N#define BLE_GATTC_SVC_BASE     0x94       /**< GATTC BLE SVC base. */
N#define BLE_GATTC_SVC_LAST     0x9F       /**< GATTC BLE SVC last. */
N
N
N#define BLE_GATTS_SVC_BASE     0xA0       /**< GATTS BLE SVC base. */
N#define BLE_GATTS_SVC_LAST     0xAF       /**< GATTS BLE SVC last. */
N
N
N#define BLE_L2CAP_SVC_BASE     0xB0       /**< L2CAP BLE SVC base. */
N#define BLE_L2CAP_SVC_LAST     0xBF       /**< L2CAP BLE SVC last. */
N
N
N#define BLE_EVT_INVALID        0x00       /**< Invalid BLE Event. */
N
N
N#define BLE_EVT_BASE           0x01       /**< Common BLE Event base. */
N#define BLE_EVT_LAST           0x0F       /**< Common BLE Event last. */
N
N
N#define BLE_GAP_EVT_BASE       0x10       /**< GAP BLE Event base. */
N#define BLE_GAP_EVT_LAST       0x2F       /**< GAP BLE Event last. */
N
N
N#define BLE_GATTC_EVT_BASE     0x30       /**< GATTC BLE Event base. */
N#define BLE_GATTC_EVT_LAST     0x4F       /**< GATTC BLE Event last. */
N
N
N#define BLE_GATTS_EVT_BASE     0x50       /**< GATTS BLE Event base. */
N#define BLE_GATTS_EVT_LAST     0x6F       /**< GATTS BLE Event last. */
N
N
N#define BLE_L2CAP_EVT_BASE     0x70       /**< L2CAP BLE Event base. */
N#define BLE_L2CAP_EVT_LAST     0x8F       /**< L2CAP BLE Event last. */
N
N
N#define BLE_OPT_INVALID        0x00       /**< Invalid BLE Option. */
N
N
N#define BLE_OPT_BASE           0x01       /**< Common BLE Option base. */
N#define BLE_OPT_LAST           0x1F       /**< Common BLE Option last. */
N
N
N#define BLE_GAP_OPT_BASE       0x20       /**< GAP BLE Option base. */
N#define BLE_GAP_OPT_LAST       0x3F       /**< GAP BLE Option last. */
N
N
N#define BLE_GATTC_OPT_BASE     0x40       /**< GATTC BLE Option base. */
N#define BLE_GATTC_OPT_LAST     0x5F       /**< GATTC BLE Option last. */
N
N
N#define BLE_GATTS_OPT_BASE     0x60       /**< GATTS BLE Option base. */
N#define BLE_GATTS_OPT_LAST     0x7F       /**< GATTS BLE Option last. */
N
N
N#define BLE_L2CAP_OPT_BASE     0x80       /**< L2CAP BLE Option base. */
N#define BLE_L2CAP_OPT_LAST     0x9F       /**< L2CAP BLE Option last. */
N
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* BLE_RANGES_H__ */
N
N/**
N  @}
N  @}
N*/
L 51 "..\..\..\..\..\..\components\softdevice\s132\headers\ble.h" 2
N#include "ble_types.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_types.h" 1
N/* 
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N * 
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N * 
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N * 
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N * 
N * 
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/**
N  @addtogroup BLE_COMMON
N  @{
N  @defgroup ble_types Common types and macro definitions
N  @{
N
N  @brief Common types and macro definitions for the BLE SoftDevice.
N */
N
N#ifndef BLE_TYPES_H__
N#define BLE_TYPES_H__
N
N#include <stdint.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup BLE_TYPES_DEFINES Defines
N * @{ */
N
N/** @defgroup BLE_CONN_HANDLES BLE Connection Handles
N * @{ */
N#define BLE_CONN_HANDLE_INVALID 0xFFFF  /**< Invalid Connection Handle. */
N#define BLE_CONN_HANDLE_ALL     0xFFFE  /**< Applies to all Connection Handles. */
N/** @} */
N
N
N/** @defgroup BLE_UUID_VALUES Assigned Values for BLE UUIDs
N * @{ */
N/* Generic UUIDs, applicable to all services */
N#define BLE_UUID_UNKNOWN                              0x0000 /**< Reserved UUID. */
N#define BLE_UUID_SERVICE_PRIMARY                      0x2800 /**< Primary Service. */
N#define BLE_UUID_SERVICE_SECONDARY                    0x2801 /**< Secondary Service. */
N#define BLE_UUID_SERVICE_INCLUDE                      0x2802 /**< Include. */
N#define BLE_UUID_CHARACTERISTIC                       0x2803 /**< Characteristic. */
N#define BLE_UUID_DESCRIPTOR_CHAR_EXT_PROP             0x2900 /**< Characteristic Extended Properties Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CHAR_USER_DESC            0x2901 /**< Characteristic User Description Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CLIENT_CHAR_CONFIG        0x2902 /**< Client Characteristic Configuration Descriptor. */
N#define BLE_UUID_DESCRIPTOR_SERVER_CHAR_CONFIG        0x2903 /**< Server Characteristic Configuration Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CHAR_PRESENTATION_FORMAT  0x2904 /**< Characteristic Presentation Format Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CHAR_AGGREGATE_FORMAT     0x2905 /**< Characteristic Aggregate Format Descriptor. */
N/* GATT specific UUIDs */
N#define BLE_UUID_GATT                                 0x1801 /**< Generic Attribute Profile. */
N#define BLE_UUID_GATT_CHARACTERISTIC_SERVICE_CHANGED  0x2A05 /**< Service Changed Characteristic. */
N/* GAP specific UUIDs */
N#define BLE_UUID_GAP                                  0x1800 /**< Generic Access Profile. */
N#define BLE_UUID_GAP_CHARACTERISTIC_DEVICE_NAME       0x2A00 /**< Device Name Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_APPEARANCE        0x2A01 /**< Appearance Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_RECONN_ADDR       0x2A03 /**< Reconnection Address Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_PPCP              0x2A04 /**< Peripheral Preferred Connection Parameters Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_CAR               0x2AA6 /**< Central Address Resolution Characteristic. */
N/** @} */
N
N
N/** @defgroup BLE_UUID_TYPES Types of UUID
N * @{ */
N#define BLE_UUID_TYPE_UNKNOWN       0x00 /**< Invalid UUID type. */
N#define BLE_UUID_TYPE_BLE           0x01 /**< Bluetooth SIG UUID (16-bit). */
N#define BLE_UUID_TYPE_VENDOR_BEGIN  0x02 /**< Vendor UUID types start at this index (128-bit). */
N/** @} */
N
N
N/** @defgroup BLE_APPEARANCES Bluetooth Appearance values
N *  @note Retrieved from http://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.gap.appearance.xml
N * @{ */
N#define BLE_APPEARANCE_UNKNOWN                                0 /**< Unknown. */
N#define BLE_APPEARANCE_GENERIC_PHONE                         64 /**< Generic Phone. */
N#define BLE_APPEARANCE_GENERIC_COMPUTER                     128 /**< Generic Computer. */
N#define BLE_APPEARANCE_GENERIC_WATCH                        192 /**< Generic Watch. */
N#define BLE_APPEARANCE_WATCH_SPORTS_WATCH                   193 /**< Watch: Sports Watch. */
N#define BLE_APPEARANCE_GENERIC_CLOCK                        256 /**< Generic Clock. */
N#define BLE_APPEARANCE_GENERIC_DISPLAY                      320 /**< Generic Display. */
N#define BLE_APPEARANCE_GENERIC_REMOTE_CONTROL               384 /**< Generic Remote Control. */
N#define BLE_APPEARANCE_GENERIC_EYE_GLASSES                  448 /**< Generic Eye-glasses. */
N#define BLE_APPEARANCE_GENERIC_TAG                          512 /**< Generic Tag. */
N#define BLE_APPEARANCE_GENERIC_KEYRING                      576 /**< Generic Keyring. */
N#define BLE_APPEARANCE_GENERIC_MEDIA_PLAYER                 640 /**< Generic Media Player. */
N#define BLE_APPEARANCE_GENERIC_BARCODE_SCANNER              704 /**< Generic Barcode Scanner. */
N#define BLE_APPEARANCE_GENERIC_THERMOMETER                  768 /**< Generic Thermometer. */
N#define BLE_APPEARANCE_THERMOMETER_EAR                      769 /**< Thermometer: Ear. */
N#define BLE_APPEARANCE_GENERIC_HEART_RATE_SENSOR            832 /**< Generic Heart rate Sensor. */
N#define BLE_APPEARANCE_HEART_RATE_SENSOR_HEART_RATE_BELT    833 /**< Heart Rate Sensor: Heart Rate Belt. */
N#define BLE_APPEARANCE_GENERIC_BLOOD_PRESSURE               896 /**< Generic Blood Pressure. */
N#define BLE_APPEARANCE_BLOOD_PRESSURE_ARM                   897 /**< Blood Pressure: Arm. */
N#define BLE_APPEARANCE_BLOOD_PRESSURE_WRIST                 898 /**< Blood Pressure: Wrist. */
N#define BLE_APPEARANCE_GENERIC_HID                          960 /**< Human Interface Device (HID). */
N#define BLE_APPEARANCE_HID_KEYBOARD                         961 /**< Keyboard (HID Subtype). */
N#define BLE_APPEARANCE_HID_MOUSE                            962 /**< Mouse (HID Subtype). */
N#define BLE_APPEARANCE_HID_JOYSTICK                         963 /**< Joystiq (HID Subtype). */
N#define BLE_APPEARANCE_HID_GAMEPAD                          964 /**< Gamepad (HID Subtype). */
N#define BLE_APPEARANCE_HID_DIGITIZERSUBTYPE                 965 /**< Digitizer Tablet (HID Subtype). */
N#define BLE_APPEARANCE_HID_CARD_READER                      966 /**< Card Reader (HID Subtype). */
N#define BLE_APPEARANCE_HID_DIGITAL_PEN                      967 /**< Digital Pen (HID Subtype). */
N#define BLE_APPEARANCE_HID_BARCODE                          968 /**< Barcode Scanner (HID Subtype). */
N#define BLE_APPEARANCE_GENERIC_GLUCOSE_METER               1024 /**< Generic Glucose Meter. */
N#define BLE_APPEARANCE_GENERIC_RUNNING_WALKING_SENSOR      1088 /**< Generic Running Walking Sensor. */
N#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_IN_SHOE      1089 /**< Running Walking Sensor: In-Shoe. */
N#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_SHOE      1090 /**< Running Walking Sensor: On-Shoe. */
N#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_HIP       1091 /**< Running Walking Sensor: On-Hip. */
N#define BLE_APPEARANCE_GENERIC_CYCLING                     1152 /**< Generic Cycling. */
N#define BLE_APPEARANCE_CYCLING_CYCLING_COMPUTER            1153 /**< Cycling: Cycling Computer. */
N#define BLE_APPEARANCE_CYCLING_SPEED_SENSOR                1154 /**< Cycling: Speed Sensor. */
N#define BLE_APPEARANCE_CYCLING_CADENCE_SENSOR              1155 /**< Cycling: Cadence Sensor. */
N#define BLE_APPEARANCE_CYCLING_POWER_SENSOR                1156 /**< Cycling: Power Sensor. */
N#define BLE_APPEARANCE_CYCLING_SPEED_CADENCE_SENSOR        1157 /**< Cycling: Speed and Cadence Sensor. */
N#define BLE_APPEARANCE_GENERIC_PULSE_OXIMETER              3136 /**< Generic Pulse Oximeter. */
N#define BLE_APPEARANCE_PULSE_OXIMETER_FINGERTIP            3137 /**< Fingertip (Pulse Oximeter subtype). */
N#define BLE_APPEARANCE_PULSE_OXIMETER_WRIST_WORN           3138 /**< Wrist Worn(Pulse Oximeter subtype). */
N#define BLE_APPEARANCE_GENERIC_WEIGHT_SCALE                3200 /**< Generic Weight Scale. */
N#define BLE_APPEARANCE_GENERIC_OUTDOOR_SPORTS_ACT          5184 /**< Generic Outdoor Sports Activity. */
N#define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_DISP         5185 /**< Location Display Device (Outdoor Sports Activity subtype). */
N#define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_AND_NAV_DISP 5186 /**< Location and Navigation Display Device (Outdoor Sports Activity subtype). */
N#define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_POD          5187 /**< Location Pod (Outdoor Sports Activity subtype). */
N#define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_AND_NAV_POD  5188 /**< Location and Navigation Pod (Outdoor Sports Activity subtype). */
N/** @} */
N
N/** @brief Set .type and .uuid fields of ble_uuid_struct to specified uuid value. */
N#define BLE_UUID_BLE_ASSIGN(instance, value) do {\
N            instance.type = BLE_UUID_TYPE_BLE; \
N            instance.uuid = value;} while(0)
X#define BLE_UUID_BLE_ASSIGN(instance, value) do {            instance.type = BLE_UUID_TYPE_BLE;             instance.uuid = value;} while(0)
N
N/** @brief Copy type and uuid members from src to dst ble_uuid_t pointer. Both pointers must be valid/non-null. */
N#define BLE_UUID_COPY_PTR(dst, src) do {\
N            (dst)->type = (src)->type; \
N            (dst)->uuid = (src)->uuid;} while(0)
X#define BLE_UUID_COPY_PTR(dst, src) do {            (dst)->type = (src)->type;             (dst)->uuid = (src)->uuid;} while(0)
N
N/** @brief Copy type and uuid members from src to dst ble_uuid_t struct. */
N#define BLE_UUID_COPY_INST(dst, src) do {\
N            (dst).type = (src).type; \
N            (dst).uuid = (src).uuid;} while(0)
X#define BLE_UUID_COPY_INST(dst, src) do {            (dst).type = (src).type;             (dst).uuid = (src).uuid;} while(0)
N
N/** @brief Compare for equality both type and uuid members of two (valid, non-null) ble_uuid_t pointers. */
N#define BLE_UUID_EQ(p_uuid1, p_uuid2) \
N            (((p_uuid1)->type == (p_uuid2)->type) && ((p_uuid1)->uuid == (p_uuid2)->uuid))
X#define BLE_UUID_EQ(p_uuid1, p_uuid2)             (((p_uuid1)->type == (p_uuid2)->type) && ((p_uuid1)->uuid == (p_uuid2)->uuid))
N
N/** @brief Compare for difference both type and uuid members of two (valid, non-null) ble_uuid_t pointers. */
N#define BLE_UUID_NEQ(p_uuid1, p_uuid2) \
N            (((p_uuid1)->type != (p_uuid2)->type) || ((p_uuid1)->uuid != (p_uuid2)->uuid))
X#define BLE_UUID_NEQ(p_uuid1, p_uuid2)             (((p_uuid1)->type != (p_uuid2)->type) || ((p_uuid1)->uuid != (p_uuid2)->uuid))
N
N/** @} */
N
N/** @addtogroup BLE_TYPES_STRUCTURES Structures
N * @{ */
N
N/** @brief 128 bit UUID values. */
Ntypedef struct
N{ 
N  uint8_t uuid128[16]; /**< Little-Endian UUID bytes. */
N} ble_uuid128_t;
N
N/** @brief  Bluetooth Low Energy UUID type, encapsulates both 16-bit and 128-bit UUIDs. */
Ntypedef struct
N{
N  uint16_t    uuid; /**< 16-bit UUID value or octets 12-13 of 128-bit UUID. */
N  uint8_t     type; /**< UUID type, see @ref BLE_UUID_TYPES. If type is @ref BLE_UUID_TYPE_UNKNOWN, the value of uuid is undefined. */
N} ble_uuid_t;
N
N/** @} */
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* BLE_TYPES_H__ */
N
N/**
N  @}
N  @}
N*/
L 52 "..\..\..\..\..\..\components\softdevice\s132\headers\ble.h" 2
N#include "ble_gap.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_gap.h" 1
N/*
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N *
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N *
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N *
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N
N/**
N  @addtogroup BLE_GAP Generic Access Profile (GAP)
N  @{
N  @brief Definitions and prototypes for the GAP interface.
N */
N
N#ifndef BLE_GAP_H__
N#define BLE_GAP_H__
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "nrf_svc.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\nrf_svc.h" 1
N/* 
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N * 
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N * 
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N * 
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N * 
N * 
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N 
N#ifndef NRF_SVC__
N#define NRF_SVC__
N
N#include "stdint.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N    
N#ifdef SVCALL_AS_NORMAL_FUNCTION
S#define SVCALL(number, return_type, signature) return_type signature
N#else
N
N#ifndef SVCALL
N#if defined (__CC_ARM)
X#if 1L
N#define SVCALL(number, return_type, signature) return_type __svc(number) signature
N#elif defined (__GNUC__)
S#ifdef __cplusplus
S#define GCC_CAST_CPP (uint8_t)
S#else
S#define GCC_CAST_CPP    
S#endif
S#define SVCALL(number, return_type, signature)          \
S  _Pragma("GCC diagnostic push")                        \
S  _Pragma("GCC diagnostic ignored \"-Wreturn-type\"")   \
S  __attribute__((naked))                                \
S  __attribute__((unused))                               \
S  static return_type signature                          \
S  {                                                     \
S    __asm(                                              \
S        "svc %0\n"                                      \
S        "bx r14" : : "I" (GCC_CAST_CPP number) : "r0"   \
S    );                                                  \
S  }                                                     \
S  _Pragma("GCC diagnostic pop")
X#define SVCALL(number, return_type, signature)            _Pragma("GCC diagnostic push")                          _Pragma("GCC diagnostic ignored \"-Wreturn-type\"")     __attribute__((naked))                                  __attribute__((unused))                                 static return_type signature                            {                                                         __asm(                                                      "svc %0\n"                                              "bx r14" : : "I" (GCC_CAST_CPP number) : "r0"       );                                                    }                                                       _Pragma("GCC diagnostic pop")
S  
S#elif defined (__ICCARM__)
S#define PRAGMA(x) _Pragma(#x)
S#define SVCALL(number, return_type, signature)          \
SPRAGMA(swi_number = (number))                           \
S __swi return_type signature;
X#define SVCALL(number, return_type, signature)          PRAGMA(swi_number = (number))                            __swi return_type signature;
S#else
S#define SVCALL(number, return_type, signature) return_type signature  
N#endif
N#endif  // SVCALL
N
N#endif  // SVCALL_AS_NORMAL_FUNCTION
N
N#ifdef __cplusplus
S}
N#endif
N#endif  // NRF_SVC__
L 49 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_gap.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**@addtogroup BLE_GAP_ENUMERATIONS Enumerations
N * @{ */
N
N/**@brief GAP API SVC numbers.
N */
Nenum BLE_GAP_SVCS
N{
N  SD_BLE_GAP_ADDR_SET = BLE_GAP_SVC_BASE,       /**< Set own Bluetooth Address. */
X  SD_BLE_GAP_ADDR_SET = 0x6C,        
N  SD_BLE_GAP_ADDR_GET,                          /**< Get own Bluetooth Address. */
N  SD_BLE_GAP_WHITELIST_SET,                     /**< Set active whitelist. */
N  SD_BLE_GAP_DEVICE_IDENTITIES_SET,             /**< Set device identity list. */
N  SD_BLE_GAP_PRIVACY_SET,                       /**< Set Privacy settings*/
N  SD_BLE_GAP_PRIVACY_GET,                       /**< Get Privacy settings*/
N  SD_BLE_GAP_ADV_DATA_SET,                      /**< Set Advertising Data. */
N  SD_BLE_GAP_ADV_START,                         /**< Start Advertising. */
N  SD_BLE_GAP_ADV_STOP,                          /**< Stop Advertising. */
N  SD_BLE_GAP_CONN_PARAM_UPDATE,                 /**< Connection Parameter Update. */
N  SD_BLE_GAP_DISCONNECT,                        /**< Disconnect. */
N  SD_BLE_GAP_TX_POWER_SET,                      /**< Set TX Power. */
N  SD_BLE_GAP_APPEARANCE_SET,                    /**< Set Appearance. */
N  SD_BLE_GAP_APPEARANCE_GET,                    /**< Get Appearance. */
N  SD_BLE_GAP_PPCP_SET,                          /**< Set PPCP. */
N  SD_BLE_GAP_PPCP_GET,                          /**< Get PPCP. */
N  SD_BLE_GAP_DEVICE_NAME_SET,                   /**< Set Device Name. */
N  SD_BLE_GAP_DEVICE_NAME_GET,                   /**< Get Device Name. */
N  SD_BLE_GAP_AUTHENTICATE,                      /**< Initiate Pairing/Bonding. */
N  SD_BLE_GAP_SEC_PARAMS_REPLY,                  /**< Reply with Security Parameters. */
N  SD_BLE_GAP_AUTH_KEY_REPLY,                    /**< Reply with an authentication key. */
N  SD_BLE_GAP_LESC_DHKEY_REPLY,                  /**< Reply with an LE Secure Connections DHKey. */
N  SD_BLE_GAP_KEYPRESS_NOTIFY,                   /**< Notify of a keypress during an authentication procedure. */
N  SD_BLE_GAP_LESC_OOB_DATA_GET,                 /**< Get the local LE Secure Connections OOB data. */
N  SD_BLE_GAP_LESC_OOB_DATA_SET,                 /**< Set the remote LE Secure Connections OOB data. */
N  SD_BLE_GAP_ENCRYPT,                           /**< Initiate encryption procedure. */
N  SD_BLE_GAP_SEC_INFO_REPLY,                    /**< Reply with Security Information. */
N  SD_BLE_GAP_CONN_SEC_GET,                      /**< Obtain connection security level. */
N  SD_BLE_GAP_RSSI_START,                        /**< Start reporting of changes in RSSI. */
N  SD_BLE_GAP_RSSI_STOP,                         /**< Stop reporting of changes in RSSI. */
N  SD_BLE_GAP_SCAN_START,                        /**< Start Scanning. */
N  SD_BLE_GAP_SCAN_STOP,                         /**< Stop Scanning. */
N  SD_BLE_GAP_CONNECT,                           /**< Connect. */
N  SD_BLE_GAP_CONNECT_CANCEL,                    /**< Cancel ongoing connection procedure. */
N  SD_BLE_GAP_RSSI_GET,                          /**< Get the last RSSI sample. */
N};
N
N/**@brief GAP Event IDs.
N * IDs that uniquely identify an event coming from the stack to the application.
N */
Nenum BLE_GAP_EVTS
N{
N  BLE_GAP_EVT_CONNECTED  = BLE_GAP_EVT_BASE,    /**< Connection established.                         \n See @ref ble_gap_evt_connected_t.            */
X  BLE_GAP_EVT_CONNECTED  = 0x10,     
N  BLE_GAP_EVT_DISCONNECTED,                     /**< Disconnected from peer.                         \n See @ref ble_gap_evt_disconnected_t.         */
N  BLE_GAP_EVT_CONN_PARAM_UPDATE,                /**< Connection Parameters updated.                  \n See @ref ble_gap_evt_conn_param_update_t.    */
N  BLE_GAP_EVT_SEC_PARAMS_REQUEST,               /**< Request to provide security parameters.         \n Reply with @ref sd_ble_gap_sec_params_reply.  \n See @ref ble_gap_evt_sec_params_request_t. */
N  BLE_GAP_EVT_SEC_INFO_REQUEST,                 /**< Request to provide security information.        \n Reply with @ref sd_ble_gap_sec_info_reply.    \n See @ref ble_gap_evt_sec_info_request_t.   */
N  BLE_GAP_EVT_PASSKEY_DISPLAY,                  /**< Request to display a passkey to the user.       \n In LESC Numeric Comparison, reply with @ref sd_ble_gap_auth_key_reply. \n See @ref ble_gap_evt_passkey_display_t. */
N  BLE_GAP_EVT_KEY_PRESSED,                      /**< Notification of a keypress on the remote device.\n See @ref ble_gap_evt_key_pressed_t           */
N  BLE_GAP_EVT_AUTH_KEY_REQUEST,                 /**< Request to provide an authentication key.       \n Reply with @ref sd_ble_gap_auth_key_reply.    \n See @ref ble_gap_evt_auth_key_request_t.   */
N  BLE_GAP_EVT_LESC_DHKEY_REQUEST,               /**< Request to calculate an LE Secure Connections DHKey. \n Reply with @ref sd_ble_gap_lesc_dhkey_reply.  \n See @ref ble_gap_evt_lesc_dhkey_request_t */
N  BLE_GAP_EVT_AUTH_STATUS,                      /**< Authentication procedure completed with status. \n See @ref ble_gap_evt_auth_status_t.          */
N  BLE_GAP_EVT_CONN_SEC_UPDATE,                  /**< Connection security updated.                    \n See @ref ble_gap_evt_conn_sec_update_t.      */
N  BLE_GAP_EVT_TIMEOUT,                          /**< Timeout expired.                                \n See @ref ble_gap_evt_timeout_t.              */
N  BLE_GAP_EVT_RSSI_CHANGED,                     /**< RSSI report.                                    \n See @ref ble_gap_evt_rssi_changed_t.         */
N  BLE_GAP_EVT_ADV_REPORT,                       /**< Advertising report.                             \n See @ref ble_gap_evt_adv_report_t.           */
N  BLE_GAP_EVT_SEC_REQUEST,                      /**< Security Request.                               \n See @ref ble_gap_evt_sec_request_t.          */
N  BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST,        /**< Connection Parameter Update Request.            \n Reply with @ref sd_ble_gap_conn_param_update. \n See @ref ble_gap_evt_conn_param_update_request_t. */
N  BLE_GAP_EVT_SCAN_REQ_REPORT,                  /**< Scan request report.                            \n See @ref ble_gap_evt_scan_req_report_t.      */
N};
N
N/**@brief GAP Option IDs.
N * IDs that uniquely identify a GAP option.
N */
Nenum BLE_GAP_OPTS
N{
N  BLE_GAP_OPT_CH_MAP  = BLE_GAP_OPT_BASE,       /**< Channel Map. @ref ble_gap_opt_ch_map_t  */
X  BLE_GAP_OPT_CH_MAP  = 0x20,        
N  BLE_GAP_OPT_LOCAL_CONN_LATENCY,               /**< Local connection latency. @ref ble_gap_opt_local_conn_latency_t */
N  BLE_GAP_OPT_PASSKEY,                          /**< Set passkey. @ref ble_gap_opt_passkey_t */
N  BLE_GAP_OPT_SCAN_REQ_REPORT,                  /**< Scan request report. @ref ble_gap_opt_scan_req_report_t */
N  BLE_GAP_OPT_COMPAT_MODE,                      /**< Compatibility mode. @ref ble_gap_opt_compat_mode_t */
N  BLE_GAP_OPT_AUTH_PAYLOAD_TIMEOUT,             /**< Set Authenticated payload timeout. @ref ble_gap_opt_auth_payload_timeout_t */
N  BLE_GAP_OPT_EXT_LEN,                          /**< Extended length packets. @ref ble_gap_opt_ext_len_t */
N};
N
N/** @} */
N
N/**@addtogroup BLE_GAP_DEFINES Defines
N * @{ */
N
N/**@defgroup BLE_ERRORS_GAP SVC return values specific to GAP
N * @{ */
N#define BLE_ERROR_GAP_UUID_LIST_MISMATCH            (NRF_GAP_ERR_BASE + 0x000)  /**< UUID list does not contain an integral number of UUIDs. */
N#define BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST   (NRF_GAP_ERR_BASE + 0x001)  /**< Use of Whitelist not permitted with discoverable advertising. */
N#define BLE_ERROR_GAP_INVALID_BLE_ADDR              (NRF_GAP_ERR_BASE + 0x002)  /**< The upper two bits of the address do not correspond to the specified address type. */
N#define BLE_ERROR_GAP_WHITELIST_IN_USE              (NRF_GAP_ERR_BASE + 0x003)  /**< Attempt to modify the whitelist while already in use by another operation. */
N#define BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE      (NRF_GAP_ERR_BASE + 0x004)  /**< Attempt to modify the device identity list while already in use by another operation. */
N#define BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE   (NRF_GAP_ERR_BASE + 0x005)  /**< The device identity list contains entries with duplicate identity addresses. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_ROLES GAP Roles
N * @note Not explicitly used in peripheral API, but will be relevant for central API.
N * @{ */
N#define BLE_GAP_ROLE_INVALID     0x0            /**< Invalid Role. */
N#define BLE_GAP_ROLE_PERIPH      0x1            /**< Peripheral Role. */
N#define BLE_GAP_ROLE_CENTRAL     0x2            /**< Central Role. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_TIMEOUT_SOURCES GAP Timeout sources
N * @{ */
N#define BLE_GAP_TIMEOUT_SRC_ADVERTISING                0x00 /**< Advertising timeout. */
N#define BLE_GAP_TIMEOUT_SRC_SECURITY_REQUEST           0x01 /**< Security request timeout. */
N#define BLE_GAP_TIMEOUT_SRC_SCAN                       0x02 /**< Scanning timeout. */
N#define BLE_GAP_TIMEOUT_SRC_CONN                       0x03 /**< Connection timeout. */
N#define BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD               0x04 /**< Authenticated payload timeout. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_ADDR_TYPES GAP Address types
N * @{ */
N#define BLE_GAP_ADDR_TYPE_PUBLIC                        0x00 /**< Public address. */
N#define BLE_GAP_ADDR_TYPE_RANDOM_STATIC                 0x01 /**< Random static address. */
N#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE     0x02 /**< Random private resolvable address. */
N#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE 0x03 /**< Random private non-resolvable address. */
N/**@} */
N
N
N/**@brief The default interval in seconds at which a private address is refreshed.  */
N#define BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S (900) /* 15 minutes. */
N/**@brief The maximum interval in seconds at which a private address can be refreshed.  */
N#define BLE_GAP_MAX_PRIVATE_ADDR_CYCLE_INTERVAL_S     (41400) /* 11 hours 30 minutes. */
N
N
N/** @brief BLE address length. */
N#define BLE_GAP_ADDR_LEN (6)
N
N
N/**@defgroup BLE_GAP_PRIVACY_MODES Privacy modes
N * @{ */
N#define BLE_GAP_PRIVACY_MODE_OFF                       0x00 /**< Device will send and accept its identity address for its own address. */
N#define BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY            0x01 /**< Device will send and accept only private addresses for its own address. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_AD_TYPE_DEFINITIONS GAP Advertising and Scan Response Data format
N * @note Found at https://www.bluetooth.org/Technical/AssignedNumbers/generic_access_profile.htm
N * @{ */
N#define BLE_GAP_AD_TYPE_FLAGS                               0x01 /**< Flags for discoverability. */
N#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 /**< Partial list of 16 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 /**< Complete list of 16 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 /**< Partial list of 32 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 /**< Complete list of 32 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 /**< Partial list of 128 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 /**< Complete list of 128 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME                    0x08 /**< Short local device name. */
N#define BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME                 0x09 /**< Complete local device name. */
N#define BLE_GAP_AD_TYPE_TX_POWER_LEVEL                      0x0A /**< Transmit power level. */
N#define BLE_GAP_AD_TYPE_CLASS_OF_DEVICE                     0x0D /**< Class of device. */
N#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C               0x0E /**< Simple Pairing Hash C. */
N#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R         0x0F /**< Simple Pairing Randomizer R. */
N#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE           0x10 /**< Security Manager TK Value. */
N#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS          0x11 /**< Security Manager Out Of Band Flags. */
N#define BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE     0x12 /**< Slave Connection Interval Range. */
N#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 /**< List of 16-bit Service Solicitation UUIDs. */
N#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 /**< List of 128-bit Service Solicitation UUIDs. */
N#define BLE_GAP_AD_TYPE_SERVICE_DATA                        0x16 /**< Service Data - 16-bit UUID. */
N#define BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS               0x17 /**< Public Target Address. */
N#define BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS               0x18 /**< Random Target Address. */
N#define BLE_GAP_AD_TYPE_APPEARANCE                          0x19 /**< Appearance. */
N#define BLE_GAP_AD_TYPE_ADVERTISING_INTERVAL                0x1A /**< Advertising Interval. */
N#define BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS         0x1B /**< LE Bluetooth Device Address. */
N#define BLE_GAP_AD_TYPE_LE_ROLE                             0x1C /**< LE Role. */
N#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C256            0x1D /**< Simple Pairing Hash C-256. */
N#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R256      0x1E /**< Simple Pairing Randomizer R-256. */
N#define BLE_GAP_AD_TYPE_SERVICE_DATA_32BIT_UUID             0x20 /**< Service Data - 32-bit UUID. */
N#define BLE_GAP_AD_TYPE_SERVICE_DATA_128BIT_UUID            0x21 /**< Service Data - 128-bit UUID. */
N#define BLE_GAP_AD_TYPE_URI                                 0x24 /**< URI */
N#define BLE_GAP_AD_TYPE_3D_INFORMATION_DATA                 0x3D /**< 3D Information Data. */
N#define BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA          0xFF /**< Manufacturer Specific Data. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_ADV_FLAGS GAP Advertisement Flags
N * @{ */
N#define BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE         (0x01)   /**< LE Limited Discoverable Mode. */
N#define BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE         (0x02)   /**< LE General Discoverable Mode. */
N#define BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED         (0x04)   /**< BR/EDR not supported. */
N#define BLE_GAP_ADV_FLAG_LE_BR_EDR_CONTROLLER         (0x08)   /**< Simultaneous LE and BR/EDR, Controller. */
N#define BLE_GAP_ADV_FLAG_LE_BR_EDR_HOST               (0x10)   /**< Simultaneous LE and BR/EDR, Host. */
N#define BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE Limited Discoverable Mode, BR/EDR not supported. */
N#define BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE General Discoverable Mode, BR/EDR not supported. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_ADV_INTERVALS GAP Advertising interval max and min
N * @{ */
N#define BLE_GAP_ADV_INTERVAL_MIN        0x0020 /**< Minimum Advertising interval in 625 us units, i.e. 20 ms. */
N#define BLE_GAP_ADV_NONCON_INTERVAL_MIN 0x00A0 /**< Minimum Advertising interval in 625 us units for non connectable mode, i.e. 100 ms. */
N#define BLE_GAP_ADV_INTERVAL_MAX        0x4000 /**< Maximum Advertising interval in 625 us units, i.e. 10.24 s. */
N /**@}  */
N
N
N/**@defgroup BLE_GAP_SCAN_INTERVALS GAP Scan interval max and min
N * @{ */
N#define BLE_GAP_SCAN_INTERVAL_MIN       0x0004 /**< Minimum Scan interval in 625 us units, i.e. 2.5 ms. */
N#define BLE_GAP_SCAN_INTERVAL_MAX       0x4000 /**< Maximum Scan interval in 625 us units, i.e. 10.24 s. */
N /** @}  */
N
N
N/**@defgroup BLE_GAP_SCAN_WINDOW GAP Scan window max and min
N * @{ */
N#define BLE_GAP_SCAN_WINDOW_MIN         0x0004 /**< Minimum Scan window in 625 us units, i.e. 2.5 ms. */
N#define BLE_GAP_SCAN_WINDOW_MAX         0x4000 /**< Maximum Scan window in 625 us units, i.e. 10.24 s. */
N /** @}  */
N
N
N/**@defgroup BLE_GAP_SCAN_TIMEOUT GAP Scan timeout max and min
N * @{ */
N#define BLE_GAP_SCAN_TIMEOUT_MIN        0x0001 /**< Minimum Scan timeout in seconds. */
N#define BLE_GAP_SCAN_TIMEOUT_MAX        0xFFFF /**< Maximum Scan timeout in seconds. */
N /** @}  */
N
N
N/**@brief Maximum size of advertising data in octets. */
N#define BLE_GAP_ADV_MAX_SIZE            (31)
N
N
N/**@defgroup BLE_GAP_ADV_TYPES GAP Advertising types
N * @{ */
N#define BLE_GAP_ADV_TYPE_ADV_IND          0x00   /**< Connectable undirected. */
N#define BLE_GAP_ADV_TYPE_ADV_DIRECT_IND   0x01   /**< Connectable directed. */
N#define BLE_GAP_ADV_TYPE_ADV_SCAN_IND     0x02   /**< Scannable undirected. */
N#define BLE_GAP_ADV_TYPE_ADV_NONCONN_IND  0x03   /**< Non connectable undirected. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_ADV_FILTER_POLICIES GAP Advertising filter policies
N * @{ */
N#define BLE_GAP_ADV_FP_ANY                0x00   /**< Allow scan requests and connect requests from any device. */
N#define BLE_GAP_ADV_FP_FILTER_SCANREQ     0x01   /**< Filter scan requests with whitelist. */
N#define BLE_GAP_ADV_FP_FILTER_CONNREQ     0x02   /**< Filter connect requests with whitelist. */
N#define BLE_GAP_ADV_FP_FILTER_BOTH        0x03   /**< Filter both scan and connect requests with whitelist. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_ADV_TIMEOUT_VALUES GAP Advertising timeout values
N * @{ */
N#define BLE_GAP_ADV_TIMEOUT_LIMITED_MAX       (180) /**< Maximum advertising time in limited discoverable mode (TGAP(lim_adv_timeout) = 180s). */
N#define BLE_GAP_ADV_TIMEOUT_GENERAL_UNLIMITED (0)   /**< Unlimited advertising in general discoverable mode. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_DISC_MODES GAP Discovery modes
N * @{ */
N#define BLE_GAP_DISC_MODE_NOT_DISCOVERABLE  0x00   /**< Not discoverable discovery Mode. */
N#define BLE_GAP_DISC_MODE_LIMITED           0x01   /**< Limited Discovery Mode. */
N#define BLE_GAP_DISC_MODE_GENERAL           0x02   /**< General Discovery Mode. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_IO_CAPS GAP IO Capabilities
N * @{ */
N#define BLE_GAP_IO_CAPS_DISPLAY_ONLY      0x00   /**< Display Only. */
N#define BLE_GAP_IO_CAPS_DISPLAY_YESNO     0x01   /**< Display and Yes/No entry. */
N#define BLE_GAP_IO_CAPS_KEYBOARD_ONLY     0x02   /**< Keyboard Only. */
N#define BLE_GAP_IO_CAPS_NONE              0x03   /**< No I/O capabilities. */
N#define BLE_GAP_IO_CAPS_KEYBOARD_DISPLAY  0x04   /**< Keyboard and Display. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_AUTH_KEY_TYPES GAP Authentication Key Types
N * @{ */
N#define BLE_GAP_AUTH_KEY_TYPE_NONE        0x00   /**< No key (may be used to reject). */
N#define BLE_GAP_AUTH_KEY_TYPE_PASSKEY     0x01   /**< 6-digit Passkey. */
N#define BLE_GAP_AUTH_KEY_TYPE_OOB         0x02   /**< Out Of Band data. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_KP_NOT_TYPES GAP Keypress Notification Types
N * @{ */
N#define BLE_GAP_KP_NOT_TYPE_PASSKEY_START       0x00   /**< Passkey entry started. */
N#define BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_IN    0x01   /**< Passkey digit entered. */
N#define BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_OUT   0x02   /**< Passkey digit erased. */
N#define BLE_GAP_KP_NOT_TYPE_PASSKEY_CLEAR       0x03   /**< Passkey cleared. */
N#define BLE_GAP_KP_NOT_TYPE_PASSKEY_END         0x04   /**< Passkey entry completed. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_SEC_STATUS GAP Security status
N * @{ */
N#define BLE_GAP_SEC_STATUS_SUCCESS                0x00  /**< Procedure completed with success. */
N#define BLE_GAP_SEC_STATUS_TIMEOUT                0x01  /**< Procedure timed out. */
N#define BLE_GAP_SEC_STATUS_PDU_INVALID            0x02  /**< Invalid PDU received. */
N#define BLE_GAP_SEC_STATUS_RFU_RANGE1_BEGIN       0x03  /**< Reserved for Future Use range #1 begin. */
N#define BLE_GAP_SEC_STATUS_RFU_RANGE1_END         0x80  /**< Reserved for Future Use range #1 end. */
N#define BLE_GAP_SEC_STATUS_PASSKEY_ENTRY_FAILED   0x81  /**< Passkey entry failed (user cancelled or other). */
N#define BLE_GAP_SEC_STATUS_OOB_NOT_AVAILABLE      0x82  /**< Out of Band Key not available. */
N#define BLE_GAP_SEC_STATUS_AUTH_REQ               0x83  /**< Authentication requirements not met. */
N#define BLE_GAP_SEC_STATUS_CONFIRM_VALUE          0x84  /**< Confirm value failed. */
N#define BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP       0x85  /**< Pairing not supported.  */
N#define BLE_GAP_SEC_STATUS_ENC_KEY_SIZE           0x86  /**< Encryption key size. */
N#define BLE_GAP_SEC_STATUS_SMP_CMD_UNSUPPORTED    0x87  /**< Unsupported SMP command. */
N#define BLE_GAP_SEC_STATUS_UNSPECIFIED            0x88  /**< Unspecified reason. */
N#define BLE_GAP_SEC_STATUS_REPEATED_ATTEMPTS      0x89  /**< Too little time elapsed since last attempt. */
N#define BLE_GAP_SEC_STATUS_INVALID_PARAMS         0x8A  /**< Invalid parameters. */
N#define BLE_GAP_SEC_STATUS_DHKEY_FAILURE          0x8B  /**< DHKey check failure. */
N#define BLE_GAP_SEC_STATUS_NUM_COMP_FAILURE       0x8C  /**< Numeric Comparison failure. */
N#define BLE_GAP_SEC_STATUS_BR_EDR_IN_PROG         0x8D  /**< BR/EDR pairing in progress. */
N#define BLE_GAP_SEC_STATUS_X_TRANS_KEY_DISALLOWED 0x8E  /**< BR/EDR Link Key cannot be used for LE keys. */
N#define BLE_GAP_SEC_STATUS_RFU_RANGE2_BEGIN       0x8F  /**< Reserved for Future Use range #2 begin. */
N#define BLE_GAP_SEC_STATUS_RFU_RANGE2_END         0xFF  /**< Reserved for Future Use range #2 end. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_SEC_STATUS_SOURCES GAP Security status sources
N * @{ */
N#define BLE_GAP_SEC_STATUS_SOURCE_LOCAL           0x00  /**< Local failure. */
N#define BLE_GAP_SEC_STATUS_SOURCE_REMOTE          0x01  /**< Remote failure. */
N/**@} */
N
N
N/**@defgroup BLE_GAP_CP_LIMITS GAP Connection Parameters Limits
N * @{ */
N#define BLE_GAP_CP_MIN_CONN_INTVL_NONE           0xFFFF  /**< No new minimum connection interval specified in connect parameters. */
N#define BLE_GAP_CP_MIN_CONN_INTVL_MIN            0x0006  /**< Lowest minimum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
N#define BLE_GAP_CP_MIN_CONN_INTVL_MAX            0x0C80  /**< Highest minimum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
N#define BLE_GAP_CP_MAX_CONN_INTVL_NONE           0xFFFF  /**< No new maximum connection interval specified in connect parameters. */
N#define BLE_GAP_CP_MAX_CONN_INTVL_MIN            0x0006  /**< Lowest maximum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
N#define BLE_GAP_CP_MAX_CONN_INTVL_MAX            0x0C80  /**< Highest maximum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
N#define BLE_GAP_CP_SLAVE_LATENCY_MAX             0x01F3  /**< Highest slave latency permitted, in connection events. */
N#define BLE_GAP_CP_CONN_SUP_TIMEOUT_NONE         0xFFFF  /**< No new supervision timeout specified in connect parameters. */
N#define BLE_GAP_CP_CONN_SUP_TIMEOUT_MIN          0x000A  /**< Lowest supervision timeout permitted, in units of 10 ms, i.e. 100 ms. */
N#define BLE_GAP_CP_CONN_SUP_TIMEOUT_MAX          0x0C80  /**< Highest supervision timeout permitted, in units of 10 ms, i.e. 32 s. */
N/**@} */
N
N
N/**@brief GAP device name defines. */
N#define BLE_GAP_DEVNAME_DEFAULT                  "nRF5x" /**< Default device name value. */
N#define BLE_GAP_DEVNAME_DEFAULT_LEN              31      /**< Default number of octets in device name. */
N#define BLE_GAP_DEVNAME_MAX_LEN                  248     /**< Maximum number of octets in device name. */
N
N
N/**@brief Disable RSSI events for connections */
N#define BLE_GAP_RSSI_THRESHOLD_INVALID 0xFF
N
N
N/**@defgroup BLE_GAP_CONN_SEC_MODE_SET_MACROS GAP attribute security requirement setters
N *
N * See @ref ble_gap_conn_sec_mode_t.
N * @{ */
N/**@brief Set sec_mode pointed to by ptr to have no access rights.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(ptr)          do {(ptr)->sm = 0; (ptr)->lv = 0;} while(0)
N/**@brief Set sec_mode pointed to by ptr to require no protection, open link.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_OPEN(ptr)               do {(ptr)->sm = 1; (ptr)->lv = 1;} while(0)
N/**@brief Set sec_mode pointed to by ptr to require encryption, but no MITM protection.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(ptr)        do {(ptr)->sm = 1; (ptr)->lv = 2;} while(0)
N/**@brief Set sec_mode pointed to by ptr to require encryption and MITM protection.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_ENC_WITH_MITM(ptr)      do {(ptr)->sm = 1; (ptr)->lv = 3;} while(0)
N/**@brief Set sec_mode pointed to by ptr to require LESC encryption and MITM protection.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_LESC_ENC_WITH_MITM(ptr) do {(ptr)->sm = 1; (ptr)->lv = 4;} while(0)
N/**@brief Set sec_mode pointed to by ptr to require signing or encryption, no MITM protection needed.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_NO_MITM(ptr)     do {(ptr)->sm = 2; (ptr)->lv = 1;} while(0)
N/**@brief Set sec_mode pointed to by ptr to require signing or encryption with MITM protection.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_WITH_MITM(ptr)   do {(ptr)->sm = 2; (ptr)->lv = 2;} while(0)
N/**@} */
N
N
N/**@brief GAP Security Random Number Length. */
N#define BLE_GAP_SEC_RAND_LEN 8
N
N
N/**@brief GAP Security Key Length. */
N#define BLE_GAP_SEC_KEY_LEN 16
N
N
N/**@brief GAP LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key Length. */
N#define BLE_GAP_LESC_P256_PK_LEN 64
N
N
N/**@brief GAP LE Secure Connections Elliptic Curve Diffie-Hellman DHKey Length. */
N#define BLE_GAP_LESC_DHKEY_LEN   32
N
N
N/**@brief GAP Passkey Length. */
N#define BLE_GAP_PASSKEY_LEN 6
N
N
N/**@brief Maximum amount of addresses in the whitelist. */
N#define BLE_GAP_WHITELIST_ADDR_MAX_COUNT (8)
N
N
N/**@brief Maximum amount of identities in the device identities list. */
N#define BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT (8)
N
N
N/**@defgroup GAP_SEC_MODES GAP Security Modes
N * @{ */
N#define BLE_GAP_SEC_MODE 0x00 /**< No key (may be used to reject). */
N/**@} */
N/** @} */
N
N
N/**@addtogroup BLE_GAP_STRUCTURES Structures
N * @{ */
N
N/**@brief Bluetooth Low Energy address. */
Ntypedef struct
N{
N  uint8_t addr_id_peer : 1;       /**< Only valid for peer addresses.
N                                       Reference to peer in device identities list (as set with @ref sd_ble_gap_device_identities_set) when peer is using privacy. */
N  uint8_t addr_type    : 7;       /**< See @ref BLE_GAP_ADDR_TYPES. */
N  uint8_t addr[BLE_GAP_ADDR_LEN]; /**< 48-bit address, LSB format. */
X  uint8_t addr[(6)];  
N} ble_gap_addr_t;
N
N
N/**@brief GAP connection parameters.
N *
N * @note  When ble_conn_params_t is received in an event, both min_conn_interval and
N *        max_conn_interval will be equal to the connection interval set by the central.
N *
N * @note If both conn_sup_timeout and max_conn_interval are specified, then the following constraint applies:
N *       conn_sup_timeout * 4 > (1 + slave_latency) * max_conn_interval
N *       that corresponds to the following Bluetooth Spec requirement:
N *       The Supervision_Timeout in milliseconds shall be larger than
N *       (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds.
N */
Ntypedef struct
N{
N  uint16_t min_conn_interval;         /**< Minimum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
N  uint16_t max_conn_interval;         /**< Maximum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
N  uint16_t slave_latency;             /**< Slave Latency in number of connection events, see @ref BLE_GAP_CP_LIMITS.*/
N  uint16_t conn_sup_timeout;          /**< Connection Supervision Timeout in 10 ms units, see @ref BLE_GAP_CP_LIMITS.*/
N} ble_gap_conn_params_t;
N
N
N/**@brief GAP connection security modes.
N *
N * Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).\n
N * Security Mode 1 Level 1: No security is needed (aka open link).\n
N * Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.\n
N * Security Mode 1 Level 3: MITM protected encrypted link required.\n
N * Security Mode 1 Level 4: LESC MITM protected encrypted link required.\n
N * Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.\n
N * Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.\n
N */
Ntypedef struct
N{
N  uint8_t sm : 4;                     /**< Security Mode (1 or 2), 0 for no permissions at all. */
N  uint8_t lv : 4;                     /**< Level (1, 2, 3 or 4), 0 for no permissions at all. */
N
N} ble_gap_conn_sec_mode_t;
N
N
N/**@brief GAP connection security status.*/
Ntypedef struct
N{
N  ble_gap_conn_sec_mode_t sec_mode;           /**< Currently active security mode for this connection.*/
N  uint8_t                 encr_key_size;      /**< Length of currently active encryption key, 7 to 16 octets (only applicable for bonding procedures). */
N} ble_gap_conn_sec_t;
N
N
N/**
N * @brief Device name and its properties
N * @note If @ref max_len is more than @ref BLE_GAP_DEVNAME_DEFAULT_LEN and vloc is set to @ref BLE_GATTS_VLOC_STACK, the attribute table size must be increased to have room for the longer device name (see @ref ble_gatts_enable_params_t).
N */
Ntypedef struct
N{
N  ble_gap_conn_sec_mode_t  write_perm;   /**< Write permissions. */
N  uint8_t                  vloc:2;       /**< Value location, see @ref BLE_GATTS_VLOCS.*/
N  uint8_t                 *p_value;      /**< Pointer to where the value (device name) is stored or will be stored.*/
N  uint16_t                 current_len;  /**< Current length in bytes of the memory pointed to by p_value.*/
N  uint16_t                 max_len;      /**< Maximum length in bytes of the memory pointed to by p_value.*/
N} ble_gap_device_name_t;
N
N
N/**
N * @brief BLE GAP initialization parameters.
N */
Ntypedef struct
N{
N  uint8_t                      periph_conn_count;  /**< Number of connections acting as a peripheral  */
N  uint8_t                      central_conn_count; /**< Number of connections acting as a central */
N  uint8_t                      central_sec_count;  /**< Number of SMP instances for all connections acting as a central. */
N  ble_gap_device_name_t const *p_device_name;      /**< Pointer to device name instance. If NULL, @ref sd_ble_enable() will set the device name to @ref BLE_GAP_DEVNAME_DEFAULT. */
N} ble_gap_enable_params_t;
N
N
N/**@brief Identity Resolving Key. */
Ntypedef struct
N{
N  uint8_t irk[BLE_GAP_SEC_KEY_LEN];   /**< Array containing IRK. */
X  uint8_t irk[16];    
N} ble_gap_irk_t;
N
N
N/**@brief Channel mask for RF channels used in advertising. */
Ntypedef struct
N{
N  uint8_t ch_37_off : 1;  /**< Setting this bit to 1 will turn off advertising on channel 37 */
N  uint8_t ch_38_off : 1;  /**< Setting this bit to 1 will turn off advertising on channel 38 */
N  uint8_t ch_39_off : 1;  /**< Setting this bit to 1 will turn off advertising on channel 39 */
N} ble_gap_adv_ch_mask_t;
N
N
N/**@brief GAP advertising parameters. */
Ntypedef struct
N{
N  uint8_t               type;                 /**< See @ref BLE_GAP_ADV_TYPES. */
N  ble_gap_addr_t const *p_peer_addr;          /**< Address of a known peer.
N                                                   - When privacy is enabled and the local device use @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE addresses, the device identity list is searched for a matching
N                                                     entry. If the local IRK for that device identity is set, the local IRK for that device will be used to generate the advertiser address field in the advertise packet.
N                                                   - If type is @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, this must be set to the targeted initiator. If the initiator is in the device identity list,
N                                                     the peer IRK for that device will be used to generate the initiator address field in the ADV_DIRECT_IND packet. */
N  uint8_t               fp;                   /**< Filter Policy, see @ref BLE_GAP_ADV_FILTER_POLICIES. */
N  uint16_t              interval;             /**< Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s), see @ref BLE_GAP_ADV_INTERVALS.
N                                                   - If type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, this parameter must be set to 0 for high duty cycle directed advertising.
N                                                   - If type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, set @ref BLE_GAP_ADV_INTERVAL_MIN <= interval <= @ref BLE_GAP_ADV_INTERVAL_MAX for low duty cycle advertising.*/
N  uint16_t              timeout;              /**< Advertising timeout between 0x0001 and 0x3FFF in seconds, 0x0000 disables timeout. See also @ref BLE_GAP_ADV_TIMEOUT_VALUES. If type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, this parameter must be set to 0 for High duty cycle directed advertising. */
N  ble_gap_adv_ch_mask_t channel_mask;         /**< Advertising channel mask. See @ref ble_gap_adv_ch_mask_t. */
N} ble_gap_adv_params_t;
N
N
N/**@brief GAP scanning parameters. */
Ntypedef struct
N{
N  uint8_t  active         : 1;  /**< If 1, perform active scanning (scan requests). */
N  uint8_t  use_whitelist  : 1;  /**< If 1, filter advertisers using current active whitelist. */
N  uint8_t  adv_dir_report : 1;  /**< If 1, also report directed advertisements where the initiator field is set to a private resolvable address,
N                                     even if the address did not resolve to an entry in the device identity list. A report will be generated
N                                     even if the peer is not in the whitelist. */
N  uint16_t interval;            /**< Scan interval between 0x0004 and 0x4000 in 0.625ms units (2.5ms to 10.24s). */
N  uint16_t window;              /**< Scan window between 0x0004 and 0x4000 in 0.625ms units (2.5ms to 10.24s). */
N  uint16_t timeout;             /**< Scan timeout between 0x0001 and 0xFFFF in seconds, 0x0000 disables timeout. */
N} ble_gap_scan_params_t;
N
N
N/**@brief Device Privacy.
N *
N *        The privacy feature provides a way for the device to avoid being tracked over a period of time.
N *        The privacy feature, when enabled, hides the local device identity and replaces it with a private address
N *        that is automatically refreshed at a specified interval.
N *
N *        If a device still wants to be recognized by other peers, it needs to share it's Identity Resolving Key (IRK).
N *        With this key, a device can generate a random private address that can only be recognized by peers in possession of that key,
N *        and devices can establish connections without revealing their real identities.
N *
N * @note  If the device IRK is updated, the new IRK becomes the one to be distributed in all
N *        bonding procedures performed after @ref sd_ble_gap_privacy_set returns.
N *        The IRK distributed during bonding procedure is the device IRK that is active when @ref sd_ble_gap_sec_params_reply is called.
N */
Ntypedef struct
N{
N  uint8_t        privacy_mode;         /**< Privacy mode, see @ref BLE_GAP_PRIVACY_MODES. Default is @ref BLE_GAP_PRIVACY_MODE_OFF. */
N  uint8_t        private_addr_type;    /**< The private address type must be either @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE or @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE. */
N  uint16_t       private_addr_cycle_s; /**< Private address cycle interval in seconds. Providing an address cycle value of 0 will use the default value defined by @ref BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S. */
N  ble_gap_irk_t *p_device_irk;         /**< When used as input, pointer to IRK structure that will be used as the default IRK. If NULL, the device default IRK will be used.
N                                            When used as output, pointer to IRK structure where the current default IRK will be written to. If NULL, this argument is ignored.
N                                            By default, the default IRK is used to generate random private resolvable addresses for the local device unless instructed otherwise. */
N} ble_gap_privacy_params_t;
N
N
N/** @brief Keys that can be exchanged during a bonding procedure. */
Ntypedef struct
N{
N  uint8_t enc     : 1;                        /**< Long Term Key and Master Identification. */
N  uint8_t id      : 1;                        /**< Identity Resolving Key and Identity Address Information. */
N  uint8_t sign    : 1;                        /**< Connection Signature Resolving Key. */
N  uint8_t link    : 1;                        /**< Derive the Link Key from the LTK. */
N} ble_gap_sec_kdist_t;
N
N
N/**@brief GAP security parameters. */
Ntypedef struct
N{
N  uint8_t               bond      : 1;             /**< Perform bonding. */
N  uint8_t               mitm      : 1;             /**< Enable Man In The Middle protection. */
N  uint8_t               lesc      : 1;             /**< Enable LE Secure Connection pairing. */
N  uint8_t               keypress  : 1;             /**< Enable generation of keypress notifications. */
N  uint8_t               io_caps   : 3;             /**< IO capabilities, see @ref BLE_GAP_IO_CAPS. */
N  uint8_t               oob       : 1;             /**< Out Of Band data available. */
N  uint8_t               min_key_size;              /**< Minimum encryption key size in octets between 7 and 16. If 0 then not applicable in this instance. */
N  uint8_t               max_key_size;              /**< Maximum encryption key size in octets between min_key_size and 16. */
N  ble_gap_sec_kdist_t   kdist_own;                 /**< Key distribution bitmap: keys that the local device will distribute. */
N  ble_gap_sec_kdist_t   kdist_peer;                /**< Key distribution bitmap: keys that the remote device will distribute. */
N} ble_gap_sec_params_t;
N
N
N/**@brief GAP Encryption Information. */
Ntypedef struct
N{
N  uint8_t   ltk[BLE_GAP_SEC_KEY_LEN];   /**< Long Term Key. */
X  uint8_t   ltk[16];    
N  uint8_t   lesc : 1;                   /**< Key generated using LE Secure Connections. */
N  uint8_t   auth : 1;                   /**< Authenticated Key. */
N  uint8_t   ltk_len : 6;                /**< LTK length in octets. */
N} ble_gap_enc_info_t;
N
N
N/**@brief GAP Master Identification. */
Ntypedef struct
N{
N  uint16_t  ediv;                       /**< Encrypted Diversifier. */
N  uint8_t   rand[BLE_GAP_SEC_RAND_LEN]; /**< Random Number. */
X  uint8_t   rand[8];  
N} ble_gap_master_id_t;
N
N
N/**@brief GAP Signing Information. */
Ntypedef struct
N{
N  uint8_t   csrk[BLE_GAP_SEC_KEY_LEN];        /**< Connection Signature Resolving Key. */
X  uint8_t   csrk[16];         
N} ble_gap_sign_info_t;
N
N
N/**@brief GAP LE Secure Connections P-256 Public Key. */
Ntypedef struct
N{
N  uint8_t   pk[BLE_GAP_LESC_P256_PK_LEN];        /**< LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key. Stored in the standard SMP protocol format: {X,Y} both in little-endian. */
X  uint8_t   pk[64];         
N} ble_gap_lesc_p256_pk_t;
N
N
N/**@brief GAP LE Secure Connections DHKey. */
Ntypedef struct
N{
N  uint8_t   key[BLE_GAP_LESC_DHKEY_LEN];        /**< LE Secure Connections Elliptic Curve Diffie-Hellman Key. Stored in little-endian. */
X  uint8_t   key[32];         
N} ble_gap_lesc_dhkey_t;
N
N
N/**@brief GAP LE Secure Connections OOB data. */
Ntypedef struct
N{
N  ble_gap_addr_t  addr;                          /**< Bluetooth address of the device. */
N  uint8_t         r[BLE_GAP_SEC_KEY_LEN];        /**< Random Number. */
X  uint8_t         r[16];         
N  uint8_t         c[BLE_GAP_SEC_KEY_LEN];        /**< Confirm Value. */
X  uint8_t         c[16];         
N} ble_gap_lesc_oob_data_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_CONNECTED. */
Ntypedef struct
N{
N  ble_gap_addr_t        peer_addr;              /**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
N                                                     and the address is the device's identity address. */
N  uint8_t               role;                   /**< BLE role for this connection, see @ref BLE_GAP_ROLES */
N  ble_gap_conn_params_t conn_params;            /**< GAP Connection Parameters. */
N} ble_gap_evt_connected_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_DISCONNECTED. */
Ntypedef struct
N{
N  uint8_t reason;                               /**< HCI error code, see @ref BLE_HCI_STATUS_CODES. */
N} ble_gap_evt_disconnected_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_CONN_PARAM_UPDATE. */
Ntypedef struct
N{
N  ble_gap_conn_params_t conn_params;            /**<  GAP Connection Parameters. */
N} ble_gap_evt_conn_param_update_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST. */
Ntypedef struct
N{
N  ble_gap_sec_params_t peer_params;             /**< Initiator Security Parameters. */
N} ble_gap_evt_sec_params_request_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_SEC_INFO_REQUEST. */
Ntypedef struct
N{
N  ble_gap_addr_t      peer_addr;                     /**< Bluetooth address of the peer device. */
N  ble_gap_master_id_t master_id;                     /**< Master Identification for LTK lookup. */
N  uint8_t             enc_info  : 1;                 /**< If 1, Encryption Information required. */
N  uint8_t             id_info   : 1;                 /**< If 1, Identity Information required. */
N  uint8_t             sign_info : 1;                 /**< If 1, Signing Information required. */
N} ble_gap_evt_sec_info_request_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_PASSKEY_DISPLAY. */
Ntypedef struct
N{
N  uint8_t passkey[BLE_GAP_PASSKEY_LEN];         /**< 6-digit passkey in ASCII ('0'-'9' digits only). */
X  uint8_t passkey[6];          
N  uint8_t match_request : 1;                    /**< If 1 requires the application to report the match using @ref sd_ble_gap_auth_key_reply
N                                                     with either @ref BLE_GAP_AUTH_KEY_TYPE_NONE if there is no match or
N                                                     @ref BLE_GAP_AUTH_KEY_TYPE_PASSKEY if there is a match. */
N} ble_gap_evt_passkey_display_t;
N
N/**@brief Event structure for @ref BLE_GAP_EVT_KEY_PRESSED. */
Ntypedef struct
N{
N  uint8_t kp_not;         /**< Keypress notification type, see @ref BLE_GAP_KP_NOT_TYPES. */
N} ble_gap_evt_key_pressed_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_AUTH_KEY_REQUEST. */
Ntypedef struct
N{
N  uint8_t key_type;                             /**< See @ref BLE_GAP_AUTH_KEY_TYPES. */
N} ble_gap_evt_auth_key_request_t;
N
N/**@brief Event structure for @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST. */
Ntypedef struct
N{
N  ble_gap_lesc_p256_pk_t *p_pk_peer;  /**< LE Secure Connections remote P-256 Public Key. This will point to the application-supplied memory
N                                           inside the keyset during the call to @ref sd_ble_gap_sec_params_reply. */
N  uint8_t oobd_req       :1;          /**< LESC OOB data required. A call to @ref sd_ble_gap_lesc_oob_data_set is required to complete the procedure. */
N} ble_gap_evt_lesc_dhkey_request_t;
N
N
N/**@brief Security levels supported.
N * @note See Bluetooth Specification Version 4.2 Volume 3, Part C, Chapter 10, Section 10.2.1.
N*/
Ntypedef struct
N{
N  uint8_t lv1 : 1;                              /**< If 1: Level 1 is supported. */
N  uint8_t lv2 : 1;                              /**< If 1: Level 2 is supported. */
N  uint8_t lv3 : 1;                              /**< If 1: Level 3 is supported. */
N  uint8_t lv4 : 1;                              /**< If 1: Level 4 is supported. */
N} ble_gap_sec_levels_t;
N
N
N/**@brief Encryption Key. */
Ntypedef struct
N{
N  ble_gap_enc_info_t    enc_info;             /**< Encryption Information. */
N  ble_gap_master_id_t   master_id;            /**< Master Identification. */
N} ble_gap_enc_key_t;
N
N
N/**@brief Identity Key. */
Ntypedef struct
N{
N  ble_gap_irk_t         id_info;              /**< Identity Resolving Key. */
N  ble_gap_addr_t        id_addr_info;         /**< Identity Address. */
N} ble_gap_id_key_t;
N
N
N/**@brief Security Keys. */
Ntypedef struct
N{
N  ble_gap_enc_key_t      *p_enc_key;           /**< Encryption Key, or NULL. */
N  ble_gap_id_key_t       *p_id_key;            /**< Identity Key, or NULL. */
N  ble_gap_sign_info_t    *p_sign_key;          /**< Signing Key, or NULL. */
N  ble_gap_lesc_p256_pk_t *p_pk;                /**< LE Secure Connections P-256 Public Key. When in debug mode the application must use the value defined
N                                                    in the Core Bluetooth Specification v4.2 Vol.3, Part H, Section 2.3.5.6.1 */
N} ble_gap_sec_keys_t;
N
N
N/**@brief Security key set for both local and peer keys. */
Ntypedef struct
N{
N  ble_gap_sec_keys_t            keys_own;     /**< Keys distributed by the local device. For LE Secure Connections the encryption key will be generated locally and will always be stored if bonding. */
N  ble_gap_sec_keys_t            keys_peer;    /**< Keys distributed by the remote device. For LE Secure Connections, p_enc_key must always be NULL. */
N} ble_gap_sec_keyset_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_AUTH_STATUS. */
Ntypedef struct
N{
N  uint8_t               auth_status;            /**< Authentication status, see @ref BLE_GAP_SEC_STATUS. */
N  uint8_t               error_src : 2;          /**< On error, source that caused the failure, see @ref BLE_GAP_SEC_STATUS_SOURCES. */
N  uint8_t               bonded : 1;             /**< Procedure resulted in a bond. */
N  ble_gap_sec_levels_t  sm1_levels;             /**< Levels supported in Security Mode 1. */
N  ble_gap_sec_levels_t  sm2_levels;             /**< Levels supported in Security Mode 2. */
N  ble_gap_sec_kdist_t   kdist_own;              /**< Bitmap stating which keys were exchanged (distributed) by the local device. If bonding with LE Secure Connections, the enc bit will be always set. */
N  ble_gap_sec_kdist_t   kdist_peer;             /**< Bitmap stating which keys were exchanged (distributed) by the remote device. If bonding with LE Secure Connections, the enc bit will never be set. */
N} ble_gap_evt_auth_status_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_CONN_SEC_UPDATE. */
Ntypedef struct
N{
N  ble_gap_conn_sec_t conn_sec;                  /**< Connection security level. */
N} ble_gap_evt_conn_sec_update_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_TIMEOUT. */
Ntypedef struct
N{
N  uint8_t src;                                  /**< Source of timeout event, see @ref BLE_GAP_TIMEOUT_SOURCES. */
N} ble_gap_evt_timeout_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_RSSI_CHANGED. */
Ntypedef struct
N{
N  int8_t  rssi;                               /**< Received Signal Strength Indication in dBm. */
N} ble_gap_evt_rssi_changed_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_ADV_REPORT. */
Ntypedef struct
N{
N  ble_gap_addr_t peer_addr;                     /**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
N                                                     and the address is the device's identity address. */
N  ble_gap_addr_t direct_addr;                   /**< Set when the scanner is unable to resolve the private resolvable address of the initiator
N                                                     field of a directed advertisement packet and the scanner has been enabled to report this in @ref ble_gap_scan_params_t::adv_dir_report. */
N  int8_t         rssi;                          /**< Received Signal Strength Indication in dBm. */
N  uint8_t        scan_rsp : 1;                  /**< If 1, the report corresponds to a scan response and the type field may be ignored. */
N  uint8_t        type     : 2;                  /**< See @ref BLE_GAP_ADV_TYPES. Only valid if the scan_rsp field is 0. */
N  uint8_t        dlen     : 5;                  /**< Advertising or scan response data length. */
N  uint8_t        data[BLE_GAP_ADV_MAX_SIZE];    /**< Advertising or scan response data. */
X  uint8_t        data[(31)];     
N} ble_gap_evt_adv_report_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_SEC_REQUEST. */
Ntypedef struct
N{
N  uint8_t    bond       : 1;                       /**< Perform bonding. */
N  uint8_t    mitm       : 1;                       /**< Man In The Middle protection requested. */
N  uint8_t    lesc       : 1;                       /**< LE Secure Connections requested. */
N  uint8_t    keypress   : 1;                       /**< Generation of keypress notifications requested. */
N} ble_gap_evt_sec_request_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST. */
Ntypedef struct
N{
N  ble_gap_conn_params_t conn_params;            /**<  GAP Connection Parameters. */
N} ble_gap_evt_conn_param_update_request_t;
N
N
N/**@brief Event structure for @ref BLE_GAP_EVT_SCAN_REQ_REPORT. */
Ntypedef struct
N{
N  int8_t                  rssi;              /**< Received Signal Strength Indication in dBm. */
N  ble_gap_addr_t          peer_addr;         /**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
N                                                  and the address is the device's identity address. */
N} ble_gap_evt_scan_req_report_t;
N
N
N/**@brief GAP event structure. */
Ntypedef struct
N{
N  uint16_t conn_handle;                                     /**< Connection Handle on which event occurred. */
N  union                                                     /**< union alternative identified by evt_id in enclosing struct. */
N  {
N    ble_gap_evt_connected_t                   connected;                    /**< Connected Event Parameters. */
N    ble_gap_evt_disconnected_t                disconnected;                 /**< Disconnected Event Parameters. */
N    ble_gap_evt_conn_param_update_t           conn_param_update;            /**< Connection Parameter Update Parameters. */
N    ble_gap_evt_sec_params_request_t          sec_params_request;           /**< Security Parameters Request Event Parameters. */
N    ble_gap_evt_sec_info_request_t            sec_info_request;             /**< Security Information Request Event Parameters. */
N    ble_gap_evt_passkey_display_t             passkey_display;              /**< Passkey Display Event Parameters. */
N    ble_gap_evt_key_pressed_t                 key_pressed;                  /**< Key Pressed Event Parameters. */
N    ble_gap_evt_auth_key_request_t            auth_key_request;             /**< Authentication Key Request Event Parameters. */
N    ble_gap_evt_lesc_dhkey_request_t          lesc_dhkey_request;           /**< LE Secure Connections DHKey calculation request. */
N    ble_gap_evt_auth_status_t                 auth_status;                  /**< Authentication Status Event Parameters. */
N    ble_gap_evt_conn_sec_update_t             conn_sec_update;              /**< Connection Security Update Event Parameters. */
N    ble_gap_evt_timeout_t                     timeout;                      /**< Timeout Event Parameters. */
N    ble_gap_evt_rssi_changed_t                rssi_changed;                 /**< RSSI Event parameters. */
N    ble_gap_evt_adv_report_t                  adv_report;                   /**< Advertising Report Event Parameters. */
N    ble_gap_evt_sec_request_t                 sec_request;                  /**< Security Request Event Parameters. */
N    ble_gap_evt_conn_param_update_request_t   conn_param_update_request;    /**< Connection Parameter Update Parameters. */
N    ble_gap_evt_scan_req_report_t             scan_req_report;              /**< Scan Request Report parameters. */
N  } params;                                                                 /**< Event Parameters. */
N} ble_gap_evt_t;
N
N
N/**@brief Channel Map option.
N *        Used with @ref sd_ble_opt_get to get the current channel map
N *        or @ref sd_ble_opt_set to set a new channel map. When setting the
N *        channel map, it applies to all current and future connections. When getting the
N *        current channel map, it applies to a single connection and the connection handle
N *        must be supplied.
N *
N * @note  Setting the channel map may take some time, depending on connection parameters.
N *        The time taken may be different for each connection and the get operation will
N *        return the previous channel map until the new one has taken effect.
N *
N * @note  After setting the channel map, by spec it can not be set again until at least 1 s has passed.
N *        See Bluetooth Specification Version 4.1 Volume 2, Part E, Section 7.3.46.
N *
N * @retval ::NRF_SUCCESS Get or set successful.
N * @retval ::NRF_ERROR_BUSY Channel map was set again before enough time had passed.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied for get.
N * @retval ::NRF_ERROR_NOT_SUPPORTED Returned by sd_ble_opt_set in peripheral-only SoftDevices.
N *
N */
Ntypedef struct
N{
N  uint16_t conn_handle;                   /**< Connection Handle (only applicable for get) */
N  uint8_t ch_map[5];                      /**< Channel Map (37-bit). */
N} ble_gap_opt_ch_map_t;
N
N
N/**@brief Local connection latency option.
N *
N *        Local connection latency is a feature which enables the slave to improve
N *        current consumption by ignoring the slave latency set by the peer. The
N *        local connection latency can only be set to a multiple of the slave latency,
N *        and cannot be longer than half of the supervision timeout.
N *
N *        Used with @ref sd_ble_opt_set to set the local connection latency. The
N *        @ref sd_ble_opt_get is not supported for this option, but the actual
N *        local connection latency (unless set to NULL) is set as a return parameter
N *        when setting the option.
N *
N * @note  The latency set will be truncated down to the closest slave latency event
N *        multiple, or the nearest multiple before half of the supervision timeout.
N *
N * @note  The local connection latency is disabled by default, and needs to be enabled for new
N *        connections and whenever the connection is updated.
N *
N * @retval ::NRF_SUCCESS Set successfully.
N * @retval ::NRF_ERROR_NOT_SUPPORTED Get is not supported.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.
N */
Ntypedef struct
N{
N  uint16_t   conn_handle;                       /**< Connection Handle */
N  uint16_t   requested_latency;                 /**< Requested local connection latency. */
N  uint16_t * p_actual_latency;                  /**< Pointer to storage for the actual local connection latency (can be set to NULL to skip return value). */
N} ble_gap_opt_local_conn_latency_t;
N
N
N/**@brief Passkey Option.
N *
N *        Structure containing the passkey to be used during pairing. This can be used with @ref
N *        sd_ble_opt_set to make the SoftDevice use a pre-programmed passkey for authentication
N *        instead of generating a random one.
N *
N * @note  Repeated pairing attempts using the same pre-programmed passkey makes pairing vulnerable to MITM attacks.
N *
N * @note  @ref sd_ble_opt_get is not supported for this option.
N *
N */
Ntypedef struct
N{
N  uint8_t * p_passkey;                          /**< Pointer to 6-digit ASCII string (digit 0..9 only, no NULL termination) passkey to be used during pairing. If this is NULL, the SoftDevice will generate a random passkey if required.*/
N} ble_gap_opt_passkey_t;
N
N
N/**@brief Scan request report option.
N *
N *        This can be used with @ref sd_ble_opt_set to make the SoftDevice send
N *        @ref BLE_GAP_EVT_SCAN_REQ_REPORT events.
N *
N *  @note   Due to the limited space reserved for scan request report events,
N *          not all received scan requests will be reported.
N *
N *  @note   If whitelisting is used, only whitelisted requests are reported.
N *
N *  @retval ::NRF_SUCCESS Set successfully.
N *  @retval ::NRF_ERROR_INVALID_STATE When advertising is ongoing while the option is set.
N */
Ntypedef struct
N{
N   uint8_t enable : 1;                           /**< Enable scan request reports. */
N} ble_gap_opt_scan_req_report_t;
N
N
N/**@brief Compatibility mode option.
N *
N *        This can be used with @ref sd_ble_opt_set to enable and disable
N *        compatibility modes. Compatibility modes are disabled by default.
N *
N *  @note  Compatibility mode 1 enables interoperability with devices that do not support
N *         a value of 0 for the WinOffset parameter in the Link Layer CONNECT_REQ packet.
N *
N *  @retval ::NRF_SUCCESS Set successfully.
N *  @retval ::NRF_ERROR_INVALID_STATE When connection creation is ongoing while mode 1 is set.
N */
Ntypedef struct
N{
N   uint8_t mode_1_enable : 1;                           /**< Enable compatibility mode 1.*/
N} ble_gap_opt_compat_mode_t;
N
N/**@brief Data length extension option.
N *
N *        This can be used with @ref sd_ble_opt_set to enable longer data packets.
N *
N * @note  An rxtx_max_pdu_payload_size of 0 will result in the default minimum payload size of 27.
N * @note  Not supported by SoftDevices for nRF51 Series devices.
N * @note  The parameters for a connection are applied when a connection complete
N *        event is generated for the host.
N *
N *
N *  @retval ::NRF_SUCCESS Set successfully.
N *  @retval ::NRF_ERROR_INVALID_PARAM If the payload size is not 0 or a valid link layer PDU payload size.
N *  @retval ::NRF_ERROR_NOT_SUPPORTED If called on a SoftDevice designed for nRF51 (e.g. s130).
N */
Ntypedef struct
N{
N  uint8_t  rxtx_max_pdu_payload_size;      /**< Max PDU payload size (in octets). */
N} ble_gap_opt_ext_len_t;
N
N
N
N/**@brief Authenticated payload timeout option.
N *
N * This can be used with @ref sd_ble_opt_set to change the Authenticated payload timeout to a value other than the default of 8 minutes.
N *
N * @note The authenticated payload timeout event ::BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD will be generated
N * if auth_payload_timeout time has elapsed without receiving a packet with a valid MIC on an encrypted
N * link.
N *
N * @note  The LE ping procedure will be initiated before the timer expires to give the peer a chance
N * to reset the timer. In addition the stack will try to prioritize running of LE ping over other
N * activities to increase chances of finishing LE ping before timer expires. To avoid side-effects
N * on other activities, it is recommended to use high timeout values.
N * Recommended timeout > 2*(connInterval * (6 + connSlaveLatency)).
N *
N * @retval ::NRF_SUCCESS Set successfully.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. auth_payload_timeout was outside of allowed range.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.
N */
Ntypedef struct
N{
N  uint16_t   conn_handle;                       /**< Connection Handle */
N  uint16_t   auth_payload_timeout;              /**< Requested timeout in 10 ms unit. Maximum is 48 000 (=480 000 ms =8 min). Minimum is 1 (=10ms). */
N} ble_gap_opt_auth_payload_timeout_t;
N
N
N/**@brief Option structure for GAP options. */
Ntypedef union
N{
N  ble_gap_opt_ch_map_t                  ch_map;                    /**< Parameters for the Channel Map option. */
N  ble_gap_opt_local_conn_latency_t      local_conn_latency;        /**< Parameters for the Local connection latency option */
N  ble_gap_opt_passkey_t                 passkey;                   /**< Parameters for the Passkey option.*/
N  ble_gap_opt_scan_req_report_t         scan_req_report;           /**< Parameters for the scan request report option.*/
N  ble_gap_opt_compat_mode_t             compat_mode;               /**< Parameters for the compatibility mode option.*/
N  ble_gap_opt_ext_len_t                 ext_len;                   /**< Parameters for the extended length option. */
N  ble_gap_opt_auth_payload_timeout_t    auth_payload_timeout;      /**< Parameters for the authenticated payload timeout option.*/
N} ble_gap_opt_t;
N/**@} */
N
N
N/**@addtogroup BLE_GAP_FUNCTIONS Functions
N * @{ */
N
N/**@brief Set the local Bluetooth identity address.
N *
N * The local Bluetooth identity address is the address that identifies this device to other peers.
N * The address type must be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC.
N * The identity address cannot be changed while roles are running.
N *
N * @note This address will be distributed to the peer during bonding.
N * If the address changes, the address stored in the peer device will not be valid and the ability to
N * reconnect using the old address will be lost.
N *
N * @note By default the SoftDevice will set an address of type @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC upon being
N * enabled. The address is a random number populated during the IC manufacturing process and remains unchanged
N * for the lifetime of each IC.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_ADV_MSC}
N * @endmscs
N *
N * @param[in] p_addr Pointer to address structure.
N *
N * @retval ::NRF_SUCCESS Address successfully set.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address.
N * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N * @retval ::NRF_ERROR_INVALID_STATE The identity address cannot be changed while the roles are running.
N */
NSVCALL(SD_BLE_GAP_ADDR_SET, uint32_t, sd_ble_gap_addr_set(ble_gap_addr_t const *p_addr));
Xuint32_t __svc(SD_BLE_GAP_ADDR_SET) sd_ble_gap_addr_set(ble_gap_addr_t const *p_addr);
N
N
N/**@brief Get local Bluetooth identity address.
N *
N * @note This will always return the identity address irrespective of the privacy settings,
N * i.e. the address type will always be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC.
N *
N * @param[out] p_addr Pointer to address structure to be filled in.
N *
N * @retval ::NRF_SUCCESS Address successfully retrieved.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid or NULL pointer supplied.
N */
NSVCALL(SD_BLE_GAP_ADDR_GET, uint32_t, sd_ble_gap_addr_get(ble_gap_addr_t *p_addr));
Xuint32_t __svc(SD_BLE_GAP_ADDR_GET) sd_ble_gap_addr_get(ble_gap_addr_t *p_addr);
N
N
N/**@brief Set the active whitelist in the SoftDevice.
N *
N * @note Only one whitelist can be used at a time and the whitelist is shared between the BLE roles.
N *       The whitelist cannot be set if a BLE role is using the whitelist.
N *
N * @note If an address is resolved using the information in the device identity list, then the whitelist
N *       filter policy applies to the peer identity address and not the resolvable address sent on air.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
N * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_PRIVATE_SCAN_MSC}
N * @endmscs
N *
N * @param[in] pp_wl_addrs Pointer to a whitelist of peer addresses, if NULL the whitelist will be cleared.
N * @param[in] len         Length of the whitelist, maximum @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT.
N *
N * @retval ::NRF_SUCCESS The whitelist is successfully set/cleared.
N * @retval ::NRF_ERROR_INVALID_ADDR The whitelist (or one of its entries) provided is invalid.
N * @retval ::BLE_ERROR_GAP_WHITELIST_IN_USE The whitelist is in use by a BLE role and cannot be set or cleared.
N * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.
N * @retval ::NRF_ERROR_DATA_SIZE The given whitelist size is invalid (zero or too large); this can only return when
N *                               pp_wl_addrs is not NULL.
N */
NSVCALL(SD_BLE_GAP_WHITELIST_SET, uint32_t, sd_ble_gap_whitelist_set(ble_gap_addr_t const * const * pp_wl_addrs, uint8_t len));
Xuint32_t __svc(SD_BLE_GAP_WHITELIST_SET) sd_ble_gap_whitelist_set(ble_gap_addr_t const * const * pp_wl_addrs, uint8_t len);
N
N
N/**@brief Set device identity list.
N *
N * @note Only one device identity list can be used at a time and the list is shared between the BLE roles.
N *       The device identity list cannot be set if a BLE role is using the list.
N *
N * @param[in] pp_id_keys     Pointer to an array of peer identity addresses and peer IRKs, if NULL the device identity list will be cleared.
N * @param[in] pp_local_irks  Pointer to an array of local IRKs. Each entry in the array maps to the entry in pp_id_keys at the same index.
N *                           To fill in the list with the currently set device IRK for all peers, set to NULL.
N * @param[in] len            Length of the device identity list, maximum @ref BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PRIVACY_ADV_MSC}
N * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_MSC}
N * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_PRIVATE_SCAN_MSC}
N * @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_CONN_PRIV_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_CONN_PRIV_MSC}
N * @endmscs
N *
N * @retval ::NRF_SUCCESS The device identity list successfully set/cleared.
N * @retval ::NRF_ERROR_INVALID_ADDR The device identity list (or one of its entries) provided is invalid.
N                                    This code may be returned if the local IRK list also has an invalid entry.
N * @retval ::BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE The device identity list is in use and cannot be set or cleared.
N * @retval ::BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE The device identity list contains multiple entries with the same identity address.
N * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.
N * @retval ::NRF_ERROR_DATA_SIZE The given device identity list size invalid (zero or too large); this can
N *                               only return when pp_id_keys is not NULL.
N */
NSVCALL(SD_BLE_GAP_DEVICE_IDENTITIES_SET, uint32_t, sd_ble_gap_device_identities_set(ble_gap_id_key_t const * const * pp_id_keys, ble_gap_irk_t const * const * pp_local_irks, uint8_t len));
Xuint32_t __svc(SD_BLE_GAP_DEVICE_IDENTITIES_SET) sd_ble_gap_device_identities_set(ble_gap_id_key_t const * const * pp_id_keys, ble_gap_irk_t const * const * pp_local_irks, uint8_t len);
N
N
N/**@brief Set privacy settings.
N *
N * @note Privacy settings cannot be set while BLE roles are running.
N *
N * @param[in] p_privacy_params Privacy settings.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PRIVACY_ADV_MSC}
N * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_MSC}
N * @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}
N * @endmscs
N *
N * @retval ::NRF_SUCCESS Set successfully.
N * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.
N * @retval ::NRF_ERROR_INVALID_ADDR The pointer to privacy settings is NULL or invalid.
N                                    Otherwise, the p_device_irk pointer in privacy parameter is an invalid pointer.
N * @retval ::NRF_ERROR_INVALID_PARAM Out of range parameters are provided.
N * @retval ::NRF_ERROR_INVALID_STATE Privacy settings cannot be changed while BLE roles using privacy are enabled.
N  */
NSVCALL(SD_BLE_GAP_PRIVACY_SET, uint32_t, sd_ble_gap_privacy_set(ble_gap_privacy_params_t const *p_privacy_params));
Xuint32_t __svc(SD_BLE_GAP_PRIVACY_SET) sd_ble_gap_privacy_set(ble_gap_privacy_params_t const *p_privacy_params);
N
N
N/**@brief Get privacy settings.
N *
N * @note The privacy settings returned include the current device irk as well.
N *
N * @param[in] p_privacy_params Privacy settings.
N *
N * @retval ::NRF_SUCCESS            Privacy settings read.
N * @retval ::NRF_ERROR_INVALID_ADDR The pointer given for returning the privacy settings may be NULL or invalid.
N                                    Otherwise, the p_device_irk pointer in privacy parameter is an invalid pointer.
N */
NSVCALL(SD_BLE_GAP_PRIVACY_GET, uint32_t, sd_ble_gap_privacy_get(ble_gap_privacy_params_t *p_privacy_params));
Xuint32_t __svc(SD_BLE_GAP_PRIVACY_GET) sd_ble_gap_privacy_get(ble_gap_privacy_params_t *p_privacy_params);
N
N
N/**@brief Set, clear or update advertising and scan response data.
N *
N * @note The format of the advertising data will be checked by this call to ensure interoperability.
N *       Limitations imposed by this API call to the data provided include having a flags data type in the scan response data and
N *       duplicating the local name in the advertising data and scan response data.
N *
N * @note To clear the advertising data and set it to a 0-length packet, simply provide a valid pointer (p_data/p_sr_data) with its corresponding
N *        length (dlen/srdlen) set to 0.
N *
N * @note The call will fail if p_data and p_sr_data are both NULL since this would have no effect.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_ADV_MSC}
N * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
N * @endmscs
N *
N * @param[in] p_data    Raw data to be placed in advertising packet. If NULL, no changes are made to the current advertising packet data.
N * @param[in] dlen      Data length for p_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_data is NULL, can be 0 if p_data is not NULL.
N * @param[in] p_sr_data Raw data to be placed in scan response packet. If NULL, no changes are made to the current scan response packet data.
N * @param[in] srdlen    Data length for p_sr_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_sr_data is NULL, can be 0 if p_data is not NULL.
N *
N * @retval ::NRF_SUCCESS Advertising data successfully updated or cleared.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, both p_data and p_sr_data cannot be NULL.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_FLAGS Invalid combination of advertising flags supplied.
N * @retval ::NRF_ERROR_INVALID_DATA Invalid data type(s) supplied, check the advertising data format specification.
N * @retval ::NRF_ERROR_INVALID_LENGTH Invalid data length(s) supplied.
N * @retval ::NRF_ERROR_NOT_SUPPORTED Unsupported data type.
N * @retval ::BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied.
N */
NSVCALL(SD_BLE_GAP_ADV_DATA_SET, uint32_t, sd_ble_gap_adv_data_set(uint8_t const *p_data, uint8_t dlen, uint8_t const *p_sr_data, uint8_t srdlen));
Xuint32_t __svc(SD_BLE_GAP_ADV_DATA_SET) sd_ble_gap_adv_data_set(uint8_t const *p_data, uint8_t dlen, uint8_t const *p_sr_data, uint8_t srdlen);
N
N
N/**@brief Start advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
N *
N * @note An application can start an advertising procedure for broadcasting purposes while a connection
N *       is active. After a @ref BLE_GAP_EVT_CONNECTED event is received, this function may therefore
N *       be called to start a broadcast advertising procedure. The advertising procedure
N *       cannot however be connectable (it must be of type @ref BLE_GAP_ADV_TYPE_ADV_SCAN_IND or
N *       @ref BLE_GAP_ADV_TYPE_ADV_NONCONN_IND). @note Only one advertiser may be active at any time.
N *
N * @events
N * @event{@ref BLE_GAP_EVT_CONNECTED, Generated after connection has been established through connectable advertising.}
N * @event{@ref BLE_GAP_EVT_TIMEOUT, Advertisement has timed out.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_ADV_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_CONN_PRIV_MSC}
N * @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}
N * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
N * @endmscs
N *
N * @param[in] p_adv_params Pointer to advertising parameters structure.
N *
N * @retval ::NRF_SUCCESS The BLE stack has started advertising.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::NRF_ERROR_CONN_COUNT The limit of available connections has been reached; connectable advertiser cannot be started.
N * @retval ::NRF_ERROR_NO_MEM The configured memory pools (see @ref ble_conn_bw_counts_t) are not large enough for the
N *                            bandwidth selected for this connection.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check the accepted ranges and limits.
N * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Bluetooth address supplied.
N * @retval ::BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST Discoverable mode and whitelist incompatible.
N * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
N *                               Stop one or more currently active roles (Central, Peripheral or Observer) and try again
N */
NSVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(ble_gap_adv_params_t const *p_adv_params));
Xuint32_t __svc(SD_BLE_GAP_ADV_START) sd_ble_gap_adv_start(ble_gap_adv_params_t const *p_adv_params);
N
N
N/**@brief Stop advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_ADV_MSC}
N * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
N * @endmscs
N *
N * @retval ::NRF_SUCCESS The BLE stack has stopped advertising.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in advertising state).
N */
NSVCALL(SD_BLE_GAP_ADV_STOP, uint32_t, sd_ble_gap_adv_stop(void));
Xuint32_t __svc(SD_BLE_GAP_ADV_STOP) sd_ble_gap_adv_stop(void);
N
N
N/**@brief Update connection parameters.
N *
N * @details In the central role this will initiate a Link Layer connection parameter update procedure,
N *          otherwise in the peripheral role, this will send the corresponding L2CAP request and wait for
N *          the central to perform the procedure. In both cases, and regardless of success or failure, the application
N *          will be informed of the result with a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE event.
N *
N * @details This function can be used as a central both to reply to a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST or to start the procedure unrequested.
N *
N * @events
N * @event{@ref BLE_GAP_EVT_CONN_PARAM_UPDATE, Result of the connection parameter update procedure.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_CPU_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}
N * @mmsc{@ref BLE_GAP_MULTILINK_CPU_MSC}
N * @mmsc{@ref BLE_GAP_MULTILINK_CTRL_PROC_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_CPU_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_conn_params  Pointer to desired connection parameters. If NULL is provided on a peripheral role,
N *                           the parameters in the PPCP characteristic of the GAP service will be used instead.
N *                           If NULL is provided on a central role and in response to a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST, the peripheral request will be rejected
N *
N * @retval ::NRF_SUCCESS The Connection Update procedure has been started successfully.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, process pending events and wait for pending procedures to complete and retry.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */
NSVCALL(SD_BLE_GAP_CONN_PARAM_UPDATE, uint32_t, sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const *p_conn_params));
Xuint32_t __svc(SD_BLE_GAP_CONN_PARAM_UPDATE) sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const *p_conn_params);
N
N
N/**@brief Disconnect (GAP Link Termination).
N *
N * @details This call initiates the disconnection procedure, and its completion will be communicated to the application
N *          with a @ref BLE_GAP_EVT_DISCONNECTED event.
N *
N * @events
N * @event{@ref BLE_GAP_EVT_DISCONNECTED, Generated when disconnection procedure is complete.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_CONN_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] hci_status_code HCI status code, see @ref BLE_HCI_STATUS_CODES (accepted values are @ref BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION and @ref BLE_HCI_CONN_INTERVAL_UNACCEPTABLE).
N *
N * @retval ::NRF_SUCCESS The disconnection procedure has been started successfully.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (disconnection is already in progress).
N */
NSVCALL(SD_BLE_GAP_DISCONNECT, uint32_t, sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code));
Xuint32_t __svc(SD_BLE_GAP_DISCONNECT) sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code);
N
N
N/**@brief Set the radio's transmit power.
N *
N * @param[in] tx_power Radio transmit power in dBm (accepted values are -40, -30, -20, -16, -12, -8, -4, 0, 3, and 4 dBm).
N *
N * @note The +3dBm setting is only available on nRF52 series ICs.
N * @note The -30dBm setting is only available on nRF51 series ICs.
N * @note The -40dBm setting is only available on nRF52 series ICs.
N *
N * @retval ::NRF_SUCCESS Successfully changed the transmit power.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N */
NSVCALL(SD_BLE_GAP_TX_POWER_SET, uint32_t, sd_ble_gap_tx_power_set(int8_t tx_power));
Xuint32_t __svc(SD_BLE_GAP_TX_POWER_SET) sd_ble_gap_tx_power_set(int8_t tx_power);
N
N
N/**@brief Set GAP Appearance value.
N *
N * @param[in] appearance Appearance (16-bit), see @ref BLE_APPEARANCES.
N *
N * @retval ::NRF_SUCCESS  Appearance value set successfully.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N */
NSVCALL(SD_BLE_GAP_APPEARANCE_SET, uint32_t, sd_ble_gap_appearance_set(uint16_t appearance));
Xuint32_t __svc(SD_BLE_GAP_APPEARANCE_SET) sd_ble_gap_appearance_set(uint16_t appearance);
N
N
N/**@brief Get GAP Appearance value.
N *
N * @param[out] p_appearance Pointer to appearance (16-bit) to be filled in, see @ref BLE_APPEARANCES.
N *
N * @retval ::NRF_SUCCESS Appearance value retrieved successfully.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_GAP_APPEARANCE_GET, uint32_t, sd_ble_gap_appearance_get(uint16_t *p_appearance));
Xuint32_t __svc(SD_BLE_GAP_APPEARANCE_GET) sd_ble_gap_appearance_get(uint16_t *p_appearance);
N
N
N/**@brief Set GAP Peripheral Preferred Connection Parameters.
N *
N * @param[in] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure with the desired parameters.
N *
N * @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters set successfully.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N */
NSVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const *p_conn_params));
Xuint32_t __svc(SD_BLE_GAP_PPCP_SET) sd_ble_gap_ppcp_set(ble_gap_conn_params_t const *p_conn_params);
N
N
N/**@brief Get GAP Peripheral Preferred Connection Parameters.
N *
N * @param[out] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure where the parameters will be stored.
N *
N * @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters retrieved successfully.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_GAP_PPCP_GET, uint32_t, sd_ble_gap_ppcp_get(ble_gap_conn_params_t *p_conn_params));
Xuint32_t __svc(SD_BLE_GAP_PPCP_GET) sd_ble_gap_ppcp_get(ble_gap_conn_params_t *p_conn_params);
N
N
N/**@brief Set GAP device name.
N *
N * @param[in] p_write_perm Write permissions for the Device Name characteristic, see @ref ble_gap_conn_sec_mode_t.
N * @param[in] p_dev_name Pointer to a UTF-8 encoded, <b>non NULL-terminated</b> string.
N * @param[in] len Length of the UTF-8, <b>non NULL-terminated</b> string pointed to by p_dev_name in octets (must be smaller or equal than @ref BLE_GAP_DEVNAME_MAX_LEN).
N *
N * @note If the device name is located in application flash memory (see @ref ble_gap_device_name_t), it cannot be changed. Then @ref NRF_ERROR_FORBIDDEN will be returned.
N *
N * @retval ::NRF_SUCCESS GAP device name and permissions set successfully.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N * @retval ::NRF_ERROR_FORBIDDEN Device name is not writable.
N */
NSVCALL(SD_BLE_GAP_DEVICE_NAME_SET, uint32_t, sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const *p_write_perm, uint8_t const *p_dev_name, uint16_t len));
Xuint32_t __svc(SD_BLE_GAP_DEVICE_NAME_SET) sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const *p_write_perm, uint8_t const *p_dev_name, uint16_t len);
N
N
N/**@brief Get GAP device name.
N *
N * @note          If the device name is longer than the size of the supplied buffer,
N *                p_len will return the complete device name length,
N *                and not the number of bytes actually returned in p_dev_name.
N *                The application may use this information to allocate a suitable buffer size.
N *
N * @param[out]    p_dev_name Pointer to an empty buffer where the UTF-8 <b>non NULL-terminated</b> string will be placed. Set to NULL to obtain the complete device name length.
N * @param[in,out] p_len      Length of the buffer pointed by p_dev_name, complete device name length on output.
N *
N * @retval ::NRF_SUCCESS GAP device name retrieved successfully.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N */
NSVCALL(SD_BLE_GAP_DEVICE_NAME_GET, uint32_t, sd_ble_gap_device_name_get(uint8_t *p_dev_name, uint16_t *p_len));
Xuint32_t __svc(SD_BLE_GAP_DEVICE_NAME_GET) sd_ble_gap_device_name_get(uint8_t *p_dev_name, uint16_t *p_len);
N
N
N/**@brief Initiate the GAP Authentication procedure.
N *
N * @details In the central role, this function will send an SMP Pairing Request (or an SMP Pairing Failed if rejected),
N *          otherwise in the peripheral role, an SMP Security Request will be sent.
N *
N * @events
N * @event{Depending on the security parameters set and the packet exchanges with the peer\, the following events may be generated:}
N * @event{@ref BLE_GAP_EVT_SEC_PARAMS_REQUEST}
N * @event{@ref BLE_GAP_EVT_SEC_INFO_REQUEST}
N * @event{@ref BLE_GAP_EVT_PASSKEY_DISPLAY}
N * @event{@ref BLE_GAP_EVT_KEY_PRESSED}
N * @event{@ref BLE_GAP_EVT_AUTH_KEY_REQUEST}
N * @event{@ref BLE_GAP_EVT_LESC_DHKEY_REQUEST}
N * @event{@ref BLE_GAP_EVT_CONN_SEC_UPDATE}
N * @event{@ref BLE_GAP_EVT_AUTH_STATUS}
N * @event{@ref BLE_GAP_EVT_TIMEOUT}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PERIPH_SEC_REQ_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_SEC_REQ_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_PAIRING_JW_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_JW_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_sec_params Pointer to the @ref ble_gap_sec_params_t structure with the security parameters to be used during the pairing or bonding procedure.
N *                         In the peripheral role, only the bond, mitm, lesc and keypress fields of this structure are used.
N *                         In the central role, this pointer may be NULL to reject a Security Request.
N *
N * @retval ::NRF_SUCCESS Successfully initiated authentication procedure.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N * @retval ::NRF_ERROR_NO_MEM The maximum number of authentication procedures that can run in parallel for the given role is reached.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported.
N * @retval ::NRF_ERROR_TIMEOUT A SMP timeout has occurred, and further SMP operations on this link is prohibited.
N */
NSVCALL(SD_BLE_GAP_AUTHENTICATE, uint32_t, sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const *p_sec_params));
Xuint32_t __svc(SD_BLE_GAP_AUTHENTICATE) sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const *p_sec_params);
N
N
N/**@brief Reply with GAP security parameters.
N *
N * @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
N * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
N *
N * @events
N * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_JW_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_BONDING_JW_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_PERIPH_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_CENTRAL_OOB_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_BONDING_STATIC_PK_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_CONFIRM_FAIL_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_PAIRING_JW_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_PD_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_KS_TOO_SMALL_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_APP_ERROR_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_REMOTE_PAIRING_FAIL_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_TIMEOUT_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_PAIRING_JW_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_JW_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] sec_status Security status, see @ref BLE_GAP_SEC_STATUS.
N * @param[in] p_sec_params Pointer to a @ref ble_gap_sec_params_t security parameters structure. In the central role this must be set to NULL, as the parameters have
N *                         already been provided during a previous call to @ref sd_ble_gap_authenticate.
N * @param[in,out] p_sec_keyset Pointer to a @ref ble_gap_sec_keyset_t security keyset structure. Any keys generated and/or distributed as a result of the ongoing security procedure
N *                         will be stored into the memory referenced by the pointers inside this structure. The keys will be stored and available to the application
N *                         upon reception of a @ref BLE_GAP_EVT_AUTH_STATUS event.
N *                         Note that the SoftDevice expects the application to provide memory for storing the
N *                         peer's keys. So it must be ensured that the relevant pointers inside this structure are not NULL. The pointers to the local key
N *                         can, however, be NULL, in which case, the local key data will not be available to the application upon reception of the
N *                         @ref BLE_GAP_EVT_AUTH_STATUS event.
N *
N * @retval ::NRF_SUCCESS Successfully accepted security parameter from the application.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported.
N */
NSVCALL(SD_BLE_GAP_SEC_PARAMS_REPLY, uint32_t, sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const *p_sec_params, ble_gap_sec_keyset_t const *p_sec_keyset));
Xuint32_t __svc(SD_BLE_GAP_SEC_PARAMS_REPLY) sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const *p_sec_params, ble_gap_sec_keyset_t const *p_sec_keyset);
N
N
N/**@brief Reply with an authentication key.
N *
N * @details This function is only used to reply to a @ref BLE_GAP_EVT_AUTH_KEY_REQUEST or a @ref BLE_GAP_EVT_PASSKEY_DISPLAY, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
N * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
N *
N * @events
N * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_CENTRAL_OOB_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] key_type See @ref BLE_GAP_AUTH_KEY_TYPES.
N * @param[in] p_key If key type is @ref BLE_GAP_AUTH_KEY_TYPE_NONE, then NULL.
N *                  If key type is @ref BLE_GAP_AUTH_KEY_TYPE_PASSKEY, then a 6-byte ASCII string (digit 0..9 only, no NULL termination)
N *                     or NULL when confirming LE Secure Connections Numeric Comparison.
N *                  If key type is @ref BLE_GAP_AUTH_KEY_TYPE_OOB, then a 16-byte OOB key value in Little Endian format.
N *
N * @retval ::NRF_SUCCESS Authentication key successfully set.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_AUTH_KEY_REPLY, uint32_t, sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const *p_key));
Xuint32_t __svc(SD_BLE_GAP_AUTH_KEY_REPLY) sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const *p_key);
N
N/**@brief Reply with an LE Secure connections DHKey.
N *
N * @details This function is only used to reply to a @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
N * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
N *
N * @events
N * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_PAIRING_JW_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_PD_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_dhkey LE Secure Connections DHKey.
N *
N * @retval ::NRF_SUCCESS DHKey successfully set.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_LESC_DHKEY_REPLY, uint32_t, sd_ble_gap_lesc_dhkey_reply(uint16_t conn_handle, ble_gap_lesc_dhkey_t const *p_dhkey));
Xuint32_t __svc(SD_BLE_GAP_LESC_DHKEY_REPLY) sd_ble_gap_lesc_dhkey_reply(uint16_t conn_handle, ble_gap_lesc_dhkey_t const *p_dhkey);
N
N/**@brief Notify the peer of a local keypress.
N *
N * @details This function can only be used when an authentication procedure using LE Secure Connection is in progress. Calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] kp_not See @ref BLE_GAP_KP_NOT_TYPES.
N *
N * @retval ::NRF_SUCCESS Keypress notification successfully queued for transmission.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either not entering a passkey or keypresses have not been enabled by both peers.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @retval ::NRF_ERROR_BUSY The BLE stack is busy. Retry at later time.
N */
NSVCALL(SD_BLE_GAP_KEYPRESS_NOTIFY, uint32_t, sd_ble_gap_keypress_notify(uint16_t conn_handle, uint8_t kp_not));
Xuint32_t __svc(SD_BLE_GAP_KEYPRESS_NOTIFY) sd_ble_gap_keypress_notify(uint16_t conn_handle, uint8_t kp_not);
N
N/**@brief Generate a set of OOB data to send to a peer out of band.
N *
N * @note The @ref ble_gap_addr_t included in the OOB data returned will be the currently active one (or, if a connection has already been established,
N *       the one used during connection setup). The application may manually overwrite it with an updated value.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle. Can be BLE_CONN_HANDLE_INVALID if a BLE connection has not been established yet.
N * @param[in] p_pk_own LE Secure Connections local P-256 Public Key.
N * @param[out] p_oobd_own The OOB data to be sent out of band to a peer.
N *
N * @retval ::NRF_SUCCESS OOB data successfully generated.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_LESC_OOB_DATA_GET, uint32_t, sd_ble_gap_lesc_oob_data_get(uint16_t conn_handle, ble_gap_lesc_p256_pk_t const *p_pk_own, ble_gap_lesc_oob_data_t *p_oobd_own));
Xuint32_t __svc(SD_BLE_GAP_LESC_OOB_DATA_GET) sd_ble_gap_lesc_oob_data_get(uint16_t conn_handle, ble_gap_lesc_p256_pk_t const *p_pk_own, ble_gap_lesc_oob_data_t *p_oobd_own);
N
N/**@brief Provide the OOB data sent/received out of band.
N *
N * @note At least one of the 2 pointers provided must be different from NULL.
N * @note An authentication procedure with OOB selected as an algorithm must be in progress when calling this function.
N * @note A @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST event with the oobd_req set to 1 must have been received prior to calling this function.
N *
N * @events
N * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_oobd_own The OOB data sent out of band to a peer or NULL if none sent.
N * @param[in] p_oobd_peer The OOB data received out of band from a peer or NULL if none received.
N *
N * @retval ::NRF_SUCCESS OOB data accepted.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_LESC_OOB_DATA_SET, uint32_t, sd_ble_gap_lesc_oob_data_set(uint16_t conn_handle, ble_gap_lesc_oob_data_t const *p_oobd_own, ble_gap_lesc_oob_data_t const *p_oobd_peer));
Xuint32_t __svc(SD_BLE_GAP_LESC_OOB_DATA_SET) sd_ble_gap_lesc_oob_data_set(uint16_t conn_handle, ble_gap_lesc_oob_data_t const *p_oobd_own, ble_gap_lesc_oob_data_t const *p_oobd_peer);
N
N/**@brief Initiate GAP Encryption procedure.
N *
N * @details In the central role, this function will initiate the encryption procedure using the encryption information provided.
N *
N * @events
N * @event{@ref BLE_GAP_EVT_CONN_SEC_UPDATE, The connection security has been updated.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_ENC_MSC}
N * @mmsc{@ref BLE_GAP_MULTILINK_CTRL_PROC_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_SEC_REQ_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_master_id Pointer to a @ref ble_gap_master_id_t master identification structure.
N * @param[in] p_enc_info  Pointer to a @ref ble_gap_enc_info_t encryption information structure.
N *
N * @retval ::NRF_SUCCESS Successfully initiated authentication procedure.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @retval ::BLE_ERROR_INVALID_ROLE Operation is not supported in the Peripheral role.
N * @retval ::NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, wait for pending procedures to complete and retry.
N */
NSVCALL(SD_BLE_GAP_ENCRYPT, uint32_t, sd_ble_gap_encrypt(uint16_t conn_handle, ble_gap_master_id_t const *p_master_id, ble_gap_enc_info_t const *p_enc_info));
Xuint32_t __svc(SD_BLE_GAP_ENCRYPT) sd_ble_gap_encrypt(uint16_t conn_handle, ble_gap_master_id_t const *p_master_id, ble_gap_enc_info_t const *p_enc_info);
N
N
N/**@brief Reply with GAP security information.
N *
N * @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_INFO_REQUEST, calling it at other times will result in @ref NRF_ERROR_INVALID_STATE.
N * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
N * @note    Data signing is not yet supported, and p_sign_info must therefore be NULL.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PERIPH_ENC_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_enc_info Pointer to a @ref ble_gap_enc_info_t encryption information structure. May be NULL to signal none is available.
N * @param[in] p_id_info Pointer to a @ref ble_gap_irk_t identity information structure. May be NULL to signal none is available.
N * @param[in] p_sign_info Pointer to a @ref ble_gap_sign_info_t signing information structure. May be NULL to signal none is available.
N *
N * @retval ::NRF_SUCCESS Successfully accepted security information.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_SEC_INFO_REPLY, uint32_t, sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const *p_enc_info, ble_gap_irk_t const *p_id_info, ble_gap_sign_info_t const *p_sign_info));
Xuint32_t __svc(SD_BLE_GAP_SEC_INFO_REPLY) sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const *p_enc_info, ble_gap_irk_t const *p_id_info, ble_gap_sign_info_t const *p_sign_info);
N
N
N/**@brief Get the current connection security.
N *
N * @param[in]  conn_handle Connection handle.
N * @param[out] p_conn_sec  Pointer to a @ref ble_gap_conn_sec_t structure to be filled in.
N *
N * @retval ::NRF_SUCCESS Current connection security successfully retrieved.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_CONN_SEC_GET, uint32_t, sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t *p_conn_sec));
Xuint32_t __svc(SD_BLE_GAP_CONN_SEC_GET) sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t *p_conn_sec);
N
N
N/**@brief Start reporting the received signal strength to the application.
N *
N * A new event is reported whenever the RSSI value changes, until @ref sd_ble_gap_rssi_stop is called.
N *
N * @events
N * @event{@ref BLE_GAP_EVT_RSSI_CHANGED, New RSSI data available. How often the event is generated is
N                                         dependent on the settings of the <code>threshold_dbm</code>
N                                         and <code>skip_count</code> input parameters.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}
N * @mmsc{@ref BLE_GAP_RSSI_FILT_MSC}
N * @endmscs
N *
N * @param[in] conn_handle        Connection handle.
N * @param[in] threshold_dbm      Minimum change in dBm before triggering the @ref BLE_GAP_EVT_RSSI_CHANGED event. Events are disabled if threshold_dbm equals @ref BLE_GAP_RSSI_THRESHOLD_INVALID.
N * @param[in] skip_count         Number of RSSI samples with a change of threshold_dbm or more before sending a new @ref BLE_GAP_EVT_RSSI_CHANGED event.
N *
N * @retval ::NRF_SUCCESS                   Successfully activated RSSI reporting.
N * @retval ::NRF_ERROR_INVALID_STATE       Disconnection in progress. Invalid state to perform operation.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_RSSI_START, uint32_t, sd_ble_gap_rssi_start(uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count));
Xuint32_t __svc(SD_BLE_GAP_RSSI_START) sd_ble_gap_rssi_start(uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count);
N
N
N/**@brief Stop reporting the received signal strength.
N *
N * @note An RSSI change detected before the call but not yet received by the application
N * may be reported after @ref sd_ble_gap_rssi_stop has been called.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}
N * @mmsc{@ref BLE_GAP_RSSI_FILT_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection handle.
N *
N * @retval ::NRF_SUCCESS                   Successfully deactivated RSSI reporting.
N * @retval ::NRF_ERROR_INVALID_STATE       Invalid state to perform operation.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_RSSI_STOP, uint32_t, sd_ble_gap_rssi_stop(uint16_t conn_handle));
Xuint32_t __svc(SD_BLE_GAP_RSSI_STOP) sd_ble_gap_rssi_stop(uint16_t conn_handle);
N
N
N/**@brief Get the received signal strength for the last connection event.
N *
N * @ref sd_ble_gap_rssi_start must be called to start reporting RSSI before using this function. @ref NRF_ERROR_NOT_FOUND
N * will be returned until RSSI was sampled for the first time after calling @ref sd_ble_gap_rssi_start.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}
N * @endmscs
N *
N * @param[in]  conn_handle Connection handle.
N * @param[out] p_rssi      Pointer to the location where the RSSI measurement shall be stored.
N *
N * @retval ::NRF_SUCCESS                   Successfully read the RSSI.
N * @retval ::NRF_ERROR_NOT_FOUND           No sample is available.
N * @retval ::NRF_ERROR_INVALID_ADDR        Invalid pointer supplied.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @retval ::NRF_ERROR_INVALID_STATE       RSSI reporting is not ongoing, or disconnection in progress.
N */
NSVCALL(SD_BLE_GAP_RSSI_GET, uint32_t, sd_ble_gap_rssi_get(uint16_t conn_handle, int8_t *p_rssi));
Xuint32_t __svc(SD_BLE_GAP_RSSI_GET) sd_ble_gap_rssi_get(uint16_t conn_handle, int8_t *p_rssi);
N
N
N/**@brief Start scanning (GAP Discovery procedure, Observer Procedure).
N *
N *
N * @events
N * @event{@ref BLE_GAP_EVT_ADV_REPORT, An advertising or scan response packet has been received.}
N * @event{@ref BLE_GAP_EVT_TIMEOUT, Scanner has timed out.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_SCAN_MSC}
N * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
N * @endmscs
N *
N * @param[in] p_scan_params Pointer to scan parameters structure.
N *
N * @retval ::NRF_SUCCESS Successfully initiated scanning procedure.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
N *                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again
N */
NSVCALL(SD_BLE_GAP_SCAN_START, uint32_t, sd_ble_gap_scan_start(ble_gap_scan_params_t const *p_scan_params));
Xuint32_t __svc(SD_BLE_GAP_SCAN_START) sd_ble_gap_scan_start(ble_gap_scan_params_t const *p_scan_params);
N
N
N/**@brief Stop scanning (GAP Discovery procedure, Observer Procedure).
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_SCAN_MSC}
N * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
N * @endmscs
N *
N * @retval ::NRF_SUCCESS Successfully stopped scanning procedure.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in scanning state).
N */
NSVCALL(SD_BLE_GAP_SCAN_STOP, uint32_t, sd_ble_gap_scan_stop(void));
Xuint32_t __svc(SD_BLE_GAP_SCAN_STOP) sd_ble_gap_scan_stop(void);
N
N
N/**@brief Create a connection (GAP Link Establishment).
N *
N * @note If a scanning procedure is currently in progress it will be automatically stopped when calling this function.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_CONN_PRIV_MSC}
N * @mmsc{@ref BLE_GAP_CENTRAL_CONN_MSC}
N * @endmscs
N *
N * @param[in] p_peer_addr   Pointer to peer address. If the use_whitelist bit is set in @ref ble_gap_scan_params_t, then this is ignored.
N *                          If @ref ble_gap_addr_t::addr_id_peer is set then p_peer_addr must be present in the device identity list
N *                          see @ref sd_ble_gap_device_identities_set.
N * @param[in] p_scan_params Pointer to scan parameters structure.
N * @param[in] p_conn_params Pointer to desired connection parameters.
N *
N * @retval ::NRF_SUCCESS Successfully initiated connection procedure.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid parameter(s) pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N                                     - Invalid parameter(s) in p_scan_params or p_conn_params.
N                                     - Use of whitelist requested but whitelist has not been set, see @ref sd_ble_gap_whitelist_set.
N                                     - Peer address was not present in the device identity list, see @ref sd_ble_gap_device_identities_set.
N * @retval ::NRF_ERROR_INVALID_STATE The SoftDevice is in an invalid state to perform this operation. This may be due to an
N *                                   existing locally initiated connect procedure, which must complete before initiating again.
N * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Peer address.
N * @retval ::NRF_ERROR_CONN_COUNT The limit of available connections has been reached.
N * @retval ::NRF_ERROR_NO_MEM The configured memory pool (see @ref ble_conn_bw_counts_t) is not large enough for the
N *                            bandwidth selected for this connection.
N * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry. If another connection is being established
N *                          wait for the corresponding @ref BLE_GAP_EVT_CONNECTED event before calling again.
N * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
N *                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again
N */
NSVCALL(SD_BLE_GAP_CONNECT, uint32_t, sd_ble_gap_connect(ble_gap_addr_t const *p_peer_addr, ble_gap_scan_params_t const *p_scan_params, ble_gap_conn_params_t const *p_conn_params));
Xuint32_t __svc(SD_BLE_GAP_CONNECT) sd_ble_gap_connect(ble_gap_addr_t const *p_peer_addr, ble_gap_scan_params_t const *p_scan_params, ble_gap_conn_params_t const *p_conn_params);
N
N
N/**@brief Cancel a connection establishment.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_CENTRAL_CONN_MSC}
N * @endmscs
N *
N * @retval ::NRF_SUCCESS Successfully cancelled an ongoing connection procedure.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N */
NSVCALL(SD_BLE_GAP_CONNECT_CANCEL, uint32_t, sd_ble_gap_connect_cancel(void));
Xuint32_t __svc(SD_BLE_GAP_CONNECT_CANCEL) sd_ble_gap_connect_cancel(void);
N
N/** @} */
N
N#ifdef __cplusplus
S}
N#endif
N#endif // BLE_GAP_H__
N
N/**
N  @}
N*/
L 53 "..\..\..\..\..\..\components\softdevice\s132\headers\ble.h" 2
N#include "ble_l2cap.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_l2cap.h" 1
N/*
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N *
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N *
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N *
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N
N/**
N  @addtogroup BLE_L2CAP Logical Link Control and Adaptation Protocol (L2CAP)
N  @{
N  @brief Definitions and prototypes for the L2CAP interface.
N */
N
N#ifndef BLE_L2CAP_H__
N#define BLE_L2CAP_H__
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "ble_err.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_err.h" 1
N/* 
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N * 
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N * 
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N * 
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N * 
N * 
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/**
N  @addtogroup BLE_COMMON
N  @{
N  @addtogroup  nrf_error
N  @{
N    @ingroup BLE_COMMON
N  @}
N
N  @defgroup ble_err General error codes
N  @{
N
N  @brief General error code definitions for the BLE API.
N
N  @ingroup BLE_COMMON
N*/
N#ifndef NRF_BLE_ERR_H__
N#define NRF_BLE_ERR_H__
N
N#include "nrf_error.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* @defgroup BLE_ERRORS Error Codes
N * @{ */
N#define BLE_ERROR_NOT_ENABLED            (NRF_ERROR_STK_BASE_NUM+0x001) /**< @ref sd_ble_enable has not been called. */
N#define BLE_ERROR_INVALID_CONN_HANDLE    (NRF_ERROR_STK_BASE_NUM+0x002) /**< Invalid connection handle. */
N#define BLE_ERROR_INVALID_ATTR_HANDLE    (NRF_ERROR_STK_BASE_NUM+0x003) /**< Invalid attribute handle. */
N#define BLE_ERROR_NO_TX_PACKETS          (NRF_ERROR_STK_BASE_NUM+0x004) /**< Not enough application packets available on this connection. */
N#define BLE_ERROR_INVALID_ROLE           (NRF_ERROR_STK_BASE_NUM+0x005) /**< Invalid role. */
N/** @} */
N
N
N/** @defgroup BLE_ERROR_SUBRANGES Module specific error code subranges
N *  @brief Assignment of subranges for module specific error codes.
N *  @note For specific error codes, see ble_<module>.h or ble_error_<module>.h.
N * @{ */
N#define NRF_L2CAP_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x100) /**< L2CAP specific errors. */
N#define NRF_GAP_ERR_BASE               (NRF_ERROR_STK_BASE_NUM+0x200) /**< GAP specific errors. */
N#define NRF_GATTC_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x300) /**< GATT client specific errors. */
N#define NRF_GATTS_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x400) /**< GATT server specific errors. */
N/** @} */
N
N#ifdef __cplusplus
S}
N#endif
N#endif
N
N
N/**
N  @}
N  @}
N*/
L 49 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_l2cap.h" 2
N#include "nrf_svc.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**@addtogroup BLE_L2CAP_ENUMERATIONS Enumerations
N * @{ */
N
N/**@brief L2CAP API SVC numbers. */
Nenum BLE_L2CAP_SVCS
N{
N  SD_BLE_L2CAP_CID_REGISTER = BLE_L2CAP_SVC_BASE,  /**< Register a CID. */
X  SD_BLE_L2CAP_CID_REGISTER = 0xB0,   
N  SD_BLE_L2CAP_CID_UNREGISTER,                     /**< Unregister a CID. */
N  SD_BLE_L2CAP_TX                                  /**< Transmit a packet. */
N};
N
N/**@brief L2CAP Event IDs. */
Nenum BLE_L2CAP_EVTS
N{
N  BLE_L2CAP_EVT_RX  = BLE_L2CAP_EVT_BASE          /**< L2CAP packet received. */
X  BLE_L2CAP_EVT_RX  = 0x70           
N};
N
N/** @} */
N
N/**@addtogroup BLE_L2CAP_DEFINES Defines
N * @{ */
N
N/**@defgroup BLE_ERRORS_L2CAP SVC return values specific to L2CAP
N * @{ */
N#define BLE_ERROR_L2CAP_CID_IN_USE            (NRF_L2CAP_ERR_BASE + 0x000)  /**< CID already in use. */
N/** @} */
N
N/**@brief Default L2CAP MTU. */
N#define BLE_L2CAP_MTU_DEF           (23)
N
N/**@brief Invalid Channel Identifier. */
N#define BLE_L2CAP_CID_INVALID       (0x0000)
N
N/**@brief Dynamic Channel Identifier base. */
N#define BLE_L2CAP_CID_DYN_BASE      (0x0040)
N
N/**@brief Maximum amount of dynamic CIDs. */
N#define BLE_L2CAP_CID_DYN_MAX       (8)
N
N/** @} */
N
N/**@addtogroup BLE_L2CAP_STRUCTURES Structures
N * @{ */
N
N/**@brief Packet header format for L2CAP transmission. */
Ntypedef struct
N{
N  uint16_t   len;                                 /**< Length of valid info in data member. */
N  uint16_t   cid;                                 /**< Channel ID on which packet is transmitted. */
N} ble_l2cap_header_t;
N
N
N/**@brief L2CAP Received packet event report. */
Ntypedef struct
N{
N  ble_l2cap_header_t header;                      /**< L2CAP packet header. */
N  uint8_t    data[1];                             /**< Packet data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                                       See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_l2cap_evt_rx_t;
N
N
N/**@brief L2CAP event callback event structure. */
Ntypedef struct
N{
N  uint16_t conn_handle;                           /**< Connection Handle on which event occured. */
N  union
N  {
N    ble_l2cap_evt_rx_t rx;                        /**< RX Event parameters. */
N  } params;                                       /**< Event Parameters. */
N} ble_l2cap_evt_t;
N
N/** @} */
N
N/**@addtogroup BLE_L2CAP_FUNCTIONS Functions
N * @{ */
N
N/**@brief Register a CID with L2CAP.
N *
N * @details This registers a higher protocol layer with the L2CAP multiplexer, and is requried prior to all operations on the CID.
N *
N * @mscs
N * @mmsc{@ref BLE_L2CAP_API_MSC}
N * @endmscs
N *
N * @param[in] cid L2CAP CID.
N *
N * @retval ::NRF_SUCCESS Successfully registered a CID with the L2CAP layer.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, CID must be above @ref BLE_L2CAP_CID_DYN_BASE.
N * @retval ::BLE_ERROR_L2CAP_CID_IN_USE L2CAP CID already in use.
N * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */
NSVCALL(SD_BLE_L2CAP_CID_REGISTER, uint32_t, sd_ble_l2cap_cid_register(uint16_t cid));
Xuint32_t __svc(SD_BLE_L2CAP_CID_REGISTER) sd_ble_l2cap_cid_register(uint16_t cid);
N
N/**@brief Unregister a CID with L2CAP.
N *
N * @details This unregisters a previously registerd higher protocol layer with the L2CAP multiplexer.
N *
N * @mscs
N * @mmsc{@ref BLE_L2CAP_API_MSC}
N * @endmscs
N *
N * @param[in] cid L2CAP CID.
N *
N * @retval ::NRF_SUCCESS Successfully unregistered the CID.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_NOT_FOUND CID not previously registered.
N */
NSVCALL(SD_BLE_L2CAP_CID_UNREGISTER, uint32_t, sd_ble_l2cap_cid_unregister(uint16_t cid));
Xuint32_t __svc(SD_BLE_L2CAP_CID_UNREGISTER) sd_ble_l2cap_cid_unregister(uint16_t cid);
N
N/**@brief Transmit an L2CAP packet.
N *
N * @note    It is important to note that a call to this function will <b>consume an application packet</b>, and will therefore
N *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted.
N *          Please see the documentation of @ref sd_ble_tx_packet_count_get for more details.
N *
N * @events
N * @event{@ref BLE_EVT_TX_COMPLETE}
N * @event{@ref BLE_L2CAP_EVT_RX}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_L2CAP_API_MSC}
N * @endmscs
N *
N * @param[in] conn_handle Connection Handle.
N * @param[in] p_header    Pointer to a packet header containing length and CID.
N * @param[in] p_data      Pointer to the data to be transmitted.
N *
N * @retval ::NRF_SUCCESS Successfully queued an L2CAP packet for transmission.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, CIDs must be registered beforehand with @ref sd_ble_l2cap_cid_register.
N * @retval ::NRF_ERROR_NOT_FOUND CID not found.
N * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @retval ::BLE_ERROR_NO_TX_PACKETS Not enough application packets available.
N * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, see @ref BLE_L2CAP_MTU_DEF.
N */
NSVCALL(SD_BLE_L2CAP_TX, uint32_t, sd_ble_l2cap_tx(uint16_t conn_handle, ble_l2cap_header_t const *p_header, uint8_t const *p_data));
Xuint32_t __svc(SD_BLE_L2CAP_TX) sd_ble_l2cap_tx(uint16_t conn_handle, ble_l2cap_header_t const *p_header, uint8_t const *p_data);
N
N/** @} */
N
N#ifdef __cplusplus
S}
N#endif
N#endif // BLE_L2CAP_H__
N
N/**
N  @}
N*/
L 54 "..\..\..\..\..\..\components\softdevice\s132\headers\ble.h" 2
N#include "ble_gatt.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_gatt.h" 1
N/* 
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N * 
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N * 
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N * 
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N * 
N * 
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/**
N  @addtogroup BLE_GATT Generic Attribute Profile (GATT) Common
N  @{
N  @brief  Common definitions and prototypes for the GATT interfaces.
N */
N
N#ifndef BLE_GATT_H__
N#define BLE_GATT_H__
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup BLE_GATT_DEFINES Defines
N * @{ */
N
N/** @brief Default MTU size, in bytes. */
N#define GATT_MTU_SIZE_DEFAULT 23
N
N/**@brief Invalid Attribute Handle. */
N#define BLE_GATT_HANDLE_INVALID            0x0000
N
N/**@brief First Attribute Handle. */
N#define BLE_GATT_HANDLE_START              0x0001
N
N/**@brief Last Attribute Handle. */
N#define BLE_GATT_HANDLE_END                0xFFFF
N
N/** @defgroup BLE_GATT_TIMEOUT_SOURCES GATT Timeout sources
N * @{ */
N#define BLE_GATT_TIMEOUT_SRC_PROTOCOL      0x00  /**< ATT Protocol timeout. */
N/** @} */
N
N/** @defgroup BLE_GATT_WRITE_OPS GATT Write operations
N * @{ */
N#define BLE_GATT_OP_INVALID                0x00  /**< Invalid Operation. */
N#define BLE_GATT_OP_WRITE_REQ              0x01  /**< Write Request. */
N#define BLE_GATT_OP_WRITE_CMD              0x02  /**< Write Command. */
N#define BLE_GATT_OP_SIGN_WRITE_CMD         0x03  /**< Signed Write Command. */
N#define BLE_GATT_OP_PREP_WRITE_REQ         0x04  /**< Prepare Write Request. */
N#define BLE_GATT_OP_EXEC_WRITE_REQ         0x05  /**< Execute Write Request. */
N/** @} */
N
N/** @defgroup BLE_GATT_EXEC_WRITE_FLAGS GATT Execute Write flags
N * @{ */
N#define BLE_GATT_EXEC_WRITE_FLAG_PREPARED_CANCEL 0x00   /**< Cancel prepared write. */
N#define BLE_GATT_EXEC_WRITE_FLAG_PREPARED_WRITE  0x01   /**< Execute prepared write. */
N/** @} */
N
N/** @defgroup BLE_GATT_HVX_TYPES GATT Handle Value operations
N * @{ */
N#define BLE_GATT_HVX_INVALID               0x00  /**< Invalid Operation. */
N#define BLE_GATT_HVX_NOTIFICATION          0x01  /**< Handle Value Notification. */
N#define BLE_GATT_HVX_INDICATION            0x02  /**< Handle Value Indication. */
N/** @} */
N
N/** @defgroup BLE_GATT_STATUS_CODES GATT Status Codes
N * @{ */
N#define BLE_GATT_STATUS_SUCCESS                           0x0000  /**< Success. */
N#define BLE_GATT_STATUS_UNKNOWN                           0x0001  /**< Unknown or not applicable status. */
N#define BLE_GATT_STATUS_ATTERR_INVALID                    0x0100  /**< ATT Error: Invalid Error Code. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_HANDLE             0x0101  /**< ATT Error: Invalid Attribute Handle. */
N#define BLE_GATT_STATUS_ATTERR_READ_NOT_PERMITTED         0x0102  /**< ATT Error: Read not permitted. */
N#define BLE_GATT_STATUS_ATTERR_WRITE_NOT_PERMITTED        0x0103  /**< ATT Error: Write not permitted. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_PDU                0x0104  /**< ATT Error: Used in ATT as Invalid PDU. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_AUTHENTICATION       0x0105  /**< ATT Error: Authenticated link required. */
N#define BLE_GATT_STATUS_ATTERR_REQUEST_NOT_SUPPORTED      0x0106  /**< ATT Error: Used in ATT as Request Not Supported. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_OFFSET             0x0107  /**< ATT Error: Offset specified was past the end of the attribute. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_AUTHORIZATION        0x0108  /**< ATT Error: Used in ATT as Insufficient Authorisation. */
N#define BLE_GATT_STATUS_ATTERR_PREPARE_QUEUE_FULL         0x0109  /**< ATT Error: Used in ATT as Prepare Queue Full. */
N#define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_FOUND        0x010A  /**< ATT Error: Used in ATT as Attribute not found. */
N#define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_LONG         0x010B  /**< ATT Error: Attribute cannot be read or written using read/write blob requests. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_ENC_KEY_SIZE         0x010C  /**< ATT Error: Encryption key size used is insufficient. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_ATT_VAL_LENGTH     0x010D  /**< ATT Error: Invalid value size. */
N#define BLE_GATT_STATUS_ATTERR_UNLIKELY_ERROR             0x010E  /**< ATT Error: Very unlikely error. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_ENCRYPTION           0x010F  /**< ATT Error: Encrypted link required. */
N#define BLE_GATT_STATUS_ATTERR_UNSUPPORTED_GROUP_TYPE     0x0110  /**< ATT Error: Attribute type is not a supported grouping attribute. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_RESOURCES            0x0111  /**< ATT Error: Encrypted link required. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE1_BEGIN           0x0112  /**< ATT Error: Reserved for Future Use range #1 begin. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE1_END             0x017F  /**< ATT Error: Reserved for Future Use range #1 end. */
N#define BLE_GATT_STATUS_ATTERR_APP_BEGIN                  0x0180  /**< ATT Error: Application range begin. */
N#define BLE_GATT_STATUS_ATTERR_APP_END                    0x019F  /**< ATT Error: Application range end. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE2_BEGIN           0x01A0  /**< ATT Error: Reserved for Future Use range #2 begin. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE2_END             0x01DF  /**< ATT Error: Reserved for Future Use range #2 end. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE3_BEGIN           0x01E0  /**< ATT Error: Reserved for Future Use range #3 begin. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE3_END             0x01FC  /**< ATT Error: Reserved for Future Use range #3 end. */
N#define BLE_GATT_STATUS_ATTERR_CPS_CCCD_CONFIG_ERROR      0x01FD  /**< ATT Common Profile and Service Error: Client Characteristic Configuration Descriptor improperly configured. */
N#define BLE_GATT_STATUS_ATTERR_CPS_PROC_ALR_IN_PROG       0x01FE  /**< ATT Common Profile and Service Error: Procedure Already in Progress. */
N#define BLE_GATT_STATUS_ATTERR_CPS_OUT_OF_RANGE           0x01FF  /**< ATT Common Profile and Service Error: Out Of Range. */
N/** @} */
N
N
N/** @defgroup BLE_GATT_CPF_FORMATS Characteristic Presentation Formats
N *  @note Found at http://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorViewer.aspx?u=org.bluetooth.descriptor.gatt.characteristic_presentation_format.xml
N * @{ */
N#define BLE_GATT_CPF_FORMAT_RFU                 0x00 /**< Reserved For Future Use. */
N#define BLE_GATT_CPF_FORMAT_BOOLEAN             0x01 /**< Boolean. */
N#define BLE_GATT_CPF_FORMAT_2BIT                0x02 /**< Unsigned 2-bit integer. */
N#define BLE_GATT_CPF_FORMAT_NIBBLE              0x03 /**< Unsigned 4-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT8               0x04 /**< Unsigned 8-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT12              0x05 /**< Unsigned 12-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT16              0x06 /**< Unsigned 16-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT24              0x07 /**< Unsigned 24-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT32              0x08 /**< Unsigned 32-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT48              0x09 /**< Unsigned 48-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT64              0x0A /**< Unsigned 64-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT128             0x0B /**< Unsigned 128-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT8               0x0C /**< Signed 2-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT12              0x0D /**< Signed 12-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT16              0x0E /**< Signed 16-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT24              0x0F /**< Signed 24-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT32              0x10 /**< Signed 32-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT48              0x11 /**< Signed 48-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT64              0x12 /**< Signed 64-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT128             0x13 /**< Signed 128-bit integer. */
N#define BLE_GATT_CPF_FORMAT_FLOAT32             0x14 /**< IEEE-754 32-bit floating point. */
N#define BLE_GATT_CPF_FORMAT_FLOAT64             0x15 /**< IEEE-754 64-bit floating point. */
N#define BLE_GATT_CPF_FORMAT_SFLOAT              0x16 /**< IEEE-11073 16-bit SFLOAT. */
N#define BLE_GATT_CPF_FORMAT_FLOAT               0x17 /**< IEEE-11073 32-bit FLOAT. */
N#define BLE_GATT_CPF_FORMAT_DUINT16             0x18 /**< IEEE-20601 format. */
N#define BLE_GATT_CPF_FORMAT_UTF8S               0x19 /**< UTF-8 string. */
N#define BLE_GATT_CPF_FORMAT_UTF16S              0x1A /**< UTF-16 string. */
N#define BLE_GATT_CPF_FORMAT_STRUCT              0x1B /**< Opaque Structure. */
N/** @} */
N
N/** @defgroup BLE_GATT_CPF_NAMESPACES GATT Bluetooth Namespaces
N * @{
N */
N#define BLE_GATT_CPF_NAMESPACE_BTSIG            0x01 /**< Bluetooth SIG defined Namespace. */
N#define BLE_GATT_CPF_NAMESPACE_DESCRIPTION_UNKNOWN 0x0000 /**< Namespace Description Unknown. */
N/** @} */
N
N/** @} */
N
N/** @addtogroup BLE_GATT_STRUCTURES Structures
N * @{ */
N
N/**
N * @brief BLE GATT initialization parameters.
N */
Ntypedef struct
N{
N  uint16_t  att_mtu;          /**< Maximum size of ATT packet the SoftDevice can send or receive.
N                                   If it is 0 then @ref GATT_MTU_SIZE_DEFAULT will be used.
N                                   Otherwise @ref GATT_MTU_SIZE_DEFAULT is the minimum value.
N                                   @mscs
N                                   @mmsc{@ref BLE_GATTC_MTU_EXCHANGE}
N                                   @mmsc{@ref BLE_GATTS_MTU_EXCHANGE}
N                                   @endmscs
N                              */
N} ble_gatt_enable_params_t;
N
N/**@brief GATT Characteristic Properties. */
Ntypedef struct
N{
N  /* Standard properties */
N  uint8_t broadcast       :1; /**< Broadcasting of the value permitted. */
N  uint8_t read            :1; /**< Reading the value permitted. */
N  uint8_t write_wo_resp   :1; /**< Writing the value with Write Command permitted. */
N  uint8_t write           :1; /**< Writing the value with Write Request permitted. */
N  uint8_t notify          :1; /**< Notications of the value permitted. */
N  uint8_t indicate        :1; /**< Indications of the value permitted. */
N  uint8_t auth_signed_wr  :1; /**< Writing the value with Signed Write Command permitted. */
N} ble_gatt_char_props_t;
N
N/**@brief GATT Characteristic Extended Properties. */
Ntypedef struct
N{
N  /* Extended properties */
N  uint8_t reliable_wr     :1; /**< Writing the value with Queued Write operations permitted. */
N  uint8_t wr_aux          :1; /**< Writing the Characteristic User Description descriptor permitted. */
N} ble_gatt_char_ext_props_t;
N
N/** @} */
N
N#ifdef __cplusplus
S}
N#endif
N#endif // BLE_GATT_H__
N
N/** @} */
L 55 "..\..\..\..\..\..\components\softdevice\s132\headers\ble.h" 2
N#include "ble_gattc.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_gattc.h" 1
N/*
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N *
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N *
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N *
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N
N/**
N  @addtogroup BLE_GATTC Generic Attribute Profile (GATT) Client
N  @{
N  @brief  Definitions and prototypes for the GATT Client interface.
N */
N
N#ifndef BLE_GATTC_H__
N#define BLE_GATTC_H__
N
N#include "ble_gatt.h"
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "nrf_svc.h"
N#include "nrf_error.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup BLE_GATTC_ENUMERATIONS Enumerations
N * @{ */
N
N/**@brief GATTC API SVC numbers. */
Nenum BLE_GATTC_SVCS
N{
N  SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = BLE_GATTC_SVC_BASE, /**< Primary Service Discovery. */
X  SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = 0x94,  
N  SD_BLE_GATTC_RELATIONSHIPS_DISCOVER,                         /**< Relationship Discovery. */
N  SD_BLE_GATTC_CHARACTERISTICS_DISCOVER,                       /**< Characteristic Discovery. */
N  SD_BLE_GATTC_DESCRIPTORS_DISCOVER,                           /**< Characteristic Descriptor Discovery. */
N  SD_BLE_GATTC_ATTR_INFO_DISCOVER,                             /**< Attribute Information Discovery. */
N  SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ,                        /**< Read Characteristic Value by UUID. */
N  SD_BLE_GATTC_READ,                                           /**< Generic read. */
N  SD_BLE_GATTC_CHAR_VALUES_READ,                               /**< Read multiple Characteristic Values. */
N  SD_BLE_GATTC_WRITE,                                          /**< Generic write. */
N  SD_BLE_GATTC_HV_CONFIRM,                                     /**< Handle Value Confirmation. */
N  SD_BLE_GATTC_EXCHANGE_MTU_REQUEST,                           /**< Exchange MTU Request. */
N};
N
N/**
N * @brief GATT Client Event IDs.
N */
Nenum BLE_GATTC_EVTS
N{
N  BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = BLE_GATTC_EVT_BASE,  /**< Primary Service Discovery Response event.      \n See @ref ble_gattc_evt_prim_srvc_disc_rsp_t.          */
X  BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = 0x30,   
N  BLE_GATTC_EVT_REL_DISC_RSP,                             /**< Relationship Discovery Response event.         \n See @ref ble_gattc_evt_rel_disc_rsp_t.                */
N  BLE_GATTC_EVT_CHAR_DISC_RSP,                            /**< Characteristic Discovery Response event.       \n See @ref ble_gattc_evt_char_disc_rsp_t.               */
N  BLE_GATTC_EVT_DESC_DISC_RSP,                            /**< Descriptor Discovery Response event.           \n See @ref ble_gattc_evt_desc_disc_rsp_t.               */
N  BLE_GATTC_EVT_ATTR_INFO_DISC_RSP,                       /**< Attribute Information Response event.          \n See @ref ble_gattc_evt_attr_info_disc_rsp_t. */
N  BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP,                /**< Read By UUID Response event.                   \n See @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t.   */
N  BLE_GATTC_EVT_READ_RSP,                                 /**< Read Response event.                           \n See @ref ble_gattc_evt_read_rsp_t.                    */
N  BLE_GATTC_EVT_CHAR_VALS_READ_RSP,                       /**< Read multiple Response event.                  \n See @ref ble_gattc_evt_char_vals_read_rsp_t.          */
N  BLE_GATTC_EVT_WRITE_RSP,                                /**< Write Response event.                          \n See @ref ble_gattc_evt_write_rsp_t.                   */
N  BLE_GATTC_EVT_HVX,                                      /**< Handle Value Notification or Indication event. \n Confirm indication with @ref sd_ble_gattc_hv_confirm.  \n See @ref ble_gattc_evt_hvx_t. */
N  BLE_GATTC_EVT_EXCHANGE_MTU_RSP,                         /**< Exchange MTU Response event.                   \n See @ref ble_gattc_evt_exchange_mtu_rsp_t.            */
N  BLE_GATTC_EVT_TIMEOUT                                   /**< Timeout event.                                 \n See @ref ble_gattc_evt_timeout_t.                     */
N};
N
N/** @} */
N
N/** @addtogroup BLE_GATTC_DEFINES Defines
N * @{ */
N
N/** @defgroup BLE_ERRORS_GATTC SVC return values specific to GATTC
N * @{ */
N#define BLE_ERROR_GATTC_PROC_NOT_PERMITTED    (NRF_GATTC_ERR_BASE + 0x000) /**< Procedure not Permitted. */
N/** @} */
N
N/** @defgroup BLE_GATTC_ATTR_INFO_FORMAT Attribute Information Formats
N * @{ */
N#define BLE_GATTC_ATTR_INFO_FORMAT_16BIT    1 /**< 16-bit Attribute Information Format. */
N#define BLE_GATTC_ATTR_INFO_FORMAT_128BIT   2 /**< 128-bit Attribute Information Format. */
N/** @} */
N
N/** @} */
N
N/** @addtogroup BLE_GATTC_STRUCTURES Structures
N * @{ */
N
N/**@brief Operation Handle Range. */
Ntypedef struct
N{
N  uint16_t          start_handle; /**< Start Handle. */
N  uint16_t          end_handle;   /**< End Handle. */
N} ble_gattc_handle_range_t;
N
N
N/**@brief GATT service. */
Ntypedef struct
N{
N  ble_uuid_t               uuid;          /**< Service UUID. */
N  ble_gattc_handle_range_t handle_range;  /**< Service Handle Range. */
N} ble_gattc_service_t;
N
N
N/**@brief  GATT include. */
Ntypedef struct
N{
N  uint16_t            handle;           /**< Include Handle. */
N  ble_gattc_service_t included_srvc;    /**< Handle of the included service. */
N} ble_gattc_include_t;
N
N
N/**@brief GATT characteristic. */
Ntypedef struct
N{
N  ble_uuid_t              uuid;                 /**< Characteristic UUID. */
N  ble_gatt_char_props_t   char_props;           /**< Characteristic Properties. */
N  uint8_t                 char_ext_props : 1;   /**< Extended properties present. */
N  uint16_t                handle_decl;          /**< Handle of the Characteristic Declaration. */
N  uint16_t                handle_value;         /**< Handle of the Characteristic Value. */
N} ble_gattc_char_t;
N
N
N/**@brief GATT descriptor. */
Ntypedef struct
N{
N  uint16_t          handle;         /**< Descriptor Handle. */
N  ble_uuid_t        uuid;           /**< Descriptor UUID. */
N} ble_gattc_desc_t;
N
N
N/**@brief Write Parameters. */
Ntypedef struct
N{
N  uint8_t        write_op;             /**< Write Operation to be performed, see @ref BLE_GATT_WRITE_OPS. */
N  uint8_t        flags;                /**< Flags, see @ref BLE_GATT_EXEC_WRITE_FLAGS. */
N  uint16_t       handle;               /**< Handle to the attribute to be written. */
N  uint16_t       offset;               /**< Offset in bytes. @note For WRITE_CMD and WRITE_REQ, offset must be 0. */
N  uint16_t       len;                  /**< Length of data in bytes. */
N  uint8_t const *p_value;              /**< Pointer to the value data. */
N} ble_gattc_write_params_t;
N
N/**@brief Attribute Information for 16-bit Attribute UUID. */
Ntypedef struct
N{
N  uint16_t       handle;               /**< Attribute handle. */
N  ble_uuid_t     uuid;                 /**< 16-bit Attribute UUID. */
N} ble_gattc_attr_info16_t;
N
N/**@brief Attribute Information for 128-bit Attribute UUID. */
Ntypedef struct
N{
N  uint16_t       handle;               /**< Attribute handle. */
N  ble_uuid128_t  uuid;                 /**< 128-bit Attribute UUID. */
N} ble_gattc_attr_info128_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t             count;           /**< Service count. */
N  ble_gattc_service_t services[1];      /**< Service data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_gattc_evt_prim_srvc_disc_rsp_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_REL_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t             count;           /**< Include count. */
N  ble_gattc_include_t includes[1];      /**< Include data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_gattc_evt_rel_disc_rsp_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_CHAR_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t            count;          /**< Characteristic count. */
N  ble_gattc_char_t    chars[1];       /**< Characteristic data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_gattc_evt_char_disc_rsp_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_DESC_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t            count;          /**< Descriptor count. */
N  ble_gattc_desc_t    descs[1];       /**< Descriptor data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_gattc_evt_desc_disc_rsp_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_ATTR_INFO_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t                     count;            /**< Attribute count. */
N  uint8_t                      format;           /**< Attribute information format, see @ref BLE_GATTC_ATTR_INFO_FORMAT. */
N  union {
N    ble_gattc_attr_info16_t  attr_info16[1];     /**< Attribute information for 16-bit Attribute UUID.
N                                                      @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                                      See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N    ble_gattc_attr_info128_t attr_info128[1];    /**< Attribute information for 128-bit Attribute UUID.
N                                                      @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                                      See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N  } info;                                        /**< Attribute information union. */
N} ble_gattc_evt_attr_info_disc_rsp_t;
N
N/**@brief GATT read by UUID handle value pair. */
Ntypedef struct
N{
N  uint16_t            handle;          /**< Attribute Handle. */
N  uint8_t            *p_value;         /**< Pointer to the Attribute Value, length is available in @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t::value_len. */
N} ble_gattc_handle_value_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP. */
Ntypedef struct
N{
N  uint16_t                  count;            /**< Handle-Value Pair Count. */
N  uint16_t                  value_len;        /**< Length of the value in Handle-Value(s) list. */
N  uint8_t                   handle_value[1];  /**< Handle-Value(s) list. To iterate through the list use @ref sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter.
N                                                   @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                                   See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_gattc_evt_char_val_by_uuid_read_rsp_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_READ_RSP. */
Ntypedef struct
N{
N  uint16_t            handle;         /**< Attribute Handle. */
N  uint16_t            offset;         /**< Offset of the attribute data. */
N  uint16_t            len;            /**< Attribute data length. */
N  uint8_t             data[1];        /**< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_gattc_evt_read_rsp_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_CHAR_VALS_READ_RSP. */
Ntypedef struct
N{
N  uint16_t            len;            /**< Concatenated Attribute values length. */
N  uint8_t             values[1];      /**< Attribute values. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_gattc_evt_char_vals_read_rsp_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_WRITE_RSP. */
Ntypedef struct
N{
N  uint16_t            handle;           /**< Attribute Handle. */
N  uint8_t             write_op;         /**< Type of write operation, see @ref BLE_GATT_WRITE_OPS. */
N  uint16_t            offset;           /**< Data offset. */
N  uint16_t            len;              /**< Data length. */
N  uint8_t             data[1];          /**< Data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_gattc_evt_write_rsp_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_HVX. */
Ntypedef struct
N{
N  uint16_t            handle;         /**< Handle to which the HVx operation applies. */
N  uint8_t             type;           /**< Indication or Notification, see @ref BLE_GATT_HVX_TYPES. */
N  uint16_t            len;            /**< Attribute data length. */
N  uint8_t             data[1];        /**< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_gattc_evt_hvx_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP. */
Ntypedef struct
N{
N  uint16_t          server_rx_mtu;            /**< Server RX MTU size. */
N} ble_gattc_evt_exchange_mtu_rsp_t;
N
N/**@brief Event structure for @ref BLE_GATTC_EVT_TIMEOUT. */
Ntypedef struct
N{
N  uint8_t          src;                       /**< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES. */
N} ble_gattc_evt_timeout_t;
N
N/**@brief GATTC event structure. */
Ntypedef struct
N{
N  uint16_t            conn_handle;                /**< Connection Handle on which event occured. */
N  uint16_t            gatt_status;                /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
N  uint16_t            error_handle;               /**< In case of error: The handle causing the error. In all other cases @ref BLE_GATT_HANDLE_INVALID. */
N  union
N  {
N    ble_gattc_evt_prim_srvc_disc_rsp_t          prim_srvc_disc_rsp;         /**< Primary Service Discovery Response Event Parameters. */
N    ble_gattc_evt_rel_disc_rsp_t                rel_disc_rsp;               /**< Relationship Discovery Response Event Parameters. */
N    ble_gattc_evt_char_disc_rsp_t               char_disc_rsp;              /**< Characteristic Discovery Response Event Parameters. */
N    ble_gattc_evt_desc_disc_rsp_t               desc_disc_rsp;              /**< Descriptor Discovery Response Event Parameters. */
N    ble_gattc_evt_char_val_by_uuid_read_rsp_t   char_val_by_uuid_read_rsp;  /**< Characteristic Value Read by UUID Response Event Parameters. */
N    ble_gattc_evt_read_rsp_t                    read_rsp;                   /**< Read Response Event Parameters. */
N    ble_gattc_evt_char_vals_read_rsp_t          char_vals_read_rsp;         /**< Characteristic Values Read Response Event Parameters. */
N    ble_gattc_evt_write_rsp_t                   write_rsp;                  /**< Write Response Event Parameters. */
N    ble_gattc_evt_hvx_t                         hvx;                        /**< Handle Value Notification/Indication Event Parameters. */
N    ble_gattc_evt_exchange_mtu_rsp_t            exchange_mtu_rsp;           /**< Exchange MTU Response Event Parameters. */
N    ble_gattc_evt_timeout_t                     timeout;                    /**< Timeout Event Parameters. */
N    ble_gattc_evt_attr_info_disc_rsp_t          attr_info_disc_rsp;         /**< Attribute Information Discovery Event Parameters. */
N  } params;                                                                 /**< Event Parameters. @note Only valid if @ref gatt_status == @ref BLE_GATT_STATUS_SUCCESS. */
N} ble_gattc_evt_t;
N/** @} */
N
N/** @addtogroup BLE_GATTC_FUNCTIONS Functions
N * @{ */
N
N/**@brief Initiate or continue a GATT Primary Service Discovery procedure.
N *
N * @details This function initiates or resumes a Primary Service discovery procedure, starting from the supplied handle.
N *          If the last service has not been reached, this function must be called again with an updated start handle value to continue the search.
N *
N * @note If any of the discovered services have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
N *       type @ref BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
N *
N * @events
N * @event{@ref BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTC_PRIM_SRVC_DISC_MSC}
N * @endmscs
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] start_handle Handle to start searching from.
N * @param[in] p_srvc_uuid Pointer to the service UUID to be found. If it is NULL, all primary services will be returned.
N *
N * @retval ::NRF_SUCCESS Successfully started or resumed the Primary Service Discovery procedure.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER, uint32_t, sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const *p_srvc_uuid));
Xuint32_t __svc(SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER) sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const *p_srvc_uuid);
N
N
N/**@brief Initiate or continue a GATT Relationship Discovery procedure.
N *
N * @details This function initiates or resumes the Find Included Services sub-procedure. If the last included service has not been reached,
N *          this must be called again with an updated handle range to continue the search.
N *
N * @events
N * @event{@ref BLE_GATTC_EVT_REL_DISC_RSP}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTC_REL_DISC_MSC}
N * @endmscs
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.
N *
N * @retval ::NRF_SUCCESS Successfully started or resumed the Relationship Discovery procedure.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_RELATIONSHIPS_DISCOVER, uint32_t, sd_ble_gattc_relationships_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_RELATIONSHIPS_DISCOVER) sd_ble_gattc_relationships_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Characteristic Discovery procedure.
N *
N * @details This function initiates or resumes a Characteristic discovery procedure. If the last Characteristic has not been reached,
N *          this must be called again with an updated handle range to continue the discovery.
N *
N * @note If any of the discovered characteristics have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
N *       type @ref BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
N *
N * @events
N * @event{@ref BLE_GATTC_EVT_CHAR_DISC_RSP}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTC_CHAR_DISC_MSC}
N * @endmscs
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.
N *
N * @retval ::NRF_SUCCESS Successfully started or resumed the Characteristic Discovery procedure.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_CHARACTERISTICS_DISCOVER, uint32_t, sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_CHARACTERISTICS_DISCOVER) sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Characteristic Descriptor Discovery procedure.
N *
N * @details This function initiates or resumes a Characteristic Descriptor discovery procedure. If the last Descriptor has not been reached,
N *          this must be called again with an updated handle range to continue the discovery.
N *
N * @events
N * @event{@ref BLE_GATTC_EVT_DESC_DISC_RSP}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTC_DESC_DISC_MSC}
N * @endmscs
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handle_range A pointer to the range of handles of the Characteristic to perform this procedure on.
N *
N * @retval ::NRF_SUCCESS Successfully started or resumed the Descriptor Discovery procedure.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_DESCRIPTORS_DISCOVER, uint32_t, sd_ble_gattc_descriptors_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_DESCRIPTORS_DISCOVER) sd_ble_gattc_descriptors_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Read using Characteristic UUID procedure.
N *
N * @details This function initiates or resumes a Read using Characteristic UUID procedure. If the last Characteristic has not been reached,
N *          this must be called again with an updated handle range to continue the discovery.
N *
N * @events
N * @event{@ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTC_READ_UUID_MSC}
N * @endmscs
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_uuid Pointer to a Characteristic value UUID to read.
N * @param[in] p_handle_range A pointer to the range of handles to perform this procedure on.
N *
N * @retval ::NRF_SUCCESS Successfully started or resumed the Read using Characteristic UUID procedure.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ, uint32_t, sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const *p_uuid, ble_gattc_handle_range_t const *p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ) sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const *p_uuid, ble_gattc_handle_range_t const *p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Read (Long) Characteristic or Descriptor procedure.
N *
N * @details This function initiates or resumes a GATT Read (Long) Characteristic or Descriptor procedure. If the Characteristic or Descriptor
N *          to be read is longer than ATT_MTU - 1, this function must be called multiple times with appropriate offset to read the
N *          complete value.
N *
N * @events
N * @event{@ref BLE_GATTC_EVT_READ_RSP}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTC_VALUE_READ_MSC}
N * @endmscs
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] handle The handle of the attribute to be read.
N * @param[in] offset Offset into the attribute value to be read.
N *
N * @retval ::NRF_SUCCESS Successfully started or resumed the Read (Long) procedure.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
N * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_READ, uint32_t, sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset));
Xuint32_t __svc(SD_BLE_GATTC_READ) sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset);
N
N
N/**@brief Initiate a GATT Read Multiple Characteristic Values procedure.
N *
N * @details This function initiates a GATT Read Multiple Characteristic Values procedure.
N *
N * @events
N * @event{@ref BLE_GATTC_EVT_CHAR_VALS_READ_RSP}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTC_READ_MULT_MSC}
N * @endmscs
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handles A pointer to the handle(s) of the attribute(s) to be read.
N * @param[in] handle_count The number of handles in p_handles.
N *
N * @retval ::NRF_SUCCESS Successfully started the Read Multiple Characteristic Values procedure.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_CHAR_VALUES_READ, uint32_t, sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const *p_handles, uint16_t handle_count));
Xuint32_t __svc(SD_BLE_GATTC_CHAR_VALUES_READ) sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const *p_handles, uint16_t handle_count);
N
N
N/**@brief Perform a Write (Characteristic Value or Descriptor, with or without response, signed or not, long or reliable) procedure.
N *
N * @details This function can perform all write procedures described in GATT.
N *
N * @note    It is important to note that a write without response will <b>consume an application buffer</b>, and will therefore
N *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. A write (with response) on the other hand will use the
N *          standard client internal buffer and thus will only generate a @ref BLE_GATTC_EVT_WRITE_RSP event as soon as the write response
N *          has been received from the peer. Please see the documentation of @ref sd_ble_tx_packet_count_get for more details.
N *
N * @events
N * @event{@ref BLE_GATTC_EVT_WRITE_RSP, Generated when using write request or queued writes.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTC_VALUE_WRITE_MSC}
N * @mmsc{@ref BLE_GATTC_VALUE_LONG_WRITE_MSC}
N * @mmsc{@ref BLE_GATTC_VALUE_RELIABLE_WRITE_MSC}
N * @mmsc{@ref BLE_COMMON_APP_BUFF_MSC}
N * @endmscs
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_write_params A pointer to a write parameters structure.
N *
N * @retval ::NRF_SUCCESS Successfully started the Write procedure.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N * @retval ::NRF_ERROR_BUSY Procedure already in progress.
N * @retval ::BLE_ERROR_NO_TX_PACKETS No available application packets for this connection.
N */
NSVCALL(SD_BLE_GATTC_WRITE, uint32_t, sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const *p_write_params));
Xuint32_t __svc(SD_BLE_GATTC_WRITE) sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const *p_write_params);
N
N
N/**@brief Send a Handle Value Confirmation to the GATT Server.
N *
N * @mscs
N * @mmsc{@ref BLE_GATTC_HVI_MSC}
N * @endmscs
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] handle The handle of the attribute in the indication.
N *
N * @retval ::NRF_SUCCESS Successfully queued the Handle Value Confirmation for transmission.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no Indication pending to be confirmed.
N * @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle.
N */
NSVCALL(SD_BLE_GATTC_HV_CONFIRM, uint32_t, sd_ble_gattc_hv_confirm(uint16_t conn_handle, uint16_t handle));
Xuint32_t __svc(SD_BLE_GATTC_HV_CONFIRM) sd_ble_gattc_hv_confirm(uint16_t conn_handle, uint16_t handle);
N
N/**@brief Discovers information about a range of attributes on a GATT server.
N *
N * @events
N * @event{@ref BLE_GATTC_EVT_ATTR_INFO_DISC_RSP, Generated when information about a range of attributes has been received.}
N * @endevents
N *
N * @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handle_range The range of handles to request information about.
N *
N * @retval ::NRF_SUCCESS Successfully started an attribute information discovery procedure.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid connection state
N * @retval ::NRF_ERROR_INVALID_ADDR  Invalid pointer supplied.
N * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_ATTR_INFO_DISCOVER, uint32_t, sd_ble_gattc_attr_info_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_ATTR_INFO_DISCOVER) sd_ble_gattc_attr_info_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * p_handle_range);
N
N/**@brief Start an ATT_MTU exchange by sending an Exchange MTU Request to the server.
N *
N * @details The SoftDevice sets ATT_MTU to the minimum of:
N *          - The Client RX MTU value, and
N *          - The Server RX MTU value from @ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP.
N *
N *          However, the SoftDevice never sets ATT_MTU lower than @ref GATT_MTU_SIZE_DEFAULT.
N *
N * @events
N * @event{@ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP}
N * @event{@ref BLE_EVT_DATA_LENGTH_CHANGED, Generated if a data length update procedure is performed after the ATT_MTU exchange.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTC_MTU_EXCHANGE}
N * @endmscs
N *
N * @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.
N * @param[in] client_rx_mtu  Client RX MTU size.
N *                           - The minimum value is @ref GATT_MTU_SIZE_DEFAULT.
N *                           - The maximum value is @ref ble_gatt_enable_params_t::att_mtu.
N *                           - The value must be equal to Server RX MTU size given in @ref sd_ble_gatts_exchange_mtu_reply
N *                             if an ATT_MTU exchange has already been performed in the other direction.
N *
N * @retval ::NRF_SUCCESS Successfully sent request to the server.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid connection state or an ATT_MTU exchange was already requested once.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid Client RX MTU size supplied.
N * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_EXCHANGE_MTU_REQUEST, uint32_t, sd_ble_gattc_exchange_mtu_request(uint16_t conn_handle, uint16_t client_rx_mtu));
Xuint32_t __svc(SD_BLE_GATTC_EXCHANGE_MTU_REQUEST) sd_ble_gattc_exchange_mtu_request(uint16_t conn_handle, uint16_t client_rx_mtu);
N
N/**@brief Iterate through Handle-Value(s) list in @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP event.
N *
N * @param[in] p_gattc_evt  Pointer to event buffer containing @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP event.
N *                         @note If the buffer contains different event, behavior is undefined.
N * @param[in,out] p_iter   Iterator, points to @ref ble_gattc_handle_value_t structure that will be filled in with
N *                         the next Handle-Value pair in each iteration. If the function returns other than
N *                         @ref NRF_SUCCESS, it will not be changed.
N *                         - To start iteration, initialize the structure to zero.
N *                         - To continue, pass the value from previous iteration.
N *
N * \code
N * ble_gattc_handle_value_t iter;
N * memset(&iter, 0, sizeof(ble_gattc_handle_value_t));
N * while (sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(&ble_evt.evt.gattc_evt, &iter) == NRF_SUCCESS)
N * {
N *   app_handle = iter.handle;
N *   memcpy(app_value, iter.p_value, ble_evt.evt.gattc_evt.params.char_val_by_uuid_read_rsp.value_len);
N * }
N * \endcode
N *
N * @retval ::NRF_SUCCESS Successfully retrieved the next Handle-Value pair.
N * @retval ::NRF_ERROR_NOT_FOUND No more Handle-Value pairs available in the list.
N */
Nstatic inline uint32_t sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(ble_gattc_evt_t *p_gattc_evt, ble_gattc_handle_value_t *p_iter)
N{
N  uint32_t value_len = p_gattc_evt->params.char_val_by_uuid_read_rsp.value_len;
N  uint8_t *p_first = p_gattc_evt->params.char_val_by_uuid_read_rsp.handle_value;
N  uint8_t *p_next = p_iter->p_value ? p_iter->p_value + value_len : p_first;
N
N  if ((p_next - p_first) / (sizeof(uint16_t) + value_len) < p_gattc_evt->params.char_val_by_uuid_read_rsp.count)
N  {
N    p_iter->handle = (uint16_t)p_next[1] << 8 | p_next[0];
N    p_iter->p_value = p_next + sizeof(uint16_t);
N    return NRF_SUCCESS;
X    return ((0x0) + 0);
N  }
N  else
N  {
N    return NRF_ERROR_NOT_FOUND;
X    return ((0x0) + 5);
N  }
N}
N
N/** @} */
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* BLE_GATTC_H__ */
N
N/**
N  @}
N*/
L 56 "..\..\..\..\..\..\components\softdevice\s132\headers\ble.h" 2
N#include "ble_gatts.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_gatts.h" 1
N/*
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N *
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N *
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N *
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N
N/**
N  @addtogroup BLE_GATTS Generic Attribute Profile (GATT) Server
N  @{
N  @brief  Definitions and prototypes for the GATTS interface.
N */
N
N#ifndef BLE_GATTS_H__
N#define BLE_GATTS_H__
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "ble_l2cap.h"
N#include "ble_gap.h"
N#include "ble_gatt.h"
N#include "nrf_svc.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup BLE_GATTS_ENUMERATIONS Enumerations
N * @{ */
N
N/**
N * @brief GATTS API SVC numbers.
N */
Nenum BLE_GATTS_SVCS
N{
N  SD_BLE_GATTS_SERVICE_ADD = BLE_GATTS_SVC_BASE, /**< Add a service. */
X  SD_BLE_GATTS_SERVICE_ADD = 0xA0,  
N  SD_BLE_GATTS_INCLUDE_ADD,                      /**< Add an included service. */
N  SD_BLE_GATTS_CHARACTERISTIC_ADD,               /**< Add a characteristic. */
N  SD_BLE_GATTS_DESCRIPTOR_ADD,                   /**< Add a generic attribute. */
N  SD_BLE_GATTS_VALUE_SET,                        /**< Set an attribute value. */
N  SD_BLE_GATTS_VALUE_GET,                        /**< Get an attribute value. */
N  SD_BLE_GATTS_HVX,                              /**< Handle Value Notification or Indication. */
N  SD_BLE_GATTS_SERVICE_CHANGED,                  /**< Perform a Service Changed Indication to one or more peers. */
N  SD_BLE_GATTS_RW_AUTHORIZE_REPLY,               /**< Reply to an authorization request for a read or write operation on one or more attributes. */
N  SD_BLE_GATTS_SYS_ATTR_SET,                     /**< Set the persistent system attributes for a connection. */
N  SD_BLE_GATTS_SYS_ATTR_GET,                     /**< Retrieve the persistent system attributes. */
N  SD_BLE_GATTS_INITIAL_USER_HANDLE_GET,          /**< Retrieve the first valid user handle. */
N  SD_BLE_GATTS_ATTR_GET,                         /**< Retrieve the UUID and/or metadata of an attribute. */
N  SD_BLE_GATTS_EXCHANGE_MTU_REPLY                /**< Reply to Exchange MTU Request. */
N};
N
N/**
N * @brief GATT Server Event IDs.
N */
Nenum BLE_GATTS_EVTS
N{
N  BLE_GATTS_EVT_WRITE = BLE_GATTS_EVT_BASE,       /**< Write operation performed.                                           \n See @ref ble_gatts_evt_write_t.                 */
X  BLE_GATTS_EVT_WRITE = 0x50,        
N  BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST,             /**< Read/Write Authorization request.                                    \n Reply with @ref sd_ble_gatts_rw_authorize_reply. \n See @ref ble_gatts_evt_rw_authorize_request_t. */
N  BLE_GATTS_EVT_SYS_ATTR_MISSING,                 /**< A persistent system attribute access is pending.                     \n Respond with @ref sd_ble_gatts_sys_attr_set.     \n See @ref ble_gatts_evt_sys_attr_missing_t.     */
N  BLE_GATTS_EVT_HVC,                              /**< Handle Value Confirmation.                                           \n See @ref ble_gatts_evt_hvc_t.                   */
N  BLE_GATTS_EVT_SC_CONFIRM,                       /**< Service Changed Confirmation. No additional event structure applies.                                                    */
N  BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST,             /**< Exchange MTU Request.                                                \n Reply with @ref sd_ble_gatts_exchange_mtu_reply. \n See @ref ble_gatts_evt_exchange_mtu_request_t. */
N  BLE_GATTS_EVT_TIMEOUT                           /**< Peer failed to resonpond to an ATT request in time.                  \n See @ref ble_gatts_evt_timeout_t.               */
N};
N/** @} */
N
N/** @addtogroup BLE_GATTS_DEFINES Defines
N * @{ */
N
N/** @defgroup BLE_ERRORS_GATTS SVC return values specific to GATTS
N * @{ */
N#define BLE_ERROR_GATTS_INVALID_ATTR_TYPE   (NRF_GATTS_ERR_BASE + 0x000) /**< Invalid attribute type. */
N#define BLE_ERROR_GATTS_SYS_ATTR_MISSING    (NRF_GATTS_ERR_BASE + 0x001) /**< System Attributes missing. */
N/** @} */
N
N/** @defgroup BLE_GATTS_ATTR_LENS_MAX Maximum attribute lengths
N * @{ */
N#define BLE_GATTS_FIX_ATTR_LEN_MAX (510)  /**< Maximum length for fixed length Attribute Values. */
N#define BLE_GATTS_VAR_ATTR_LEN_MAX (512)  /**< Maximum length for variable length Attribute Values. */
N/** @} */
N
N/** @defgroup BLE_GATTS_SRVC_TYPES GATT Server Service Types
N * @{ */
N#define BLE_GATTS_SRVC_TYPE_INVALID          0x00  /**< Invalid Service Type. */
N#define BLE_GATTS_SRVC_TYPE_PRIMARY          0x01  /**< Primary Service. */
N#define BLE_GATTS_SRVC_TYPE_SECONDARY        0x02  /**< Secondary Type. */
N/** @} */
N
N
N/** @defgroup BLE_GATTS_ATTR_TYPES GATT Server Attribute Types
N * @{ */
N#define BLE_GATTS_ATTR_TYPE_INVALID         0x00  /**< Invalid Attribute Type. */
N#define BLE_GATTS_ATTR_TYPE_PRIM_SRVC_DECL  0x01  /**< Primary Service Declaration. */
N#define BLE_GATTS_ATTR_TYPE_SEC_SRVC_DECL   0x02  /**< Secondary Service Declaration. */
N#define BLE_GATTS_ATTR_TYPE_INC_DECL        0x03  /**< Include Declaration. */
N#define BLE_GATTS_ATTR_TYPE_CHAR_DECL       0x04  /**< Characteristic Declaration. */
N#define BLE_GATTS_ATTR_TYPE_CHAR_VAL        0x05  /**< Characteristic Value. */
N#define BLE_GATTS_ATTR_TYPE_DESC            0x06  /**< Descriptor. */
N#define BLE_GATTS_ATTR_TYPE_OTHER           0x07  /**< Other, non-GATT specific type. */
N/** @} */
N
N
N/** @defgroup BLE_GATTS_OPS GATT Server Operations
N * @{ */
N#define BLE_GATTS_OP_INVALID                0x00  /**< Invalid Operation. */
N#define BLE_GATTS_OP_WRITE_REQ              0x01  /**< Write Request. */
N#define BLE_GATTS_OP_WRITE_CMD              0x02  /**< Write Command. */
N#define BLE_GATTS_OP_SIGN_WRITE_CMD         0x03  /**< Signed Write Command. */
N#define BLE_GATTS_OP_PREP_WRITE_REQ         0x04  /**< Prepare Write Request. */
N#define BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL  0x05  /**< Execute Write Request: Cancel all prepared writes. */
N#define BLE_GATTS_OP_EXEC_WRITE_REQ_NOW     0x06  /**< Execute Write Request: Immediately execute all prepared writes. */
N/** @} */
N
N/** @defgroup BLE_GATTS_VLOCS GATT Value Locations
N * @{ */
N#define BLE_GATTS_VLOC_INVALID       0x00  /**< Invalid Location. */
N#define BLE_GATTS_VLOC_STACK         0x01  /**< Attribute Value is located in stack memory, no user memory is required. */
N#define BLE_GATTS_VLOC_USER          0x02  /**< Attribute Value is located in user memory. This requires the user to maintain a valid buffer through the lifetime of the attribute, since the stack
N                                                will read and write directly to the memory using the pointer provided in the APIs. There are no alignment requirements for the buffer. */
N/** @} */
N
N/** @defgroup BLE_GATTS_AUTHORIZE_TYPES GATT Server Authorization Types
N * @{ */
N#define BLE_GATTS_AUTHORIZE_TYPE_INVALID    0x00  /**< Invalid Type. */
N#define BLE_GATTS_AUTHORIZE_TYPE_READ       0x01  /**< Authorize a Read Operation. */
N#define BLE_GATTS_AUTHORIZE_TYPE_WRITE      0x02  /**< Authorize a Write Request Operation. */
N/** @} */
N
N/** @defgroup BLE_GATTS_SYS_ATTR_FLAGS System Attribute Flags
N * @{ */
N#define BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS (1 << 0)  /**< Restrict system attributes to system services only. */
N#define BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS (1 << 1)  /**< Restrict system attributes to user services only. */
N/** @} */
N
N/** @defgroup BLE_GATTS_ATTR_TAB_SIZE Attribute Table size
N * @{
N */
N#define BLE_GATTS_ATTR_TAB_SIZE_MIN         248    /**< Minimum Attribute Table size */
N#define BLE_GATTS_ATTR_TAB_SIZE_DEFAULT     0x0000 /**< Default Attribute Table size (0x580 bytes for this version of the SoftDevice). */
N/** @} */
N
N/** @} */
N
N/** @addtogroup BLE_GATTS_STRUCTURES Structures
N * @{ */
N
N/**
N * @brief BLE GATTS initialization parameters.
N */
Ntypedef struct
N{
N  uint8_t                  service_changed:1; /**< Include the Service Changed characteristic in the Attribute Table. */
N  uint32_t                 attr_tab_size;     /**< Attribute Table size in bytes. The size must be a multiple of 4. @ref BLE_GATTS_ATTR_TAB_SIZE_DEFAULT is used to set the default size. */
N} ble_gatts_enable_params_t;
N
N/**@brief Attribute metadata. */
Ntypedef struct
N{
N  ble_gap_conn_sec_mode_t read_perm;       /**< Read permissions. */
N  ble_gap_conn_sec_mode_t write_perm;      /**< Write permissions. */
N  uint8_t                 vlen       :1;   /**< Variable length attribute. */
N  uint8_t                 vloc       :2;   /**< Value location, see @ref BLE_GATTS_VLOCS.*/
N  uint8_t                 rd_auth    :1;   /**< Read authorization and value will be requested from the application on every read operation. */
N  uint8_t                 wr_auth    :1;   /**< Write authorization will be requested from the application on every Write Request operation (but not Write Command). */
N} ble_gatts_attr_md_t;
N
N
N/**@brief GATT Attribute. */
Ntypedef struct
N{
N  ble_uuid_t          *p_uuid;          /**< Pointer to the attribute UUID. */
N  ble_gatts_attr_md_t *p_attr_md;       /**< Pointer to the attribute metadata structure. */
N  uint16_t             init_len;        /**< Initial attribute value length in bytes. */
N  uint16_t             init_offs;       /**< Initial attribute value offset in bytes. If different from zero, the first init_offs bytes of the attribute value will be left uninitialized. */
N  uint16_t             max_len;         /**< Maximum attribute value length in bytes, see @ref BLE_GATTS_ATTR_LENS_MAX for maximum values. */
N  uint8_t*             p_value;         /**< Pointer to the attribute data. Please note that if the @ref BLE_GATTS_VLOC_USER value location is selected in the attribute metadata, this will have to point to a buffer
N                                             that remains valid through the lifetime of the attribute. This excludes usage of automatic variables that may go out of scope or any other temporary location.
N                                             The stack may access that memory directly without the application's knowledge. For writable characteristics, this value must not be a location in flash memory.*/
N} ble_gatts_attr_t;
N
N/**@brief GATT Attribute Value. */
Ntypedef struct
N{
N  uint16_t  len;        /**< Length in bytes to be written or read. Length in bytes written or read after successful return.*/
N  uint16_t  offset;     /**< Attribute value offset. */
N  uint8_t   *p_value;   /**< Pointer to where value is stored or will be stored.
N                             If value is stored in user memory, only the attribute length is updated when p_value == NULL.
N                             Set to NULL when reading to obtain the complete length of the attribute value */
N} ble_gatts_value_t;
N
N
N/**@brief GATT Characteristic Presentation Format. */
Ntypedef struct
N{
N  uint8_t          format;      /**< Format of the value, see @ref BLE_GATT_CPF_FORMATS. */
N  int8_t           exponent;    /**< Exponent for integer data types. */
N  uint16_t         unit;        /**< Unit from Bluetooth Assigned Numbers. */
N  uint8_t          name_space;  /**< Namespace from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES. */
N  uint16_t         desc;        /**< Namespace description from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES. */
N} ble_gatts_char_pf_t;
N
N
N/**@brief GATT Characteristic metadata. */
Ntypedef struct
N{
N  ble_gatt_char_props_t       char_props;               /**< Characteristic Properties. */
N  ble_gatt_char_ext_props_t   char_ext_props;           /**< Characteristic Extended Properties. */
N  uint8_t                    *p_char_user_desc;         /**< Pointer to a UTF-8 encoded string (non-NULL terminated), NULL if the descriptor is not required. */
N  uint16_t                    char_user_desc_max_size;  /**< The maximum size in bytes of the user description descriptor. */
N  uint16_t                    char_user_desc_size;      /**< The size of the user description, must be smaller or equal to char_user_desc_max_size. */
N  ble_gatts_char_pf_t*        p_char_pf;                /**< Pointer to a presentation format structure or NULL if the CPF descriptor is not required. */
N  ble_gatts_attr_md_t*        p_user_desc_md;           /**< Attribute metadata for the User Description descriptor, or NULL for default values. */
N  ble_gatts_attr_md_t*        p_cccd_md;                /**< Attribute metadata for the Client Characteristic Configuration Descriptor, or NULL for default values. */
N  ble_gatts_attr_md_t*        p_sccd_md;                /**< Attribute metadata for the Server Characteristic Configuration Descriptor, or NULL for default values. */
N} ble_gatts_char_md_t;
N
N
N/**@brief GATT Characteristic Definition Handles. */
Ntypedef struct
N{
N  uint16_t          value_handle;       /**< Handle to the characteristic value. */
N  uint16_t          user_desc_handle;   /**< Handle to the User Description descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present. */
N  uint16_t          cccd_handle;        /**< Handle to the Client Characteristic Configuration Descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present. */
N  uint16_t          sccd_handle;        /**< Handle to the Server Characteristic Configuration Descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present. */
N} ble_gatts_char_handles_t;
N
N
N/**@brief GATT HVx parameters. */
Ntypedef struct
N{
N  uint16_t          handle;             /**< Characteristic Value Handle. */
N  uint8_t           type;               /**< Indication or Notification, see @ref BLE_GATT_HVX_TYPES. */
N  uint16_t          offset;             /**< Offset within the attribute value. */
N  uint16_t         *p_len;              /**< Length in bytes to be written, length in bytes written after successful return. */
N  uint8_t          *p_data;             /**< Actual data content, use NULL to use the current attribute value. */
N} ble_gatts_hvx_params_t;
N
N/**@brief GATT Authorization parameters. */
Ntypedef struct
N{
N  uint16_t          gatt_status;        /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
N  uint8_t           update : 1;         /**< If set, data supplied in p_data will be used to update the attribute value.
N                                             Please note that for @ref BLE_GATTS_AUTHORIZE_TYPE_WRITE operations this bit must always be set,
N                                             as the data to be written needs to be stored and later provided by the application. */
N  uint16_t          offset;             /**< Offset of the attribute value being updated. */
N  uint16_t          len;                /**< Length in bytes of the value in p_data pointer, see @ref BLE_GATTS_ATTR_LENS_MAX. */
N  const uint8_t    *p_data;             /**< Pointer to new value used to update the attribute value. */
N} ble_gatts_authorize_params_t;
N
N/**@brief GATT Read or Write Authorize Reply parameters. */
Ntypedef struct
N{
N  uint8_t                               type;   /**< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES. */
N  union {
N    ble_gatts_authorize_params_t        read;   /**< Read authorization parameters. */
N    ble_gatts_authorize_params_t        write;  /**< Write authorization parameters. */
N  } params;                                     /**< Reply Parameters. */
N} ble_gatts_rw_authorize_reply_params_t;
N
N
N
N/**@brief Event structure for @ref BLE_GATTS_EVT_WRITE. */
Ntypedef struct
N{
N  uint16_t                    handle;             /**< Attribute Handle. */
N  ble_uuid_t                  uuid;               /**< Attribute UUID. */
N  uint8_t                     op;                 /**< Type of write operation, see @ref BLE_GATTS_OPS. */
N  uint8_t                     auth_required;      /**< Writing operation deferred due to authorization requirement. Application may use @ref sd_ble_gatts_value_set to finalise the writing operation. */
N  uint16_t                    offset;             /**< Offset for the write operation. */
N  uint16_t                    len;                /**< Length of the received data. */
N  uint8_t                     data[1];            /**< Received data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
N                                                       See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
N} ble_gatts_evt_write_t;
N
N/**@brief Event substructure for authorized read requests, see @ref ble_gatts_evt_rw_authorize_request_t. */
Ntypedef struct
N{
N  uint16_t                    handle;             /**< Attribute Handle. */
N  ble_uuid_t                  uuid;               /**< Attribute UUID. */
N  uint16_t                    offset;             /**< Offset for the read operation. */
N} ble_gatts_evt_read_t;
N
N/**@brief Event structure for @ref BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST. */
Ntypedef struct
N{
N  uint8_t                     type;             /**< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES. */
N  union {
N    ble_gatts_evt_read_t      read;             /**< Attribute Read Parameters. */
N    ble_gatts_evt_write_t     write;            /**< Attribute Write Parameters. */
N  } request;                                    /**< Request Parameters. */
N} ble_gatts_evt_rw_authorize_request_t;
N
N/**@brief Event structure for @ref BLE_GATTS_EVT_SYS_ATTR_MISSING. */
Ntypedef struct
N{
N  uint8_t hint;                                 /**< Hint (currently unused). */
N} ble_gatts_evt_sys_attr_missing_t;
N
N
N/**@brief Event structure for @ref BLE_GATTS_EVT_HVC. */
Ntypedef struct
N{
N  uint16_t          handle;                       /**< Attribute Handle. */
N} ble_gatts_evt_hvc_t;
N
N/**@brief Event structure for @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST. */
Ntypedef struct
N{
N  uint16_t          client_rx_mtu;              /**< Client RX MTU size. */
N} ble_gatts_evt_exchange_mtu_request_t;
N
N/**@brief Event structure for @ref BLE_GATTS_EVT_TIMEOUT. */
Ntypedef struct
N{
N  uint8_t          src;                       /**< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES. */
N} ble_gatts_evt_timeout_t;
N
N
N/**@brief GATTS event structure. */
Ntypedef struct
N{
N  uint16_t conn_handle;                                       /**< Connection Handle on which the event occurred. */
N  union
N  {
N    ble_gatts_evt_write_t                 write;                 /**< Write Event Parameters. */
N    ble_gatts_evt_rw_authorize_request_t  authorize_request;     /**< Read or Write Authorize Request Parameters. */
N    ble_gatts_evt_sys_attr_missing_t      sys_attr_missing;      /**< System attributes missing. */
N    ble_gatts_evt_hvc_t                   hvc;                   /**< Handle Value Confirmation Event Parameters. */
N    ble_gatts_evt_exchange_mtu_request_t  exchange_mtu_request;  /**< Exchange MTU Request Event Parameters. */
N    ble_gatts_evt_timeout_t               timeout;               /**< Timeout Event. */
N  } params;                                                      /**< Event Parameters. */
N} ble_gatts_evt_t;
N
N/** @} */
N
N/** @addtogroup BLE_GATTS_FUNCTIONS Functions
N * @{ */
N
N/**@brief Add a service declaration to the Attribute Table.
N *
N * @note Secondary Services are only relevant in the context of the entity that references them, it is therefore forbidden to
N *       add a secondary service declaration that is not referenced by another service later in the Attribute Table.
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}
N * @endmscs
N *
N * @param[in] type      Toggles between primary and secondary services, see @ref BLE_GATTS_SRVC_TYPES.
N * @param[in] p_uuid    Pointer to service UUID.
N * @param[out] p_handle Pointer to a 16-bit word where the assigned handle will be stored.
N *
N * @retval ::NRF_SUCCESS Successfully added a service declaration.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, Vendor Specific UUIDs need to be present in the table.
N * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
N * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */
NSVCALL(SD_BLE_GATTS_SERVICE_ADD, uint32_t, sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const *p_uuid, uint16_t *p_handle));
Xuint32_t __svc(SD_BLE_GATTS_SERVICE_ADD) sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const *p_uuid, uint16_t *p_handle);
N
N
N/**@brief Add an include declaration to the Attribute Table.
N *
N * @note It is currently only possible to add an include declaration to the last added service (i.e. only sequential population is supported at this time).
N *
N * @note The included service must already be present in the Attribute Table prior to this call.
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}
N * @endmscs
N *
N * @param[in] service_handle    Handle of the service where the included service is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
N * @param[in] inc_srvc_handle   Handle of the included service.
N * @param[out] p_include_handle Pointer to a 16-bit word where the assigned handle will be stored.
N *
N * @retval ::NRF_SUCCESS Successfully added an include declaration.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, handle values need to match previously added services.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @retval ::NRF_ERROR_NOT_SUPPORTED Feature is not supported, service_handle must be that of the last added service.
N * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, self inclusions are not allowed.
N * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @retval ::NRF_ERROR_NOT_FOUND Attribute not found.
N */
NSVCALL(SD_BLE_GATTS_INCLUDE_ADD, uint32_t, sd_ble_gatts_include_add(uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t *p_include_handle));
Xuint32_t __svc(SD_BLE_GATTS_INCLUDE_ADD) sd_ble_gatts_include_add(uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t *p_include_handle);
N
N
N/**@brief Add a characteristic declaration, a characteristic value declaration and optional characteristic descriptor declarations to the Attribute Table.
N *
N * @note It is currently only possible to add a characteristic to the last added service (i.e. only sequential population is supported at this time).
N *
N * @note Several restrictions apply to the parameters, such as matching permissions between the user description descriptor and the writeable auxiliaries bits,
N *       readable (no security) and writeable (selectable) CCCDs and SCCDs and valid presentation format values.
N *
N * @note If no metadata is provided for the optional descriptors, their permissions will be derived from the characteristic permissions.
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}
N * @endmscs
N *
N * @param[in] service_handle    Handle of the service where the characteristic is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
N * @param[in] p_char_md         Characteristic metadata.
N * @param[in] p_attr_char_value Pointer to the attribute structure corresponding to the characteristic value.
N * @param[out] p_handles        Pointer to the structure where the assigned handles will be stored.
N *
N * @retval ::NRF_SUCCESS Successfully added a characteristic.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, service handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a service context is required.
N * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
N * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
N */
NSVCALL(SD_BLE_GATTS_CHARACTERISTIC_ADD, uint32_t, sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const *p_char_md, ble_gatts_attr_t const *p_attr_char_value, ble_gatts_char_handles_t *p_handles));
Xuint32_t __svc(SD_BLE_GATTS_CHARACTERISTIC_ADD) sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const *p_char_md, ble_gatts_attr_t const *p_attr_char_value, ble_gatts_char_handles_t *p_handles);
N
N
N/**@brief Add a descriptor to the Attribute Table.
N *
N * @note It is currently only possible to add a descriptor to the last added characteristic (i.e. only sequential population is supported at this time).
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}
N * @endmscs
N *
N * @param[in] char_handle   Handle of the characteristic where the descriptor is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
N * @param[in] p_attr        Pointer to the attribute structure.
N * @param[out] p_handle     Pointer to a 16-bit word where the assigned handle will be stored.
N *
N * @retval ::NRF_SUCCESS Successfully added a descriptor.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, characteristic handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a characteristic context is required.
N * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
N * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
N */
NSVCALL(SD_BLE_GATTS_DESCRIPTOR_ADD, uint32_t, sd_ble_gatts_descriptor_add(uint16_t char_handle, ble_gatts_attr_t const *p_attr, uint16_t *p_handle));
Xuint32_t __svc(SD_BLE_GATTS_DESCRIPTOR_ADD) sd_ble_gatts_descriptor_add(uint16_t char_handle, ble_gatts_attr_t const *p_attr, uint16_t *p_handle);
N
N/**@brief Set the value of a given attribute.
N *
N * @note Values other than system attributes can be set at any time, regardless of wheter any active connections exist.
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}
N * @endmscs
N *
N * @param[in] conn_handle  Connection handle. If the value does not belong to a system attribute then @ref BLE_CONN_HANDLE_INVALID can be used.
N * @param[in] handle       Attribute handle.
N * @param[in,out] p_value  Attribute value information.
N *
N * @retval ::NRF_SUCCESS Successfully set the value of the attribute.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::NRF_ERROR_NOT_FOUND Attribute not found.
N * @retval ::NRF_ERROR_FORBIDDEN Forbidden handle supplied, certain attributes are not modifiable by the application.
N * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @retval ::BLE_ERROR_GATTS_INVALID_ATTR_TYPE @ref BLE_CONN_HANDLE_INVALID supplied on a system attribute.
N */
NSVCALL(SD_BLE_GATTS_VALUE_SET, uint32_t, sd_ble_gatts_value_set(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t *p_value));
Xuint32_t __svc(SD_BLE_GATTS_VALUE_SET) sd_ble_gatts_value_set(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t *p_value);
N
N/**@brief Get the value of a given attribute.
N *
N * @note                 If the attribute value is longer than the size of the supplied buffer,
N *                       p_len will return the total attribute value length (excluding offset),
N *                       and not the number of bytes actually returned in p_data.
N *                       The application may use this information to allocate a suitable buffer size.
N *
N * @note                 When retrieving system attribute values with this function, the connection handle
N *                       may refer to an already disconnected connection. Refer to the documentation of
N *                       @ref sd_ble_gatts_sys_attr_get for further information.
N *
N * @param[in] conn_handle  Connection handle. If the value does not belong to a system attribute then @ref BLE_CONN_HANDLE_INVALID can be used.
N * @param[in] handle       Attribute handle.
N * @param[in,out] p_value  Attribute value information.
N *
N * @retval ::NRF_SUCCESS Successfully retrieved the value of the attribute.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_NOT_FOUND Attribute not found.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid attribute offset supplied.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @retval ::BLE_ERROR_GATTS_INVALID_ATTR_TYPE @ref BLE_CONN_HANDLE_INVALID supplied on a system attribute.
N * @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.
N */
NSVCALL(SD_BLE_GATTS_VALUE_GET, uint32_t, sd_ble_gatts_value_get(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t *p_value));
Xuint32_t __svc(SD_BLE_GATTS_VALUE_GET) sd_ble_gatts_value_get(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t *p_value);
N
N/**@brief Notify or Indicate an attribute value.
N *
N * @details This function checks for the relevant Client Characteristic Configuration descriptor value to verify that the relevant operation
N *          (notification or indication) has been enabled by the client. It is also able to update the attribute value before issuing the PDU, so that
N *          the application can atomically perform a value update and a server initiated transaction with a single API call.
N *          If the application chooses to indicate an attribute value, a @ref BLE_GATTS_EVT_HVC event will be issued as soon as the confirmation arrives from
N *          the peer.
N *
N * @note    The local attribute value may be updated even if an outgoing packet is not sent to the peer due to an error during execution.
N *          The Attribute Table has been updated if one of the following error codes is returned: @ref NRF_ERROR_INVALID_STATE, @ref NRF_ERROR_BUSY,
N *          @ref NRF_ERROR_FORBIDDEN, @ref BLE_ERROR_GATTS_SYS_ATTR_MISSING and @ref BLE_ERROR_NO_TX_PACKETS.
N *          The caller can check whether the value has been updated by looking at the contents of *(p_hvx_params->p_len).
N *
N * @note    It is important to note that a notification will <b>consume an application buffer</b>, and will therefore
N *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. An indication on the other hand will use the
N *          standard server internal buffer and thus will only generate a @ref BLE_GATTS_EVT_HVC event as soon as the confirmation
N *          has been received from the peer. Please see the documentation of @ref sd_ble_tx_packet_count_get for more details.
N *
N * @events
N * @event{@ref BLE_EVT_TX_COMPLETE, Transmission complete.}
N * @event{@ref BLE_GATTS_EVT_HVC, Confirmation received from peer.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_HVX_SYS_ATTRS_MISSING_MSC}
N * @mmsc{@ref BLE_GATTS_HVN_MSC}
N * @mmsc{@ref BLE_GATTS_HVI_MSC}
N * @mmsc{@ref BLE_GATTS_HVX_DISABLED_MSC}
N * @mmsc{@ref BLE_COMMON_APP_BUFF_MSC}
N * @endmscs
N *
N * @param[in] conn_handle  Connection handle.
N * @param[in] p_hvx_params Pointer to an HVx parameters structure. If the p_data member contains a non-NULL pointer the attribute value will be updated with
N *                         the contents pointed by it before sending the notification or indication.
N *
N * @retval ::NRF_SUCCESS Successfully queued a notification or indication for transmission, and optionally updated the attribute value.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE One or more of the following is true:
N *                                   - Invalid Connection State
N *                                   - Notifications and/or indications not enabled in the CCCD
N *                                   - An ATT_MTU exchange is ongoing
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied. Only attributes added directly by the application are available to notify and indicate.
N * @retval ::BLE_ERROR_GATTS_INVALID_ATTR_TYPE Invalid attribute type(s) supplied, only characteristic values may be notified and indicated.
N * @retval ::NRF_ERROR_NOT_FOUND Attribute not found.
N * @retval ::NRF_ERROR_FORBIDDEN The connection's current security level is lower than the one required by the write permissions of the CCCD associated with this characteristic.
N * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N * @retval ::NRF_ERROR_BUSY Procedure already in progress.
N * @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.
N * @retval ::BLE_ERROR_NO_TX_PACKETS  No available application packets for this connection, applies only to notifications.
N */
NSVCALL(SD_BLE_GATTS_HVX, uint32_t, sd_ble_gatts_hvx(uint16_t conn_handle, ble_gatts_hvx_params_t const *p_hvx_params));
Xuint32_t __svc(SD_BLE_GATTS_HVX) sd_ble_gatts_hvx(uint16_t conn_handle, ble_gatts_hvx_params_t const *p_hvx_params);
N
N/**@brief Indicate the Service Changed attribute value.
N *
N * @details This call will send a Handle Value Indication to one or more peers connected to inform them that the Attribute
N *          Table layout has changed. As soon as the peer has confirmed the indication, a @ref BLE_GATTS_EVT_SC_CONFIRM event will
N *          be issued.
N *
N * @note    Some of the restrictions and limitations that apply to @ref sd_ble_gatts_hvx also apply here.
N *
N * @events
N * @event{@ref BLE_GATTS_EVT_SC_CONFIRM, Confirmation of attribute table change received from peer.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_SC_MSC}
N * @endmscs
N *
N * @param[in] conn_handle  Connection handle.
N * @param[in] start_handle Start of affected attribute handle range.
N * @param[in] end_handle   End of affected attribute handle range.
N *
N * @retval ::NRF_SUCCESS Successfully queued the Service Changed indication for transmission.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_NOT_SUPPORTED Service Changed not enabled at initialization. See @ref sd_ble_enable and @ref ble_gatts_enable_params_t.
N * @retval ::NRF_ERROR_INVALID_STATE One or more of the following is true:
N *                                   - Invalid Connection State
N *                                   - Notifications and/or indications not enabled in the CCCD
N *                                   - An ATT_MTU exchange is ongoing
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied, handles must be in the range populated by the application.
N * @retval ::NRF_ERROR_BUSY Procedure already in progress.
N * @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.
N */
NSVCALL(SD_BLE_GATTS_SERVICE_CHANGED, uint32_t, sd_ble_gatts_service_changed(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle));
Xuint32_t __svc(SD_BLE_GATTS_SERVICE_CHANGED) sd_ble_gatts_service_changed(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle);
N
N/**@brief Respond to a Read/Write authorization request.
N *
N * @note This call should only be used as a response to a @ref BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST event issued to the application.
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_AUTH_MSC}
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_AUTH_MSC}
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}
N * @mmsc{@ref BLE_GATTS_READ_REQ_AUTH_MSC}
N * @mmsc{@ref BLE_GATTS_WRITE_REQ_AUTH_MSC}
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_PEER_CANCEL_MSC}
N * @endmscs
N *
N * @param[in] conn_handle                 Connection handle.
N * @param[in] p_rw_authorize_reply_params Pointer to a structure with the attribute provided by the application.
N *
N * @note @ref ble_gatts_authorize_params_t::p_data is ignored when this function is used to respond
N *       to a @ref BLE_GATTS_AUTHORIZE_TYPE_READ event if @ref ble_gatts_authorize_params_t::update
N *       is set to 0.
N *
N * @retval ::NRF_SUCCESS               Successfully queued a response to the peer, and in the case of a write operation, Attribute Table updated.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_ADDR    Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_STATE   Invalid Connection State or no authorization request pending.
N * @retval ::NRF_ERROR_INVALID_PARAM   Authorization op invalid,
N *                                         handle supplied does not match requested handle,
N *                                         or invalid data to be written provided by the application.
N * @retval ::NRF_ERROR_BUSY The stack is busy. Retry at later time.
N */
NSVCALL(SD_BLE_GATTS_RW_AUTHORIZE_REPLY, uint32_t, sd_ble_gatts_rw_authorize_reply(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const *p_rw_authorize_reply_params));
Xuint32_t __svc(SD_BLE_GATTS_RW_AUTHORIZE_REPLY) sd_ble_gatts_rw_authorize_reply(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const *p_rw_authorize_reply_params);
N
N
N/**@brief Update persistent system attribute information.
N *
N * @details Supply information about persistent system attributes to the stack,
N *          previously obtained using @ref sd_ble_gatts_sys_attr_get.
N *          This call is only allowed for active connections, and is usually
N *          made immediately after a connection is established with an known bonded device,
N *          often as a response to a @ref BLE_GATTS_EVT_SYS_ATTR_MISSING.
N *
N *          p_sysattrs may point directly to the application's stored copy of the system attributes
N *          obtained using @ref sd_ble_gatts_sys_attr_get.
N *          If the pointer is NULL, the system attribute info is initialized, assuming that
N *          the application does not have any previously saved system attribute data for this device.
N *
N * @note The state of persistent system attributes is reset upon connection establishment and then remembered for its duration.
N *
N * @note If this call returns with an error code different from @ref NRF_SUCCESS, the storage of persistent system attributes may have been completed only partially.
N *       This means that the state of the attribute table is undefined, and the application should either provide a new set of attributes using this same call or
N *       reset the SoftDevice to return to a known state.
N *
N * @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS is used with this function, only the system attributes included in system services will be modified.
N * @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS is used with this function, only the system attributes included in user services will be modified.
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_HVX_SYS_ATTRS_MISSING_MSC}
N * @mmsc{@ref BLE_GATTS_SYS_ATTRS_UNK_PEER_MSC}
N * @mmsc{@ref BLE_GATTS_SYS_ATTRS_BONDED_PEER_MSC}
N * @endmscs
N *
N * @param[in]  conn_handle        Connection handle.
N * @param[in]  p_sys_attr_data    Pointer to a saved copy of system attributes supplied to the stack, or NULL.
N * @param[in]  len                Size of data pointed by p_sys_attr_data, in octets.
N * @param[in]  flags              Optional additional flags, see @ref BLE_GATTS_SYS_ATTR_FLAGS
N *
N * @retval ::NRF_SUCCESS Successfully set the system attribute information.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid flags supplied.
N * @retval ::NRF_ERROR_INVALID_DATA Invalid data supplied, the data should be exactly the same as retrieved with @ref sd_ble_gatts_sys_attr_get.
N * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @retval ::NRF_ERROR_BUSY The stack is busy. Retry at later time.
N */
NSVCALL(SD_BLE_GATTS_SYS_ATTR_SET, uint32_t, sd_ble_gatts_sys_attr_set(uint16_t conn_handle, uint8_t const *p_sys_attr_data, uint16_t len, uint32_t flags));
Xuint32_t __svc(SD_BLE_GATTS_SYS_ATTR_SET) sd_ble_gatts_sys_attr_set(uint16_t conn_handle, uint8_t const *p_sys_attr_data, uint16_t len, uint32_t flags);
N
N
N/**@brief Retrieve persistent system attribute information from the stack.
N *
N * @details This call is used to retrieve information about values to be stored perisistently by the application
N *          during the lifetime of a connection or after it has been terminated. When a new connection is established with the same bonded device,
N *          the system attribute information retrieved with this function should be restored using using @ref sd_ble_gatts_sys_attr_set.
N *          If retrieved after disconnection, the data should be read before a new connection established. The connection handle for
N *          the previous, now disconnected, connection will remain valid until a new one is created to allow this API call to refer to it.
N *          Connection handles belonging to active connections can be used as well, but care should be taken since the system attributes
N *          may be written to at any time by the peer during a connection's lifetime.
N *
N * @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS is used with this function, only the system attributes included in system services will be returned.
N * @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS is used with this function, only the system attributes included in user services will be returned.
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_SYS_ATTRS_BONDED_PEER_MSC}
N * @endmscs
N *
N * @param[in]     conn_handle       Connection handle of the recently terminated connection.
N * @param[out]    p_sys_attr_data   Pointer to a buffer where updated information about system attributes will be filled in. The format of the data is described
N *                                  in @ref BLE_GATTS_SYS_ATTRS_FORMAT. NULL can be provided to obtain the length of the data.
N * @param[in,out] p_len             Size of application buffer if p_sys_attr_data is not NULL. Unconditially updated to actual length of system attribute data.
N * @param[in]     flags             Optional additional flags, see @ref BLE_GATTS_SYS_ATTR_FLAGS
N *
N * @retval ::NRF_SUCCESS Successfully retrieved the system attribute information.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid flags supplied.
N * @retval ::NRF_ERROR_DATA_SIZE The system attribute information did not fit into the provided buffer.
N * @retval ::NRF_ERROR_NOT_FOUND No system attributes found.
N */
NSVCALL(SD_BLE_GATTS_SYS_ATTR_GET, uint32_t, sd_ble_gatts_sys_attr_get(uint16_t conn_handle, uint8_t *p_sys_attr_data, uint16_t *p_len, uint32_t flags));
Xuint32_t __svc(SD_BLE_GATTS_SYS_ATTR_GET) sd_ble_gatts_sys_attr_get(uint16_t conn_handle, uint8_t *p_sys_attr_data, uint16_t *p_len, uint32_t flags);
N
N
N/**@brief Retrieve the first valid user attribute handle.
N *
N * @param[out] p_handle   Pointer to an integer where the handle will be stored.
N *
N * @retval ::NRF_SUCCESS Successfully retrieved the handle.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_GATTS_INITIAL_USER_HANDLE_GET, uint32_t, sd_ble_gatts_initial_user_handle_get(uint16_t *p_handle));
Xuint32_t __svc(SD_BLE_GATTS_INITIAL_USER_HANDLE_GET) sd_ble_gatts_initial_user_handle_get(uint16_t *p_handle);
N
N/**@brief Retrieve the attribute UUID and/or metadata.
N *
N * @param[in]  handle Attribute handle
N * @param[out] p_uuid UUID of the attribute. Use NULL to omit this field.
N * @param[out] p_md Metadata of the attribute. Use NULL to omit this field.
N *
N * @retval ::NRF_SUCCESS Successfully retrieved the attribute metadata,
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameters supplied. Returned when both @c p_uuid and @c p_md are NULL.
N * @retval ::NRF_ERROR_NOT_FOUND Attribute was not found.
N */
NSVCALL(SD_BLE_GATTS_ATTR_GET, uint32_t, sd_ble_gatts_attr_get(uint16_t handle, ble_uuid_t * p_uuid, ble_gatts_attr_md_t * p_md));
Xuint32_t __svc(SD_BLE_GATTS_ATTR_GET) sd_ble_gatts_attr_get(uint16_t handle, ble_uuid_t * p_uuid, ble_gatts_attr_md_t * p_md);
N
N/**@brief Reply to an ATT_MTU exchange request by sending an Exchange MTU Response to the client.
N *
N * @details This function is only used to reply to a @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST event.
N *
N * @details The SoftDevice sets ATT_MTU to the minimum of:
N *          - The Client RX MTU value from @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST, and
N *          - The Server RX MTU value.
N *
N *          However, the SoftDevice never sets ATT_MTU lower than @ref GATT_MTU_SIZE_DEFAULT.
N *
N * @events
N * @event{@ref BLE_EVT_DATA_LENGTH_CHANGED, Generated if a data length update procedure is performed after the ATT_MTU exchange.}
N * @endevents
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_MTU_EXCHANGE}
N * @endmscs
N *
N * @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.
N * @param[in] server_rx_mtu  Server RX MTU size.
N *                           - The minimum value is @ref GATT_MTU_SIZE_DEFAULT.
N *                           - The maximum value is @ref ble_gatt_enable_params_t::att_mtu.
N *                           - The value must be equal to Client RX MTU size given in @ref sd_ble_gattc_exchange_mtu_request
N *                             if an ATT_MTU exchange has already been performed in the other direction.
N *
N * @retval ::NRF_SUCCESS Successfully sent response to the client.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no ATT_MTU exchange request pending.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid Server RX MTU size supplied.
N * @retval ::NRF_ERROR_BUSY The stack is busy. Retry at later time.
N */
NSVCALL(SD_BLE_GATTS_EXCHANGE_MTU_REPLY, uint32_t, sd_ble_gatts_exchange_mtu_reply(uint16_t conn_handle, uint16_t server_rx_mtu));
Xuint32_t __svc(SD_BLE_GATTS_EXCHANGE_MTU_REPLY) sd_ble_gatts_exchange_mtu_reply(uint16_t conn_handle, uint16_t server_rx_mtu);
N/** @} */
N
N#ifdef __cplusplus
S}
N#endif
N#endif // BLE_GATTS_H__
N
N/**
N  @}
N*/
L 57 "..\..\..\..\..\..\components\softdevice\s132\headers\ble.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup BLE_COMMON_ENUMERATIONS Enumerations
N * @{ */
N
N/**
N * @brief Common API SVC numbers.
N */
Nenum BLE_COMMON_SVCS
N{
N  SD_BLE_ENABLE = BLE_SVC_BASE,         /**< Enable and initialize the BLE stack */
X  SD_BLE_ENABLE = 0x60,          
N  SD_BLE_EVT_GET,                       /**< Get an event from the pending events queue. */
N  SD_BLE_TX_PACKET_COUNT_GET,           /**< Get the total number of available application transmission packets for a particular connection. */
N  SD_BLE_UUID_VS_ADD,                   /**< Add a Vendor Specific UUID. */
N  SD_BLE_UUID_DECODE,                   /**< Decode UUID bytes. */
N  SD_BLE_UUID_ENCODE,                   /**< Encode UUID bytes. */
N  SD_BLE_VERSION_GET,                   /**< Get the local version information (company id, Link Layer Version, Link Layer Subversion). */
N  SD_BLE_USER_MEM_REPLY,                /**< User Memory Reply. */
N  SD_BLE_OPT_SET,                       /**< Set a BLE option. */
N  SD_BLE_OPT_GET,                       /**< Get a BLE option. */
N};
N
N  /**
N   * @brief BLE Module Independent Event IDs.
N   */
Nenum BLE_COMMON_EVTS
N{
N  BLE_EVT_TX_COMPLETE  = BLE_EVT_BASE,  /**< Transmission Complete. @ref ble_evt_tx_complete_t */
X  BLE_EVT_TX_COMPLETE  = 0x01,   
N  BLE_EVT_USER_MEM_REQUEST,             /**< User Memory request. @ref ble_evt_user_mem_request_t */
N  BLE_EVT_USER_MEM_RELEASE,             /**< User Memory release. @ref ble_evt_user_mem_release_t */
N  BLE_EVT_DATA_LENGTH_CHANGED           /**< Link layer PDU length changed. @ref ble_evt_data_length_changed_t. */
N};
N
N/**@brief BLE connection bandwidth types.
N * Bandwidth types supported by the SoftDevice. The bandwidth type dictates the maximum number of full length packets per connection interval.
N */
Nenum BLE_CONN_BWS
N{
N  BLE_CONN_BW_INVALID = 0,              /**< Invalid connection bandwidth. */
N  BLE_CONN_BW_LOW,                      /**< Low connection bandwidth. */
N  BLE_CONN_BW_MID,                      /**< Medium connection bandwidth. */
N  BLE_CONN_BW_HIGH                      /**< High connection bandwidth. */
N};
N
N/**@brief Common Option IDs.
N * IDs that uniquely identify a common option.
N */
Nenum BLE_COMMON_OPTS
N{
N  BLE_COMMON_OPT_CONN_BW = BLE_OPT_BASE,     /**< Bandwidth configuration @ref ble_common_opt_conn_bw_t */
X  BLE_COMMON_OPT_CONN_BW = 0x01,      
N  BLE_COMMON_OPT_PA_LNA,                     /**< PA and LNA options */
N  BLE_COMMON_OPT_CONN_EVT_EXT,               /**< Extended connection events option */
N};
N
N/** @} */
N
N/** @addtogroup BLE_COMMON_DEFINES Defines
N * @{ */
N
N/** @brief  Required pointer alignment for BLE Events.
N*/
N#define BLE_EVTS_PTR_ALIGNMENT    4
N
N/** @brief  Maximum possible length for BLE Events.
N * @note Value of @ref ble_gatt_enable_params_t::att_mtu shall be used as a parameter.
N * If that value is set to 0 then @ref GATT_MTU_SIZE_DEFAULT must be used instead.
N*/
N#define BLE_EVTS_LEN_MAX(ATT_MTU) (MAX( \
N  sizeof(ble_evt_t), \
N  MAX( \
N    offsetof(ble_evt_t, evt.gattc_evt.params.rel_disc_rsp.includes) + ((ATT_MTU) - 2) / 6 * sizeof(ble_gattc_include_t), \
N    offsetof(ble_evt_t, evt.gattc_evt.params.attr_info_disc_rsp.info.attr_info16) + ((ATT_MTU) - 2) / 4 * sizeof(ble_gattc_attr_info16_t) \
N  ) \
N))
X#define BLE_EVTS_LEN_MAX(ATT_MTU) (MAX(   sizeof(ble_evt_t),   MAX(     offsetof(ble_evt_t, evt.gattc_evt.params.rel_disc_rsp.includes) + ((ATT_MTU) - 2) / 6 * sizeof(ble_gattc_include_t),     offsetof(ble_evt_t, evt.gattc_evt.params.attr_info_disc_rsp.info.attr_info16) + ((ATT_MTU) - 2) / 4 * sizeof(ble_gattc_attr_info16_t)   ) ))
N
N/** @defgroup BLE_USER_MEM_TYPES User Memory Types
N * @{ */
N#define BLE_USER_MEM_TYPE_INVALID               0x00  /**< Invalid User Memory Types. */
N#define BLE_USER_MEM_TYPE_GATTS_QUEUED_WRITES   0x01  /**< User Memory for GATTS queued writes. */
N/** @} */
N
N/** @defgroup BLE_UUID_VS_COUNTS Vendor Specific UUID counts
N * @{
N */
N#define BLE_UUID_VS_COUNT_MIN         1    /**< Minimum VS UUID count. */
N#define BLE_UUID_VS_COUNT_DEFAULT     0    /**< Use the default VS UUID count (10 for this version of the SoftDevice). */
N/** @} */
N
N/** @} */
N
N/** @addtogroup BLE_COMMON_STRUCTURES Structures
N * @{ */
N
N/**@brief User Memory Block. */
Ntypedef struct
N{
N  uint8_t          *p_mem;      /**< Pointer to the start of the user memory block. */
N  uint16_t          len;        /**< Length in bytes of the user memory block. */
N} ble_user_mem_block_t;
N
N/**
N * @brief Event structure for @ref BLE_EVT_TX_COMPLETE.
N */
Ntypedef struct
N{
N  uint8_t count;                        /**< Number of packets transmitted. */
N} ble_evt_tx_complete_t;
N
N/**@brief Event structure for @ref BLE_EVT_USER_MEM_REQUEST. */
Ntypedef struct
N{
N  uint8_t                     type;     /**< User memory type, see @ref BLE_USER_MEM_TYPES. */
N} ble_evt_user_mem_request_t;
N
N/**@brief Event structure for @ref BLE_EVT_USER_MEM_RELEASE. */
Ntypedef struct
N{
N  uint8_t                     type;       /**< User memory type, see @ref BLE_USER_MEM_TYPES. */
N  ble_user_mem_block_t        mem_block;  /**< User memory block */
N} ble_evt_user_mem_release_t;
N
N/**@brief Event structure for @ref BLE_EVT_DATA_LENGTH_CHANGED. */
Ntypedef struct
N{
N  uint16_t max_tx_octets;                 /**< The maximum number of payload octets in a Link Layer Data Channel PDU that the local Controller will send. Range: 27-251 */
N  uint16_t max_tx_time;                   /**< The maximum time (in microseconds) that the local Controller will take to send a Link Layer Data Channel PDU. Range: 328-2120  */
N  uint16_t max_rx_octets;                 /**< The maximum number of payload octets in a Link Layer Data Channel PDU that the local controller expects to receive. Range: 27-251 */
N  uint16_t max_rx_time;                   /**< The maximum time (in microseconds) that the local Controller expects to take to receive a Link Layer Data Channel PDU. Range: 328-2120 */
N} ble_evt_data_length_changed_t;
N
N/**@brief Event structure for events not associated with a specific function module. */
Ntypedef struct
N{
N  uint16_t conn_handle;                                 /**< Connection Handle on which this event occurred. */
N  union
N  {
N    ble_evt_tx_complete_t           tx_complete;         /**< Transmission Complete. */
N    ble_evt_user_mem_request_t      user_mem_request;    /**< User Memory Request Event Parameters. */
N    ble_evt_user_mem_release_t      user_mem_release;    /**< User Memory Release Event Parameters. */
N    ble_evt_data_length_changed_t   data_length_changed; /**< Data Length Changed Event Parameters. */
N  } params;                                              /**< Event parameter union. */
N} ble_common_evt_t;
N
N/**@brief BLE Event header. */
Ntypedef struct
N{
N  uint16_t evt_id;                /**< Value from a BLE_<module>_EVT series. */
N  uint16_t evt_len;               /**< Length in octets including this header. */
N} ble_evt_hdr_t;
N
N/**@brief Common BLE Event type, wrapping the module specific event reports. */
Ntypedef struct
N{
N  ble_evt_hdr_t header;           /**< Event header. */
N  union
N  {
N    ble_common_evt_t  common_evt; /**< Common Event, evt_id in BLE_EVT_* series. */
N    ble_gap_evt_t     gap_evt;    /**< GAP originated event, evt_id in BLE_GAP_EVT_* series. */
N    ble_l2cap_evt_t   l2cap_evt;  /**< L2CAP originated event, evt_id in BLE_L2CAP_EVT* series. */
N    ble_gattc_evt_t   gattc_evt;  /**< GATT client originated event, evt_id in BLE_GATTC_EVT* series. */
N    ble_gatts_evt_t   gatts_evt;  /**< GATT server originated event, evt_id in BLE_GATTS_EVT* series. */
N  } evt;                          /**< Event union. */
N} ble_evt_t;
N
N
N/**
N * @brief Version Information.
N */
Ntypedef struct
N{
N  uint8_t   version_number;    /**< Link Layer Version number for BT 4.1 spec is 7 (https://www.bluetooth.org/en-us/specification/assigned-numbers/link-layer). */
N  uint16_t  company_id;        /**< Company ID, Nordic Semiconductor's company ID is 89 (0x0059) (https://www.bluetooth.org/apps/content/Default.aspx?doc_id=49708). */
N  uint16_t  subversion_number; /**< Link Layer Sub Version number, corresponds to the SoftDevice Config ID or Firmware ID (FWID). */
N} ble_version_t;
N
N/**
N * @brief Configuration parameters for the PA and LNA.
N */
Ntypedef struct
N{
N     uint8_t enable :1;      /**< Enable toggling for this amplifier */
N     uint8_t active_high :1; /**< Set the pin to be active high */
N     uint8_t gpio_pin :6;    /**< The GPIO pin to toggle for this amplifier */
N} ble_pa_lna_cfg_t;
N
N/**
N * @brief PA & LNA GPIO toggle configuration
N *
N * This option configures the SoftDevice to toggle pins when the radio is active for use with a power amplifier and/or
N * a low noise amplifier.
N *
N * Toggling the pins is achieved by using two PPI channels and a GPIOTE channel. The hardware channel IDs are provided
N * by the application and should be regarded as reserved as long as any PA/LNA toggling is enabled.
N *
N * @note  @ref sd_ble_opt_get is not supported for this option.
N * @note  This feature is only supported for nRF52, on nRF51 @ref NRF_ERROR_NOT_SUPPORTED will always be returned.
N * @note  Setting this option while the radio is in use (i.e. any of the roles are active) may have undefined consequences
N * and must be avoided by the application.
N */
Ntypedef struct
N{
N   ble_pa_lna_cfg_t pa_cfg;   /**< Power Amplifier configuration */
N   ble_pa_lna_cfg_t lna_cfg;  /**< Low Noise Amplifier configuration */
N
N   uint8_t ppi_ch_id_set;     /**< PPI channel used for radio pin setting */
N   uint8_t ppi_ch_id_clr;     /**< PPI channel used for radio pin clearing */
N   uint8_t gpiote_ch_id;      /**< GPIOTE channel used for radio pin toggling */
N} ble_common_opt_pa_lna_t;
N
N/**
N * @brief BLE connection bandwidth configuration parameters
N */
Ntypedef struct
N{
N  uint8_t conn_bw_tx;   /**< Connection bandwidth configuration for transmission, see @ref BLE_CONN_BWS.*/
N  uint8_t conn_bw_rx;   /**< Connection bandwidth configuration for reception, see @ref BLE_CONN_BWS.*/
N} ble_conn_bw_t;
N
N/**@brief BLE connection specific bandwidth configuration parameters.
N *
N * This can be used with @ref sd_ble_opt_set to set the bandwidth configuration to be used when creating connections.
N *
N * Call @ref sd_ble_opt_set with this option prior to calling @ref sd_ble_gap_adv_start or @ref sd_ble_gap_connect.
N *
N * The bandwidth configurations set via @ref sd_ble_opt_set are maintained separately for central and peripheral
N * connections. The given configurations are used for all future connections of the role indicated in this structure
N * unless they are changed by subsequent @ref sd_ble_opt_set calls.
N *
N * @note When this option is not used, the SoftDevice will use the default options:
N * - @ref BLE_CONN_BW_HIGH for @ref BLE_GAP_ROLE_PERIPH connections (both transmission and reception).
N * - @ref BLE_CONN_BW_MID for @ref BLE_GAP_ROLE_CENTRAL connections (both transmisison and reception).
N * This option allows the application to selectively override these defaults for each role.
N *
N * @note The global memory pool configuration can be set with the @ref ble_conn_bw_counts_t configuration parameter, which
N * is provided to @ref sd_ble_enable.
N *
N * @note @ref sd_ble_opt_get is not supported for this option.
N * @note Please refer to SoftDevice Specification for more information on bandwidth configuration.
N *
N * @mscs
N * @mmsc{@ref BLE_COMMON_CONF_BW}
N * @endmscs
N *
N * @retval ::NRF_SUCCESS Set successfully.
N * @retval ::BLE_ERROR_INVALID_ROLE The role is invalid.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid bandwidth configuration parameters.
N * @retval ::NRF_ERROR_NOT_SUPPORTED If the combination of role and bandwidth configuration is not supported.
N */
Ntypedef struct
N{
N  uint8_t            role;     /**< BLE role of the connection, see @ref BLE_GAP_ROLES. */
N  ble_conn_bw_t      conn_bw;  /**< Bandwidth configuration parameters. */
N} ble_common_opt_conn_bw_t;
N
N/**
N * @brief Configuration of extended BLE connection events.
N *
N * When enabled the SoftDevice will dynamically extend the connection event when possible.
N *
N * The connection event length is controlled by the bandwidth configuration as set by @ref ble_common_opt_conn_bw_t.
N * The connection event can be extended if there is time to send another packet pair before the start of the next connection interval,
N * and if there are no conflicts with other BLE roles requesting radio time.
N *
N * @note @ref sd_ble_opt_get is not supported for this option.
N */
Ntypedef struct
N{
N   uint8_t enable : 1; /**< Enable extended BLE connection events, disabled by default. */
N} ble_common_opt_conn_evt_ext_t;
N
N/**@brief Option structure for common options. */
Ntypedef union
N{
N  ble_common_opt_conn_bw_t      conn_bw;       /**< Parameters for the connection bandwidth option. */
N  ble_common_opt_pa_lna_t       pa_lna;        /**< Parameters for controlling PA and LNA pin toggling. */
N  ble_common_opt_conn_evt_ext_t conn_evt_ext;  /**< Parameters for enabling extended connection events. */
N} ble_common_opt_t;
N
N/**@brief Common BLE Option type, wrapping the module specific options. */
Ntypedef union
N{
N  ble_common_opt_t  common_opt;         /**< COMMON options, opt_id in @ref BLE_COMMON_OPTS series. */
N  ble_gap_opt_t     gap_opt;            /**< GAP option, opt_id in @ref BLE_GAP_OPTS series. */
N} ble_opt_t;
N
N/**
N * @brief BLE bandwidth count parameters
N *
N * These parameters are used to configure the memory pools allocated within the SoftDevice for application packets
N * (both transmission and reception) for all connections.
N *
N * @note The sum of all three counts must add up to the sum of @ref ble_gap_enable_params_t::central_conn_count and
N * @ref ble_gap_enable_params_t::periph_conn_count in @ref ble_gap_enable_params_t.
N */
Ntypedef struct {
N  uint8_t high_count;   /**< Total number of high bandwidth TX or RX memory pools available to the application at runtime for all active connections. */
N  uint8_t mid_count;    /**< Total number of medium bandwidth TX or RX memory pools available to the application at runtime for all active connections. */
N  uint8_t low_count;    /**< Total number of low bandwidth TX or RX memory pools available to the application at runtime for all active connections. */
N} ble_conn_bw_count_t;
N
N/**
N * @brief BLE bandwidth global memory pool configuration parameters
N *
N * These configuration parameters are used to set the amount of memory dedicated to application packets for
N * all connections. The application should specify the most demanding configuration for the intended use.
N *
N * Please refer to the SoftDevice Specification for more information on bandwidth configuration.
N *
N * @note Each connection created at runtime requires both a TX and an RX memory pool. By the use of these configuration
N * parameters, the application can decide the size and total number of the global memory pools that will be later
N * available for connection creation.
N *
N * @mscs
N * @mmsc{@ref BLE_COMMON_CONF_BW}
N * @endmscs
N *
N */
Ntypedef struct {
N  ble_conn_bw_count_t tx_counts;   /**< Global memory pool configuration for transmission.*/
N  ble_conn_bw_count_t rx_counts;   /**< Global memory pool configuration for reception.*/
N} ble_conn_bw_counts_t;
N
N/**
N * @brief BLE Common Initialization parameters.
N *
N * @note If @ref p_conn_bw_counts is NULL the SoftDevice will assume default bandwidth configuration for all connections.
N * To fit a custom bandwidth configuration requirement, the application developer may have to specify a custom memory
N * pool configuration here. See @ref ble_common_opt_conn_bw_t for bandwidth configuration of individual connections.
N * Please refer to the SoftDevice Specification for more information on bandwidth configuration.
N */
Ntypedef struct
N{
N  uint16_t                  vs_uuid_count;     /**< Maximum number of 128-bit, Vendor Specific UUID bases to allocate. */
N  ble_conn_bw_counts_t      *p_conn_bw_counts; /**< Bandwidth configuration parameters or NULL for defaults. */
N} ble_common_enable_params_t;
N
N/**
N * @brief BLE Initialization parameters.
N */
Ntypedef struct
N{
N  ble_common_enable_params_t        common_enable_params;  /**< Common init parameters @ref ble_common_enable_params_t. */
N  ble_gap_enable_params_t           gap_enable_params;     /**< GAP init parameters @ref ble_gap_enable_params_t. */
N  ble_gatt_enable_params_t          gatt_enable_params;    /**< GATT init parameters @ref ble_gatt_enable_params_t. */
N  ble_gatts_enable_params_t         gatts_enable_params;   /**< GATTS init parameters @ref ble_gatts_enable_params_t. */
N} ble_enable_params_t;
N
N/** @} */
N
N/** @addtogroup BLE_COMMON_FUNCTIONS Functions
N * @{ */
N
N/**@brief Enable the BLE stack
N *
N * @param[in, out] p_ble_enable_params Pointer to ble_enable_params_t
N * @param[in, out] p_app_ram_base      Pointer to a variable containing the start address of the application RAM region
N * (APP_RAM_BASE). On return, this will contain the minimum start address of the application RAM region required by the
N * SoftDevice for this configuration. Calling @ref sd_ble_enable() with *p_app_ram_base set to 0 can be used during
N * development to find out how much memory a specific configuration will need.
N *
N * @note The memory requirement for a specific configuration will not increase between SoftDevices with the same major
N * version number.
N *
N * @note At runtime the IC's RAM is split into 2 regions: The SoftDevice RAM region is located between 0x20000000 and
N *       APP_RAM_BASE-1 and the application's RAM region is located between APP_RAM_BASE and the start of the call stack.
N *
N * @details This call initializes the BLE stack, no other BLE related function can be called before this one.
N *
N * @mscs
N * @mmsc{@ref BLE_COMMON_ENABLE}
N * @endmscs
N *
N * @retval ::NRF_SUCCESS              The BLE stack has been initialized successfully.
N * @retval ::NRF_ERROR_INVALID_STATE  The BLE stack had already been initialized and cannot be reinitialized.
N * @retval ::NRF_ERROR_INVALID_ADDR   Invalid or not sufficiently aligned pointer supplied.
N * @retval ::NRF_ERROR_INVALID_LENGTH One or more of the following is true:
N *                                    - The specified Attribute Table size is too small.
N *                                      The minimum acceptable size is defined by @ref BLE_GATTS_ATTR_TAB_SIZE_MIN.
N *                                    - The specified Attribute Table size is not a multiple of 4.
N *                                    - The device name length is invalid (must be between 0 and @ref BLE_GAP_DEVNAME_MAX_LEN).
N *                                    - The device name length is too long for the given Attribute Table.
N * @retval ::NRF_ERROR_INVALID_PARAM  One or more of the following is true:
N *                                    - Incorrectly configured VS UUID count.
N *                                    - Invalid connection count parameters.
N *                                    - Invalid device name location (vloc).
N *                                    - Invalid device name security mode.
N *                                    - Invalid maximum ATT_MTU size, see @ref ble_gatt_enable_params_t::att_mtu.
N * @retval ::NRF_ERROR_NOT_SUPPORTED  Device name security mode is not supported.
N * @retval ::NRF_ERROR_NO_MEM         The amount of memory assigned to the SoftDevice by *p_app_ram_base is not
N *                                    large enough to fit this configuration's memory requirement. Check *p_app_ram_base
N *                                    and set the start address of the application RAM region accordingly.
N * @retval ::NRF_ERROR_CONN_COUNT     The requested number of connections exceeds the maximum supported by the SoftDevice.
N *                                    Please refer to the SoftDevice Specification for more information on role configuration.
N */
NSVCALL(SD_BLE_ENABLE, uint32_t, sd_ble_enable(ble_enable_params_t * p_ble_enable_params, uint32_t * p_app_ram_base));
Xuint32_t __svc(SD_BLE_ENABLE) sd_ble_enable(ble_enable_params_t * p_ble_enable_params, uint32_t * p_app_ram_base);
N
N/**@brief Get an event from the pending events queue.
N *
N * @param[out] p_dest Pointer to buffer to be filled in with an event, or NULL to retrieve the event length.
N *                    This buffer <b>must be aligned to the extend defined by @ref BLE_EVTS_PTR_ALIGNMENT</b>.
N * @param[in, out] p_len Pointer the length of the buffer, on return it is filled with the event length.
N *
N * @details This call allows the application to pull a BLE event from the BLE stack. The application is signaled that
N * an event is available from the BLE stack by the triggering of the SD_EVT_IRQn interrupt.
N * The application is free to choose whether to call this function from thread mode (main context) or directly from the
N * Interrupt Service Routine that maps to SD_EVT_IRQn. In any case however, and because the BLE stack runs at a higher
N * priority than the application, this function should be called in a loop (until @ref NRF_ERROR_NOT_FOUND is returned)
N * every time SD_EVT_IRQn is raised to ensure that all available events are pulled from the BLE stack. Failure to do so
N * could potentially leave events in the internal queue without the application being aware of this fact. Sizing the
N * p_dest buffer is equally important, since the application needs to provide all the memory necessary for the event to
N * be copied into application memory. If the buffer provided is not large enough to fit the entire contents of the event,
N * @ref NRF_ERROR_DATA_SIZE will be returned and the application can then call again with a larger buffer size.
N * The maximum possible event length is defined by @ref BLE_EVTS_LEN_MAX. The application may also "peek" the event length
N * by providing p_dest as a NULL pointer and inspecting the value of *p_len upon return:
N *
N *     \code
N *     uint16_t len;
N *     errcode = sd_ble_evt_get(NULL, &len);
N *     \endcode
N *
N * @mscs
N * @mmsc{@ref BLE_COMMON_IRQ_EVT_MSC}
N * @mmsc{@ref BLE_COMMON_THREAD_EVT_MSC}
N * @endmscs
N *
N * @retval ::NRF_SUCCESS Event pulled and stored into the supplied buffer.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid or not sufficiently aligned pointer supplied.
N * @retval ::NRF_ERROR_NOT_FOUND No events ready to be pulled.
N * @retval ::NRF_ERROR_DATA_SIZE Event ready but could not fit into the supplied buffer.
N */
NSVCALL(SD_BLE_EVT_GET, uint32_t, sd_ble_evt_get(uint8_t *p_dest, uint16_t *p_len));
Xuint32_t __svc(SD_BLE_EVT_GET) sd_ble_evt_get(uint8_t *p_dest, uint16_t *p_len);
N
N
N/**@brief Get the total number of available guaranteed application transmission packets for a particular connection.
N *
N * @details This call allows the application to obtain the total number of guaranteed application transmission packets
N * available for a connection. Please note that this does not return the number of free packets, but rather the total
N * amount of them for that particular connection. The application has two options to handle transmitting application packets:
N * - Use a simple arithmetic calculation: after connection creation time the application should use this function to
N * find out the total amount of guaranteed packets available to it and store it in a variable.
N * Every time a packet is successfully queued for a transmission on this connection using any of the exposed functions in
N * this  BLE API, the application should decrement that variable. Conversely, whenever a @ref BLE_EVT_TX_COMPLETE event
N * with the conn_handle matching the particular connection is received by the application, it should retrieve the count
N * field in such event and add that number to the same variable storing the number of available guaranteed packets. This
N * mechanism allows the application to be aware at any time of the number of guaranteed application packets available for
N * each of the active connections, and therefore it can know with certainty whether it is possible to send more data or
N * it has to wait for a @ref BLE_EVT_TX_COMPLETE event before it proceeds.
N * The application can still pursue transmissions when the number of guaranteed application packets available is smaller
N * than or equal to zero, but successful queuing of the tranmsission is not guaranteed.
N * - Choose to simply not keep track of available packets at all, and instead handle the @ref BLE_ERROR_NO_TX_PACKETS error
N * by queueing the packet to be transmitted and try again as soon as a @ref BLE_EVT_TX_COMPLETE event arrives.
N *
N * The API functions that <b>may</b> consume an application packet depending on the parameters supplied to them can be found below:
N * - @ref sd_ble_gattc_write (write without response only)
N * - @ref sd_ble_gatts_hvx (notifications only)
N * - @ref sd_ble_l2cap_tx (all packets)
N *
N * @param[in]  conn_handle Connection handle.
N * @param[out] p_count Pointer to a uint8_t which will contain the number of application transmission packets upon
N *                     successful return.
N * @mscs
N * @mmsc{@ref BLE_COMMON_APP_BUFF_MSC}
N * @endmscs
N *
N * @retval ::NRF_SUCCESS Number of application transmission packets retrieved successfully.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_TX_PACKET_COUNT_GET, uint32_t, sd_ble_tx_packet_count_get(uint16_t conn_handle, uint8_t *p_count));
Xuint32_t __svc(SD_BLE_TX_PACKET_COUNT_GET) sd_ble_tx_packet_count_get(uint16_t conn_handle, uint8_t *p_count);
N
N
N/**@brief Add a Vendor Specific base UUID.
N *
N * @details This call enables the application to add a vendor specific base UUID to the BLE stack's table, for later
N * use with all other modules and APIs. This then allows the application to use the shorter, 24-bit @ref ble_uuid_t
N * format when dealing with both 16-bit and 128-bit UUIDs without having to check for lengths and having split code
N * paths. This is accomplished by extending the grouping mechanism that the Bluetooth SIG standard base UUID uses
N * for all other 128-bit UUIDs. The type field in the @ref ble_uuid_t structure is an index (relative to
N * @ref BLE_UUID_TYPE_VENDOR_BEGIN) to the table populated by multiple calls to this function, and the uuid field
N * in the same structure contains the 2 bytes at indices 12 and 13. The number of possible 128-bit UUIDs available to
N * the application is therefore the number of Vendor Specific UUIDs added with the help of this function times 65536,
N * although restricted to modifying bytes 12 and 13 for each of the entries in the supplied array.
N *
N * @note Bytes 12 and 13 of the provided UUID will not be used internally, since those are always replaced by
N * the 16-bit uuid field in @ref ble_uuid_t.
N *
N * @note If a UUID is already present in the BLE stack's internal table, the corresponding index will be returned in
N * p_uuid_type along with an NRF_SUCCESS error code.
N *
N * @param[in]  p_vs_uuid    Pointer to a 16-octet (128-bit) little endian Vendor Specific UUID disregarding
N *                          bytes 12 and 13.
N * @param[out] p_uuid_type  Pointer to a uint8_t where the type field in @ref ble_uuid_t corresponding to this UUID will be stored.
N *
N * @retval ::NRF_SUCCESS Successfully added the Vendor Specific UUID.
N * @retval ::NRF_ERROR_INVALID_ADDR If p_vs_uuid or p_uuid_type is NULL or invalid.
N * @retval ::NRF_ERROR_NO_MEM If there are no more free slots for VS UUIDs.
N */
NSVCALL(SD_BLE_UUID_VS_ADD, uint32_t, sd_ble_uuid_vs_add(ble_uuid128_t const *p_vs_uuid, uint8_t *p_uuid_type));
Xuint32_t __svc(SD_BLE_UUID_VS_ADD) sd_ble_uuid_vs_add(ble_uuid128_t const *p_vs_uuid, uint8_t *p_uuid_type);
N
N
N/** @brief Decode little endian raw UUID bytes (16-bit or 128-bit) into a 24 bit @ref ble_uuid_t structure.
N *
N * @details The raw UUID bytes excluding bytes 12 and 13 (i.e. bytes 0-11 and 14-15) of p_uuid_le are compared
N * to the corresponding ones in each entry of the table of vendor specific UUIDs populated with @ref sd_ble_uuid_vs_add
N * to look for a match. If there is such a match, bytes 12 and 13 are returned as p_uuid->uuid and the index
N * relative to @ref BLE_UUID_TYPE_VENDOR_BEGIN as p_uuid->type.
N *
N * @note If the UUID length supplied is 2, then the type set by this call will always be @ref BLE_UUID_TYPE_BLE.
N *
N * @param[in]   uuid_le_len Length in bytes of the buffer pointed to by p_uuid_le (must be 2 or 16 bytes).
N * @param[in]   p_uuid_le   Pointer pointing to little endian raw UUID bytes.
N * @param[out]  p_uuid      Pointer to a @ref ble_uuid_t structure to be filled in.
N *
N * @retval ::NRF_SUCCESS Successfully decoded into the @ref ble_uuid_t structure.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_LENGTH Invalid UUID length.
N * @retval ::NRF_ERROR_NOT_FOUND For a 128-bit UUID, no match in the populated table of UUIDs.
N */
NSVCALL(SD_BLE_UUID_DECODE, uint32_t, sd_ble_uuid_decode(uint8_t uuid_le_len, uint8_t const *p_uuid_le, ble_uuid_t *p_uuid));
Xuint32_t __svc(SD_BLE_UUID_DECODE) sd_ble_uuid_decode(uint8_t uuid_le_len, uint8_t const *p_uuid_le, ble_uuid_t *p_uuid);
N
N
N/** @brief Encode a @ref ble_uuid_t structure into little endian raw UUID bytes (16-bit or 128-bit).
N *
N * @note The pointer to the destination buffer p_uuid_le may be NULL, in which case only the validity and size of p_uuid is computed.
N *
N * @param[in]   p_uuid        Pointer to a @ref ble_uuid_t structure that will be encoded into bytes.
N * @param[out]  p_uuid_le_len Pointer to a uint8_t that will be filled with the encoded length (2 or 16 bytes).
N * @param[out]  p_uuid_le     Pointer to a buffer where the little endian raw UUID bytes (2 or 16) will be stored.
N *
N * @retval ::NRF_SUCCESS Successfully encoded into the buffer.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid UUID type.
N */
NSVCALL(SD_BLE_UUID_ENCODE, uint32_t, sd_ble_uuid_encode(ble_uuid_t const *p_uuid, uint8_t *p_uuid_le_len, uint8_t *p_uuid_le));
Xuint32_t __svc(SD_BLE_UUID_ENCODE) sd_ble_uuid_encode(ble_uuid_t const *p_uuid, uint8_t *p_uuid_le_len, uint8_t *p_uuid_le);
N
N
N/**@brief Get Version Information.
N *
N * @details This call allows the application to get the BLE stack version information.
N *
N * @param[out] p_version Pointer to a ble_version_t structure to be filled in.
N *
N * @retval ::NRF_SUCCESS  Version information stored successfully.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::NRF_ERROR_BUSY The BLE stack is busy (typically doing a locally-initiated disconnection procedure).
N */
NSVCALL(SD_BLE_VERSION_GET, uint32_t, sd_ble_version_get(ble_version_t *p_version));
Xuint32_t __svc(SD_BLE_VERSION_GET) sd_ble_version_get(ble_version_t *p_version);
N
N
N/**@brief Provide a user memory block.
N *
N * @note This call can only be used as a response to a @ref BLE_EVT_USER_MEM_REQUEST event issued to the application.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in,out] p_block Pointer to a user memory block structure.
N *
N * @mscs
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_PEER_CANCEL_MSC}
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_AUTH_MSC}
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_AUTH_MSC}
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_NOAUTH_MSC}
N * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}
N * @endmscs
N *
N * @retval ::NRF_SUCCESS Successfully queued a response to the peer.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection state or no execute write request pending.
N * @retval ::NRF_ERROR_BUSY The BLE stack is busy. Retry at later time.
N */
NSVCALL(SD_BLE_USER_MEM_REPLY, uint32_t, sd_ble_user_mem_reply(uint16_t conn_handle, ble_user_mem_block_t const *p_block));
Xuint32_t __svc(SD_BLE_USER_MEM_REPLY) sd_ble_user_mem_reply(uint16_t conn_handle, ble_user_mem_block_t const *p_block);
N
N/**@brief Set a BLE option.
N *
N * @details This call allows the application to set the value of an option.
N *
N * @mscs
N * @mmsc{@ref BLE_GAP_PERIPH_BONDING_STATIC_PK_MSC}
N * @mmsc{@ref BLE_COMMON_CONF_BW}
N * @endmscs
N *
N * @param[in] opt_id Option ID, see @ref BLE_COMMON_OPTS and @ref BLE_GAP_OPTS.
N * @param[in] p_opt Pointer to a ble_opt_t structure containing the option value.
N *
N * @retval ::NRF_SUCCESS  Option set successfully.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.
N * @retval ::NRF_ERROR_INVALID_STATE Unable to set the parameter at this time.
N * @retval ::NRF_ERROR_BUSY The BLE stack is busy or the previous procedure has not completed.
N */
NSVCALL(SD_BLE_OPT_SET, uint32_t, sd_ble_opt_set(uint32_t opt_id, ble_opt_t const *p_opt));
Xuint32_t __svc(SD_BLE_OPT_SET) sd_ble_opt_set(uint32_t opt_id, ble_opt_t const *p_opt);
N
N
N/**@brief Get a BLE option.
N *
N * @details This call allows the application to retrieve the value of an option.
N *
N * @param[in] opt_id Option ID, see @ref BLE_COMMON_OPTS and @ref BLE_GAP_OPTS.
N * @param[out] p_opt Pointer to a ble_opt_t structure to be filled in.
N *
N * @retval ::NRF_SUCCESS  Option retrieved successfully.
N * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.
N * @retval ::NRF_ERROR_INVALID_STATE Unable to retrieve the parameter at this time.
N * @retval ::NRF_ERROR_BUSY The BLE stack is busy or the previous procedure has not completed.
N * @retval ::NRF_ERROR_NOT_SUPPORTED This option is not supported.
N *
N */
NSVCALL(SD_BLE_OPT_GET, uint32_t, sd_ble_opt_get(uint32_t opt_id, ble_opt_t *p_opt));
Xuint32_t __svc(SD_BLE_OPT_GET) sd_ble_opt_get(uint32_t opt_id, ble_opt_t *p_opt);
N
N/** @} */
N#ifdef __cplusplus
S}
N#endif
N#endif /* BLE_H__ */
N
N/**
N  @}
N  @}
N*/
L 35 "..\..\..\main.c" 2
N#include "ble_hci.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\ble_hci.h" 1
N/* 
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N * 
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N * 
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N * 
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N * 
N * 
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/**
N  @addtogroup BLE_COMMON 
N  @{
N*/
N
N
N#ifndef BLE_HCI_H__
N#define BLE_HCI_H__ 
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup BLE_HCI_STATUS_CODES Bluetooth status codes
N * @{ */
N
N#define BLE_HCI_STATUS_CODE_SUCCESS                        0x00   /**< Success. */
N#define BLE_HCI_STATUS_CODE_UNKNOWN_BTLE_COMMAND           0x01   /**< Unknown BLE Command. */
N#define BLE_HCI_STATUS_CODE_UNKNOWN_CONNECTION_IDENTIFIER  0x02   /**< Unknown Connection Identifier. */
N/*0x03 Hardware Failure
N0x04 Page Timeout
N*/
N#define BLE_HCI_AUTHENTICATION_FAILURE                     0x05   /**< Authentication Failure. */
N#define BLE_HCI_STATUS_CODE_PIN_OR_KEY_MISSING             0x06   /**< Pin or Key missing. */
N#define BLE_HCI_MEMORY_CAPACITY_EXCEEDED                   0x07   /**< Memory Capacity Exceeded. */
N#define BLE_HCI_CONNECTION_TIMEOUT                         0x08   /**< Connection Timeout. */
N/*0x09 Connection Limit Exceeded
N0x0A Synchronous Connection Limit To A Device Exceeded
N0x0B ACL Connection Already Exists*/
N#define BLE_HCI_STATUS_CODE_COMMAND_DISALLOWED             0x0C   /**< Command Disallowed. */
N/*0x0D Connection Rejected due to Limited Resources
N0x0E Connection Rejected Due To Security Reasons
N0x0F Connection Rejected due to Unacceptable BD_ADDR
N0x10 Connection Accept Timeout Exceeded
N0x11 Unsupported Feature or Parameter Value*/
N#define BLE_HCI_STATUS_CODE_INVALID_BTLE_COMMAND_PARAMETERS 0x12  /**< Invalid BLE Command Parameters. */
N#define BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION           0x13  /**< Remote User Terminated Connection. */
N#define BLE_HCI_REMOTE_DEV_TERMINATION_DUE_TO_LOW_RESOURCES 0x14  /**< Remote Device Terminated Connection due to low resources.*/
N#define BLE_HCI_REMOTE_DEV_TERMINATION_DUE_TO_POWER_OFF     0x15  /**< Remote Device Terminated Connection due to power off. */
N#define BLE_HCI_LOCAL_HOST_TERMINATED_CONNECTION            0x16  /**< Local Host Terminated Connection. */
N/*
N0x17 Repeated Attempts
N0x18 Pairing Not Allowed
N0x19 Unknown LMP PDU
N*/
N#define BLE_HCI_UNSUPPORTED_REMOTE_FEATURE 0x1A                   /**< Unsupported Remote Feature. */
N/*
N0x1B SCO Offset Rejected
N0x1C SCO Interval Rejected
N0x1D SCO Air Mode Rejected*/
N#define BLE_HCI_STATUS_CODE_INVALID_LMP_PARAMETERS     0x1E       /**< Invalid LMP Parameters. */
N#define BLE_HCI_STATUS_CODE_UNSPECIFIED_ERROR          0x1F       /**< Unspecified Error. */
N/*0x20 Unsupported LMP Parameter Value
N0x21 Role Change Not Allowed
N*/
N#define BLE_HCI_STATUS_CODE_LMP_RESPONSE_TIMEOUT       0x22       /**< LMP Response Timeout. */
N/*0x23 LMP Error Transaction Collision*/
N#define BLE_HCI_STATUS_CODE_LMP_PDU_NOT_ALLOWED        0x24       /**< LMP PDU Not Allowed. */
N/*0x25 Encryption Mode Not Acceptable
N0x26 Link Key Can Not be Changed
N0x27 Requested QoS Not Supported
N*/
N#define BLE_HCI_INSTANT_PASSED                         0x28       /**< Instant Passed. */
N#define BLE_HCI_PAIRING_WITH_UNIT_KEY_UNSUPPORTED      0x29       /**< Pairing with Unit Key Unsupported. */
N#define BLE_HCI_DIFFERENT_TRANSACTION_COLLISION        0x2A       /**< Different Transaction Collision. */
N/*
N0x2B Reserved
N0x2C QoS Unacceptable Parameter
N0x2D QoS Rejected
N0x2E Channel Classification Not Supported
N0x2F Insufficient Security
N0x30 Parameter Out Of Mandatory Range
N0x31 Reserved
N0x32 Role Switch Pending
N0x33 Reserved
N0x34 Reserved Slot Violation
N0x35 Role Switch Failed
N0x36 Extended Inquiry Response Too Large
N0x37 Secure Simple Pairing Not Supported By Host.
N0x38 Host Busy - Pairing
N0x39 Connection Rejected due to No Suitable Channel Found*/
N#define BLE_HCI_CONTROLLER_BUSY                        0x3A       /**< Controller Busy. */
N#define BLE_HCI_CONN_INTERVAL_UNACCEPTABLE             0x3B       /**< Connection Interval Unacceptable. */
N#define BLE_HCI_DIRECTED_ADVERTISER_TIMEOUT            0x3C       /**< Directed Adverisement Timeout. */
N#define BLE_HCI_CONN_TERMINATED_DUE_TO_MIC_FAILURE     0x3D       /**< Connection Terminated due to MIC Failure. */
N#define BLE_HCI_CONN_FAILED_TO_BE_ESTABLISHED          0x3E       /**< Connection Failed to be Established. */
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N#endif // BLE_HCI_H__
N
N/** @} */
L 36 "..\..\..\main.c" 2
N#include "ble_srv_common.h"
L 1 "..\..\..\..\..\..\components\ble\common\ble_srv_common.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_sdk_srv_common Common service definitions
N * @{
N * @ingroup ble_sdk_srv
N * @brief Constants, type definitions, and functions that are common to all services.
N */
N
N#ifndef BLE_SRV_COMMON_H__
N#define BLE_SRV_COMMON_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "ble_types.h"
N#include "app_util.h"
L 1 "..\..\..\..\..\..\components\libraries\util\app_util.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup app_util Utility Functions and Definitions
N * @{
N * @ingroup app_common
N *
N * @brief Various types and definitions available to all applications.
N */
N
N#ifndef APP_UTIL_H__
N#define APP_UTIL_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "compiler_abstraction.h"
N#include "nrf.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N//lint -save -e27 -e10 -e19
N#if defined ( __CC_ARM )
X#if 1L
Nextern char STACK$$Base;
Nextern char STACK$$Length;
N#define STACK_BASE    &STACK$$Base
N#define STACK_TOP    ((void*)((uint32_t)STACK_BASE + (uint32_t)&STACK$$Length))
N#elif defined ( __ICCARM__ )
Sextern char CSTACK$$Base;
Sextern char CSTACK$$Length;
S#define STACK_BASE    &CSTACK$$Base
S#define STACK_TOP    ((void*)((uint32_t)STACK_BASE + (uint32_t)&CSTACK$$Length))
S#elif defined   ( __GNUC__ )
Sextern uint32_t __StackTop;
Sextern uint32_t __StackLimit;
S#define STACK_BASE    &__StackLimit
S#define STACK_TOP     &__StackTop
N#endif
N//lint -restore
N
Nenum
N{
N    UNIT_0_625_MS = 625,                                /**< Number of microseconds in 0.625 milliseconds. */
N    UNIT_1_25_MS  = 1250,                               /**< Number of microseconds in 1.25 milliseconds. */
N    UNIT_10_MS    = 10000                               /**< Number of microseconds in 10 milliseconds. */
N};
N
N
N/**@brief Implementation specific macro for delayed macro expansion used in string concatenation
N*
N* @param[in]   lhs   Left hand side in concatenation
N* @param[in]   rhs   Right hand side in concatenation
N*/
N#define STRING_CONCATENATE_IMPL(lhs, rhs) lhs ## rhs
N
N
N/**@brief Macro used to concatenate string using delayed macro expansion
N*
N* @note This macro will delay concatenation until the expressions have been resolved
N*
N* @param[in]   lhs   Left hand side in concatenation
N* @param[in]   rhs   Right hand side in concatenation
N*/
N#define STRING_CONCATENATE(lhs, rhs) STRING_CONCATENATE_IMPL(lhs, rhs)
N
N
N// Disable lint-warnings/errors for STATIC_ASSERT
N//lint --emacro(10,STATIC_ASSERT)
N//lint --emacro(18,STATIC_ASSERT)
N//lint --emacro(19,STATIC_ASSERT)
N//lint --emacro(30,STATIC_ASSERT)
N//lint --emacro(37,STATIC_ASSERT)
N//lint --emacro(42,STATIC_ASSERT)
N//lint --emacro(26,STATIC_ASSERT)
N//lint --emacro(102,STATIC_ASSERT)
N//lint --emacro(533,STATIC_ASSERT)
N//lint --emacro(534,STATIC_ASSERT)
N//lint --emacro(132,STATIC_ASSERT)
N//lint --emacro(414,STATIC_ASSERT)
N//lint --emacro(578,STATIC_ASSERT)
N//lint --emacro(628,STATIC_ASSERT)
N//lint --emacro(648,STATIC_ASSERT)
N//lint --emacro(830,STATIC_ASSERT)
N
N
N/**@brief Macro for doing static (i.e. compile time) assertion.
N*
N* @note If the EXPR isn't resolvable, then the error message won't be shown.
N*
N* @note The output of STATIC_ASSERT will be different across different compilers.
N*
N* @param[in] EXPR Constant expression to be verified.
N*/
N#if defined ( __COUNTER__ )
X#if 0L
S
S#define STATIC_ASSERT(EXPR) \
S    ;enum { STRING_CONCATENATE(static_assert_, __COUNTER__) = 1 / (!!(EXPR)) }
X#define STATIC_ASSERT(EXPR)     ;enum { STRING_CONCATENATE(static_assert_, __COUNTER__) = 1 / (!!(EXPR)) }
S
N#else
N
N#define STATIC_ASSERT(EXPR) \
N    ;enum { STRING_CONCATENATE(assert_line_, __LINE__) = 1 / (!!(EXPR)) }
X#define STATIC_ASSERT(EXPR)     ;enum { STRING_CONCATENATE(assert_line_, __LINE__) = 1 / (!!(EXPR)) }
N
N#endif
N
N/**@brief Implementation details for NUM_VAR_ARGS */
N#define NUM_VA_ARGS_IMPL(                              \
N    _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,       \
N    _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,  \
N    _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,  \
N    _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,  \
N    _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,  \
N    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,  \
N    _61, _62, N, ...) N
X#define NUM_VA_ARGS_IMPL(                                  _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,           _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,      _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,      _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,      _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,      _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,      _61, _62, N, ...) N
N
N
N/**@brief Macro to get the number of arguments in a call variadic macro call
N *
N * param[in]    ...     List of arguments
N *
N * @retval  Number of variadic arguments in the argument list
N */
N#define NUM_VA_ARGS(...) NUM_VA_ARGS_IMPL(__VA_ARGS__, 63, 62, 61,  \
N    60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                         \
N    50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                         \
N    40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                         \
N    30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                         \
N    20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                         \
N    10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
X#define NUM_VA_ARGS(...) NUM_VA_ARGS_IMPL(__VA_ARGS__, 63, 62, 61,      60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                             50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                             40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                             30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                             20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                             10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
N
N/**@brief Implementation details for NUM_VAR_ARGS */
N#define NUM_VA_ARGS_LESS_1_IMPL(                       \
N    _ignored,                                          \
N    _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,       \
N    _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,  \
N    _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,  \
N    _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,  \
N    _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,  \
N    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,  \
N    _61, _62, N, ...) N
X#define NUM_VA_ARGS_LESS_1_IMPL(                           _ignored,                                              _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,           _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,      _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,      _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,      _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,      _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,      _61, _62, N, ...) N
N
N/**@brief Macro to get the number of arguments in a call variadic macro call.
N * First argument is not counted.
N *
N * param[in]    ...     List of arguments
N *
N * @retval  Number of variadic arguments in the argument list
N */
N#define NUM_VA_ARGS_LESS_1(...) NUM_VA_ARGS_LESS_1_IMPL(__VA_ARGS__, 63, 62, 61,  \
N    60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                         \
N    50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                         \
N    40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                         \
N    30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                         \
N    20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                         \
N    10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, ~)
X#define NUM_VA_ARGS_LESS_1(...) NUM_VA_ARGS_LESS_1_IMPL(__VA_ARGS__, 63, 62, 61,      60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                             50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                             40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                             30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                             20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                             10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, ~)
N
N
N/**@brief type for holding an encoded (i.e. little endian) 16 bit unsigned integer. */
Ntypedef uint8_t uint16_le_t[2];
N
N/**@brief Type for holding an encoded (i.e. little endian) 32 bit unsigned integer. */
Ntypedef uint8_t uint32_le_t[4];
N
N/**@brief Byte array type. */
Ntypedef struct
N{
N    uint16_t  size;                 /**< Number of array entries. */
N    uint8_t * p_data;               /**< Pointer to array entries. */
N} uint8_array_t;
N
N
N/**@brief Macro for performing rounded integer division (as opposed to truncating the result).
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Rounded (integer) result of dividing A by B.
N */
N#define ROUNDED_DIV(A, B) (((A) + ((B) / 2)) / (B))
N
N
N/**@brief Macro for checking if an integer is a power of two.
N *
N * @param[in]   A   Number to be tested.
N *
N * @return      true if value is power of two.
N * @return      false if value not power of two.
N */
N#define IS_POWER_OF_TWO(A) ( ((A) != 0) && ((((A) - 1) & (A)) == 0) )
N
N
N/**@brief Macro for converting milliseconds to ticks.
N *
N * @param[in] TIME          Number of milliseconds to convert.
N * @param[in] RESOLUTION    Unit to be converted to in [us/ticks].
N */
N#define MSEC_TO_UNITS(TIME, RESOLUTION) (((TIME) * 1000) / (RESOLUTION))
N
N
N/**@brief Macro for performing integer division, making sure the result is rounded up.
N *
N * @details One typical use for this is to compute the number of objects with size B is needed to
N *          hold A number of bytes.
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Integer result of dividing A by B, rounded up.
N */
N#define CEIL_DIV(A, B)      \
N    (((A) + (B) - 1) / (B))
X#define CEIL_DIV(A, B)          (((A) + (B) - 1) / (B))
N
N
N/**@brief Macro for creating a buffer aligned to 4 bytes.
N *
N * @param[in]   NAME        Name of the buffor.
N * @param[in]   MIN_SIZE    Size of this buffor (it will be rounded up to multiples of 4 bytes).
N */
N#define WORD_ALIGNED_MEM_BUFF(NAME, MIN_SIZE) static uint32_t NAME[CEIL_DIV(MIN_SIZE, sizeof(uint32_t))]
N
N
N/**@brief Macro for calculating the number of words that are needed to hold a number of bytes.
N *
N * @details Adds 3 and divides by 4.
N *
N * @param[in]  n_bytes  The number of bytes.
N *
N * @return The number of words that @p n_bytes take up (rounded up).
N */
N#define BYTES_TO_WORDS(n_bytes) (((n_bytes) + 3) >> 2)
N
N
N/**@brief The number of bytes in a word.
N */
N#define BYTES_PER_WORD (4)
N
N
N/**@brief Macro for increasing a number to the nearest (larger) multiple of another number.
N *
N * @param[in]  alignment  The number to align to.
N * @param[in]  number     The number to align (increase).
N *
N * @return The aligned (increased) @p number.
N */
N#define ALIGN_NUM(alignment, number) ((number - 1) + alignment - ((number - 1) % alignment))
N
N/**@brief Macro for getting first of 2 parameters.
N *
N * @param[in] a1    First parameter.
N * @param[in] a2    Second parameter.
N */
N#define GET_ARG_1(a1, a2) a1
N
N/**@brief Macro for getting second of 2 parameters.
N *
N * @param[in] a1    First parameter.
N * @param[in] a2    Second parameter.
N */
N#define GET_ARG_2(a1, a2) a2
N
N
N/**@brief Function for changing the value unit.
N *
N * @param[in]   value               Value to be rescaled.
N * @param[in]   old_unit_reversal   Reversal of the incoming unit.
N * @param[in]   new_unit_reversal   Reversal of the desired unit.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint64_t value_rescale(uint32_t value, uint32_t old_unit_reversal, uint16_t new_unit_reversal)
Xstatic __inline uint64_t value_rescale(uint32_t value, uint32_t old_unit_reversal, uint16_t new_unit_reversal)
N{
N    return (uint64_t)ROUNDED_DIV((uint64_t)value * new_unit_reversal, old_unit_reversal);
X    return (uint64_t)((((uint64_t)value * new_unit_reversal) + ((old_unit_reversal) / 2)) / (old_unit_reversal));
N}
N
N/**@brief Function for encoding a uint16 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
N    return sizeof(uint16_t);
N}
N
N/**@brief Function for encoding a three-byte value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint24_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint24_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x00FF0000) >> 16);
N    return 3;
N}
N
N/**@brief Function for encoding a uint32 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x00FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((value & 0xFF000000) >> 24);
N    return sizeof(uint32_t);
N}
N
N/**@brief Function for encoding a uint48 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint48_encode(uint64_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint48_encode(uint64_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x0000000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x00000000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x000000FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((value & 0x0000FF000000) >> 24);
N    p_encoded_data[4] = (uint8_t) ((value & 0x00FF00000000) >> 32);
N    p_encoded_data[5] = (uint8_t) ((value & 0xFF0000000000) >> 40);
N    return 6;
N}
N
N/**@brief Function for decoding a uint16 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint16_t uint16_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint16_t uint16_decode(const uint8_t * p_encoded_data)
N{
N        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) |
N                 (((uint16_t)((uint8_t *)p_encoded_data)[1]) << 8 ));
N}
N
N/**@brief Function for decoding a uint16 value in big-endian format.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint16_t uint16_big_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint16_t uint16_big_decode(const uint8_t * p_encoded_data)
N{
N        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0]) << 8 ) |
N                 (((uint16_t)((uint8_t *)p_encoded_data)[1])) );
N}
N
N/**@brief Function for decoding a three-byte value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value (uint32_t).
N */
Nstatic __INLINE uint32_t uint24_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint24_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16));
N}
N
N/**@brief Function for decoding a uint32 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint32_t uint32_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint32_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 24 ));
N}
N
N/**@brief Function for decoding a uint32 value in big-endian format.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint32_t uint32_big_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint32_big_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 24) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 16) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 0) );
N}
N
N/**@brief Function for encoding a uint32 value in big-endian format.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data will be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint32_big_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint32_big_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    *(uint32_t *)p_encoded_data = __REV(value);
X    *(uint32_t *)p_encoded_data = __rev(value);
N    return sizeof(uint32_t);
N}
N
N/**@brief Function for decoding a uint48 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value. (uint64_t)
N */
Nstatic __INLINE uint64_t uint48_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint64_t uint48_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint64_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint64_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint64_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N             (((uint64_t)((uint8_t *)p_encoded_data)[3]) << 24) |
N             (((uint64_t)((uint8_t *)p_encoded_data)[4]) << 32) |
N             (((uint64_t)((uint8_t *)p_encoded_data)[5]) << 40 ));
N}
N
N/** @brief Function for converting the input voltage (in milli volts) into percentage of 3.0 Volts.
N *
N *  @details The calculation is based on a linearized version of the battery's discharge
N *           curve. 3.0V returns 100% battery level. The limit for power failure is 2.1V and
N *           is considered to be the lower boundary.
N *
N *           The discharge curve for CR2032 is non-linear. In this model it is split into
N *           4 linear sections:
N *           - Section 1: 3.0V - 2.9V = 100% - 42% (58% drop on 100 mV)
N *           - Section 2: 2.9V - 2.74V = 42% - 18% (24% drop on 160 mV)
N *           - Section 3: 2.74V - 2.44V = 18% - 6% (12% drop on 300 mV)
N *           - Section 4: 2.44V - 2.1V = 6% - 0% (6% drop on 340 mV)
N *
N *           These numbers are by no means accurate. Temperature and
N *           load in the actual application is not accounted for!
N *
N *  @param[in] mvolts The voltage in mV
N *
N *  @return    Battery level in percent.
N*/
Nstatic __INLINE uint8_t battery_level_in_percent(const uint16_t mvolts)
Xstatic __inline uint8_t battery_level_in_percent(const uint16_t mvolts)
N{
N    uint8_t battery_level;
N
N    if (mvolts >= 3000)
N    {
N        battery_level = 100;
N    }
N    else if (mvolts > 2900)
N    {
N        battery_level = 100 - ((3000 - mvolts) * 58) / 100;
N    }
N    else if (mvolts > 2740)
N    {
N        battery_level = 42 - ((2900 - mvolts) * 24) / 160;
N    }
N    else if (mvolts > 2440)
N    {
N        battery_level = 18 - ((2740 - mvolts) * 12) / 300;
N    }
N    else if (mvolts > 2100)
N    {
N        battery_level = 6 - ((2440 - mvolts) * 6) / 340;
N    }
N    else
N    {
N        battery_level = 0;
N    }
N
N    return battery_level;
N}
N
N/**@brief Function for checking if a pointer value is aligned to a 4 byte boundary.
N *
N * @param[in]   p   Pointer value to be checked.
N *
N * @return      TRUE if pointer is aligned to a 4 byte boundary, FALSE otherwise.
N */
Nstatic __INLINE bool is_word_aligned(void const* p)
Xstatic __inline _Bool is_word_aligned(void const* p)
N{
N    return (((uintptr_t)p & 0x03) == 0);
N}
N
N/**
N * @brief Function for checking if provided address is located in stack space.
N *
N * @param[in]   ptr Pointer to be checked.
N *
N * @return      true if address is in stack space, false otherwise.
N */
Nstatic __INLINE bool is_address_from_stack(void * ptr)
Xstatic __inline _Bool is_address_from_stack(void * ptr)
N{
N    if (((uint32_t)ptr >= (uint32_t)STACK_BASE) &&
X    if (((uint32_t)ptr >= (uint32_t)&STACK$$Base) &&
N        ((uint32_t)ptr <  (uint32_t)STACK_TOP) )
X        ((uint32_t)ptr <  (uint32_t)((void*)((uint32_t)&STACK$$Base + (uint32_t)&STACK$$Length))) )
N    {
N        return true;
X        return 1;
N    }
N    else
N    {
N        return false;
X        return 0;
N    }
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_UTIL_H__
N
N/** @} */
L 28 "..\..\..\..\..\..\components\ble\common\ble_srv_common.h" 2
N#include "ble.h"
N#include "ble_gap.h"
N#include "ble_gatt.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup UUID_SERVICES Service UUID definitions
N * @{ */
N#define BLE_UUID_ALERT_NOTIFICATION_SERVICE                      0x1811     /**< Alert Notification service UUID. */
N#define BLE_UUID_BATTERY_SERVICE                                 0x180F     /**< Battery service UUID. */
N#define BLE_UUID_BLOOD_PRESSURE_SERVICE                          0x1810     /**< Blood Pressure service UUID. */
N#define BLE_UUID_CURRENT_TIME_SERVICE                            0x1805     /**< Current Time service UUID. */
N#define BLE_UUID_CYCLING_SPEED_AND_CADENCE                       0x1816     /**< Cycling Speed and Cadence service UUID. */
N#define BLE_UUID_LOCATION_AND_NAVIGATION_SERVICE                 0x1819     /**< Location and Navigation service UUID. */
N#define BLE_UUID_DEVICE_INFORMATION_SERVICE                      0x180A     /**< Device Information service UUID. */
N#define BLE_UUID_GLUCOSE_SERVICE                                 0x1808     /**< Glucose service UUID. */
N#define BLE_UUID_HEALTH_THERMOMETER_SERVICE                      0x1809     /**< Health Thermometer service UUID. */
N#define BLE_UUID_HEART_RATE_SERVICE                              0x180D     /**< Heart Rate service UUID. */
N#define BLE_UUID_HUMAN_INTERFACE_DEVICE_SERVICE                  0x1812     /**< Human Interface Device service UUID. */
N#define BLE_UUID_IMMEDIATE_ALERT_SERVICE                         0x1802     /**< Immediate Alert service UUID. */
N#define BLE_UUID_LINK_LOSS_SERVICE                               0x1803     /**< Link Loss service UUID. */
N#define BLE_UUID_NEXT_DST_CHANGE_SERVICE                         0x1807     /**< Next Dst Change service UUID. */
N#define BLE_UUID_PHONE_ALERT_STATUS_SERVICE                      0x180E     /**< Phone Alert Status service UUID. */
N#define BLE_UUID_REFERENCE_TIME_UPDATE_SERVICE                   0x1806     /**< Reference Time Update service UUID. */
N#define BLE_UUID_RUNNING_SPEED_AND_CADENCE                       0x1814     /**< Running Speed and Cadence service UUID. */
N#define BLE_UUID_SCAN_PARAMETERS_SERVICE                         0x1813     /**< Scan Parameters service UUID. */
N#define BLE_UUID_TX_POWER_SERVICE                                0x1804     /**< TX Power service UUID. */
N#define BLE_UUID_IPSP_SERVICE                                    0x1820     /**< Internet Protocol Support service UUID. */
N#define BLE_UUID_BMS_SERVICE                                     0x181E     /**< BOND MANAGEMENT service UUID*/
N#define BLE_UUID_CGM_SERVICE                                     0x181F     /**< Contiunous Glucose Monitoring service UUID*/
N#define BLE_UUID_PLX_SERVICE                                     0x1822     /**< Pulse Oximeter Service UUID*/
N
N
N/** @} */
N
N/** @defgroup UUID_CHARACTERISTICS Characteristic UUID definitions
N * @{ */
N#define BLE_UUID_REMOVABLE_CHAR                                  0x2A3A     /**< Removable characteristic UUID. */
N#define BLE_UUID_SERVICE_REQUIRED_CHAR                           0x2A3B     /**< Service Required characteristic UUID. */
N#define BLE_UUID_ALERT_CATEGORY_ID_CHAR                          0x2A43     /**< Alert Category Id characteristic UUID. */
N#define BLE_UUID_ALERT_CATEGORY_ID_BIT_MASK_CHAR                 0x2A42     /**< Alert Category Id Bit Mask characteristic UUID. */
N#define BLE_UUID_ALERT_LEVEL_CHAR                                0x2A06     /**< Alert Level characteristic UUID. */
N#define BLE_UUID_ALERT_NOTIFICATION_CONTROL_POINT_CHAR           0x2A44     /**< Alert Notification Control Point characteristic UUID. */
N#define BLE_UUID_ALERT_STATUS_CHAR                               0x2A3F     /**< Alert Status characteristic UUID. */
N#define BLE_UUID_BATTERY_LEVEL_CHAR                              0x2A19     /**< Battery Level characteristic UUID. */
N#define BLE_UUID_BLOOD_PRESSURE_FEATURE_CHAR                     0x2A49     /**< Blood Pressure Feature characteristic UUID. */
N#define BLE_UUID_BLOOD_PRESSURE_MEASUREMENT_CHAR                 0x2A35     /**< Blood Pressure Measurement characteristic UUID. */
N#define BLE_UUID_BODY_SENSOR_LOCATION_CHAR                       0x2A38     /**< Body Sensor Location characteristic UUID. */
N#define BLE_UUID_BOOT_KEYBOARD_INPUT_REPORT_CHAR                 0x2A22     /**< Boot Keyboard Input Report characteristic UUID. */
N#define BLE_UUID_BOOT_KEYBOARD_OUTPUT_REPORT_CHAR                0x2A32     /**< Boot Keyboard Output Report characteristic UUID. */
N#define BLE_UUID_BOOT_MOUSE_INPUT_REPORT_CHAR                    0x2A33     /**< Boot Mouse Input Report characteristic UUID. */
N#define BLE_UUID_CURRENT_TIME_CHAR                               0x2A2B     /**< Current Time characteristic UUID. */
N#define BLE_UUID_DATE_TIME_CHAR                                  0x2A08     /**< Date Time characteristic UUID. */
N#define BLE_UUID_DAY_DATE_TIME_CHAR                              0x2A0A     /**< Day Date Time characteristic UUID. */
N#define BLE_UUID_DAY_OF_WEEK_CHAR                                0x2A09     /**< Day Of Week characteristic UUID. */
N#define BLE_UUID_DST_OFFSET_CHAR                                 0x2A0D     /**< Dst Offset characteristic UUID. */
N#define BLE_UUID_EXACT_TIME_256_CHAR                             0x2A0C     /**< Exact Time 256 characteristic UUID. */
N#define BLE_UUID_FIRMWARE_REVISION_STRING_CHAR                   0x2A26     /**< Firmware Revision String characteristic UUID. */
N#define BLE_UUID_GLUCOSE_FEATURE_CHAR                            0x2A51     /**< Glucose Feature characteristic UUID. */
N#define BLE_UUID_GLUCOSE_MEASUREMENT_CHAR                        0x2A18     /**< Glucose Measurement characteristic UUID. */
N#define BLE_UUID_GLUCOSE_MEASUREMENT_CONTEXT_CHAR                0x2A34     /**< Glucose Measurement Context characteristic UUID. */
N#define BLE_UUID_HARDWARE_REVISION_STRING_CHAR                   0x2A27     /**< Hardware Revision String characteristic UUID. */
N#define BLE_UUID_HEART_RATE_CONTROL_POINT_CHAR                   0x2A39     /**< Heart Rate Control Point characteristic UUID. */
N#define BLE_UUID_HEART_RATE_MEASUREMENT_CHAR                     0x2A37     /**< Heart Rate Measurement characteristic UUID. */
N#define BLE_UUID_HID_CONTROL_POINT_CHAR                          0x2A4C     /**< Hid Control Point characteristic UUID. */
N#define BLE_UUID_HID_INFORMATION_CHAR                            0x2A4A     /**< Hid Information characteristic UUID. */
N#define BLE_UUID_IEEE_REGULATORY_CERTIFICATION_DATA_LIST_CHAR    0x2A2A     /**< IEEE Regulatory Certification Data List characteristic UUID. */
N#define BLE_UUID_INTERMEDIATE_CUFF_PRESSURE_CHAR                 0x2A36     /**< Intermediate Cuff Pressure characteristic UUID. */
N#define BLE_UUID_INTERMEDIATE_TEMPERATURE_CHAR                   0x2A1E     /**< Intermediate Temperature characteristic UUID. */
N#define BLE_UUID_LOCAL_TIME_INFORMATION_CHAR                     0x2A0F     /**< Local Time Information characteristic UUID. */
N#define BLE_UUID_MANUFACTURER_NAME_STRING_CHAR                   0x2A29     /**< Manufacturer Name String characteristic UUID. */
N#define BLE_UUID_MEASUREMENT_INTERVAL_CHAR                       0x2A21     /**< Measurement Interval characteristic UUID. */
N#define BLE_UUID_MODEL_NUMBER_STRING_CHAR                        0x2A24     /**< Model Number String characteristic UUID. */
N#define BLE_UUID_UNREAD_ALERT_CHAR                               0x2A45     /**< Unread Alert characteristic UUID. */
N#define BLE_UUID_NEW_ALERT_CHAR                                  0x2A46     /**< New Alert characteristic UUID. */
N#define BLE_UUID_PNP_ID_CHAR                                     0x2A50     /**< PNP Id characteristic UUID. */
N#define BLE_UUID_PROTOCOL_MODE_CHAR                              0x2A4E     /**< Protocol Mode characteristic UUID. */
N#define BLE_UUID_RECORD_ACCESS_CONTROL_POINT_CHAR                0x2A52     /**< Record Access Control Point characteristic UUID. */
N#define BLE_UUID_REFERENCE_TIME_INFORMATION_CHAR                 0x2A14     /**< Reference Time Information characteristic UUID. */
N#define BLE_UUID_REPORT_CHAR                                     0x2A4D     /**< Report characteristic UUID. */
N#define BLE_UUID_REPORT_MAP_CHAR                                 0x2A4B     /**< Report Map characteristic UUID. */
N#define BLE_UUID_RINGER_CONTROL_POINT_CHAR                       0x2A40     /**< Ringer Control Point characteristic UUID. */
N#define BLE_UUID_RINGER_SETTING_CHAR                             0x2A41     /**< Ringer Setting characteristic UUID. */
N#define BLE_UUID_SCAN_INTERVAL_WINDOW_CHAR                       0x2A4F     /**< Scan Interval Window characteristic UUID. */
N#define BLE_UUID_SCAN_REFRESH_CHAR                               0x2A31     /**< Scan Refresh characteristic UUID. */
N#define BLE_UUID_SERIAL_NUMBER_STRING_CHAR                       0x2A25     /**< Serial Number String characteristic UUID. */
N#define BLE_UUID_SOFTWARE_REVISION_STRING_CHAR                   0x2A28     /**< Software Revision String characteristic UUID. */
N#define BLE_UUID_SUPPORTED_NEW_ALERT_CATEGORY_CHAR               0x2A47     /**< Supported New Alert Category characteristic UUID. */
N#define BLE_UUID_SUPPORTED_UNREAD_ALERT_CATEGORY_CHAR            0x2A48     /**< Supported Unread Alert Category characteristic UUID. */
N#define BLE_UUID_SYSTEM_ID_CHAR                                  0x2A23     /**< System Id characteristic UUID. */
N#define BLE_UUID_TEMPERATURE_MEASUREMENT_CHAR                    0x2A1C     /**< Temperature Measurement characteristic UUID. */
N#define BLE_UUID_TEMPERATURE_TYPE_CHAR                           0x2A1D     /**< Temperature Type characteristic UUID. */
N#define BLE_UUID_TIME_ACCURACY_CHAR                              0x2A12     /**< Time Accuracy characteristic UUID. */
N#define BLE_UUID_TIME_SOURCE_CHAR                                0x2A13     /**< Time Source characteristic UUID. */
N#define BLE_UUID_TIME_UPDATE_CONTROL_POINT_CHAR                  0x2A16     /**< Time Update Control Point characteristic UUID. */
N#define BLE_UUID_TIME_UPDATE_STATE_CHAR                          0x2A17     /**< Time Update State characteristic UUID. */
N#define BLE_UUID_TIME_WITH_DST_CHAR                              0x2A11     /**< Time With Dst characteristic UUID. */
N#define BLE_UUID_TIME_ZONE_CHAR                                  0x2A0E     /**< Time Zone characteristic UUID. */
N#define BLE_UUID_TX_POWER_LEVEL_CHAR                             0x2A07     /**< TX Power Level characteristic UUID. */
N#define BLE_UUID_CSC_FEATURE_CHAR                                0x2A5C     /**< Cycling Speed and Cadence Feature characteristic UUID. */
N#define BLE_UUID_CSC_MEASUREMENT_CHAR                            0x2A5B     /**< Cycling Speed and Cadence Measurement characteristic UUID. */
N#define BLE_UUID_RSC_FEATURE_CHAR                                0x2A54     /**< Running Speed and Cadence Feature characteristic UUID. */
N#define BLE_UUID_SC_CTRLPT_CHAR                                  0x2A55     /**< Speed and Cadence Control Point UUID. */
N#define BLE_UUID_RSC_MEASUREMENT_CHAR                            0x2A53     /**< Running Speed and Cadence Measurement characteristic UUID. */
N#define BLE_UUID_SENSOR_LOCATION_CHAR                            0x2A5D     /**< Sensor Location characteristic UUID. */
N#define BLE_UUID_EXTERNAL_REPORT_REF_DESCR                       0x2907     /**< External Report Reference descriptor UUID. */
N#define BLE_UUID_REPORT_REF_DESCR                                0x2908     /**< Report Reference descriptor UUID. */
N#define BLE_UUID_LN_FEATURE_CHAR                                 0x2A6A     /**< Location Navigation Service, Feature characteristic UUID. */
N#define BLE_UUID_LN_POSITION_QUALITY_CHAR                        0x2A69     /**< Location Navigation Service, Position quality UUID. */
N#define BLE_UUID_LN_LOCATION_AND_SPEED_CHAR                      0x2A67     /**< Location Navigation Service, Location and Speed characteristic UUID. */
N#define BLE_UUID_LN_NAVIGATION_CHAR                              0x2A68     /**< Location Navigation Service, Navigation characteristic UUID. */
N#define BLE_UUID_LN_CONTROL_POINT_CHAR                           0x2A6B     /**< Location Navigation Service, Control point characteristic UUID. */
N#define BLE_UUID_BMS_CTRLPT                                      0x2AA4     /**< BMS Control Point characteristic UUID. */
N#define BLE_UUID_BMS_FEATURE                                     0x2AA5     /**< BMS Feature characteristic UUID. */
N#define BLE_UUID_CGM_MEASUREMENT                                 0x2AA7     /**< CGM Service, Measurement characteristic UUID*/
N#define BLE_UUID_CGM_FEATURE                                     0x2AA8     /**< CGM Service, Feature characteristic UUID*/
N#define BLE_UUID_CGM_STATUS                                      0x2AA9     /**< CGM Service, Status characteristic UUID*/
N#define BLE_UUID_CGM_SESSION_START_TIME                          0x2AAA     /**< CGM Service, session start time characteristic UUID*/
N#define BLE_UUID_CGM_SESSION_RUN_TIME                            0x2AAB     /**< CGM Service, session run time characteristic UUID*/
N#define BLE_UUID_CGM_SPECIFIC_OPS_CTRLPT                         0x2AAC     /**< CGM Service, specific ops ctrlpt characteristic UUID*/
N#define BLE_UUID_PLX_SPOT_CHECK_MEAS                             0x2A5E     /**< PLX Service, spot check measurement characteristic UUID*/
N#define BLE_UUID_PLX_CONTINUOUS_MEAS                             0x2A5F     /**< PLX Service, continuous measurement characteristic UUID*/
N#define BLE_UUID_PLX_FEATURES                                    0x2A60     /**< PLX Service, feature characteristic UUID*/
N
N
N
N
N
N/** @} */
N
N/** @defgroup ALERT_LEVEL_VALUES Definitions for the Alert Level characteristic values
N * @{ */
N#define BLE_CHAR_ALERT_LEVEL_NO_ALERT                            0x00       /**< No Alert. */
N#define BLE_CHAR_ALERT_LEVEL_MILD_ALERT                          0x01       /**< Mild Alert. */
N#define BLE_CHAR_ALERT_LEVEL_HIGH_ALERT                          0x02       /**< High Alert. */
N/** @} */
N
N#define BLE_SRV_ENCODED_REPORT_REF_LEN                           2          /**< The length of an encoded Report Reference Descriptor. */
N#define BLE_CCCD_VALUE_LEN                                       2          /**< The length of a CCCD value. */
N
N/**@brief Type definition for error handler function that will be called in case of an error in
N *        a service or a service library module. */
Ntypedef void (*ble_srv_error_handler_t) (uint32_t nrf_error);
N
N
N
N/**@brief Value of a Report Reference descriptor.
N *
N * @details This is mapping information that maps the parent characteristic to the Report ID(s) and
N *          Report Type(s) defined within a Report Map characteristic.
N */
Ntypedef struct
N{
N    uint8_t report_id;                                  /**< Non-zero value if there is more than one instance of the same Report Type */
N    uint8_t report_type;                                /**< Type of Report characteristic (see @ref BLE_HIDS_REPORT_TYPE) */
N} ble_srv_report_ref_t;
N
N/**@brief UTF-8 string data type.
N *
N * @note The type can only hold a pointer to the string data (i.e. not the actual data).
N */
Ntypedef struct
N{
N    uint16_t  length;                                   /**< String length. */
N    uint8_t * p_str;                                    /**< String data. */
N} ble_srv_utf8_str_t;
N
N
N/**@brief Security settings structure.
N * @details This structure contains the security options needed during initialization of the
N *          service.
N */
Ntypedef struct
N{
N    ble_gap_conn_sec_mode_t read_perm;                  /**< Read permissions. */
N    ble_gap_conn_sec_mode_t write_perm;                 /**< Write permissions. */
N} ble_srv_security_mode_t;
N
N/**@brief Security settings structure.
N * @details This structure contains the security options needed during initialization of the
N *          service. It can be used when the characteristics contains a CCCD.
N */
Ntypedef struct
N{
N    ble_gap_conn_sec_mode_t cccd_write_perm;            /**< Write permissions for Client Characteristic Configuration Descriptor. */
N    ble_gap_conn_sec_mode_t read_perm;                  /**< Read permissions. */
N    ble_gap_conn_sec_mode_t write_perm;                 /**< Write permissions. */
N} ble_srv_cccd_security_mode_t;
N
N/**@brief Function for decoding a CCCD value, and then testing if notification is
N *        enabled.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded CCCD is stored.
N *
N * @retval      TRUE If notification is enabled.
N * @retval      FALSE Otherwise.
N */
Nbool ble_srv_is_notification_enabled(uint8_t const * p_encoded_data);
X_Bool ble_srv_is_notification_enabled(uint8_t const * p_encoded_data);
N
N
N/**@brief Function for decoding a CCCD value, and then testing if indication is
N *        enabled.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded CCCD is stored.
N *
N * @retval      TRUE If indication is enabled.
N * @retval      FALSE Otherwise.
N */
Nbool ble_srv_is_indication_enabled(uint8_t const * p_encoded_data);
X_Bool ble_srv_is_indication_enabled(uint8_t const * p_encoded_data);
N
N
N/**@brief Function for encoding a Report Reference Descriptor.
N *
N * @param[in]   p_encoded_buffer  The buffer of the encoded data.
N * @param[in]   p_report_ref      Report Reference value to be encoded.
N *
N * @return      Length of the encoded data.
N */
Nuint8_t ble_srv_report_ref_encode(uint8_t *                    p_encoded_buffer,
N                                  const ble_srv_report_ref_t * p_report_ref);
N
N/**@brief Function for making a UTF-8 structure refer to an ASCII string.
N *
N * @param[out]  p_utf8   UTF-8 structure to be set.
N * @param[in]   p_ascii  ASCII string to be referred to.
N */
Nvoid ble_srv_ascii_to_utf8(ble_srv_utf8_str_t * p_utf8, char * p_ascii);
N
N
N/**@brief Security Access enumeration.
N * @details This enumeration gives the possible requirements for accessing a characteristic value.
N */
Ntypedef enum
N{
N    SEC_NO_ACCESS    = 0,            /**< Not possible to access. */
N    SEC_OPEN         = 1,            /**< Access open. */
N    SEC_JUST_WORKS   = 2,            /**< Access possible with 'Just Works' security at least. */
N    SEC_MITM         = 3,            /**< Access possible with 'MITM' security at least. */
N    SEC_SIGNED       = 4,            /**< Access possible with 'signed' security at least. */
N    SEC_SIGNED_MITM  = 5             /**< Access possible with 'signed and MITM' security at least. */
N}security_req_t;
N
N
N/**@brief Characteristic User Descriptor parameters.
N * @details This structure contains the parameters for User Descriptor.
N */
Ntypedef struct
N{
N    uint16_t               max_size;                      /**< Maximum size of the user descriptor*/
N    uint16_t               size;                          /**< Size of the user descriptor*/
N    uint8_t                *p_char_user_desc;             /**< User descriptor content, pointer to a UTF-8 encoded string (non-NULL terminated)*/
N    bool                   is_var_len;                    /**< Indicates if the user descriptor has variable length.*/
X    _Bool                   is_var_len;                     
N    ble_gatt_char_props_t  char_props;                    /**< user descriptor properties.*/
N    bool                   is_defered_read;               /**< Indicate if deferred read operations are supported.*/
X    _Bool                   is_defered_read;                
N    bool                   is_defered_write;              /**< Indicate if deferred write operations are supported.*/
X    _Bool                   is_defered_write;               
N    security_req_t         read_access;                   /**< Security requirement for reading the user descriptor.*/
N    security_req_t         write_access;                  /**< Security requirement for writing the user descriptor.*/
N    bool                   is_value_user;                 /**< Indicate if the content of the characteristic is to be stored in the application (user) or in the stack.*/
X    _Bool                   is_value_user;                  
N}ble_add_char_user_desc_t;
N
N
N/**@brief Add characteristic parameters structure.
N * @details This structure contains the parameters needed to use the @ref characteristic_add function.
N */
Ntypedef struct
N{
N    uint16_t                    uuid;                     /**< Characteristic UUID (16 bits UUIDs).*/
N    uint8_t                     uuid_type;                /**< Base UUID. If 0, the Bluetooth SIG UUID will be used. Otherwise, this should be a value returned by @ref sd_ble_uuid_vs_add when adding the base UUID.*/
N    uint16_t                    max_len;                  /**< Maximum length of the characteristic value.*/
N    uint16_t                    init_len;                 /**< Initial length of the characteristic value.*/
N    uint8_t *                   p_init_value;             /**< Initial encoded value of the characteristic.*/
N    bool                        is_var_len;               /**< Indicates if the characteristic value has variable length.*/
X    _Bool                        is_var_len;                
N    ble_gatt_char_props_t       char_props;               /**< Characteristic properties.*/
N    ble_gatt_char_ext_props_t   char_ext_props;           /**< Characteristic extended properties.*/
N    bool                        is_defered_read;          /**< Indicate if deferred read operations are supported.*/
X    _Bool                        is_defered_read;           
N    bool                        is_defered_write;         /**< Indicate if deferred write operations are supported.*/
X    _Bool                        is_defered_write;          
N    security_req_t              read_access;              /**< Security requirement for reading the characteristic value.*/
N    security_req_t              write_access;             /**< Security requirement for writing the characteristic value.*/
N    security_req_t              cccd_write_access;        /**< Security requirement for writing the characteristic's CCCD.*/
N    bool                        is_value_user;            /**< Indicate if the content of the characteristic is to be stored in the application (user) or in the stack.*/
X    _Bool                        is_value_user;             
N    ble_add_char_user_desc_t    *p_user_descr;            /**< Pointer to user descriptor if needed*/
N    ble_gatts_char_pf_t         *p_presentation_format;   /**< Pointer to characteristic format if needed*/
N} ble_add_char_params_t;
N
N
N/**@brief Add descriptor parameters structure.
N * @details This structure contains the parameters needed to use the @ref descriptor_add function.
N */
Ntypedef struct
N{
N    uint16_t       uuid;                     /**< descriptor UUID (16 bits UUIDs).*/
N    uint8_t        uuid_type;                /**< Base UUID. If 0, the Bluetooth SIG UUID will be used. Otherwise, this should be a value returned by @ref sd_ble_uuid_vs_add when adding the base UUID.*/
N    bool           is_defered_read;          /**< Indicate if deferred read operations are supported.*/
X    _Bool           is_defered_read;           
N    bool           is_defered_write;         /**< Indicate if deferred write operations are supported.*/
X    _Bool           is_defered_write;          
N    bool           is_var_len;               /**< Indicates if the descriptor value has variable length.*/
X    _Bool           is_var_len;                
N    security_req_t read_access;              /**< Security requirement for reading the descriptor value.*/
N    security_req_t write_access;             /**< Security requirement for writing the descriptor value.*/
N    bool           is_value_user;            /**< Indicate if the content of the characteristic is to be stored in the application (user) or in the stack.*/
X    _Bool           is_value_user;             
N    uint16_t       init_len;                 /**< Initial descriptor value length in bytes. */
N    uint16_t       init_offs;                /**< Initial descriptor value offset in bytes. If different from zero, the first init_offs bytes of the attribute value will be left uninitialized. */
N    uint16_t       max_len;                  /**< Maximum descriptor value length in bytes, see @ref BLE_GATTS_ATTR_LENS_MAX for maximum values. */
N    uint8_t*       p_value;                  /**< Pointer to the value of the descriptor*/
N} ble_add_descr_params_t;
N
N
N/**@brief Function for adding a characteristic to a given service.
N *
N * If no pointer is given for the initial value,
N * the initial length parameter will be ignored and the initial length will be 0.
N *
N * @param[in]  service_handle Handle of the service to which the characteristic is to be added.
N * @param[in]  p_char_props   Information needed to add the characteristic.
N * @param[out] p_char_handle  Handle of the added characteristic.
N *
N * @retval      NRF_SUCCESS If the characteristic was added successfully. Otherwise, an error code is returned.
N */
Nuint32_t characteristic_add(uint16_t                   service_handle,
N                            ble_add_char_params_t *    p_char_props,
N                            ble_gatts_char_handles_t * p_char_handle);
N
N
N/**@brief Function for adding a characteristic's descriptor to a given characteristic.
N *
N * @param[in]  char_handle    Handle of the characteristic to which the descriptor is to be added, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
N * @param[in]  p_descr_props  Information needed to add the descriptor.
N * @param[out] p_descr_handle Handle of the added descriptor.
N *
N * @retval      NRF_SUCCESS If the characteristic was added successfully. Otherwise, an error code is returned.
N */
Nuint32_t descriptor_add(uint16_t                   char_handle,
N                        ble_add_descr_params_t *   p_descr_props,
N                        uint16_t *                 p_descr_handle);
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // BLE_SRV_COMMON_H__
N
N/** @} */
L 37 "..\..\..\main.c" 2
N#include "ble_advdata.h"
L 1 "..\..\..\..\..\..\components\ble\common\ble_advdata.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_sdk_lib_advdata Advertising and Scan Response Data Encoder
N * @{
N * @ingroup ble_sdk_lib
N * @brief Functions for encoding data in the Advertising and Scan Response Data format,
N *        and for passing the data to the stack.
N */
N
N#ifndef BLE_ADVDATA_H__
N#define BLE_ADVDATA_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <string.h>
N#include "ble.h"
N#include "app_util.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#define ADV_LENGTH_FIELD_SIZE              1UL                                 /**< Advertising Data and Scan Response format contains 1 octet for the length. */
N#define ADV_AD_TYPE_FIELD_SIZE             1UL                                 /**< Advertising Data and Scan Response format contains 1 octet for the AD type. */
N#define ADV_AD_DATA_OFFSET                 (ADV_LENGTH_FIELD_SIZE + \
N                                            ADV_AD_TYPE_FIELD_SIZE)            /**< Offset for the AD data field of the Advertising Data and Scan Response format. */
X#define ADV_AD_DATA_OFFSET                 (ADV_LENGTH_FIELD_SIZE +                                             ADV_AD_TYPE_FIELD_SIZE)             
N#define AD_TYPE_BLE_DEVICE_ADDR_TYPE_SIZE  1UL                                 /**< Data size (in octets) of the Address type of the LE Bluetooth Device Address AD type. */
N#define AD_TYPE_BLE_DEVICE_ADDR_DATA_SIZE  (BLE_GAP_ADDR_LEN + \
N                                            AD_TYPE_BLE_DEVICE_ADDR_TYPE_SIZE) /**< Data size (in octets) of the LE Bluetooth Device Address AD type. */
X#define AD_TYPE_BLE_DEVICE_ADDR_DATA_SIZE  (BLE_GAP_ADDR_LEN +                                             AD_TYPE_BLE_DEVICE_ADDR_TYPE_SIZE)  
N#define AD_TYPE_BLE_DEVICE_ADDR_SIZE       (ADV_AD_DATA_OFFSET + \
N                                            AD_TYPE_BLE_DEVICE_ADDR_DATA_SIZE) /**< Size (in octets) of the LE Bluetooth Device Address AD type. */
X#define AD_TYPE_BLE_DEVICE_ADDR_SIZE       (ADV_AD_DATA_OFFSET +                                             AD_TYPE_BLE_DEVICE_ADDR_DATA_SIZE)  
N#define AD_TYPE_APPEARANCE_DATA_SIZE       2UL                                 /**< Data size (in octets) of the Appearance AD type. */
N#define AD_TYPE_APPEARANCE_SIZE            (ADV_AD_DATA_OFFSET + \
N                                            AD_TYPE_APPEARANCE_DATA_SIZE)      /**< Size (in octets) of the Appearance AD type. */
X#define AD_TYPE_APPEARANCE_SIZE            (ADV_AD_DATA_OFFSET +                                             AD_TYPE_APPEARANCE_DATA_SIZE)       
N#define AD_TYPE_FLAGS_DATA_SIZE            1UL                                 /**< Data size (in octets) of the Flags AD type. */
N#define AD_TYPE_FLAGS_SIZE                 (ADV_AD_DATA_OFFSET + \
N                                            AD_TYPE_FLAGS_DATA_SIZE)           /**< Size (in octets) of the Flags AD type. */
X#define AD_TYPE_FLAGS_SIZE                 (ADV_AD_DATA_OFFSET +                                             AD_TYPE_FLAGS_DATA_SIZE)            
N#define AD_TYPE_TX_POWER_LEVEL_DATA_SIZE   1UL                                 /**< Data size (in octets) of the TX Power Level AD type. */
N#define AD_TYPE_TX_POWER_LEVEL_SIZE        (ADV_AD_DATA_OFFSET + \
N                                            AD_TYPE_TX_POWER_LEVEL_DATA_SIZE)  /**< Size (in octets) of the TX Power Level AD type. */
X#define AD_TYPE_TX_POWER_LEVEL_SIZE        (ADV_AD_DATA_OFFSET +                                             AD_TYPE_TX_POWER_LEVEL_DATA_SIZE)   
N#define AD_TYPE_CONN_INT_DATA_SIZE         4UL                                 /**< Data size (in octets) of the Slave Connection Interval Range AD type. */
N#define AD_TYPE_CONN_INT_SIZE              (ADV_AD_DATA_OFFSET + \
N                                            AD_TYPE_CONN_INT_DATA_SIZE)        /**< Data size (in octets) of the Slave Connection Interval Range AD type. */
X#define AD_TYPE_CONN_INT_SIZE              (ADV_AD_DATA_OFFSET +                                             AD_TYPE_CONN_INT_DATA_SIZE)         
N#define AD_TYPE_MANUF_SPEC_DATA_ID_SIZE    2UL                                 /**< Size (in octets) of the Company Identifier Code, which is a part of the Manufacturer Specific Data AD type. */
N#define AD_TYPE_SERV_DATA_16BIT_UUID_SIZE  2UL                                 /**< Size (in octets) of the 16-bit UUID, which is a part of the Service Data AD type. */
N
N/**@brief Security Manager TK value. */
Ntypedef struct
N{
N  uint8_t tk[BLE_GAP_SEC_KEY_LEN];   /**< Array containing TK value. */
X  uint8_t tk[16];    
N} ble_advdata_tk_value_t;
N
N/**@brief Advertising data LE Role types. This enumeration contains the options available for the LE role inside
N *        the advertising data. */
Ntypedef enum
N{
N    BLE_ADVDATA_ROLE_NOT_PRESENT = 0,                                 /**< LE Role AD structure not present. */
N    BLE_ADVDATA_ROLE_ONLY_PERIPH,                                     /**< Only Peripheral Role supported. */
N    BLE_ADVDATA_ROLE_ONLY_CENTRAL,                                    /**< Only Central Role supported. */
N    BLE_ADVDATA_ROLE_BOTH_PERIPH_PREFERRED,                           /**< Peripheral and Central Role supported. Peripheral Role preferred for connection establishment. */
N    BLE_ADVDATA_ROLE_BOTH_CENTRAL_PREFERRED                           /**< Peripheral and Central Role supported. Central Role preferred for connection establishment */
N} ble_advdata_le_role_t;
N
N/**@brief Advertising data name type. This enumeration contains the options available for the device name inside
N *        the advertising data. */
Ntypedef enum
N{
N    BLE_ADVDATA_NO_NAME,                                              /**< Include no device name in advertising data. */
N    BLE_ADVDATA_SHORT_NAME,                                           /**< Include short device name in advertising data. */
N    BLE_ADVDATA_FULL_NAME                                             /**< Include full device name in advertising data. */
N} ble_advdata_name_type_t;
N
N/**@brief UUID list type. */
Ntypedef struct
N{
N    uint16_t                     uuid_cnt;                            /**< Number of UUID entries. */
N    ble_uuid_t *                 p_uuids;                             /**< Pointer to UUID array entries. */
N} ble_advdata_uuid_list_t;
N
N/**@brief Connection interval range structure. */
Ntypedef struct
N{
N    uint16_t                     min_conn_interval;                   /**< Minimum connection interval, in units of 1.25 ms, range 6 to 3200 (7.5 ms to 4 s). */
N    uint16_t                     max_conn_interval;                   /**< Maximum connection interval, in units of 1.25 ms, range 6 to 3200 (7.5 ms to 4 s). The value 0xFFFF indicates no specific maximum. */
N} ble_advdata_conn_int_t;
N
N/**@brief Manufacturer specific data structure. */
Ntypedef struct
N{
N    uint16_t                     company_identifier;                  /**< Company identifier code. */
N    uint8_array_t                data;                                /**< Additional manufacturer specific data. */
N} ble_advdata_manuf_data_t;
N
N/**@brief Service data structure. */
Ntypedef struct
N{
N    uint16_t                     service_uuid;                        /**< Service UUID. */
N    uint8_array_t                data;                                /**< Additional service data. */
N} ble_advdata_service_data_t;
N
N/**@brief Advertising data structure. This structure contains all options and data needed for encoding and
N *        setting the advertising data. */
Ntypedef struct
N{
N    ble_advdata_name_type_t      name_type;                           /**< Type of device name. */
N    uint8_t                      short_name_len;                      /**< Length of short device name (if short type is specified). */
N    bool                         include_appearance;                  /**< Determines if Appearance shall be included. */
X    _Bool                         include_appearance;                   
N    uint8_t                      flags;                               /**< Advertising data Flags field. */
N    int8_t *                     p_tx_power_level;                    /**< TX Power Level field. */
N    ble_advdata_uuid_list_t      uuids_more_available;                /**< List of UUIDs in the 'More Available' list. */
N    ble_advdata_uuid_list_t      uuids_complete;                      /**< List of UUIDs in the 'Complete' list. */
N    ble_advdata_uuid_list_t      uuids_solicited;                     /**< List of solicited UUIDs. */
N    ble_advdata_conn_int_t *     p_slave_conn_int;                    /**< Slave Connection Interval Range. */
N    ble_advdata_manuf_data_t *   p_manuf_specific_data;               /**< Manufacturer specific data. */
N    ble_advdata_service_data_t * p_service_data_array;                /**< Array of Service data structures. */
N    uint8_t                      service_data_count;                  /**< Number of Service data structures. */
N    bool                         include_ble_device_addr;             /**< Determines if LE Bluetooth Device Address shall be included. */
X    _Bool                         include_ble_device_addr;              
N    ble_advdata_le_role_t        le_role;                             /**< LE Role field. Included when different from @ref BLE_ADVDATA_ROLE_NOT_PRESENT. @warning This field can be used only for NFC. For BLE advertising, set it to NULL. */
N    ble_advdata_tk_value_t *     p_tk_value;                          /**< Security Manager TK value field. Included when different from NULL. @warning This field can be used only for NFC. For BLE advertising, set it to NULL.*/
N    uint8_t *                    p_sec_mgr_oob_flags;                 /**< Security Manager Out Of Band Flags field. Included when different from NULL. @warning This field can be used only for NFC. For BLE advertising, set it to NULL.*/
N} ble_advdata_t;
N
N/**@brief Function for encoding data in the Advertising and Scan Response data format
N *        (AD structures).
N *
N * @details This function encodes data into the Advertising and Scan Response data format
N *          (AD structures) based on the selections in the supplied structures. This function can be used to
N *          create a payload of Advertising packet or Scan Response packet, or a payload of NFC
N *          message intended for initiating the Out-of-Band pairing.
N *
N * @param[in]      p_advdata       Pointer to the structure for specifying the content of encoded data.
N * @param[out]     p_encoded_data  Pointer to the buffer where encoded data will be returned.
N * @param[in,out]  p_len           \c in: Size of \p p_encoded_data buffer.
N *                                 \c out: Length of encoded data.
N *
N * @retval NRF_SUCCESS             If the operation was successful.
N * @retval NRF_ERROR_INVALID_PARAM If the operation failed because a wrong parameter was provided in \p p_advdata.
N * @retval NRF_ERROR_DATA_SIZE     If the operation failed because not all the requested data could fit into the
N *                                 provided buffer or some encoded AD structure is too long and its
N *                                 length cannot be encoded with one octet.
N *
N * @warning This API may override the application's request to use the long name and use a short name
N * instead. This truncation will occur in case the long name does not fit the provided buffer size.
N * The application can specify a preferred short name length if truncation is required.
N * For example, if the complete device name is ABCD_HRMonitor, the application can specify the short name
N * length to be 8, so that the short device name appears as ABCD_HRM instead of ABCD_HRMo or ABCD_HRMoni
N * if the available size for the short name is 9 or 12 respectively, to have a more appropriate short name.
N * However, it should be noted that this is just a preference that the application can specify, and
N * if the preference is too large to fit in the provided buffer, the name can be truncated further.
N */
Nuint32_t adv_data_encode(ble_advdata_t const * const p_advdata,
N                         uint8_t             * const p_encoded_data,
N                         uint16_t            * const p_len);
N
N/**@brief Function for encoding and setting the advertising data and/or scan response data.
N *
N * @details This function encodes advertising data and/or scan response data based on the selections
N *          in the supplied structures, and passes the encoded data to the stack.
N *
N * @param[in]   p_advdata   Structure for specifying the content of the advertising data.
N *                          Set to NULL if advertising data is not to be set.
N * @param[in]   p_srdata    Structure for specifying the content of the scan response data.
N *                          Set to NULL if scan response data is not to be set.
N *
N * @retval NRF_SUCCESS             If the operation was successful.
N * @retval NRF_ERROR_INVALID_PARAM If the operation failed because a wrong parameter was provided in \p p_advdata.
N * @retval NRF_ERROR_DATA_SIZE     If the operation failed because not all the requested data could fit into the
N *                                 advertising packet. The maximum size of the advertisement packet
N *                                 is @ref BLE_GAP_ADV_MAX_SIZE.
N *
N * @warning This API may override the application's request to use the long name and use a short name
N * instead. This truncation will occur in case the long name does not fit the provided buffer size.
N * The application can specify a preferred short name length if truncation is required.
N * For example, if the complete device name is ABCD_HRMonitor, the application can specify the short name
N * length to be 8, so that the short device name appears as ABCD_HRM instead of ABCD_HRMo or ABCD_HRMoni
N * if the available size for the short name is 9 or 12 respectively, to have a more appropriate short name.
N * However, it should be noted that this is just a preference that the application can specify, and
N * if the preference is too large to fit in the provided buffer, the name can be truncated further.
N */
Nuint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // BLE_ADVDATA_H__
N
N/** @} */
L 38 "..\..\..\main.c" 2
N#include "ble_advertising.h"
L 1 "..\..\..\..\..\..\components\ble\ble_advertising\ble_advertising.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N */
N
N
N/**@file
N *
N * @defgroup ble_advertising Advertising Module
N * @{
N * @ingroup  ble_sdk_lib
N * @brief    Module for handling connectable BLE advertising.
N *
N * @details  The Advertising Module handles connectable advertising for your application. It can
N *           be configured with advertising modes to suit most typical use cases.
N *           Your main application can react to changes in advertising modes
N *           if an event handler is provided.
N *
N * @note     The Advertising Module supports only applications with a single peripheral link.
N *
N * The application must propagate BLE stack events to this module by calling
N * @ref ble_advertising_on_ble_evt() and system events by calling
N * @ref ble_advertising_on_sys_evt().
N *
N */
N
N#ifndef BLE_ADVERTISING_H__
N#define BLE_ADVERTISING_H__
N
N#include <stdint.h>
N#include "nrf_error.h"
N#include "ble.h"
N#include "ble_gattc.h"
N#include "ble_advdata.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**@brief Advertising modes.
N*/
Ntypedef enum
N{
N    BLE_ADV_MODE_IDLE,          /**< Idle; no connectable advertising is ongoing. */
N    BLE_ADV_MODE_DIRECTED,      /**< Directed advertising attempts to connect to the most recently disconnected peer. */
N    BLE_ADV_MODE_DIRECTED_SLOW, /**< Directed advertising (low duty cycle) attempts to connect to the most recently disconnected peer. */
N    BLE_ADV_MODE_FAST,          /**< Fast advertising will connect to any peer device, or filter with a whitelist if one exists. */
N    BLE_ADV_MODE_SLOW,          /**< Slow advertising is similar to fast advertising. By default, it uses a longer advertising interval and time-out than fast advertising. However, these options are defined by the user. */
N} ble_adv_mode_t;
N
N/**@brief Advertising events.
N *
N * @details These events are propagated to the main application if a handler was provided during
N *          initialization of the Advertising Module. Events for modes that are not used can be
N *          ignored. Similarly, BLE_ADV_EVT_WHITELIST_REQUEST and BLE_ADV_EVT_PEER_ADDR_REQUEST
N *          can be ignored if whitelist and direct advertising is not used.
N */
Ntypedef enum
N{
N    BLE_ADV_EVT_IDLE,                /**< Idle; no connectable advertising is ongoing.*/
N    BLE_ADV_EVT_DIRECTED,            /**< Direct advertising mode has started. */
N    BLE_ADV_EVT_DIRECTED_SLOW,       /**< Directed advertising (low duty cycle) has started. */
N    BLE_ADV_EVT_FAST,                /**< Fast advertising mode has started. */
N    BLE_ADV_EVT_SLOW,                /**< Slow advertising mode has started. */
N    BLE_ADV_EVT_FAST_WHITELIST,      /**< Fast advertising mode using the whitelist has started. */
N    BLE_ADV_EVT_SLOW_WHITELIST,      /**< Slow advertising mode using the whitelist has started. */
N    BLE_ADV_EVT_WHITELIST_REQUEST,   /**< Request a whitelist from the main application. For whitelist advertising to work, the whitelist must be set when this event occurs. */
N    BLE_ADV_EVT_PEER_ADDR_REQUEST    /**< Request a peer address from the main application. For directed advertising to work, the peer address must be set when this event occurs. */
N} ble_adv_evt_t;
N
N
N/**@brief Options for the different advertisement modes.
N *
N * @details This structure is used to enable or disable advertising modes and to configure time-out
N *          periods and advertising intervals.
N */
Ntypedef struct
N{
N    bool     ble_adv_whitelist_enabled;       /**< Enable or disable use of the whitelist. */
X    _Bool     ble_adv_whitelist_enabled;        
N    bool     ble_adv_directed_enabled;        /**< Enable or disable direct advertising mode. */
X    _Bool     ble_adv_directed_enabled;         
N    bool     ble_adv_directed_slow_enabled;   /**< Enable or disable direct advertising mode. */
X    _Bool     ble_adv_directed_slow_enabled;    
N    bool     ble_adv_fast_enabled;            /**< Enable or disable fast advertising mode. */
X    _Bool     ble_adv_fast_enabled;             
N    bool     ble_adv_slow_enabled;            /**< Enable or disable slow advertising mode. */
X    _Bool     ble_adv_slow_enabled;             
N    uint32_t ble_adv_directed_slow_interval;  /**< Advertising interval for directed advertising. */
N    uint32_t ble_adv_directed_slow_timeout;   /**< Time-out (number of tries) for direct advertising. */
N    uint32_t ble_adv_fast_interval;           /**< Advertising interval for fast advertising. */
N    uint32_t ble_adv_fast_timeout;            /**< Time-out (in seconds) for fast advertising. */
N    uint32_t ble_adv_slow_interval;           /**< Advertising interval for slow advertising. */
N    uint32_t ble_adv_slow_timeout;            /**< Time-out (in seconds) for slow advertising. */
N} ble_adv_modes_config_t;
N
N
Ntypedef struct
N{
N    uint32_t interval;
N    uint32_t timeout;
N    bool     enabled;
X    _Bool     enabled;
N} ble_adv_mode_config_t;
N
N
N/**@brief BLE advertising event handler type. */
Ntypedef void (*ble_advertising_evt_handler_t) (ble_adv_evt_t const adv_evt);
N
N/**@brief BLE advertising error handler type. */
Ntypedef void (*ble_advertising_error_handler_t) (uint32_t nrf_error);
N
N/**@brief Initialization parameters for the Advertising Module.
N * @details This structure is used to pass advertising options, advertising data, and an event handler to the Advertising Module during initialization. */
Ntypedef struct
N{
N    ble_adv_modes_config_t        options;     /**< Parameters for advertising modes.*/
N    ble_advdata_t                 advdata;     /**< Advertising data. */
N    ble_advertising_evt_handler_t evt_handler; /**< Event handler. */
N} ble_adv_init_t;
N
N
N/**@brief Function for handling BLE events.
N *
N * @details This function must be called from the BLE stack event dispatcher for
N *          the module to handle BLE events that are relevant for the Advertising Module.
N *
N * @param[in] p_ble_evt BLE stack event.
N */
Nvoid ble_advertising_on_ble_evt(const ble_evt_t * const p_ble_evt);
N
N
N/**@brief Function for handling system events.
N *
N * @details This function must be called to handle system events that are relevant
N *          for the Advertising Module. Specifically, the advertising module can not use the
N *          softdevice as long as there are pending writes to the flash memory. This
N *          event handler is designed to delay advertising until there is no flash operation.
N *
N * @param[in] sys_evt  System event.
N */
Nvoid ble_advertising_on_sys_evt(uint32_t sys_evt);
N
N
N/**@brief Function for initializing the Advertising Module.
N *
N * @details Encodes the required advertising data and passes it to the stack.
N *          Also builds a structure to be passed to the stack when starting advertising.
N *          The supplied advertising data is copied to a local structure and is manipulated
N *          depending on what advertising modes are started in @ref ble_advertising_start.
N *
N * @param[in] p_advdata     Advertising data: name, appearance, discovery flags, and more.
N * @param[in] p_srdata      Scan response data: Supplement to advertising data.
N * @param[in] p_config      Select which advertising modes and intervals will be utilized.
N * @param[in] evt_handler   Event handler that will be called upon advertising events.
N * @param[in] error_handler Error handler that will propogate internal errors to the main applications.
N *
N * @retval NRF_SUCCESS If initialization was successful. Otherwise, an error code is returned.
N */
Nuint32_t ble_advertising_init(ble_advdata_t                   const * p_advdata,
N                              ble_advdata_t                   const * p_srdata,
N                              ble_adv_modes_config_t          const * p_config,
N                              ble_advertising_evt_handler_t   const   evt_handler,
N                              ble_advertising_error_handler_t const   error_handler);
N
N
N/**@brief Function for starting advertising.
N *
N * @details You can start advertising in any of the advertising modes that you enabled
N *          during initialization.
N *
N * @param[in] advertising_mode  Advertising mode.
N *
N * @retval @ref NRF_SUCCESS On success, else an error code indicating reason for failure.
N * @retval @ref NRF_ERROR_INVALID_STATE If the module is not initialized.
N */
Nuint32_t ble_advertising_start(ble_adv_mode_t advertising_mode);
N
N
N/**@brief Function for setting the peer address.
N *
N * @details The peer address must be set by the application upon receiving a
N *          @ref BLE_ADV_EVT_PEER_ADDR_REQUEST event. Without the peer address, the directed
N *          advertising mode will not be run.
N *
N * @param[in] p_peer_addr  Pointer to a peer address.
N *
N * @retval @ref NRF_SUCCESS Successfully stored the peer address pointer in the advertising module.
N * @retval @ref NRF_ERROR_INVALID_STATE If a reply was not expected.
N */
Nuint32_t ble_advertising_peer_addr_reply(ble_gap_addr_t * p_peer_addr);
N
N
N/**@brief Function for setting a whitelist.
N *
N * @details The whitelist must be set by the application upon receiving a
N *          @ref BLE_ADV_EVT_WHITELIST_REQUEST event. Without the whitelist, the whitelist
N *          advertising for fast and slow modes will not be run.
N *
N * @param[in] p_gap_addrs   The list of GAP addresses to whitelist.
N * @param[in] addr_cnt      The number of GAP addresses to whitelist.
N * @param[in] p_gap_irks    The list of peer IRK to whitelist.
N * @param[in] irk_cnt       The number of peer IRK to whitelist.
N *
N * @retval @ref NRF_SUCCESS                 If the operation was successful.
N * @retval @ref NRF_ERROR_INVALID_STATE     If a call to this function was made without a
N *                                          BLE_ADV_EVT_WHITELIST_REQUEST event being received.
N */
Nuint32_t ble_advertising_whitelist_reply(ble_gap_addr_t const * p_gap_addrs,
N                                         uint32_t               addr_cnt,
N                                         ble_gap_irk_t  const * p_gap_irks,
N                                         uint32_t               irk_cnt);
N
N
N/**@brief Function for disabling whitelist advertising.
N *
N * @details This function temporarily disables whitelist advertising.
N *          Calling this function resets the current time-out countdown.
N *
N * @retval @ref NRF_SUCCESS On success, else an error message propogated from the Softdevice.
N */
Nuint32_t ble_advertising_restart_without_whitelist(void);
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // BLE_ADVERTISING_H__
N
N/** @} */
L 39 "..\..\..\main.c" 2
N#include "ble_conn_params.h"
L 1 "..\..\..\..\..\..\components\ble\common\ble_conn_params.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_sdk_lib_conn_params Connection Parameters Negotiation
N * @{
N * @ingroup ble_sdk_lib
N * @brief Module for initiating and executing a connection parameters negotiation procedure.
N */
N
N#ifndef BLE_CONN_PARAMS_H__
N#define BLE_CONN_PARAMS_H__
N
N#include <stdint.h>
N#include "ble.h"
N#include "ble_srv_common.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**@brief Connection Parameters Module event type. */
Ntypedef enum
N{
N    BLE_CONN_PARAMS_EVT_FAILED   ,                                  /**< Negotiation procedure failed. */
N    BLE_CONN_PARAMS_EVT_SUCCEEDED                                   /**< Negotiation procedure succeeded. */
N} ble_conn_params_evt_type_t;
N
N/**@brief Connection Parameters Module event. */
Ntypedef struct
N{
N    ble_conn_params_evt_type_t evt_type;                            /**< Type of event. */
N} ble_conn_params_evt_t;
N
N/**@brief Connection Parameters Module event handler type. */
Ntypedef void (*ble_conn_params_evt_handler_t) (ble_conn_params_evt_t * p_evt);
N
N/**@brief Connection Parameters Module init structure. This contains all options and data needed for
N *        initialization of the connection parameters negotiation module. */
Ntypedef struct
N{
N    ble_gap_conn_params_t *       p_conn_params;                    /**< Pointer to the connection parameters desired by the application. When calling ble_conn_params_init, if this parameter is set to NULL, the connection parameters will be fetched from host. */
N    uint32_t                      first_conn_params_update_delay;   /**< Time from initiating event (connect or start of notification) to first time sd_ble_gap_conn_param_update is called (in number of timer ticks). */
N    uint32_t                      next_conn_params_update_delay;    /**< Time between each call to sd_ble_gap_conn_param_update after the first (in number of timer ticks). Recommended value 30 seconds as per BLUETOOTH SPECIFICATION Version 4.0. */
N    uint8_t                       max_conn_params_update_count;     /**< Number of attempts before giving up the negotiation. */
N    uint16_t                      start_on_notify_cccd_handle;      /**< If procedure is to be started when notification is started, set this to the handle of the corresponding CCCD. Set to BLE_GATT_HANDLE_INVALID if procedure is to be started on connect event. */
N    bool                          disconnect_on_fail;               /**< Set to TRUE if a failed connection parameters update shall cause an automatic disconnection, set to FALSE otherwise. */
X    _Bool                          disconnect_on_fail;                
N    ble_conn_params_evt_handler_t evt_handler;                      /**< Event handler to be called for handling events in the Connection Parameters. */
N    ble_srv_error_handler_t       error_handler;                    /**< Function to be called in case of an error. */
N} ble_conn_params_init_t;
N
N
N/**@brief Function for initializing the Connection Parameters module.
N *
N * @note If the negotiation procedure should be triggered when notification/indication of
N *       any characteristic is enabled by the peer, then this function must be called after
N *       having initialized the services.
N *
N * @param[in]   p_init  This contains information needed to initialize this module.
N *
N * @return      NRF_SUCCESS on successful initialization, otherwise an error code.
N */
Nuint32_t ble_conn_params_init(const ble_conn_params_init_t * p_init);
N
N/**@brief Function for stopping the Connection Parameters module.
N *
N * @details This function is intended to be used by the application to clean up the connection
N *          parameters update module. This will stop the connection parameters update timer if
N *          running, thereby preventing any impending connection parameters update procedure. This
N *          function must be called by the application when it needs to clean itself up (for
N *          example, before disabling the bluetooth SoftDevice) so that an unwanted timer expiry
N *          event can be avoided.
N *
N * @return      NRF_SUCCESS on successful initialization, otherwise an error code.
N */
Nuint32_t ble_conn_params_stop(void);
N
N/**@brief Function for changing the current connection parameters to a new set.
N *
N *  @details Use this function to change the connection parameters to a new set of parameter
N *       (ie different from the ones given at init of the module).
N *       This function is usefull for scenario where most of the time the application
N *       needs a relatively big connection interval, and just sometimes, for a temporary
N *       period requires shorter connection interval, for example to transfer a higher
N *       amount of data.
N *       If the given parameters does not match the current connection's parameters
N *       this function initiates a new negotiation.
N *
N * @param[in]   new_params  This contains the new connections parameters to setup.
N *
N * @return      NRF_SUCCESS on successful initialization, otherwise an error code.
N */
Nuint32_t ble_conn_params_change_conn_params(ble_gap_conn_params_t *new_params);
N
N/**@brief Function for handling the Application's BLE Stack events.
N *
N * @details Handles all events from the BLE stack that are of interest to this module.
N *
N * @param[in]   p_ble_evt  The event received from the BLE stack.
N */
Nvoid ble_conn_params_on_ble_evt(ble_evt_t * p_ble_evt);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // BLE_CONN_PARAMS_H__
N
N/** @} */
L 40 "..\..\..\main.c" 2
N#include "ble_hrs.h"
L 1 "..\..\..\..\..\..\components\ble\ble_services\ble_hrs\ble_hrs.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_hrs Heart Rate Service
N * @{
N * @ingroup ble_sdk_srv
N * @brief Heart Rate Service module.
N *
N * @details This module implements the Heart Rate Service with the Heart Rate Measurement,
N *          Body Sensor Location and Heart Rate Control Point characteristics.
N *          During initialization it adds the Heart Rate Service and Heart Rate Measurement
N *          characteristic to the BLE stack database. Optionally it also adds the
N *          Body Sensor Location and Heart Rate Control Point characteristics.
N *
N *          If enabled, notification of the Heart Rate Measurement characteristic is performed
N *          when the application calls ble_hrs_heart_rate_measurement_send().
N *
N *          The Heart Rate Service also provides a set of functions for manipulating the
N *          various fields in the Heart Rate Measurement characteristic, as well as setting
N *          the Body Sensor Location characteristic value.
N *
N *          If an event handler is supplied by the application, the Heart Rate Service will
N *          generate Heart Rate Service events to the application.
N *
N * @note The application must propagate BLE stack events to the Heart Rate Service module by calling
N *       ble_hrs_on_ble_evt() from the @ref softdevice_handler callback.
N *
N * @note Attention!
N *  To maintain compliance with Nordic Semiconductor ASA Bluetooth profile
N *  qualification listings, this section of source code must not be modified.
N */
N
N#ifndef BLE_HRS_H__
N#define BLE_HRS_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "ble.h"
N#include "ble_srv_common.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N// Body Sensor Location values
N#define BLE_HRS_BODY_SENSOR_LOCATION_OTHER      0
N#define BLE_HRS_BODY_SENSOR_LOCATION_CHEST      1
N#define BLE_HRS_BODY_SENSOR_LOCATION_WRIST      2
N#define BLE_HRS_BODY_SENSOR_LOCATION_FINGER     3
N#define BLE_HRS_BODY_SENSOR_LOCATION_HAND       4
N#define BLE_HRS_BODY_SENSOR_LOCATION_EAR_LOBE   5
N#define BLE_HRS_BODY_SENSOR_LOCATION_FOOT       6
N
N#define BLE_HRS_MAX_BUFFERED_RR_INTERVALS       20      /**< Size of RR Interval buffer inside service. */
N
N/**@brief Heart Rate Service event type. */
Ntypedef enum
N{
N    BLE_HRS_EVT_NOTIFICATION_ENABLED,                   /**< Heart Rate value notification enabled event. */
N    BLE_HRS_EVT_NOTIFICATION_DISABLED                   /**< Heart Rate value notification disabled event. */
N} ble_hrs_evt_type_t;
N
N/**@brief Heart Rate Service event. */
Ntypedef struct
N{
N    ble_hrs_evt_type_t evt_type;                        /**< Type of event. */
N} ble_hrs_evt_t;
N
N// Forward declaration of the ble_hrs_t type.
Ntypedef struct ble_hrs_s ble_hrs_t;
N
N/**@brief Heart Rate Service event handler type. */
Ntypedef void (*ble_hrs_evt_handler_t) (ble_hrs_t * p_hrs, ble_hrs_evt_t * p_evt);
N
N/**@brief Heart Rate Service init structure. This contains all options and data needed for
N *        initialization of the service. */
Ntypedef struct
N{
N    ble_hrs_evt_handler_t        evt_handler;                                          /**< Event handler to be called for handling events in the Heart Rate Service. */
N    bool                         is_sensor_contact_supported;                          /**< Determines if sensor contact detection is to be supported. */
X    _Bool                         is_sensor_contact_supported;                           
N    uint8_t *                    p_body_sensor_location;                               /**< If not NULL, initial value of the Body Sensor Location characteristic. */
N    ble_srv_cccd_security_mode_t hrs_hrm_attr_md;                                      /**< Initial security level for heart rate service measurement attribute */
N    ble_srv_security_mode_t      hrs_bsl_attr_md;                                      /**< Initial security level for body sensor location attribute */
N} ble_hrs_init_t;
N
N/**@brief Heart Rate Service structure. This contains various status information for the service. */
Nstruct ble_hrs_s
N{
N    ble_hrs_evt_handler_t        evt_handler;                                          /**< Event handler to be called for handling events in the Heart Rate Service. */
N    bool                         is_expended_energy_supported;                         /**< TRUE if Expended Energy measurement is supported. */
X    _Bool                         is_expended_energy_supported;                          
N    bool                         is_sensor_contact_supported;                          /**< TRUE if sensor contact detection is supported. */
X    _Bool                         is_sensor_contact_supported;                           
N    uint16_t                     service_handle;                                       /**< Handle of Heart Rate Service (as provided by the BLE stack). */
N    ble_gatts_char_handles_t     hrm_handles;                                          /**< Handles related to the Heart Rate Measurement characteristic. */
N    ble_gatts_char_handles_t     bsl_handles;                                          /**< Handles related to the Body Sensor Location characteristic. */
N    ble_gatts_char_handles_t     hrcp_handles;                                         /**< Handles related to the Heart Rate Control Point characteristic. */
N    uint16_t                     conn_handle;                                          /**< Handle of the current connection (as provided by the BLE stack, is BLE_CONN_HANDLE_INVALID if not in a connection). */
N    bool                         is_sensor_contact_detected;                           /**< TRUE if sensor contact has been detected. */
X    _Bool                         is_sensor_contact_detected;                            
N    uint16_t                     rr_interval[BLE_HRS_MAX_BUFFERED_RR_INTERVALS];       /**< Set of RR Interval measurements since the last Heart Rate Measurement transmission. */
X    uint16_t                     rr_interval[20];        
N    uint16_t                     rr_interval_count;                                    /**< Number of RR Interval measurements since the last Heart Rate Measurement transmission. */
N};
N
N/**@brief Function for initializing the Heart Rate Service.
N *
N * @param[out]  p_hrs       Heart Rate Service structure. This structure will have to be supplied by
N *                          the application. It will be initialized by this function, and will later
N *                          be used to identify this particular service instance.
N * @param[in]   p_hrs_init  Information needed to initialize the service.
N *
N * @return      NRF_SUCCESS on successful initialization of service, otherwise an error code.
N */
Nuint32_t ble_hrs_init(ble_hrs_t * p_hrs, const ble_hrs_init_t * p_hrs_init);
N
N/**@brief Function for handling the Application's BLE Stack events.
N *
N * @details Handles all events from the BLE stack of interest to the Heart Rate Service.
N *
N * @param[in]   p_hrs      Heart Rate Service structure.
N * @param[in]   p_ble_evt  Event received from the BLE stack.
N */
Nvoid ble_hrs_on_ble_evt(ble_hrs_t * p_hrs, ble_evt_t * p_ble_evt);
N
N/**@brief Function for sending heart rate measurement if notification has been enabled.
N *
N * @details The application calls this function after having performed a heart rate measurement.
N *          If notification has been enabled, the heart rate measurement data is encoded and sent to
N *          the client.
N *
N * @param[in]   p_hrs                    Heart Rate Service structure.
N * @param[in]   heart_rate               New heart rate measurement.
N *
N * @return      NRF_SUCCESS on success, otherwise an error code.
N */
Nuint32_t ble_hrs_heart_rate_measurement_send(ble_hrs_t * p_hrs, uint16_t heart_rate);
N
N/**@brief Function for adding a RR Interval measurement to the RR Interval buffer.
N *
N * @details All buffered RR Interval measurements will be included in the next heart rate
N *          measurement message, up to the maximum number of measurements that will fit into the
N *          message. If the buffer is full, the oldest measurement in the buffer will be deleted.
N *
N * @param[in]   p_hrs        Heart Rate Service structure.
N * @param[in]   rr_interval  New RR Interval measurement (will be buffered until the next
N *                           transmission of Heart Rate Measurement).
N */
Nvoid ble_hrs_rr_interval_add(ble_hrs_t * p_hrs, uint16_t rr_interval);
N
N/**@brief Function for checking if RR Interval buffer is full.
N *
N * @param[in]   p_hrs        Heart Rate Service structure.
N *
N * @return      true if RR Interval buffer is full, false otherwise.
N */
Nbool ble_hrs_rr_interval_buffer_is_full(ble_hrs_t * p_hrs);
X_Bool ble_hrs_rr_interval_buffer_is_full(ble_hrs_t * p_hrs);
N
N/**@brief Function for setting the state of the Sensor Contact Supported bit.
N *
N * @param[in]   p_hrs                        Heart Rate Service structure.
N * @param[in]   is_sensor_contact_supported  New state of the Sensor Contact Supported bit.
N *
N * @return      NRF_SUCCESS on success, otherwise an error code.
N */
Nuint32_t ble_hrs_sensor_contact_supported_set(ble_hrs_t * p_hrs, bool is_sensor_contact_supported);
Xuint32_t ble_hrs_sensor_contact_supported_set(ble_hrs_t * p_hrs, _Bool is_sensor_contact_supported);
N
N/**@brief Function for setting the state of the Sensor Contact Detected bit.
N *
N * @param[in]   p_hrs                        Heart Rate Service structure.
N * @param[in]   is_sensor_contact_detected   TRUE if sensor contact is detected, FALSE otherwise.
N */
Nvoid ble_hrs_sensor_contact_detected_update(ble_hrs_t * p_hrs, bool is_sensor_contact_detected);
Xvoid ble_hrs_sensor_contact_detected_update(ble_hrs_t * p_hrs, _Bool is_sensor_contact_detected);
N
N/**@brief Function for setting the Body Sensor Location.
N *
N * @details Sets a new value of the Body Sensor Location characteristic. The new value will be sent
N *          to the client the next time the client reads the Body Sensor Location characteristic.
N *
N * @param[in]   p_hrs                 Heart Rate Service structure.
N * @param[in]   body_sensor_location  New Body Sensor Location.
N *
N * @return      NRF_SUCCESS on success, otherwise an error code.
N */
Nuint32_t ble_hrs_body_sensor_location_set(ble_hrs_t * p_hrs, uint8_t body_sensor_location);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // BLE_HRS_H__
N
N/** @} */
L 41 "..\..\..\main.c" 2
N#include "boards.h"
L 1 "..\..\..\..\..\bsp\boards.h" 1
N/* Copyright (c) 2014 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N#ifndef BOARDS_H
N#define BOARDS_H
N
N#include "nrf_gpio.h"
L 1 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_gpio.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N*
N* The information contained herein is property of Nordic Semiconductor ASA.
N* Terms and conditions of usage are described in detail in NORDIC
N* SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N*
N* Licensees are granted free, non-transferable use of the information. NO
N* WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N* the file.
N*
N*/
N#ifndef NRF_GPIO_H__
N#define NRF_GPIO_H__
N
N#include "nrf.h"
N#include <stdbool.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @defgroup nrf_gpio GPIO abstraction
N * @{
N * @ingroup nrf_drivers
N * @brief GPIO pin abstraction and port abstraction for reading and writing byte-wise to GPIO ports.
N *
N * Here, the GPIO ports are defined as follows:
N * - Port 0 -> pin 0-7
N * - Port 1 -> pin 8-15
N * - Port 2 -> pin 16-23
N * - Port 3 -> pin 24-31
N */
N
N#define NUMBER_OF_PINS 32
N
N/**
N * @brief Enumerator used for selecting between port 0 - 3.
N */
Ntypedef enum
N{
N    NRF_GPIO_PORT_SELECT_PORT0 = 0,           ///<  Port 0 (GPIO pin 0-7)
N    NRF_GPIO_PORT_SELECT_PORT1,               ///<  Port 1 (GPIO pin 8-15)
N    NRF_GPIO_PORT_SELECT_PORT2,               ///<  Port 2 (GPIO pin 16-23)
N    NRF_GPIO_PORT_SELECT_PORT3,               ///<  Port 3 (GPIO pin 24-31)
N} nrf_gpio_port_select_t;
N
N/**
N * @brief Enumerator used for setting the direction of a GPIO port.
N */
Ntypedef enum
N{
N    NRF_GPIO_PORT_DIR_OUTPUT,       ///<  Output
N    NRF_GPIO_PORT_DIR_INPUT         ///<  Input
N} nrf_gpio_port_dir_t;
N
N/**
N * @brief Pin direction definitions.
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_DIR_INPUT  = GPIO_PIN_CNF_DIR_Input,   ///< Input
X    NRF_GPIO_PIN_DIR_INPUT  = (0UL),   
N    NRF_GPIO_PIN_DIR_OUTPUT = GPIO_PIN_CNF_DIR_Output   ///< Output
X    NRF_GPIO_PIN_DIR_OUTPUT = (1UL)   
N} nrf_gpio_pin_dir_t;
N
N/**
N * @brief Connection of input buffer
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_INPUT_CONNECT    = GPIO_PIN_CNF_INPUT_Connect,   ///< Connect input buffer
X    NRF_GPIO_PIN_INPUT_CONNECT    = (0UL),   
N    NRF_GPIO_PIN_INPUT_DISCONNECT = GPIO_PIN_CNF_INPUT_Disconnect ///< Disconnect input buffer
X    NRF_GPIO_PIN_INPUT_DISCONNECT = (1UL) 
N} nrf_gpio_pin_input_t;
N
N/**
N * @brief Enumerator used for selecting the pin to be pulled down or up at the time of pin configuration
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_NOPULL   = GPIO_PIN_CNF_PULL_Disabled,                 ///<  Pin pullup resistor disabled
X    NRF_GPIO_PIN_NOPULL   = (0UL),                 
N    NRF_GPIO_PIN_PULLDOWN = GPIO_PIN_CNF_PULL_Pulldown,                 ///<  Pin pulldown resistor enabled
X    NRF_GPIO_PIN_PULLDOWN = (1UL),                 
N    NRF_GPIO_PIN_PULLUP   = GPIO_PIN_CNF_PULL_Pullup,                   ///<  Pin pullup resistor enabled
X    NRF_GPIO_PIN_PULLUP   = (3UL),                   
N} nrf_gpio_pin_pull_t;
N
N/**
N * @brief Enumerator used for selecting output drive mode
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_S0S1 = GPIO_PIN_CNF_DRIVE_S0S1, ///< !< Standard '0', standard '1'
X    NRF_GPIO_PIN_S0S1 = (0UL), 
N    NRF_GPIO_PIN_H0S1 = GPIO_PIN_CNF_DRIVE_H0S1, ///< !< High drive '0', standard '1'
X    NRF_GPIO_PIN_H0S1 = (1UL), 
N    NRF_GPIO_PIN_S0H1 = GPIO_PIN_CNF_DRIVE_S0H1, ///< !< Standard '0', high drive '1'
X    NRF_GPIO_PIN_S0H1 = (2UL), 
N    NRF_GPIO_PIN_H0H1 = GPIO_PIN_CNF_DRIVE_H0H1, ///< !< High drive '0', high 'drive '1''
X    NRF_GPIO_PIN_H0H1 = (3UL), 
N    NRF_GPIO_PIN_D0S1 = GPIO_PIN_CNF_DRIVE_D0S1, ///< !< Disconnect '0' standard '1'
X    NRF_GPIO_PIN_D0S1 = (4UL), 
N    NRF_GPIO_PIN_D0H1 = GPIO_PIN_CNF_DRIVE_D0H1, ///< !< Disconnect '0', high drive '1'
X    NRF_GPIO_PIN_D0H1 = (5UL), 
N    NRF_GPIO_PIN_S0D1 = GPIO_PIN_CNF_DRIVE_S0D1, ///< !< Standard '0'. disconnect '1'
X    NRF_GPIO_PIN_S0D1 = (6UL), 
N    NRF_GPIO_PIN_H0D1 = GPIO_PIN_CNF_DRIVE_H0D1, ///< !< High drive '0', disconnect '1'
X    NRF_GPIO_PIN_H0D1 = (7UL), 
N} nrf_gpio_pin_drive_t;
N
N/**
N * @brief Enumerator used for selecting the pin to sense high or low level on the pin input.
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_NOSENSE    = GPIO_PIN_CNF_SENSE_Disabled,              ///<  Pin sense level disabled.
X    NRF_GPIO_PIN_NOSENSE    = (0UL),              
N    NRF_GPIO_PIN_SENSE_LOW  = GPIO_PIN_CNF_SENSE_Low,                   ///<  Pin sense low level.
X    NRF_GPIO_PIN_SENSE_LOW  = (3UL),                   
N    NRF_GPIO_PIN_SENSE_HIGH = GPIO_PIN_CNF_SENSE_High,                  ///<  Pin sense high level.
X    NRF_GPIO_PIN_SENSE_HIGH = (2UL),                  
N} nrf_gpio_pin_sense_t;
N
N
N#if (__LINT__ != 1)
N
N/**
N * @brief Function for configuring the GPIO pin range as outputs with normal drive strength.
N *        This function can be used to configure pin range as simple output with gate driving GPIO_PIN_CNF_DRIVE_S0S1 (normal cases).
N *
N * @param pin_range_start specifies the start number (inclusive) in the range of pin numbers to be configured (allowed values 0-30)
N *
N * @param pin_range_end specifies the end number (inclusive) in the range of pin numbers to be configured (allowed values 0-30)
N *
N * @note For configuring only one pin as output use @ref nrf_gpio_cfg_output
N *       Sense capability on the pin is disabled, and input is disconnected from the buffer as the pins are configured as output.
N */
N__STATIC_INLINE void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end);
Xstatic __inline void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end);
N
N/**
N * @brief Function for configuring the GPIO pin range as inputs with given initial value set, hiding inner details.
N *        This function can be used to configure pin range as simple input.
N *
N * @param pin_range_start specifies the start number (inclusive) in the range of pin numbers to be configured (allowed values 0-30)
N *
N * @param pin_range_end specifies the end number (inclusive) in the range of pin numbers to be configured (allowed values 0-30)
N *
N * @param pull_config State of the pin range pull resistor (no pull, pulled down or pulled high)
N *
N * @note  For configuring only one pin as input use @ref nrf_gpio_cfg_input
N *        Sense capability on the pin is disabled, and input is connected to buffer so that the GPIO->IN register is readable
N */
N__STATIC_INLINE void nrf_gpio_range_cfg_input(uint32_t pin_range_start, uint32_t pin_range_end, nrf_gpio_pin_pull_t pull_config);
Xstatic __inline void nrf_gpio_range_cfg_input(uint32_t pin_range_start, uint32_t pin_range_end, nrf_gpio_pin_pull_t pull_config);
N
N/**
N * @brief Pin configuration function
N *
N * The main pin configuration function.
N * This function allows to set any aspect in PIN_CNF register.
N * @param pin_number Specifies the pin number (allowed values 0-31).
N * @param dir   Pin direction
N * @param input Connect or disconnect input buffer
N * @param pull  Pull configuration
N * @param drive Drive configuration
N * @param sense Pin sensing mechanism
N */
N__STATIC_INLINE void nrf_gpio_cfg(
Xstatic __inline void nrf_gpio_cfg(
N        uint32_t             pin_number,
N        nrf_gpio_pin_dir_t   dir,
N        nrf_gpio_pin_input_t input,
N        nrf_gpio_pin_pull_t  pull,
N        nrf_gpio_pin_drive_t drive,
N        nrf_gpio_pin_sense_t sense);
N
N/**
N * @brief Function for configuring the given GPIO pin number as output with given initial value set, hiding inner details.
N *        This function can be used to configure pin range as simple input with gate driving GPIO_PIN_CNF_DRIVE_S0S1 (normal cases).
N *
N * @param pin_number specifies the pin number (allowed values 0-31)
N *
N * @note  Sense capability on the pin is disabled, and input is disconnected from the buffer as the pins are configured as output.
N */
N__STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number);
Xstatic __inline void nrf_gpio_cfg_output(uint32_t pin_number);
N
N/**
N * @brief Function for configuring the given GPIO pin number as input with given initial value set, hiding inner details.
N *        This function can be used to configure pin range as simple input with gate driving GPIO_PIN_CNF_DRIVE_S0S1 (normal cases).
N *
N * @param pin_number Specifies the pin number (allowed values 0-30).
N * @param pull_config State of the pin range pull resistor (no pull, pulled down or pulled high).
N *
N * @note  Sense capability on the pin is disabled, and input is connected to buffer so that the GPIO->IN register is readable
N */
N__STATIC_INLINE void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config);
Xstatic __inline void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config);
N
N/**
N * @brief Function for reseting pin configuration to its default state.
N *
N * @param pin_number Specifies the pin number (allowed values 0-31).
N */
N__STATIC_INLINE void nrf_gpio_cfg_default(uint32_t pin_number);
Xstatic __inline void nrf_gpio_cfg_default(uint32_t pin_number);
N
N/**
N * @brief Function for configuring the given GPIO pin number as a watcher. Only input is connected.
N *
N * @param pin_number Specifies the pin number (allowed values 0-31).
N *
N */
N__STATIC_INLINE void nrf_gpio_cfg_watcher(uint32_t pin_number);
Xstatic __inline void nrf_gpio_cfg_watcher(uint32_t pin_number);
N
N/**
N * @brief Function for disconnecting input for the given GPIO.
N *
N * @param pin_number Specifies the pin number (allowed values 0-31).
N *
N */
N__STATIC_INLINE void nrf_gpio_input_disconnect(uint32_t pin_number);
Xstatic __inline void nrf_gpio_input_disconnect(uint32_t pin_number);
N
N/**
N * @brief Function for configuring the given GPIO pin number as input with given initial value set, hiding inner details.
N *        This function can be used to configure pin range as simple input with gate driving GPIO_PIN_CNF_DRIVE_S0S1 (normal cases).
N *        Sense capability on the pin is configurable, and input is connected to buffer so that the GPIO->IN register is readable.
N *
N * @param pin_number   Specifies the pin number (allowed values 0-30).
N * @param pull_config  State of the pin pull resistor (no pull, pulled down or pulled high).
N * @param sense_config Sense level of the pin (no sense, sense low or sense high).
N */
N__STATIC_INLINE void nrf_gpio_cfg_sense_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config, nrf_gpio_pin_sense_t sense_config);
Xstatic __inline void nrf_gpio_cfg_sense_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config, nrf_gpio_pin_sense_t sense_config);
N
N/**
N * @brief Function for configuring sense level for the given GPIO.
N *
N * @param pin_number   Specifies the pin number of gpio pin numbers to be configured (allowed values 0-30).
N * @param sense_config Sense configuration.
N *
N */
N__STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config);
Xstatic __inline void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config);
N
N/**
N * @brief Function for setting the direction for a GPIO pin.
N *
N * @param pin_number specifies the pin number (0-31) for which to
N * set the direction.
N *
N * @param direction specifies the direction
N */
N__STATIC_INLINE void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction);
Xstatic __inline void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction);
N
N/**
N * @brief Function for setting a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number Specifies the pin number (0-31) to set.
N */
N__STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number);
Xstatic __inline void nrf_gpio_pin_set(uint32_t pin_number);
N
N/**
N * @brief Function for setting GPIO pins.
N *
N * Note that the pins must be configured as outputs for this
N * function to have any effect.
N *
N * @param pin_mask Specifies the pins to set.
N */
N__STATIC_INLINE void nrf_gpio_pins_set(uint32_t pin_mask);
Xstatic __inline void nrf_gpio_pins_set(uint32_t pin_mask);
N
N/**
N * @brief Function for clearing a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number Specifies the pin number (0-31) to clear.
N */
N__STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number);
Xstatic __inline void nrf_gpio_pin_clear(uint32_t pin_number);
N
N/**
N * @brief Function for clearing GPIO pins.
N *
N * Note that the pins must be configured as outputs for this
N * function to have any effect.
N *
N * @param pin_mask Specifies the pins to clear.
N */
N__STATIC_INLINE void nrf_gpio_pins_clear(uint32_t pin_mask);
Xstatic __inline void nrf_gpio_pins_clear(uint32_t pin_mask);
N
N/**
N * @brief Function for toggling a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number Specifies the pin number (0-31) to toggle.
N */
N__STATIC_INLINE void nrf_gpio_pin_toggle(uint32_t pin_number);
Xstatic __inline void nrf_gpio_pin_toggle(uint32_t pin_number);
N
N/**
N * @brief Function for toggling GPIO pins.
N *
N * Note that the pins must be configured as outputs for this
N * function to have any effect.
N *
N * @param pin_mask Specifies the pins to toggle.
N */
N__STATIC_INLINE void nrf_gpio_pins_toggle(uint32_t pin_mask);
Xstatic __inline void nrf_gpio_pins_toggle(uint32_t pin_mask);
N
N/**
N * @brief Function for writing a value to a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number specifies the pin number (0-31) to
N * write.
N *
N * @param value specifies the value to be written to the pin.
N * @arg 0 clears the pin
N * @arg >=1 sets the pin.
N */
N__STATIC_INLINE void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value);
Xstatic __inline void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value);
N
N/**
N * @brief Function for reading the input level of a GPIO pin.
N *
N * Note that the pin must have input connected for the value
N * returned from this function to be valid.
N *
N * @param pin_number specifies the pin number (0-31) to
N * read.
N *
N * @return
N * @retval 0 if the pin input level is low.
N * @retval 1 if the pin input level is high.
N * @retval > 1 should never occur.
N */
N__STATIC_INLINE uint32_t nrf_gpio_pin_read(uint32_t pin_number);
Xstatic __inline uint32_t nrf_gpio_pin_read(uint32_t pin_number);
N
N/**
N * @brief Function for reading the input level of all GPIO pins.
N *
N * Note that the pin must have input connected for the value
N * returned from this function to be valid.
N *
N * @retval Status of input of all pins
N */
N__STATIC_INLINE uint32_t nrf_gpio_pins_read(void);
Xstatic __inline uint32_t nrf_gpio_pins_read(void);
N
N/**
N * @brief Function for reading the sense configuration of a GPIO pin.
N *
N * @param pin_number specifies the pin number (0-31) to
N * read.
N *
N * @retval Sense configuration
N */
N__STATIC_INLINE nrf_gpio_pin_sense_t nrf_gpio_pin_sense_get(uint32_t pin_number);
Xstatic __inline nrf_gpio_pin_sense_t nrf_gpio_pin_sense_get(uint32_t pin_number);
N
N/**
N * @brief Generic function for writing a single byte of a 32 bit word at a given
N * address.
N *
N * This function should not be called from outside the nrf_gpio
N * abstraction layer.
N *
N * @param word_address is the address of the word to be written.
N *
N * @param byte_no is the word byte number (0-3) to be written.
N *
N * @param value is the value to be written to byte "byte_no" of word
N * at address "word_address"
N */
N__STATIC_INLINE void nrf_gpio_word_byte_write(volatile uint32_t * word_address, uint8_t byte_no, uint8_t value);
Xstatic __inline void nrf_gpio_word_byte_write(volatile uint32_t * word_address, uint8_t byte_no, uint8_t value);
N
N/**
N * @brief Generic function for reading a single byte of a 32 bit word at a given
N * address.
N *
N * This function should not be called from outside the nrf_gpio
N * abstraction layer.
N *
N * @param word_address is the address of the word to be read.
N *
N * @param byte_no is the byte number (0-3) of the word to be read.
N *
N * @return byte "byte_no" of word at address "word_address".
N */
N__STATIC_INLINE uint8_t nrf_gpio_word_byte_read(const volatile uint32_t* word_address, uint8_t byte_no);
Xstatic __inline uint8_t nrf_gpio_word_byte_read(const volatile uint32_t* word_address, uint8_t byte_no);
N
N/**
N * @brief Function for setting the direction of a port.
N *
N * @param port is the port for which to set the direction.
N *
N * @param dir direction to be set for this port.
N */
N__STATIC_INLINE void nrf_gpio_port_dir_set(nrf_gpio_port_select_t port, nrf_gpio_port_dir_t dir);
Xstatic __inline void nrf_gpio_port_dir_set(nrf_gpio_port_select_t port, nrf_gpio_port_dir_t dir);
N
N/**
N * @brief Function for reading a GPIO port.
N *
N * @param port is the port to read.
N *
N * @return the input value on this port.
N */
N__STATIC_INLINE uint8_t nrf_gpio_port_read(nrf_gpio_port_select_t port);
Xstatic __inline uint8_t nrf_gpio_port_read(nrf_gpio_port_select_t port);
N
N/**
N * @brief Function for writing to a GPIO port.
N *
N * @param port is the port to write.
N *
N * @param value is the value to write to this port.
N *
N * @sa nrf_gpio_port_dir_set()
N */
N__STATIC_INLINE void nrf_gpio_port_write(nrf_gpio_port_select_t port, uint8_t value);
Xstatic __inline void nrf_gpio_port_write(nrf_gpio_port_select_t port, uint8_t value);
N
N/**
N * @brief Function for setting individual pins on GPIO port.
N *
N * @param port is the port for which to set the pins.
N *
N * @param set_mask is a mask specifying which pins to set. A bit
N * set to 1 indicates that the corresponding port pin shall be
N * set.
N *
N * @sa nrf_gpio_port_dir_set()
N */
N__STATIC_INLINE void nrf_gpio_port_set(nrf_gpio_port_select_t port, uint8_t set_mask);
Xstatic __inline void nrf_gpio_port_set(nrf_gpio_port_select_t port, uint8_t set_mask);
N
N/**
N * @brief Function for clearing individual pins on GPIO port.
N *
N * @param port is the port for which to clear the pins.
N *
N * @param clr_mask is a mask specifying which pins to clear. A bit
N * set to 1 indicates that the corresponding port pin shall be
N * cleared.
N *
N * @sa nrf_gpio_port_dir_set()
N */
N__STATIC_INLINE void nrf_gpio_port_clear(nrf_gpio_port_select_t port, uint8_t clr_mask);
Xstatic __inline void nrf_gpio_port_clear(nrf_gpio_port_select_t port, uint8_t clr_mask);
N
N#endif // #ifndef (__LINT__ != 1)
N
N#ifndef SUPPRESS_INLINE_IMPLEMENTATION
N
N__STATIC_INLINE void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end)
Xstatic __inline void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    for (; pin_range_start <= pin_range_end; pin_range_start++)
N    {
N        nrf_gpio_cfg_output(pin_range_start);
N    }
N}
N
N__STATIC_INLINE void nrf_gpio_range_cfg_input(uint32_t pin_range_start, uint32_t pin_range_end, nrf_gpio_pin_pull_t pull_config)
Xstatic __inline void nrf_gpio_range_cfg_input(uint32_t pin_range_start, uint32_t pin_range_end, nrf_gpio_pin_pull_t pull_config)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    for (; pin_range_start <= pin_range_end; pin_range_start++)
N    {
N        nrf_gpio_cfg_input(pin_range_start, pull_config);
N    }
N}
N
N__STATIC_INLINE void nrf_gpio_cfg(
Xstatic __inline void nrf_gpio_cfg(
N        uint32_t             pin_number,
N        nrf_gpio_pin_dir_t   dir,
N        nrf_gpio_pin_input_t input,
N        nrf_gpio_pin_pull_t  pull,
N        nrf_gpio_pin_drive_t drive,
N        nrf_gpio_pin_sense_t sense)
N{
N    NRF_GPIO->PIN_CNF[pin_number] = ((uint32_t)dir   << GPIO_PIN_CNF_DIR_Pos)
X    ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] = ((uint32_t)dir   << (0UL))
N                                  | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
X                                  | ((uint32_t)input << (1UL))
N                                  | ((uint32_t)pull  << GPIO_PIN_CNF_PULL_Pos)
X                                  | ((uint32_t)pull  << (2UL))
N                                  | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
X                                  | ((uint32_t)drive << (8UL))
N                                  | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
X                                  | ((uint32_t)sense << (16UL));
N}
N
N__STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
Xstatic __inline void nrf_gpio_cfg_output(uint32_t pin_number)
N{
N    nrf_gpio_cfg(
N            pin_number,
N            NRF_GPIO_PIN_DIR_OUTPUT,
N            NRF_GPIO_PIN_INPUT_DISCONNECT,
N            NRF_GPIO_PIN_NOPULL,
N            NRF_GPIO_PIN_S0S1,
N            NRF_GPIO_PIN_NOSENSE);
N}
N
N__STATIC_INLINE void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
Xstatic __inline void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
N{
N    nrf_gpio_cfg(
N            pin_number,
N            NRF_GPIO_PIN_DIR_INPUT,
N            NRF_GPIO_PIN_INPUT_CONNECT,
N            pull_config,
N            NRF_GPIO_PIN_S0S1,
N            NRF_GPIO_PIN_NOSENSE);
N}
N
N__STATIC_INLINE void nrf_gpio_cfg_default(uint32_t pin_number)
Xstatic __inline void nrf_gpio_cfg_default(uint32_t pin_number)
N{
N    nrf_gpio_cfg(
N            pin_number,
N            NRF_GPIO_PIN_DIR_INPUT,
N            NRF_GPIO_PIN_INPUT_DISCONNECT,
N            NRF_GPIO_PIN_NOPULL,
N            NRF_GPIO_PIN_S0S1,
N            NRF_GPIO_PIN_NOSENSE);
N}
N
N__STATIC_INLINE void nrf_gpio_cfg_watcher(uint32_t pin_number)
Xstatic __inline void nrf_gpio_cfg_watcher(uint32_t pin_number)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    uint32_t cnf = NRF_GPIO->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_INPUT_Msk;
X    uint32_t cnf = ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] & ~(0x1UL << (1UL));
N    NRF_GPIO->PIN_CNF[pin_number] = cnf | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos);
X    ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] = cnf | ((0UL) << (1UL));
N}
N
N__STATIC_INLINE void nrf_gpio_input_disconnect(uint32_t pin_number)
Xstatic __inline void nrf_gpio_input_disconnect(uint32_t pin_number)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    uint32_t cnf = NRF_GPIO->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_INPUT_Msk;
X    uint32_t cnf = ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] & ~(0x1UL << (1UL));
N    NRF_GPIO->PIN_CNF[pin_number] = cnf | (GPIO_PIN_CNF_INPUT_Disconnect << GPIO_PIN_CNF_INPUT_Pos);
X    ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] = cnf | ((1UL) << (1UL));
N}
N
N__STATIC_INLINE void nrf_gpio_cfg_sense_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config, nrf_gpio_pin_sense_t sense_config)
Xstatic __inline void nrf_gpio_cfg_sense_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config, nrf_gpio_pin_sense_t sense_config)
N{
N    nrf_gpio_cfg(
N            pin_number,
N            NRF_GPIO_PIN_DIR_INPUT,
N            NRF_GPIO_PIN_INPUT_CONNECT,
N            pull_config,
N            NRF_GPIO_PIN_S0S1,
N            sense_config);
N}
N
N__STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config)
Xstatic __inline void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    //uint32_t cnf = NRF_GPIO->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
N    NRF_GPIO->PIN_CNF[pin_number] &= ~GPIO_PIN_CNF_SENSE_Msk;
X    ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] &= ~(0x3UL << (16UL));
N    NRF_GPIO->PIN_CNF[pin_number] |= (sense_config << GPIO_PIN_CNF_SENSE_Pos);
X    ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] |= (sense_config << (16UL));
N}
N
N__STATIC_INLINE void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction)
Xstatic __inline void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction)
N{
N    if (direction == NRF_GPIO_PIN_DIR_INPUT)
N    {
N        nrf_gpio_cfg(
N                pin_number,
N                NRF_GPIO_PIN_DIR_INPUT,
N                NRF_GPIO_PIN_INPUT_CONNECT,
N                NRF_GPIO_PIN_NOPULL,
N                NRF_GPIO_PIN_S0S1,
N                NRF_GPIO_PIN_NOSENSE);
N    }
N    else
N    {
N        NRF_GPIO->DIRSET = (1UL << pin_number);
X        ((NRF_GPIO_Type *) 0x50000000UL)->DIRSET = (1UL << pin_number);
N    }
N}
N
N__STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
Xstatic __inline void nrf_gpio_pin_set(uint32_t pin_number)
N{
N    NRF_GPIO->OUTSET = (1UL << pin_number);
X    ((NRF_GPIO_Type *) 0x50000000UL)->OUTSET = (1UL << pin_number);
N}
N
N__STATIC_INLINE void nrf_gpio_pins_set(uint32_t pin_mask)
Xstatic __inline void nrf_gpio_pins_set(uint32_t pin_mask)
N{
N    NRF_GPIO->OUTSET = pin_mask;
X    ((NRF_GPIO_Type *) 0x50000000UL)->OUTSET = pin_mask;
N}
N
N__STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
Xstatic __inline void nrf_gpio_pin_clear(uint32_t pin_number)
N{
N    NRF_GPIO->OUTCLR = (1UL << pin_number);
X    ((NRF_GPIO_Type *) 0x50000000UL)->OUTCLR = (1UL << pin_number);
N}
N
N__STATIC_INLINE void nrf_gpio_pins_clear(uint32_t pin_mask)
Xstatic __inline void nrf_gpio_pins_clear(uint32_t pin_mask)
N{
N    NRF_GPIO->OUTCLR = pin_mask;
X    ((NRF_GPIO_Type *) 0x50000000UL)->OUTCLR = pin_mask;
N}
N
N__STATIC_INLINE void nrf_gpio_pin_toggle(uint32_t pin_number)
Xstatic __inline void nrf_gpio_pin_toggle(uint32_t pin_number)
N{
N    nrf_gpio_pins_toggle(1UL << pin_number);
N}
N
N__STATIC_INLINE void nrf_gpio_pins_toggle(uint32_t pin_mask)
Xstatic __inline void nrf_gpio_pins_toggle(uint32_t pin_mask)
N{
N    uint32_t pins_state = NRF_GPIO->OUT;
X    uint32_t pins_state = ((NRF_GPIO_Type *) 0x50000000UL)->OUT;
N    NRF_GPIO->OUTSET = (~pins_state & pin_mask);
X    ((NRF_GPIO_Type *) 0x50000000UL)->OUTSET = (~pins_state & pin_mask);
N    NRF_GPIO->OUTCLR = ( pins_state & pin_mask);
X    ((NRF_GPIO_Type *) 0x50000000UL)->OUTCLR = ( pins_state & pin_mask);
N}
N
N__STATIC_INLINE void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value)
Xstatic __inline void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value)
N{
N    if (value == 0)
N    {
N        nrf_gpio_pin_clear(pin_number);
N    }
N    else
N    {
N        nrf_gpio_pin_set(pin_number);
N    }
N}
N
N__STATIC_INLINE uint32_t nrf_gpio_pin_read(uint32_t pin_number)
Xstatic __inline uint32_t nrf_gpio_pin_read(uint32_t pin_number)
N{
N    return  ((NRF_GPIO->IN >> pin_number) & 1UL);
X    return  ((((NRF_GPIO_Type *) 0x50000000UL)->IN >> pin_number) & 1UL);
N}
N
N__STATIC_INLINE uint32_t nrf_gpio_pins_read(void)
Xstatic __inline uint32_t nrf_gpio_pins_read(void)
N{
N    return NRF_GPIO->IN;
X    return ((NRF_GPIO_Type *) 0x50000000UL)->IN;
N}
N
N__STATIC_INLINE nrf_gpio_pin_sense_t nrf_gpio_pin_sense_get(uint32_t pin_number)
Xstatic __inline nrf_gpio_pin_sense_t nrf_gpio_pin_sense_get(uint32_t pin_number)
N{
N    return (nrf_gpio_pin_sense_t)((NRF_GPIO->PIN_CNF[pin_number] & GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
X    return (nrf_gpio_pin_sense_t)((((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] & (0x3UL << (16UL))) >> (16UL));
N}
N
N__STATIC_INLINE void nrf_gpio_word_byte_write(volatile uint32_t * word_address, uint8_t byte_no, uint8_t value)
Xstatic __inline void nrf_gpio_word_byte_write(volatile uint32_t * word_address, uint8_t byte_no, uint8_t value)
N{
N    *((volatile uint8_t*)(word_address) + byte_no) = value;
N}
N
N__STATIC_INLINE uint8_t nrf_gpio_word_byte_read(const volatile uint32_t* word_address, uint8_t byte_no)
Xstatic __inline uint8_t nrf_gpio_word_byte_read(const volatile uint32_t* word_address, uint8_t byte_no)
N{
N    return (*((const volatile uint8_t*)(word_address) + byte_no));
N}
N
N__STATIC_INLINE void nrf_gpio_port_dir_set(nrf_gpio_port_select_t port, nrf_gpio_port_dir_t dir)
Xstatic __inline void nrf_gpio_port_dir_set(nrf_gpio_port_select_t port, nrf_gpio_port_dir_t dir)
N{
N    if (dir == NRF_GPIO_PORT_DIR_OUTPUT)
N    {
N        nrf_gpio_word_byte_write(&NRF_GPIO->DIRSET, port, 0xFF);
X        nrf_gpio_word_byte_write(&((NRF_GPIO_Type *) 0x50000000UL)->DIRSET, port, 0xFF);
N    }
N    else
N    {
N        nrf_gpio_range_cfg_input(port*8, (port+1)*8-1, NRF_GPIO_PIN_NOPULL);
N    }
N}
N
N__STATIC_INLINE uint8_t nrf_gpio_port_read(nrf_gpio_port_select_t port)
Xstatic __inline uint8_t nrf_gpio_port_read(nrf_gpio_port_select_t port)
N{
N    return nrf_gpio_word_byte_read(&NRF_GPIO->IN, port);
X    return nrf_gpio_word_byte_read(&((NRF_GPIO_Type *) 0x50000000UL)->IN, port);
N}
N
N__STATIC_INLINE void nrf_gpio_port_write(nrf_gpio_port_select_t port, uint8_t value)
Xstatic __inline void nrf_gpio_port_write(nrf_gpio_port_select_t port, uint8_t value)
N{
N    nrf_gpio_word_byte_write(&NRF_GPIO->OUT, port, value);
X    nrf_gpio_word_byte_write(&((NRF_GPIO_Type *) 0x50000000UL)->OUT, port, value);
N}
N
N__STATIC_INLINE void nrf_gpio_port_set(nrf_gpio_port_select_t port, uint8_t set_mask)
Xstatic __inline void nrf_gpio_port_set(nrf_gpio_port_select_t port, uint8_t set_mask)
N{
N    nrf_gpio_word_byte_write(&NRF_GPIO->OUTSET, port, set_mask);
X    nrf_gpio_word_byte_write(&((NRF_GPIO_Type *) 0x50000000UL)->OUTSET, port, set_mask);
N}
N
N__STATIC_INLINE void nrf_gpio_port_clear(nrf_gpio_port_select_t port, uint8_t clr_mask)
Xstatic __inline void nrf_gpio_port_clear(nrf_gpio_port_select_t port, uint8_t clr_mask)
N{
N    nrf_gpio_word_byte_write(&NRF_GPIO->OUTCLR, port, clr_mask);
X    nrf_gpio_word_byte_write(&((NRF_GPIO_Type *) 0x50000000UL)->OUTCLR, port, clr_mask);
N}
N
N#endif //SUPPRESS_INLINE_IMPLEMENTATION
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 16 "..\..\..\..\..\bsp\boards.h" 2
N
N#if defined(BOARD_NRF6310)
X#if 0L
S  #include "nrf6310.h"
S#elif defined(BOARD_PCA10000)
X#elif 0L
S  #include "pca10000.h"
S#elif defined(BOARD_PCA10001)
X#elif 0L
S  #include "pca10001.h"
S#elif defined(BOARD_PCA10002)
X#elif 0L
S  #include "pca10000.h"
S#elif defined(BOARD_PCA10003)
X#elif 0L
S  #include "pca10003.h"
S#elif defined(BOARD_PCA20006)
X#elif 0L
S  #include "pca20006.h"
S#elif defined(BOARD_PCA10028)
X#elif 0L
S  #include "pca10028.h"
S#elif defined(BOARD_PCA10031)
X#elif 0L
S  #include "pca10031.h"
S#elif defined(BOARD_PCA10036)
X#elif 0L
S  #include "pca10036.h"
N#elif defined(BOARD_PCA10040)
X#elif 1L
N  #include "pca10040.h"
L 1 "..\..\..\..\..\bsp\pca10040.h" 1
N/* Copyright (c) 2014 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N#ifndef PCA10040_H
N#define PCA10040_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N// LEDs definitions for PCA10040
N#define LEDS_NUMBER    4
N
N#define LED_START      17
N#define LED_1          17
N#define LED_2          18
N#define LED_3          19
N#define LED_4          20
N#define LED_STOP       20
N
N#define LEDS_LIST { LED_1, LED_2, LED_3, LED_4 }
N
N#define BSP_LED_0      LED_1
N#define BSP_LED_1      LED_2
N#define BSP_LED_2      LED_3
N#define BSP_LED_3      LED_4
N
N#define BSP_LED_0_MASK (1<<BSP_LED_0)
N#define BSP_LED_1_MASK (1<<BSP_LED_1)
N#define BSP_LED_2_MASK (1<<BSP_LED_2)
N#define BSP_LED_3_MASK (1<<BSP_LED_3)
N
N#define LEDS_MASK      (BSP_LED_0_MASK | BSP_LED_1_MASK | BSP_LED_2_MASK | BSP_LED_3_MASK)
N/* all LEDs are lit when GPIO is low */
N#define LEDS_INV_MASK  LEDS_MASK
N
N#define BUTTONS_NUMBER 4
N
N#define BUTTON_START   13
N#define BUTTON_1       13
N#define BUTTON_2       14
N#define BUTTON_3       15
N#define BUTTON_4       16
N#define BUTTON_STOP    16
N#define BUTTON_PULL    NRF_GPIO_PIN_PULLUP
N
N#define BUTTONS_LIST { BUTTON_1, BUTTON_2, BUTTON_3, BUTTON_4 }
N
N#define BSP_BUTTON_0   BUTTON_1
N#define BSP_BUTTON_1   BUTTON_2
N#define BSP_BUTTON_2   BUTTON_3
N#define BSP_BUTTON_3   BUTTON_4
N
N#define BSP_BUTTON_0_MASK (1<<BSP_BUTTON_0)
N#define BSP_BUTTON_1_MASK (1<<BSP_BUTTON_1)
N#define BSP_BUTTON_2_MASK (1<<BSP_BUTTON_2)
N#define BSP_BUTTON_3_MASK (1<<BSP_BUTTON_3)
N
N#define BUTTONS_MASK   0x001E0000
N
N#define RX_PIN_NUMBER  8
N#define TX_PIN_NUMBER  6
N#define CTS_PIN_NUMBER 7
N#define RTS_PIN_NUMBER 5
N#define HWFC           true
N
N#define SPIS_MISO_PIN   28  // SPI MISO signal.
N#define SPIS_CSN_PIN    12  // SPI CSN signal.
N#define SPIS_MOSI_PIN   25  // SPI MOSI signal.
N#define SPIS_SCK_PIN    29  // SPI SCK signal.
N
N#define SPIM0_SCK_PIN   29  // SPI clock GPIO pin number.
N#define SPIM0_MOSI_PIN  25  // SPI Master Out Slave In GPIO pin number.
N#define SPIM0_MISO_PIN  28  // SPI Master In Slave Out GPIO pin number.
N#define SPIM0_SS_PIN    12  // SPI Slave Select GPIO pin number.
N
N#define SPIM1_SCK_PIN   2   // SPI clock GPIO pin number.
N#define SPIM1_MOSI_PIN  3   // SPI Master Out Slave In GPIO pin number.
N#define SPIM1_MISO_PIN  4   // SPI Master In Slave Out GPIO pin number.
N#define SPIM1_SS_PIN    5   // SPI Slave Select GPIO pin number.
N
N#define SPIM2_SCK_PIN   12  // SPI clock GPIO pin number.
N#define SPIM2_MOSI_PIN  13  // SPI Master Out Slave In GPIO pin number.
N#define SPIM2_MISO_PIN  14  // SPI Master In Slave Out GPIO pin number.
N#define SPIM2_SS_PIN    15  // SPI Slave Select GPIO pin number.
N
N// serialization APPLICATION board - temp. setup for running serialized MEMU tests
N#define SER_APP_RX_PIN              23    // UART RX pin number.
N#define SER_APP_TX_PIN              24    // UART TX pin number.
N#define SER_APP_CTS_PIN             2     // UART Clear To Send pin number.
N#define SER_APP_RTS_PIN             25    // UART Request To Send pin number.
N
N#define SER_APP_SPIM0_SCK_PIN       27     // SPI clock GPIO pin number.
N#define SER_APP_SPIM0_MOSI_PIN      2      // SPI Master Out Slave In GPIO pin number
N#define SER_APP_SPIM0_MISO_PIN      26     // SPI Master In Slave Out GPIO pin number
N#define SER_APP_SPIM0_SS_PIN        23     // SPI Slave Select GPIO pin number
N#define SER_APP_SPIM0_RDY_PIN       25     // SPI READY GPIO pin number
N#define SER_APP_SPIM0_REQ_PIN       24     // SPI REQUEST GPIO pin number
N
N// serialization CONNECTIVITY board
N#define SER_CON_RX_PIN              24    // UART RX pin number.
N#define SER_CON_TX_PIN              23    // UART TX pin number.
N#define SER_CON_CTS_PIN             25    // UART Clear To Send pin number. Not used if HWFC is set to false.
N#define SER_CON_RTS_PIN             2     // UART Request To Send pin number. Not used if HWFC is set to false.
N
N
N#define SER_CON_SPIS_SCK_PIN        27    // SPI SCK signal.
N#define SER_CON_SPIS_MOSI_PIN       2     // SPI MOSI signal.
N#define SER_CON_SPIS_MISO_PIN       26    // SPI MISO signal.
N#define SER_CON_SPIS_CSN_PIN        23    // SPI CSN signal.
N#define SER_CON_SPIS_RDY_PIN        25    // SPI READY GPIO pin number.
N#define SER_CON_SPIS_REQ_PIN        24    // SPI REQUEST GPIO pin number.
N
N#define SER_CONN_CHIP_RESET_PIN     11    // Pin used to reset connectivity chip
N
N
N// Arduino board mappings
N#define ARDUINO_SCL_PIN             27    // SCL signal pin
N#define ARDUINO_SDA_PIN             26    // SDA signal pin
N#define ARDUINO_AREF_PIN            2     // Aref pin
N#define ARDUINO_13_PIN              25    // Digital pin 13
N#define ARDUINO_12_PIN              24    // Digital pin 12
N#define ARDUINO_11_PIN              23    // Digital pin 11
N#define ARDUINO_10_PIN              22    // Digital pin 10
N#define ARDUINO_9_PIN               20    // Digital pin 9
N#define ARDUINO_8_PIN               19    // Digital pin 8
N
N#define ARDUINO_7_PIN               18    // Digital pin 7
N#define ARDUINO_6_PIN               17    // Digital pin 6
N#define ARDUINO_5_PIN               16    // Digital pin 5
N#define ARDUINO_4_PIN               15    // Digital pin 4
N#define ARDUINO_3_PIN               14    // Digital pin 3
N#define ARDUINO_2_PIN               13    // Digital pin 2
N#define ARDUINO_1_PIN               12    // Digital pin 1
N#define ARDUINO_0_PIN               11    // Digital pin 0
N
N#define ARDUINO_A0_PIN              3     // Analog channel 0
N#define ARDUINO_A1_PIN              4     // Analog channel 1
N#define ARDUINO_A2_PIN              28    // Analog channel 2
N#define ARDUINO_A3_PIN              29    // Analog channel 3
N#define ARDUINO_A4_PIN              30    // Analog channel 4
N#define ARDUINO_A5_PIN              31    // Analog channel 5
N
N// Low frequency clock source to be used by the SoftDevice
N#define NRF_CLOCK_LFCLKSRC      {.source        = NRF_CLOCK_LF_SRC_XTAL,            \
N                                 .rc_ctiv       = 0,                                \
N                                 .rc_temp_ctiv  = 0,                                \
N                                 .xtal_accuracy = NRF_CLOCK_LF_XTAL_ACCURACY_20_PPM}
X#define NRF_CLOCK_LFCLKSRC      {.source        = NRF_CLOCK_LF_SRC_XTAL,                                             .rc_ctiv       = 0,                                                                 .rc_temp_ctiv  = 0,                                                                 .xtal_accuracy = NRF_CLOCK_LF_XTAL_ACCURACY_20_PPM}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // PCA10040_H
L 37 "..\..\..\..\..\bsp\boards.h" 2
N#elif defined(BOARD_WT51822)
S  #include "wt51822.h"
S#elif defined(BOARD_N5DK1)
S  #include "n5_starterkit.h"
S#elif defined (BOARD_D52DK1)
S  #include "d52_starterkit.h"
S#elif defined (BOARD_ARDUINO_PRIMO)
S  #include "arduino_primo.h"
S#elif defined(BOARD_CUSTOM)
S  #include "custom_board.h"
S#else
S#error "Board is not defined"
S
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define LEDS_OFF(leds_mask) do {  NRF_GPIO->OUTSET = (leds_mask) & (LEDS_MASK & LEDS_INV_MASK); \
N                            NRF_GPIO->OUTCLR = (leds_mask) & (LEDS_MASK & ~LEDS_INV_MASK); } while (0)
X#define LEDS_OFF(leds_mask) do {  NRF_GPIO->OUTSET = (leds_mask) & (LEDS_MASK & LEDS_INV_MASK);                             NRF_GPIO->OUTCLR = (leds_mask) & (LEDS_MASK & ~LEDS_INV_MASK); } while (0)
N
N#define LEDS_ON(leds_mask) do {  NRF_GPIO->OUTCLR = (leds_mask) & (LEDS_MASK & LEDS_INV_MASK); \
N                           NRF_GPIO->OUTSET = (leds_mask) & (LEDS_MASK & ~LEDS_INV_MASK); } while (0)
X#define LEDS_ON(leds_mask) do {  NRF_GPIO->OUTCLR = (leds_mask) & (LEDS_MASK & LEDS_INV_MASK);                            NRF_GPIO->OUTSET = (leds_mask) & (LEDS_MASK & ~LEDS_INV_MASK); } while (0)
N
N#define LED_IS_ON(leds_mask) ((leds_mask) & (NRF_GPIO->OUT ^ LEDS_INV_MASK) )
N
N#define LEDS_INVERT(leds_mask) do { uint32_t gpio_state = NRF_GPIO->OUT;      \
N                              NRF_GPIO->OUTSET = ((leds_mask) & ~gpio_state); \
N                              NRF_GPIO->OUTCLR = ((leds_mask) & gpio_state); } while (0)
X#define LEDS_INVERT(leds_mask) do { uint32_t gpio_state = NRF_GPIO->OUT;                                    NRF_GPIO->OUTSET = ((leds_mask) & ~gpio_state);                               NRF_GPIO->OUTCLR = ((leds_mask) & gpio_state); } while (0)
N
N#define LEDS_CONFIGURE(leds_mask) do { uint32_t pin;                  \
N                                  for (pin = 0; pin < 32; pin++) \
N                                      if ( (leds_mask) & (1 << pin) )   \
N                                          nrf_gpio_cfg_output(pin); } while (0)
X#define LEDS_CONFIGURE(leds_mask) do { uint32_t pin;                                                    for (pin = 0; pin < 32; pin++)                                       if ( (leds_mask) & (1 << pin) )                                             nrf_gpio_cfg_output(pin); } while (0)
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 42 "..\..\..\main.c" 2
N#include "softdevice_handler.h"
L 1 "..\..\..\..\..\..\components\softdevice\common\softdevice_handler\softdevice_handler.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup softdevice_handler SoftDevice Event Handler
N * @{
N * @ingroup  app_common
N * @brief    API for initializing and disabling the SoftDevice
N *
N * @details  This API contains the functions and defines exposed by the @ref lib_softdevice_handler.
N *           For more information on the library and how the application should use it, please refer
N *           @ref lib_softdevice_handler.
N *
N * @note     Use the USE_SCHEDULER parameter of the SOFTDEVICE_HANDLER_INIT() macro to select if
N *           the @ref app_scheduler is to be used or not.
N *
N * @note     Even if the scheduler is not used, softdevice_handler.h will include app_scheduler.h.
N *           So when compiling, app_scheduler.h must be available in one of the compiler include
N *           paths.
N */
N
N#ifndef SOFTDEVICE_HANDLER_H__
N#define SOFTDEVICE_HANDLER_H__
N
N#include <stdlib.h>
N#include "nordic_common.h"
N#include "nrf_sdm.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\nrf_sdm.h" 1
N/*
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N *
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N *
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N *
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N/**
N  @defgroup nrf_sdm_api SoftDevice Manager API
N  @{
N
N  @brief APIs for SoftDevice management.
N
N*/
N
N#ifndef NRF_SDM_H__
N#define NRF_SDM_H__
N
N#include "nrf_svc.h"
N#include "nrf.h"
N#include "nrf_soc.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\nrf_soc.h" 1
N/* 
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N * 
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N * 
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N * 
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N * 
N * 
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */ 
N/**
N * @defgroup nrf_soc_api SoC Library API
N * @{
N * 
N * @brief APIs for the SoC library.
N * 
N */
N
N#ifndef NRF_SOC_H__
N#define NRF_SOC_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "nrf_svc.h"
N#include "nrf.h"
N
N#include "nrf_error_soc.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\nrf_error_soc.h" 1
N/* 
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N * 
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N * 
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N * 
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N * 
N * 
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N/**
N  @addtogroup nrf_soc_api
N  @{
N  @defgroup nrf_soc_error SoC Library Error Codes
N  @{
N     
N  @brief Error definitions for the SoC library
N
N*/
N
N/* Header guard */
N#ifndef NRF_ERROR_SOC_H__
N#define NRF_ERROR_SOC_H__
N
N#include "nrf_error.h"
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Mutex Errors */
N#define NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN                 (NRF_ERROR_SOC_BASE_NUM + 0)  ///< Mutex already taken
N
N/* NVIC errors */
N#define NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE        (NRF_ERROR_SOC_BASE_NUM + 1)  ///< NVIC interrupt not available
N#define NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED (NRF_ERROR_SOC_BASE_NUM + 2)  ///< NVIC interrupt priority not allowed
N#define NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN              (NRF_ERROR_SOC_BASE_NUM + 3)  ///< NVIC should not return
N
N/* Power errors */
N#define NRF_ERROR_SOC_POWER_MODE_UNKNOWN                  (NRF_ERROR_SOC_BASE_NUM + 4)  ///< Power mode unknown
N#define NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN         (NRF_ERROR_SOC_BASE_NUM + 5)  ///< Power POF threshold unknown
N#define NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN         (NRF_ERROR_SOC_BASE_NUM + 6)  ///< Power off should not return
N
N/* Rand errors */
N#define NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES              (NRF_ERROR_SOC_BASE_NUM + 7)  ///< RAND not enough values
N
N/* PPI errors */
N#define NRF_ERROR_SOC_PPI_INVALID_CHANNEL                 (NRF_ERROR_SOC_BASE_NUM + 8)  ///< Invalid PPI Channel
N#define NRF_ERROR_SOC_PPI_INVALID_GROUP                   (NRF_ERROR_SOC_BASE_NUM + 9)  ///< Invalid PPI Group
N
N#ifdef __cplusplus
S}
N#endif
N#endif // NRF_ERROR_SOC_H__
N/**
N  @}
N  @}
N*/
L 53 "..\..\..\..\..\..\components\softdevice\s132\headers\nrf_soc.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**@addtogroup NRF_SOC_DEFINES Defines
N * @{ */
N
N/**@brief The number of the lowest SVC number reserved for the SoC library. */
N#define SOC_SVC_BASE               (0x20)                   /**< Base value for SVCs that are available when the SoftDevice is disabled. */
N#define SOC_SVC_BASE_NOT_AVAILABLE (0x2B)                   /**< Base value for SVCs that are not available when the SoftDevice is disabled. */
N
N/**@brief Guranteed time for application to process radio inactive notification. */
N#define NRF_RADIO_NOTIFICATION_INACTIVE_GUARANTEED_TIME_US  (62)
N
N/**@brief The minimum allowed timeslot extension time. */
N#define NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US (200)
N
N#define SOC_ECB_KEY_LENGTH                (16)                       /**< ECB key length. */
N#define SOC_ECB_CLEARTEXT_LENGTH          (16)                       /**< ECB cleartext length. */
N#define SOC_ECB_CIPHERTEXT_LENGTH         (SOC_ECB_CLEARTEXT_LENGTH) /**< ECB ciphertext length. */
N
N#ifdef NRF51
S#define SD_EVT_IRQn                       (SWI2_IRQn)        /**< SoftDevice Event IRQ number. Used for both protocol events and SoC events. */
S#define SD_EVT_IRQHandler                 (SWI2_IRQHandler)  /**< SoftDevice Event IRQ handler. Used for both protocol events and SoC events. */
S#define RADIO_NOTIFICATION_IRQn           (SWI1_IRQn)        /**< The radio notification IRQ number. */
S#define RADIO_NOTIFICATION_IRQHandler     (SWI1_IRQHandler)  /**< The radio notification IRQ handler. */
N#endif
N#ifdef NRF52
N#define SD_EVT_IRQn                       (SWI2_EGU2_IRQn)        /**< SoftDevice Event IRQ number. Used for both protocol events and SoC events. */
N#define SD_EVT_IRQHandler                 (SWI2_EGU2_IRQHandler)  /**< SoftDevice Event IRQ handler. Used for both protocol events and SoC events. */
N#define RADIO_NOTIFICATION_IRQn           (SWI1_EGU1_IRQn)        /**< The radio notification IRQ number. */
N#define RADIO_NOTIFICATION_IRQHandler     (SWI1_EGU1_IRQHandler)  /**< The radio notification IRQ handler. */
N#endif
N
N#define NRF_RADIO_LENGTH_MIN_US           (100)               /**< The shortest allowed radio timeslot, in microseconds. */
N#define NRF_RADIO_LENGTH_MAX_US           (100000)            /**< The longest allowed radio timeslot, in microseconds. */
N
N#define NRF_RADIO_DISTANCE_MAX_US         (128000000UL - 1UL) /**< The longest timeslot distance, in microseconds, allowed for the distance parameter (see @ref nrf_radio_request_normal_t) in the request. */
N
N#define NRF_RADIO_EARLIEST_TIMEOUT_MAX_US (128000000UL - 1UL) /**< The longest timeout, in microseconds, allowed when requesting the earliest possible timeslot. */
N
N#define NRF_RADIO_START_JITTER_US         (2)                 /**< The maximum jitter in @ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START relative to the requested start time. */
N
N/**@} */
N
N/**@addtogroup NRF_SOC_ENUMS Enumerations
N * @{ */
N
N/**@brief The SVC numbers used by the SVC functions in the SoC library. */
Nenum NRF_SOC_SVCS
N{
N  SD_PPI_CHANNEL_ENABLE_GET = SOC_SVC_BASE,
X  SD_PPI_CHANNEL_ENABLE_GET = (0x20),
N  SD_PPI_CHANNEL_ENABLE_SET,
N  SD_PPI_CHANNEL_ENABLE_CLR,
N  SD_PPI_CHANNEL_ASSIGN,
N  SD_PPI_GROUP_TASK_ENABLE,
N  SD_PPI_GROUP_TASK_DISABLE,
N  SD_PPI_GROUP_ASSIGN,
N  SD_PPI_GROUP_GET,
N  SD_FLASH_PAGE_ERASE,
N  SD_FLASH_WRITE,
N  SD_FLASH_PROTECT,
N  SD_MUTEX_NEW = SOC_SVC_BASE_NOT_AVAILABLE,
X  SD_MUTEX_NEW = (0x2B),
N  SD_MUTEX_ACQUIRE,
N  SD_MUTEX_RELEASE,
N  SD_RAND_APPLICATION_POOL_CAPACITY_GET,
N  SD_RAND_APPLICATION_BYTES_AVAILABLE_GET,
N  SD_RAND_APPLICATION_VECTOR_GET,
N  SD_POWER_MODE_SET,
N  SD_POWER_SYSTEM_OFF,
N  SD_POWER_RESET_REASON_GET,
N  SD_POWER_RESET_REASON_CLR,
N  SD_POWER_POF_ENABLE,
N  SD_POWER_POF_THRESHOLD_SET,
N  SD_POWER_RAMON_SET,
N  SD_POWER_RAMON_CLR,
N  SD_POWER_RAMON_GET,
N  SD_POWER_GPREGRET_SET,
N  SD_POWER_GPREGRET_CLR,
N  SD_POWER_GPREGRET_GET,
N  SD_POWER_DCDC_MODE_SET,
N  SD_APP_EVT_WAIT,
N  SD_CLOCK_HFCLK_REQUEST,
N  SD_CLOCK_HFCLK_RELEASE,
N  SD_CLOCK_HFCLK_IS_RUNNING,
N  SD_RADIO_NOTIFICATION_CFG_SET,
N  SD_ECB_BLOCK_ENCRYPT,
N  SD_ECB_BLOCKS_ENCRYPT,
N  SD_RADIO_SESSION_OPEN,
N  SD_RADIO_SESSION_CLOSE,
N  SD_RADIO_REQUEST,
N  SD_EVT_GET,
N  SD_TEMP_GET,
N  SVC_SOC_LAST
N};
N
N/**@brief Possible values of a ::nrf_mutex_t. */
Nenum NRF_MUTEX_VALUES
N{
N  NRF_MUTEX_FREE,
N  NRF_MUTEX_TAKEN
N};
N
N/**@brief Power modes. */
Nenum NRF_POWER_MODES
N{
N  NRF_POWER_MODE_CONSTLAT,  /**< Constant latency mode. See power management in the reference manual. */
N  NRF_POWER_MODE_LOWPWR     /**< Low power mode. See power management in the reference manual. */
N};
N
N
N/**@brief Power failure thresholds */
Nenum NRF_POWER_THRESHOLDS
N{
N  NRF_POWER_THRESHOLD_V21,  /**< 2.1 Volts power failure threshold. */
N  NRF_POWER_THRESHOLD_V23,  /**< 2.3 Volts power failure threshold. */
N  NRF_POWER_THRESHOLD_V25,  /**< 2.5 Volts power failure threshold. */ 
N  NRF_POWER_THRESHOLD_V27   /**< 2.7 Volts power failure threshold. */
N};
N
N
N/**@brief DC/DC converter modes. */
Nenum NRF_POWER_DCDC_MODES
N{
N  NRF_POWER_DCDC_DISABLE,          /**< The DCDC is disabled. */
N  NRF_POWER_DCDC_ENABLE            /**< The DCDC is enabled.  */
N};
N
N/**@brief Radio notification distances. */
Nenum NRF_RADIO_NOTIFICATION_DISTANCES
N{
N  NRF_RADIO_NOTIFICATION_DISTANCE_NONE = 0, /**< The event does not have a notification. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_800US,    /**< The distance from the active notification to start of radio activity. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_1740US,   /**< The distance from the active notification to start of radio activity. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_2680US,   /**< The distance from the active notification to start of radio activity. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_3620US,   /**< The distance from the active notification to start of radio activity. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_4560US,   /**< The distance from the active notification to start of radio activity. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_5500US    /**< The distance from the active notification to start of radio activity. */
N};
N
N
N/**@brief Radio notification types. */
Nenum NRF_RADIO_NOTIFICATION_TYPES
N{
N  NRF_RADIO_NOTIFICATION_TYPE_NONE = 0,        /**< The event does not have a radio notification signal. */
N  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_ACTIVE,   /**< Using interrupt for notification when the radio will be enabled. */
N  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE, /**< Using interrupt for notification when the radio has been disabled. */
N  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH,     /**< Using interrupt for notification both when the radio will be enabled and disabled. */
N};
N
N/**@brief The Radio signal callback types. */
Nenum NRF_RADIO_CALLBACK_SIGNAL_TYPE
N{
N  NRF_RADIO_CALLBACK_SIGNAL_TYPE_START,             /**< This signal indicates the start of the radio timeslot. */
N  NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0,            /**< This signal indicates the NRF_TIMER0 interrupt. */
N  NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO,             /**< This signal indicates the NRF_RADIO interrupt. */
N  NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_FAILED,     /**< This signal indicates extend action failed. */
N  NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_SUCCEEDED   /**< This signal indicates extend action succeeded. */
N};
N
N/**@brief The actions requested by the signal callback.
N *
N *  This code gives the SOC instructions about what action to take when the signal callback has
N *  returned.
N */
Nenum NRF_RADIO_SIGNAL_CALLBACK_ACTION
N{
N  NRF_RADIO_SIGNAL_CALLBACK_ACTION_NONE,            /**< Return without action. */
N  NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND,          /**< Request an extension of the current timeslot (maximum execution time for this action is when the extension succeeded). */
N  NRF_RADIO_SIGNAL_CALLBACK_ACTION_END,             /**< End the current radio timeslot. */
N  NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END  /**< Request a new radio timeslot and end the current timeslot. */
N};
N
N/**@brief Radio timeslot high frequency clock source configuration. */
Nenum NRF_RADIO_HFCLK_CFG
N{
N  NRF_RADIO_HFCLK_CFG_XTAL_GUARANTEED, /**< The SoftDevice will guarantee that the high frequency clock source is the
N                                           external crystal for the whole duration of the timeslot. This should be the
N                                           preferred option for events that use the radio or require high timing accuracy. */
N  NRF_RADIO_HFCLK_CFG_NO_GUARANTEE    /**< This configuration allows for earlier and tighter scheduling of timeslots.
N                                           The RC oscillator may be the clock source in part or for the whole duration of the timeslot.
N                                           The RC oscillator's accuracy must therefore be taken into consideration.
N                                           @note If the application will use the radio peripheral in timeslots with this configuration,
N                                           it must make sure that the crystal is running and stable before starting the radio. */
N};
N
N/**@brief Radio timeslot priorities. */
Nenum NRF_RADIO_PRIORITY
N{
N  NRF_RADIO_PRIORITY_HIGH,                          /**< High (equal priority as the normal connection priority of the SoftDevice stack(s)). */
N  NRF_RADIO_PRIORITY_NORMAL,                        /**< Normal (equal priority as the priority of secondary activites of the SoftDevice stack(s)). */
N};
N
N/**@brief Radio timeslot request type. */
Nenum NRF_RADIO_REQUEST_TYPE
N{
N  NRF_RADIO_REQ_TYPE_EARLIEST,                      /**< Request radio timeslot as early as possible. This should always be used for the first request in a session. */
N  NRF_RADIO_REQ_TYPE_NORMAL                         /**< Normal radio timeslot request. */
N};
N
N/**@brief SoC Events. */
Nenum NRF_SOC_EVTS
N{
N  NRF_EVT_HFCLKSTARTED,                         /**< Event indicating that the HFCLK has started. */
N  NRF_EVT_POWER_FAILURE_WARNING,                /**< Event indicating that a power failure warning has occurred. */
N  NRF_EVT_FLASH_OPERATION_SUCCESS,              /**< Event indicating that the ongoing flash operation has completed successfully. */
N  NRF_EVT_FLASH_OPERATION_ERROR,                /**< Event indicating that the ongoing flash operation has timed out with an error. */
N  NRF_EVT_RADIO_BLOCKED,                        /**< Event indicating that a radio timeslot was blocked. */
N  NRF_EVT_RADIO_CANCELED,                       /**< Event indicating that a radio timeslot was canceled by SoftDevice. */
N  NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN, /**< Event indicating that a radio timeslot signal callback handler return was invalid. */
N  NRF_EVT_RADIO_SESSION_IDLE,                   /**< Event indicating that a radio timeslot session is idle. */
N  NRF_EVT_RADIO_SESSION_CLOSED,                 /**< Event indicating that a radio timeslot session is closed. */
N  NRF_EVT_NUMBER_OF_EVTS
N};
N
N/**@} */
N
N
N/**@addtogroup NRF_SOC_STRUCTURES Structures
N * @{ */
N
N/**@brief Represents a mutex for use with the nrf_mutex functions.
N * @note Accessing the value directly is not safe, use the mutex functions!
N */
Ntypedef volatile uint8_t nrf_mutex_t;
N
N/**@brief Parameters for a request for a timeslot as early as possible. */
Ntypedef struct
N{
N  uint8_t       hfclk;                              /**< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG. */
N  uint8_t       priority;                           /**< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY. */
N  uint32_t      length_us;                          /**< The radio timeslot length (in the range 100 to 100,000] microseconds). */
N  uint32_t      timeout_us;                         /**< Longest acceptable delay until the start of the requested timeslot (up to @ref NRF_RADIO_EARLIEST_TIMEOUT_MAX_US microseconds). */
N} nrf_radio_request_earliest_t;
N
N/**@brief Parameters for a normal radio timeslot request. */
Ntypedef struct
N{
N  uint8_t       hfclk;                              /**< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG. */
N  uint8_t       priority;                           /**< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY. */
N  uint32_t      distance_us;                        /**< Distance from the start of the previous radio timeslot (up to @ref NRF_RADIO_DISTANCE_MAX_US microseconds). */
N  uint32_t      length_us;                          /**< The radio timeslot length (in the range [100..100,000] microseconds). */
N} nrf_radio_request_normal_t;
N
N/**@brief Radio timeslot request parameters. */
Ntypedef struct
N{
N  uint8_t                         request_type;     /**< Type of request, see @ref NRF_RADIO_REQUEST_TYPE. */
N  union
N  {
N    nrf_radio_request_earliest_t  earliest;         /**< Parameters for requesting a radio timeslot as early as possible. */
N    nrf_radio_request_normal_t    normal;           /**< Parameters for requesting a normal radio timeslot. */
N  } params;                                         /**< Parameter union. */
N} nrf_radio_request_t;
N
N/**@brief Return parameters of the radio timeslot signal callback. */
Ntypedef struct
N{
N  uint8_t               callback_action;            /**< The action requested by the application when returning from the signal callback, see @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION. */
N  union
N  {
N    struct
N    {
N      nrf_radio_request_t * p_next;                 /**< The request parameters for the next radio timeslot. */
N    } request;                                      /**< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END. */
N    struct
N    {
N      uint32_t              length_us;              /**< Requested extension of the radio timeslot duration (microseconds) (for minimum time see @ref NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US). */
N    } extend;                                       /**< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND. */
N  } params;                                         /**< Parameter union. */
N} nrf_radio_signal_callback_return_param_t;
N
N/**@brief The radio timeslot signal callback type.
N *
N * @note In case of invalid return parameters, the radio timeslot will automatically end
N *       immediately after returning from the signal callback and the
N *       @ref NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN event will be sent.
N * @note The returned struct pointer must remain valid after the signal callback
N *       function returns. For instance, this means that it must not point to a stack variable.
N *
N * @param[in] signal_type Type of signal, see @ref NRF_RADIO_CALLBACK_SIGNAL_TYPE.
N *
N * @return Pointer to structure containing action requested by the application.
N */
Ntypedef nrf_radio_signal_callback_return_param_t * (*nrf_radio_signal_callback_t) (uint8_t signal_type);
N
N/**@brief AES ECB parameter typedefs */
Ntypedef uint8_t soc_ecb_key_t[SOC_ECB_KEY_LENGTH];                /**< Encryption key type. */
Xtypedef uint8_t soc_ecb_key_t[(16)];                 
Ntypedef uint8_t soc_ecb_cleartext_t[SOC_ECB_CLEARTEXT_LENGTH];    /**< Cleartext data type. */
Xtypedef uint8_t soc_ecb_cleartext_t[(16)];     
Ntypedef uint8_t soc_ecb_ciphertext_t[SOC_ECB_CIPHERTEXT_LENGTH];  /**< Ciphertext data type. */
Xtypedef uint8_t soc_ecb_ciphertext_t[((16))];   
N
N/**@brief AES ECB data structure */
Ntypedef struct
N{
N  soc_ecb_key_t        key;            /**< Encryption key. */
N  soc_ecb_cleartext_t  cleartext;      /**< Cleartext data. */
N  soc_ecb_ciphertext_t ciphertext;     /**< Ciphertext data. */
N} nrf_ecb_hal_data_t;
N
N/**@brief AES ECB block. Used to provide multiple blocks in a single call
N          to @ref sd_ecb_blocks_encrypt.*/
Ntypedef struct
N{
N  soc_ecb_key_t*        p_key;           /**< Pointer to the Encryption key. */
N  soc_ecb_cleartext_t*  p_cleartext;     /**< Pointer to the Cleartext data. */
N  soc_ecb_ciphertext_t* p_ciphertext;    /**< Pointer to the Ciphertext data. */
N} nrf_ecb_hal_data_block_t;
N
N/**@} */
N
N/**@addtogroup NRF_SOC_FUNCTIONS Functions
N * @{ */
N
N/**@brief Initialize a mutex.
N *
N * @param[in] p_mutex Pointer to the mutex to initialize.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_MUTEX_NEW, uint32_t, sd_mutex_new(nrf_mutex_t * p_mutex));
Xuint32_t __svc(SD_MUTEX_NEW) sd_mutex_new(nrf_mutex_t * p_mutex);
N
N/**@brief Attempt to acquire a mutex.
N *
N * @param[in] p_mutex Pointer to the mutex to acquire.
N *
N * @retval ::NRF_SUCCESS The mutex was successfully acquired.
N * @retval ::NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN The mutex could not be acquired.
N */
NSVCALL(SD_MUTEX_ACQUIRE, uint32_t, sd_mutex_acquire(nrf_mutex_t * p_mutex));
Xuint32_t __svc(SD_MUTEX_ACQUIRE) sd_mutex_acquire(nrf_mutex_t * p_mutex);
N
N/**@brief Release a mutex.
N *
N * @param[in] p_mutex Pointer to the mutex to release.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_MUTEX_RELEASE, uint32_t, sd_mutex_release(nrf_mutex_t * p_mutex));
Xuint32_t __svc(SD_MUTEX_RELEASE) sd_mutex_release(nrf_mutex_t * p_mutex);
N
N/**@brief Query the capacity of the application random pool.
N *
N * @param[out] p_pool_capacity The capacity of the pool.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_RAND_APPLICATION_POOL_CAPACITY_GET, uint32_t, sd_rand_application_pool_capacity_get(uint8_t * p_pool_capacity));
Xuint32_t __svc(SD_RAND_APPLICATION_POOL_CAPACITY_GET) sd_rand_application_pool_capacity_get(uint8_t * p_pool_capacity);
N
N/**@brief Get number of random bytes available to the application.
N *
N * @param[out] p_bytes_available The number of bytes currently available in the pool.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_RAND_APPLICATION_BYTES_AVAILABLE_GET, uint32_t, sd_rand_application_bytes_available_get(uint8_t * p_bytes_available));
Xuint32_t __svc(SD_RAND_APPLICATION_BYTES_AVAILABLE_GET) sd_rand_application_bytes_available_get(uint8_t * p_bytes_available);
N
N/**@brief Get random bytes from the application pool.
N *
N * @param[out]  p_buff  Pointer to unit8_t buffer for storing the bytes.
N * @param[in]   length  Number of bytes to take from pool and place in p_buff.
N *
N * @retval ::NRF_SUCCESS The requested bytes were written to p_buff.
N * @retval ::NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES No bytes were written to the buffer, because there were not enough bytes available.
N*/
NSVCALL(SD_RAND_APPLICATION_VECTOR_GET, uint32_t, sd_rand_application_vector_get(uint8_t * p_buff, uint8_t length));
Xuint32_t __svc(SD_RAND_APPLICATION_VECTOR_GET) sd_rand_application_vector_get(uint8_t * p_buff, uint8_t length);
N
N/**@brief Gets the reset reason register. 
N *
N * @param[out]  p_reset_reason  Contents of the NRF_POWER->RESETREAS register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_RESET_REASON_GET, uint32_t, sd_power_reset_reason_get(uint32_t * p_reset_reason));
Xuint32_t __svc(SD_POWER_RESET_REASON_GET) sd_power_reset_reason_get(uint32_t * p_reset_reason);
N
N/**@brief Clears the bits of the reset reason register. 
N *
N * @param[in] reset_reason_clr_msk Contains the bits to clear from the reset reason register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_RESET_REASON_CLR, uint32_t, sd_power_reset_reason_clr(uint32_t reset_reason_clr_msk));
Xuint32_t __svc(SD_POWER_RESET_REASON_CLR) sd_power_reset_reason_clr(uint32_t reset_reason_clr_msk);
N
N/**@brief Sets the power mode when in CPU sleep.
N *
N * @param[in] power_mode The power mode to use when in CPU sleep, see @ref NRF_POWER_MODES. @sa sd_app_evt_wait
N *
N * @retval ::NRF_SUCCESS The power mode was set.
N * @retval ::NRF_ERROR_SOC_POWER_MODE_UNKNOWN The power mode was unknown.
N */
NSVCALL(SD_POWER_MODE_SET, uint32_t, sd_power_mode_set(uint8_t power_mode));
Xuint32_t __svc(SD_POWER_MODE_SET) sd_power_mode_set(uint8_t power_mode);
N
N/**@brief Puts the chip in System OFF mode. 
N *
N * @retval ::NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN
N */
NSVCALL(SD_POWER_SYSTEM_OFF, uint32_t, sd_power_system_off(void));
Xuint32_t __svc(SD_POWER_SYSTEM_OFF) sd_power_system_off(void);
N
N/**@brief Enables or disables the power-fail comparator.
N *
N * Enabling this will give a softdevice event (NRF_EVT_POWER_FAILURE_WARNING) when the power failure warning occurs.
N * The event can be retrieved with sd_evt_get();
N *
N * @param[in] pof_enable    True if the power-fail comparator should be enabled, false if it should be disabled.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_POF_ENABLE, uint32_t, sd_power_pof_enable(uint8_t pof_enable));
Xuint32_t __svc(SD_POWER_POF_ENABLE) sd_power_pof_enable(uint8_t pof_enable);
N
N/**@brief Sets the power-fail threshold value.
N *
N * @param[in] threshold The power-fail threshold value to use, see @ref NRF_POWER_THRESHOLDS.
N *
N * @retval ::NRF_SUCCESS The power failure threshold was set.
N * @retval ::NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN The power failure threshold is unknown.
N */
NSVCALL(SD_POWER_POF_THRESHOLD_SET, uint32_t, sd_power_pof_threshold_set(uint8_t threshold));
Xuint32_t __svc(SD_POWER_POF_THRESHOLD_SET) sd_power_pof_threshold_set(uint8_t threshold);
N
N/**@brief Sets bits in the NRF_POWER->RAMON register.
N *
N * @param[in] ramon Contains the bits needed to be set in the NRF_POWER->RAMON register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_RAMON_SET, uint32_t, sd_power_ramon_set(uint32_t ramon));
Xuint32_t __svc(SD_POWER_RAMON_SET) sd_power_ramon_set(uint32_t ramon);
N
N/**@brief Clears bits in the NRF_POWER->RAMON register.
N *
N * @param ramon Contains the bits needed to be cleared in the NRF_POWER->RAMON register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_RAMON_CLR, uint32_t, sd_power_ramon_clr(uint32_t ramon));
Xuint32_t __svc(SD_POWER_RAMON_CLR) sd_power_ramon_clr(uint32_t ramon);
N
N/**@brief Get contents of NRF_POWER->RAMON register, indicates power status of ram blocks.
N *
N * @param[out] p_ramon Content of NRF_POWER->RAMON register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_RAMON_GET, uint32_t, sd_power_ramon_get(uint32_t * p_ramon));
Xuint32_t __svc(SD_POWER_RAMON_GET) sd_power_ramon_get(uint32_t * p_ramon);
N
N/**@brief Set bits in the general purpose retention registers (NRF_POWER->GPREGRET*).
N *
N * @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2.
N * @param[in] gpregret_msk Bits to be set in the GPREGRET register.
N *
N * @note nRF51 does only have one general purpose retained register, so gpregret_id must be 0 on nRF51.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_GPREGRET_SET, uint32_t, sd_power_gpregret_set(uint32_t gpregret_id, uint32_t gpregret_msk));
Xuint32_t __svc(SD_POWER_GPREGRET_SET) sd_power_gpregret_set(uint32_t gpregret_id, uint32_t gpregret_msk);
N
N/**@brief Clear bits in the general purpose retention registers (NRF_POWER->GPREGRET*).
N *
N * @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2.
N * @param[in] gpregret_msk Bits to be clear in the GPREGRET register.
N *
N * @note nRF51 does only have one general purpose retained register, so gpregret_id must be 0 on nRF51.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_GPREGRET_CLR, uint32_t, sd_power_gpregret_clr(uint32_t gpregret_id, uint32_t gpregret_msk));
Xuint32_t __svc(SD_POWER_GPREGRET_CLR) sd_power_gpregret_clr(uint32_t gpregret_id, uint32_t gpregret_msk);
N
N/**@brief Get contents of the general purpose retention registers (NRF_POWER->GPREGRET*).
N *
N * @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2.
N * @param[out] p_gpregret Contents of the GPREGRET register.
N *
N * @note nRF51 does only have one general purpose retained register, so gpregret_id must be 0 on nRF51.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_GPREGRET_GET, uint32_t, sd_power_gpregret_get(uint32_t gpregret_id, uint32_t *p_gpregret));
Xuint32_t __svc(SD_POWER_GPREGRET_GET) sd_power_gpregret_get(uint32_t gpregret_id, uint32_t *p_gpregret);
N
N/**@brief Sets the DCDC mode.
N *
N * Enable or disable the DCDC peripheral.
N *
N * @param[in] dcdc_mode The mode of the DCDC, see @ref NRF_POWER_DCDC_MODES.
N *
N * @retval ::NRF_SUCCESS
N * @retval ::NRF_ERROR_INVALID_PARAM The DCDC mode is invalid.
N */
NSVCALL(SD_POWER_DCDC_MODE_SET, uint32_t, sd_power_dcdc_mode_set(uint8_t dcdc_mode));
Xuint32_t __svc(SD_POWER_DCDC_MODE_SET) sd_power_dcdc_mode_set(uint8_t dcdc_mode);
N
N/**@brief Request the high frequency crystal oscillator.
N *
N * Will start the high frequency crystal oscillator, the startup time of the crystal varies
N * and the ::sd_clock_hfclk_is_running function can be polled to check if it has started.
N *
N * @see sd_clock_hfclk_is_running
N * @see sd_clock_hfclk_release
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_CLOCK_HFCLK_REQUEST, uint32_t, sd_clock_hfclk_request(void));
Xuint32_t __svc(SD_CLOCK_HFCLK_REQUEST) sd_clock_hfclk_request(void);
N
N/**@brief Releases the high frequency crystal oscillator.
N *
N * Will stop the high frequency crystal oscillator, this happens immediately.
N *
N * @see sd_clock_hfclk_is_running
N * @see sd_clock_hfclk_request
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_CLOCK_HFCLK_RELEASE, uint32_t, sd_clock_hfclk_release(void));
Xuint32_t __svc(SD_CLOCK_HFCLK_RELEASE) sd_clock_hfclk_release(void);
N
N/**@brief Checks if the high frequency crystal oscillator is running.
N *
N * @see sd_clock_hfclk_request
N * @see sd_clock_hfclk_release
N *
N * @param[out] p_is_running 1 if the external crystal oscillator is running, 0 if not.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_CLOCK_HFCLK_IS_RUNNING, uint32_t, sd_clock_hfclk_is_running(uint32_t * p_is_running));
Xuint32_t __svc(SD_CLOCK_HFCLK_IS_RUNNING) sd_clock_hfclk_is_running(uint32_t * p_is_running);
N
N/**@brief Waits for an application event.
N * 
N * An application event is either an application interrupt or a pended interrupt when the
N * interrupt is disabled. When the interrupt is enabled it will be taken immediately since
N * this function will wait in thread mode, then the execution will return in the application's
N * main thread. When an interrupt is disabled and gets pended it will return to the application's 
N * thread main. The application must ensure that the pended flag is cleared using 
N * ::sd_nvic_ClearPendingIRQ in order to sleep using this function. This is only necessary for
N * disabled interrupts, as the interrupt handler will clear the pending flag automatically for
N * enabled interrupts.
N *
N * In order to wake up from disabled interrupts, the SEVONPEND flag has to be set in the Cortex-M0
N * System Control Register (SCR). @sa CMSIS_SCB
N *
N * @note If an application interrupt has happened since the last time sd_app_evt_wait was
N *       called this function will return immediately and not go to sleep. This is to avoid race
N *       conditions that can occur when a flag is updated in the interrupt handler and processed
N *       in the main loop.
N *
N * @post An application interrupt has happened or a interrupt pending flag is set.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_APP_EVT_WAIT, uint32_t, sd_app_evt_wait(void));
Xuint32_t __svc(SD_APP_EVT_WAIT) sd_app_evt_wait(void);
N
N/**@brief Get PPI channel enable register contents.
N *
N * @param[out] p_channel_enable The contents of the PPI CHEN register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_CHANNEL_ENABLE_GET, uint32_t, sd_ppi_channel_enable_get(uint32_t * p_channel_enable));
Xuint32_t __svc(SD_PPI_CHANNEL_ENABLE_GET) sd_ppi_channel_enable_get(uint32_t * p_channel_enable);
N
N/**@brief Set PPI channel enable register.
N *
N * @param[in] channel_enable_set_msk Mask containing the bits to set in the PPI CHEN register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_CHANNEL_ENABLE_SET, uint32_t, sd_ppi_channel_enable_set(uint32_t channel_enable_set_msk));
Xuint32_t __svc(SD_PPI_CHANNEL_ENABLE_SET) sd_ppi_channel_enable_set(uint32_t channel_enable_set_msk);
N
N/**@brief Clear PPI channel enable register.
N *
N * @param[in] channel_enable_clr_msk Mask containing the bits to clear in the PPI CHEN register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_CHANNEL_ENABLE_CLR, uint32_t, sd_ppi_channel_enable_clr(uint32_t channel_enable_clr_msk));
Xuint32_t __svc(SD_PPI_CHANNEL_ENABLE_CLR) sd_ppi_channel_enable_clr(uint32_t channel_enable_clr_msk);
N
N/**@brief Assign endpoints to a PPI channel.
N *
N * @param[in] channel_num Number of the PPI channel to assign.
N * @param[in] evt_endpoint Event endpoint of the PPI channel.
N * @param[in] task_endpoint Task endpoint of the PPI channel.
N *
N * @retval ::NRF_ERROR_SOC_PPI_INVALID_CHANNEL The channel number is invalid.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_CHANNEL_ASSIGN, uint32_t, sd_ppi_channel_assign(uint8_t channel_num, const volatile void * evt_endpoint, const volatile void * task_endpoint));
Xuint32_t __svc(SD_PPI_CHANNEL_ASSIGN) sd_ppi_channel_assign(uint8_t channel_num, const volatile void * evt_endpoint, const volatile void * task_endpoint);
N
N/**@brief Task to enable a channel group.
N *
N * @param[in] group_num Number of the channel group.
N *
N * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_GROUP_TASK_ENABLE, uint32_t, sd_ppi_group_task_enable(uint8_t group_num));
Xuint32_t __svc(SD_PPI_GROUP_TASK_ENABLE) sd_ppi_group_task_enable(uint8_t group_num);
N
N/**@brief Task to disable a channel group.
N *
N * @param[in] group_num Number of the PPI group.
N *
N * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_GROUP_TASK_DISABLE, uint32_t, sd_ppi_group_task_disable(uint8_t group_num));
Xuint32_t __svc(SD_PPI_GROUP_TASK_DISABLE) sd_ppi_group_task_disable(uint8_t group_num);
N
N/**@brief Assign PPI channels to a channel group.
N *
N * @param[in] group_num Number of the channel group.
N * @param[in] channel_msk Mask of the channels to assign to the group.
N *
N * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_GROUP_ASSIGN, uint32_t, sd_ppi_group_assign(uint8_t group_num, uint32_t channel_msk));
Xuint32_t __svc(SD_PPI_GROUP_ASSIGN) sd_ppi_group_assign(uint8_t group_num, uint32_t channel_msk);
N
N/**@brief Gets the PPI channels of a channel group.
N *
N * @param[in]   group_num Number of the channel group.
N * @param[out]  p_channel_msk Mask of the channels assigned to the group.
N *
N * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_GROUP_GET, uint32_t, sd_ppi_group_get(uint8_t group_num, uint32_t * p_channel_msk));
Xuint32_t __svc(SD_PPI_GROUP_GET) sd_ppi_group_get(uint8_t group_num, uint32_t * p_channel_msk);
N
N/**@brief Configures the Radio Notification signal.
N *
N * @note
N *      - The notification signal latency depends on the interrupt priority settings of SWI used
N *        for notification signal.
N *      - To ensure that the radio notification signal behaves in a consistent way, always 
N *        configure radio notifications when there is no protocol stack or other SoftDevice 
N *        activity in progress. It is recommended that the radio notification signal is 
N *        configured directly after the SoftDevice has been enabled.
N *      - In the period between the ACTIVE signal and the start of the Radio Event, the SoftDevice
N *        will interrupt the application to do Radio Event preparation.
N *      - Using the Radio Notification feature may limit the bandwidth, as the SoftDevice may have
N *        to shorten the connection events to have time for the Radio Notification signals.
N *
N * @param[in]  type      Type of notification signal, see @ref NRF_RADIO_NOTIFICATION_TYPES.
N *                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE shall be used to turn off radio
N *                       notification. Using @ref NRF_RADIO_NOTIFICATION_DISTANCE_NONE is
N *                       recommended (but not required) to be used with
N *                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE.
N *
N * @param[in]  distance  Distance between the notification signal and start of radio activity, see @ref NRF_RADIO_NOTIFICATION_DISTANCES.
N *                       This parameter is ignored when @ref NRF_RADIO_NOTIFICATION_TYPE_NONE or 
N *                       @ref NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE is used. 
N *
N * @retval ::NRF_ERROR_INVALID_PARAM The group number is invalid.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_RADIO_NOTIFICATION_CFG_SET, uint32_t, sd_radio_notification_cfg_set(uint8_t type, uint8_t distance));
Xuint32_t __svc(SD_RADIO_NOTIFICATION_CFG_SET) sd_radio_notification_cfg_set(uint8_t type, uint8_t distance);
N
N/**@brief Encrypts a block according to the specified parameters.
N *
N * 128-bit AES encryption.
N *
N * @note:
N *    - The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice sleep while
N *      the ECB is running. The SEVONPEND bit should only be cleared (set to 0) from application
N *      main or low interrupt level.
N *
N * @param[in, out] p_ecb_data Pointer to the ECB parameters' struct (two input
N *                            parameters and one output parameter).
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_ECB_BLOCK_ENCRYPT, uint32_t, sd_ecb_block_encrypt(nrf_ecb_hal_data_t * p_ecb_data));
Xuint32_t __svc(SD_ECB_BLOCK_ENCRYPT) sd_ecb_block_encrypt(nrf_ecb_hal_data_t * p_ecb_data);
N
N/**@brief Encrypts multiple data blocks provided as an array of data block structures.
N *
N * @details: Performs 128-bit AES encryption on multiple data blocks
N *
N * @note:
N *    - The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice sleep while
N *      the ECB is running. The SEVONPEND bit should only be cleared (set to 0) from application
N *      main or low interrupt level.
N *
N * @param[in]     block_count     Count of blocks in the p_data_blocks array.
N * @param[in,out] p_data_blocks   Pointer to the first entry in a contiguous array of
N *                                @ref nrf_ecb_hal_data_block_t structures.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_ECB_BLOCKS_ENCRYPT, uint32_t, sd_ecb_blocks_encrypt(uint8_t block_count, nrf_ecb_hal_data_block_t * p_data_blocks));
Xuint32_t __svc(SD_ECB_BLOCKS_ENCRYPT) sd_ecb_blocks_encrypt(uint8_t block_count, nrf_ecb_hal_data_block_t * p_data_blocks);
N
N/**@brief Gets any pending events generated by the SoC API.
N *
N * The application should keep calling this function to get events, until ::NRF_ERROR_NOT_FOUND is returned.
N *
N * @param[out] p_evt_id Set to one of the values in @ref NRF_SOC_EVTS, if any events are pending.
N *
N * @retval ::NRF_SUCCESS An event was pending. The event id is written in the p_evt_id parameter.
N * @retval ::NRF_ERROR_NOT_FOUND No pending events. 
N */
NSVCALL(SD_EVT_GET, uint32_t, sd_evt_get(uint32_t * p_evt_id));
Xuint32_t __svc(SD_EVT_GET) sd_evt_get(uint32_t * p_evt_id);
N
N/**@brief Get the temperature measured on the chip
N * 
N * This function will block until the temperature measurement is done.
N * It takes around 50us from call to return.
N *
N * @param[out] p_temp Result of temperature measurement. Die temperature in 0.25 degrees celsius.
N *
N * @retval ::NRF_SUCCESS A temperature measurement was done, and the temperature was written to temp
N */
NSVCALL(SD_TEMP_GET, uint32_t, sd_temp_get(int32_t * p_temp));
Xuint32_t __svc(SD_TEMP_GET) sd_temp_get(int32_t * p_temp);
N
N/**@brief Flash Write
N*
N* Commands to write a buffer to flash
N*
N* If the SoftDevice is enabled:
N*  This call initiates the flash access command, and its completion will be communicated to the
N*  application with exactly one of the following events:
N*      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed.
N*      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started.
N*
N* If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the 
N * write has been completed
N*
N* @note
N*      - This call takes control over the radio and the CPU during flash erase and write to make sure that
N*        they will not interfere with the flash access. This means that all interrupts will be blocked
N*        for a predictable time (depending on the NVMC specification in nRF51 Series Reference Manual
N*        and the command parameters).
N*      - The data in the p_src buffer should not be modified before the @ref NRF_EVT_FLASH_OPERATION_SUCCESS
N*        or the @ref NRF_EVT_FLASH_OPERATION_ERROR have been received if the SoftDevice is enabled.
N*
N*
N* @param[in]  p_dst Pointer to start of flash location to be written.
N* @param[in]  p_src Pointer to buffer with data to be written.
N* @param[in]  size  Number of 32-bit words to write. Maximum size is 256 32-bit words for nRF51 and 1024 for nRF52.
N*
N* @retval ::NRF_ERROR_INVALID_ADDR   Tried to write to a non existing flash address, or p_dst or p_src was unaligned.
N* @retval ::NRF_ERROR_BUSY           The previous command has not yet completed.
N* @retval ::NRF_ERROR_INVALID_LENGTH Size was 0, or higher than the maximum allowed size.
N* @retval ::NRF_ERROR_FORBIDDEN      Tried to write to or read from protected location.
N* @retval ::NRF_SUCCESS              The command was accepted.
N*/
NSVCALL(SD_FLASH_WRITE, uint32_t, sd_flash_write(uint32_t * const p_dst, uint32_t const * const p_src, uint32_t size));
Xuint32_t __svc(SD_FLASH_WRITE) sd_flash_write(uint32_t * const p_dst, uint32_t const * const p_src, uint32_t size);
N
N
N/**@brief Flash Erase page
N*
N* Commands to erase a flash page
N* If the SoftDevice is enabled:
N*  This call initiates the flash access command, and its completion will be communicated to the
N*  application with exactly one of the following events:
N*      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed.
N*      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started.
N*
N* If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the 
N* erase has been completed
N*
N* @note
N*      - This call takes control over the radio and the CPU during flash erase and write to make sure that
N*        they will not interfere with the flash access. This means that all interrupts will be blocked
N*        for a predictable time (depending on the NVMC specification in nRF51 Series Reference Manual
N*        and the command parameters).
N*
N*
N* @param[in]  page_number Pagenumber of the page to erase
N* @retval ::NRF_ERROR_INTERNAL      If a new session could not be opened due to an internal error.
N* @retval ::NRF_ERROR_INVALID_ADDR  Tried to erase to a non existing flash page.
N* @retval ::NRF_ERROR_BUSY          The previous command has not yet completed.
N* @retval ::NRF_ERROR_FORBIDDEN     Tried to erase a protected page.
N* @retval ::NRF_SUCCESS             The command was accepted.
N*/
NSVCALL(SD_FLASH_PAGE_ERASE, uint32_t, sd_flash_page_erase(uint32_t page_number));
Xuint32_t __svc(SD_FLASH_PAGE_ERASE) sd_flash_page_erase(uint32_t page_number);
N
N
N/**@brief Flash Protection set
N *
N * Commands to set the flash protection configuration registers.
N   On nRF51 this sets the PROTENSETx registers of the MPU peripheral.
N   On nRF52 this sets the CONFIGx registers of the BPROT peripheral.
N *
N * @note To read the values read them directly. They are only write-protected.
N *
N * @param[in]  block_cfg0 Value to be written to the configuration register.
N * @param[in]  block_cfg1 Value to be written to the configuration register.
N * @param[in]  block_cfg2 Value to be written to the configuration register (ignored on nRF51).
N * @param[in]  block_cfg3 Value to be written to the configuration register (ignored on nRF51).
N *
N * @retval ::NRF_ERROR_FORBIDDEN Tried to protect the SoftDevice.
N * @retval ::NRF_SUCCESS Values successfully written to configuration registers.
N */
NSVCALL(SD_FLASH_PROTECT, uint32_t, sd_flash_protect(uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3));
Xuint32_t __svc(SD_FLASH_PROTECT) sd_flash_protect(uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3);
N
N/**@brief Opens a session for radio timeslot requests.
N *
N * @note Only one session can be open at a time.
N * @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START) will be called when the radio timeslot
N *       starts. From this point the NRF_RADIO and NRF_TIMER0 peripherals can be freely accessed
N *       by the application.
N * @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0) is called whenever the NRF_TIMER0
N *       interrupt occurs.
N * @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO) is called whenever the NRF_RADIO
N *       interrupt occurs.
N * @note p_radio_signal_callback() will be called at ARM interrupt priority level 0. This
N *       implies that none of the sd_* API calls can be used from p_radio_signal_callback().
N *
N * @param[in] p_radio_signal_callback The signal callback.
N *
N * @retval ::NRF_ERROR_INVALID_ADDR p_radio_signal_callback is an invalid function pointer.
N * @retval ::NRF_ERROR_BUSY If session cannot be opened.
N * @retval ::NRF_ERROR_INTERNAL If a new session could not be opened due to an internal error.
N * @retval ::NRF_SUCCESS Otherwise.
N */
N SVCALL(SD_RADIO_SESSION_OPEN, uint32_t, sd_radio_session_open(nrf_radio_signal_callback_t p_radio_signal_callback));
X uint32_t __svc(SD_RADIO_SESSION_OPEN) sd_radio_session_open(nrf_radio_signal_callback_t p_radio_signal_callback);
N
N/**@brief Closes a session for radio timeslot requests.
N *
N * @note Any current radio timeslot will be finished before the session is closed.
N * @note If a radio timeslot is scheduled when the session is closed, it will be canceled.
N * @note The application cannot consider the session closed until the @ref NRF_EVT_RADIO_SESSION_CLOSED
N *       event is received.
N *
N * @retval ::NRF_ERROR_FORBIDDEN If session not opened.
N * @retval ::NRF_ERROR_BUSY If session is currently being closed.
N * @retval ::NRF_SUCCESS Otherwise.
N */
N SVCALL(SD_RADIO_SESSION_CLOSE, uint32_t, sd_radio_session_close(void));
X uint32_t __svc(SD_RADIO_SESSION_CLOSE) sd_radio_session_close(void);
N
N/**@brief Requests a radio timeslot.
N *
N * @note The request type is determined by p_request->request_type, and can be one of @ref NRF_RADIO_REQ_TYPE_EARLIEST
N *       and @ref NRF_RADIO_REQ_TYPE_NORMAL. The first request in a session must always be of type @ref NRF_RADIO_REQ_TYPE_EARLIEST.
N * @note For a normal request (@ref NRF_RADIO_REQ_TYPE_NORMAL), the start time of a radio timeslot is specified by
N *       p_request->distance_us and is given relative to the start of the previous timeslot. 
N * @note A too small p_request->distance_us will lead to a @ref NRF_EVT_RADIO_BLOCKED event.
N * @note Timeslots scheduled too close will lead to a @ref NRF_EVT_RADIO_BLOCKED event.
N * @note See the SoftDevice Specification for more on radio timeslot scheduling, distances and lengths.
N * @note If an opportunity for the first radio timeslot is not found before 100ms after the call to this
N *       function, it is not scheduled, and instead a @ref NRF_EVT_RADIO_BLOCKED event is sent.
N *       The application may then try to schedule the first radio timeslot again.
N * @note Successful requests will result in nrf_radio_signal_callback_t(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START).
N *       Unsuccessful requests will result in a @ref NRF_EVT_RADIO_BLOCKED event, see @ref NRF_SOC_EVTS.
N * @note The jitter in the start time of the radio timeslots is +/- @ref NRF_RADIO_START_JITTER_US us.
N * @note The nrf_radio_signal_callback_t(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START) call has a latency relative to the
N *       specified radio timeslot start, but this does not affect the actual start time of the timeslot.
N * @note NRF_TIMER0 is reset at the start of the radio timeslot, and is clocked at 1MHz from the high frequency
N *       (16 MHz) clock source. If p_request->hfclk_force_xtal is true, the high frequency clock is 
N *       guaranteed to be clocked from the external crystal.
N * @note The SoftDevice will neither access the NRF_RADIO peripheral nor the NRF_TIMER0 peripheral
N *       during the radio timeslot.
N *
N * @param[in] p_request Pointer to the request parameters.
N *
N * @retval ::NRF_ERROR_FORBIDDEN If session not opened or the session is not IDLE.
N * @retval ::NRF_ERROR_INVALID_ADDR If the p_request pointer is invalid.
N * @retval ::NRF_ERROR_INVALID_PARAM If the parameters of p_request are not valid.
N * @retval ::NRF_SUCCESS Otherwise.
N */
N SVCALL(SD_RADIO_REQUEST, uint32_t, sd_radio_request(nrf_radio_request_t * p_request ));
X uint32_t __svc(SD_RADIO_REQUEST) sd_radio_request(nrf_radio_request_t * p_request );
N
N/**@} */
N
N#ifdef __cplusplus
S}
N#endif
N#endif // NRF_SOC_H__
N
N/**@} */
L 50 "..\..\..\..\..\..\components\softdevice\s132\headers\nrf_sdm.h" 2
N#include "nrf_error_sdm.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\nrf_error_sdm.h" 1
N/*
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N *
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N *
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N *
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N /**
N  @addtogroup nrf_sdm_api
N  @{
N  @defgroup nrf_sdm_error SoftDevice Manager Error Codes
N  @{
N
N  @brief Error definitions for the SDM API
N*/
N
N/* Header guard */
N#ifndef NRF_ERROR_SDM_H__
N#define NRF_ERROR_SDM_H__
N
N#include "nrf_error.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN              (NRF_ERROR_SDM_BASE_NUM + 0)  ///< Unknown lfclk source.
N#define NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION (NRF_ERROR_SDM_BASE_NUM + 1)  ///< Incorrect interrupt configuration (can be caused by using illegal priority levels, or having enabled SoftDevice interrupts).
N#define NRF_ERROR_SDM_INCORRECT_CLENR0                  (NRF_ERROR_SDM_BASE_NUM + 2)  ///< Incorrect CLENR0 (can be caused by erronous SoftDevice flashing).
N
N#ifdef __cplusplus
S}
N#endif
N#endif // NRF_ERROR_SDM_H__
N
N/**
N  @}
N  @}
N*/
L 51 "..\..\..\..\..\..\components\softdevice\s132\headers\nrf_sdm.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup NRF_SDM_DEFINES Defines
N * @{ */
N#ifdef NRFSOC_DOXYGEN
S/// Declared in nrf_mbr.h
S#define MBR_SIZE 0
S#warning test
N#endif
N
N/** @brief The major version for the SoftDevice binary distributed with this header file. */
N#define SD_MAJOR_VERSION  (3)
N
N/** @brief The minor version for the SoftDevice binary distributed with this header file. */
N#define SD_MINOR_VERSION  (0)
N
N/** @brief The bugfix version for the SoftDevice binary distributed with this header file. */
N#define SD_BUGFIX_VERSION (0)
N
N/** @brief The full version number for the SoftDevice binary this header file was distributed
N *         with, as a decimal number in the form Mmmmbbb, where:
N *           - M is major version (one or more digits)
N *           - mmm is minor version (three digits)
N *           - bbb is bugfix version (three digits). */
N#define SD_VERSION (SD_MAJOR_VERSION * 1000000 + SD_MINOR_VERSION * 1000 + SD_BUGFIX_VERSION)
N
N/** @brief SoftDevice Manager SVC Base number. */
N#define SDM_SVC_BASE 0x10
N
N/** @brief Invalid info field. Returned when an info field does not exist. */
N#define SDM_INFO_FIELD_INVALID (0)
N
N/** @brief Defines the SoftDevice Information Structure location (address) as an offset from
Nthe start of the softdevice (without MBR)*/
N#define SOFTDEVICE_INFO_STRUCT_OFFSET (0x2000)
N
N/** @brief Defines the absolute SoftDevice Information Structure location (address) when the
N *         SoftDevice is installed just above the MBR (the usual case). */
N#define SOFTDEVICE_INFO_STRUCT_ADDRESS (SOFTDEVICE_INFO_STRUCT_OFFSET + MBR_SIZE)
N
N/** @brief Defines the offset for the SoftDevice Information Structure size value relative to the
N *         SoftDevice base address. The size value is of type uint8_t. */
N#define SD_INFO_STRUCT_SIZE_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET)
N
N/** @brief Defines the offset for the SoftDevice size value relative to the SoftDevice base address.
N *         The size value is of type uint32_t. */
N#define SD_SIZE_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x08)
N
N/** @brief Defines the offset for FWID value relative to the SoftDevice base address. The FWID value
N *         is of type uint16_t.  */
N#define SD_FWID_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x0C)
N
N/** @brief Defines the offset for the SoftDevice ID relative to the SoftDevice base address. The ID
N *         is of type uint32_t. */
N#define SD_ID_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x10)
N
N/** @brief Defines the offset for the SoftDevice version relative to the SoftDevice base address in
N *         the same format as @ref SD_VERSION, stored as an uint32_t. */
N#define SD_VERSION_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x14)
N
N/** @brief Defines a macro for retreiving the actual SoftDevice Information Structure size value
N *         from a given base address. Use @ref MBR_SIZE as the argument when the SoftDevice is
N *         installed just above the MBR (the usual case). */
N#define SD_INFO_STRUCT_SIZE_GET(baseaddr) (*((uint8_t *) ((baseaddr) + SD_INFO_STRUCT_SIZE_OFFSET)))
N
N/** @brief Defines a macro for retreiving the actual SoftDevice size value from a given base
N *         address. Use @ref MBR_SIZE as the argument when the SoftDevice is installed just above
N *         the MBR (the usual case). */
N#define SD_SIZE_GET(baseaddr) (*((uint32_t *) ((baseaddr) + SD_SIZE_OFFSET)))
N
N/** @brief Defines a macro for retreiving the actual FWID value from a given base address. Use @ref
N *         MBR_SIZE as the argument when the SoftDevice is installed just above the MBR (the usual
N *         case). */
N#define SD_FWID_GET(baseaddr) (*((uint16_t *) ((baseaddr) + SD_FWID_OFFSET)))
N
N/** @brief Defines a macro for retreiving the actual SoftDevice ID from a given base address. Use
N *         @ref MBR_SIZE as the argument when the SoftDevice is installed just above the MBR (the
N *         usual case). */
N#define SD_ID_GET(baseaddr) ((SD_INFO_STRUCT_SIZE_GET(baseaddr) > (SD_ID_OFFSET - SOFTDEVICE_INFO_STRUCT_OFFSET)) \
N        ? (*((uint32_t *) ((baseaddr) + SD_ID_OFFSET))) : SDM_INFO_FIELD_INVALID)
X#define SD_ID_GET(baseaddr) ((SD_INFO_STRUCT_SIZE_GET(baseaddr) > (SD_ID_OFFSET - SOFTDEVICE_INFO_STRUCT_OFFSET))         ? (*((uint32_t *) ((baseaddr) + SD_ID_OFFSET))) : SDM_INFO_FIELD_INVALID)
N
N/** @brief Defines a macro for retreiving the actual FWID value from a given base address. Use @ref
N *         MBR_SIZE as the argument when the SoftDevice is installed just above the MBR (the usual
N *         case). */
N#define SD_VERSION_GET(baseaddr) ((SD_INFO_STRUCT_SIZE_GET(baseaddr) > (SD_VERSION_OFFSET - SOFTDEVICE_INFO_STRUCT_OFFSET)) \
N        ? (*((uint32_t *) ((baseaddr) + SD_VERSION_OFFSET))) : SDM_INFO_FIELD_INVALID)
X#define SD_VERSION_GET(baseaddr) ((SD_INFO_STRUCT_SIZE_GET(baseaddr) > (SD_VERSION_OFFSET - SOFTDEVICE_INFO_STRUCT_OFFSET))         ? (*((uint32_t *) ((baseaddr) + SD_VERSION_OFFSET))) : SDM_INFO_FIELD_INVALID)
N
N/**@defgroup NRF_FAULT_ID_RANGES Fault ID ranges
N * @{ */
N#define NRF_FAULT_ID_SD_RANGE_START     0x00000000            /**< SoftDevice ID range start. */
N#define NRF_FAULT_ID_APP_RANGE_START    0x00001000            /**< Application ID range start. */
N/**@} */
N
N/**@defgroup NRF_FAULT_IDS Fault ID types
N * @{ */
N#define NRF_FAULT_ID_SD_ASSERT    (NRF_FAULT_ID_SD_RANGE_START + 1)           /**< SoftDevice assertion. The info parameter will be set to 0x00000000. */
N#define NRF_FAULT_ID_APP_MEMACC   (NRF_FAULT_ID_APP_RANGE_START + 1)          /**< Application invalid memory access (nRF52 only). The info parameter will contain 0x00000000, in case of SoftDevice RAM
N                                                                              access violation. In case of SoftDevice peripheral register violation the info parameter will contain the sub-region number of PREGION[0], on whose address range the unallowed
N                                                                              write access caused the memory access fault. */
N/**@} */
N
N/** @} */
N
N/** @addtogroup NRF_SDM_ENUMS Enumerations
N * @{ */
N
N/**@brief nRF SoftDevice Manager API SVC numbers. */
Nenum NRF_SD_SVCS
N{
N  SD_SOFTDEVICE_ENABLE = SDM_SVC_BASE, /**< ::sd_softdevice_enable */
X  SD_SOFTDEVICE_ENABLE = 0x10,  
N  SD_SOFTDEVICE_DISABLE,               /**< ::sd_softdevice_disable */
N  SD_SOFTDEVICE_IS_ENABLED,            /**< ::sd_softdevice_is_enabled */
N  SD_SOFTDEVICE_VECTOR_TABLE_BASE_SET, /**< ::sd_softdevice_vector_table_base_set */
N  SVC_SDM_LAST                         /**< Placeholder for last SDM SVC */
N};
N
N/** @} */
N
N/** @addtogroup NRF_SDM_DEFINES Defines
N * @{ */
N
N/**@defgroup NRF_CLOCK_LF_XTAL_ACCURACY Clock accuracy
N * @{ */
N
N#define NRF_CLOCK_LF_XTAL_ACCURACY_250_PPM (0) /**< Default: 250 ppm */
N#define NRF_CLOCK_LF_XTAL_ACCURACY_500_PPM (1) /**< 500 ppm */
N#define NRF_CLOCK_LF_XTAL_ACCURACY_150_PPM (2) /**< 150 ppm */
N#define NRF_CLOCK_LF_XTAL_ACCURACY_100_PPM (3) /**< 100 ppm */
N#define NRF_CLOCK_LF_XTAL_ACCURACY_75_PPM  (4) /**< 75 ppm */
N#define NRF_CLOCK_LF_XTAL_ACCURACY_50_PPM  (5) /**< 50 ppm */
N#define NRF_CLOCK_LF_XTAL_ACCURACY_30_PPM  (6) /**< 30 ppm */
N#define NRF_CLOCK_LF_XTAL_ACCURACY_20_PPM  (7) /**< 20 ppm */
N
N/** @} */
N
N/**@defgroup NRF_CLOCK_LF_SRC Possible lfclk oscillator sources
N * @{ */
N
N#define NRF_CLOCK_LF_SRC_RC      (0)                        /**< LFCLK RC oscillator. */
N#define NRF_CLOCK_LF_SRC_XTAL    (1)                        /**< LFCLK crystal oscillator. */
N#define NRF_CLOCK_LF_SRC_SYNTH   (2)                        /**< LFCLK Synthesized from HFCLK. */
N
N/** @} */
N
N/** @} */
N
N/** @addtogroup NRF_SDM_TYPES Types
N * @{ */
N
N/**@brief Type representing lfclk oscillator source. */
Ntypedef struct
N{
N  uint8_t source;        /**< LF oscillator clock source, see @ref NRF_CLOCK_LF_SRC. */
N  uint8_t rc_ctiv;      /**< Only for NRF_CLOCK_LF_SRC_RC: Calibration timer interval in 1/4 second
N                              units (nRF51: 1-64, nRF52: 1-32).
N                              @note To avoid excessive clock drift, 0.5 degrees Celsius is the
N                                    maximum temperature change allowed in one calibration timer
N                                    interval. The interval should be selected to ensure this.
N
N                              @note Must be 0 if source is not NRF_CLOCK_LF_SRC_RC.  */
N  uint8_t rc_temp_ctiv; /**<  Only for NRF_CLOCK_LF_SRC_RC: How often (in number of calibration
N                              intervals) the RC oscillator shall be calibrated if the temperature
N                              hasn't changed.
N                                  0: Always calibrate even if the temperature hasn't changed.
N                                  1: Only calibrate if the temperature has changed (nRF51 only).
N                                  2-33: Check the temperature and only calibrate if it has changed,
N                                        however calibration will take place every rc_temp_ctiv
N                                        intervals in any case.
N
N                              @note Must be 0 if source is not NRF_CLOCK_LF_SRC_RC.
N
N                              @note For nRF52, the application must ensure calibration at least once
N                                    every 8 seconds to ensure +/-250ppm clock stability. The
N                                    recommended configuration for NRF_CLOCK_LF_SRC_RC on nRF52 is
N                                    rc_ctiv=16 and rc_temp_ctiv=2. This will ensure calibration at
N                                    least once every 8 seconds and for temperature changes of 0.5
N                                    degrees Celsius every 4 seconds. See the Product Specification
N                                    for the nRF52 device being used for more information.*/
N  uint8_t xtal_accuracy; /**< External crystal clock accuracy used in the LL to compute timing windows.
N
N                              @note For the NRF_CLOCK_LF_SRC_RC clock source this parameter is ignored. */
N} nrf_clock_lf_cfg_t;
N
N/**@brief Fault Handler type.
N *
N * When certain unrecoverable errors occur within the application or SoftDevice the fault handler will be called back.
N * The protocol stack will be in an undefined state when this happens and the only way to recover will be to
N * perform a reset, using e.g. CMSIS NVIC_SystemReset().
N *
N * @note This callback is executed in HardFault context, thus SVC functions cannot be called from the fault callback.
N *
N * @param[in] id Fault identifier. See @ref NRF_FAULT_IDS.
N * @param[in] pc The program counter of the instruction that triggered the fault.
N * @param[in] info Optional additional information regarding the fault. Refer to each Fault identifier for details.
N *
N * @note When id is set to NRF_FAULT_ID_APP_MEMACC, pc will contain the address of the instruction being executed at the time when
N * the fault is detected by the CPU. The CPU program counter may have advanced up to 2 instructions (no branching) after the one that triggered the fault.
N */
Ntypedef void (*nrf_fault_handler_t)(uint32_t id, uint32_t pc, uint32_t info);
N
N/** @} */
N
N/** @addtogroup NRF_SDM_FUNCTIONS Functions
N * @{ */
N
N/**@brief Enables the SoftDevice and by extension the protocol stack.
N *
N * @note Some care must be taken if a low frequency clock source is already running when calling this function:
N *       If the LF clock has a different source then the one currently running, it will be stopped. Then, the new
N *       clock source will be started.
N *
N * @note This function has no effect when returning with an error.
N *
N * @post If return code is ::NRF_SUCCESS
N *       - SoC library and protocol stack APIs are made available.
N *       - A portion of RAM will be unavailable (see relevant SDS documentation).
N *       - Some peripherals will be unavailable or available only through the SoC API (see relevant SDS documentation).
N *       - Interrupts will not arrive from protected peripherals or interrupts.
N *       - nrf_nvic_ functions must be used instead of CMSIS NVIC_ functions for reliable usage of the SoftDevice.
N *       - Interrupt latency may be affected by the SoftDevice  (see relevant SDS documentation).
N *       - Chosen low frequency clock source will be running.
N *
N * @param p_clock_lf_cfg Low frequency clock source and accuracy.
N                         If NULL the clock will be configured as an rc source with rc_ctiv = 16 and .rc_temp_ctiv = 2
N                         In the case of XTAL source, the PPM accuracy of the chosen clock source must be greater than or equal to the actual characteristics of your XTAL clock.
N * @param fault_handler Callback to be invoked in case of fault.
N *
N * @retval ::NRF_SUCCESS
N * @retval ::NRF_ERROR_INVALID_STATE SoftDevice is already enabled, and the clock source and fault handler cannot be updated.
N * @retval ::NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION SoftDevice interrupt is already enabled, or an enabled interrupt has an illegal priority level.
N * @retval ::NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN Unknown low frequency clock source selected.
N */
NSVCALL(SD_SOFTDEVICE_ENABLE, uint32_t, sd_softdevice_enable(nrf_clock_lf_cfg_t const * p_clock_lf_cfg, nrf_fault_handler_t fault_handler));
Xuint32_t __svc(SD_SOFTDEVICE_ENABLE) sd_softdevice_enable(nrf_clock_lf_cfg_t const * p_clock_lf_cfg, nrf_fault_handler_t fault_handler);
N
N
N/**@brief Disables the SoftDevice and by extension the protocol stack.
N *
N * Idempotent function to disable the SoftDevice.
N *
N * @post SoC library and protocol stack APIs are made unavailable.
N * @post All interrupts that was protected by the SoftDevice will be disabled and initialized to priority 0 (highest).
N * @post All peripherals used by the SoftDevice will be reset to default values.
N * @post All of RAM become available.
N * @post All interrupts are forwarded to the application.
N * @post LFCLK source chosen in ::sd_softdevice_enable will be left running.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_SOFTDEVICE_DISABLE, uint32_t, sd_softdevice_disable(void));
Xuint32_t __svc(SD_SOFTDEVICE_DISABLE) sd_softdevice_disable(void);
N
N/**@brief Check if the SoftDevice is enabled.
N *
N * @param[out]  p_softdevice_enabled If the SoftDevice is enabled: 1 else 0.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_SOFTDEVICE_IS_ENABLED, uint32_t, sd_softdevice_is_enabled(uint8_t * p_softdevice_enabled));
Xuint32_t __svc(SD_SOFTDEVICE_IS_ENABLED) sd_softdevice_is_enabled(uint8_t * p_softdevice_enabled);
N
N/**@brief Sets the base address of the interrupt vector table for interrupts forwarded from the SoftDevice
N *
N * This function is only intended to be called when a bootloader is enabled.
N *
N * @param[in] address The base address of the interrupt vector table for forwarded interrupts.
N
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_SOFTDEVICE_VECTOR_TABLE_BASE_SET, uint32_t, sd_softdevice_vector_table_base_set(uint32_t address));
Xuint32_t __svc(SD_SOFTDEVICE_VECTOR_TABLE_BASE_SET) sd_softdevice_vector_table_base_set(uint32_t address);
N
N/** @} */
N
N#ifdef __cplusplus
S}
N#endif
N#endif // NRF_SDM_H__
N
N/**
N  @}
N*/
L 38 "..\..\..\..\..\..\components\softdevice\common\softdevice_handler\softdevice_handler.h" 2
N#include "app_error.h"
N#include "app_util.h"
N#include "ble_stack_handler_types.h"
L 1 "..\..\..\..\..\..\components\softdevice\common\softdevice_handler\ble_stack_handler_types.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**@file
N *
N * @defgroup ble_stack_handler_types Types definitions for BLE support in SoftDevice handler.
N * @{
N * @ingroup  softdevice_handler
N * @brief    This file contains the declarations of types required for BLE stack support. These
N *           types will be defined when the preprocessor define BLE_STACK_SUPPORT_REQD is defined.
N */
N
N#ifndef BLE_STACK_HANDLER_TYPES_H__
N#define BLE_STACK_HANDLER_TYPES_H__
N
N#ifdef BLE_STACK_SUPPORT_REQD
N
N#include <stdlib.h>
N#include "ble.h"
N#include "nrf_sdm.h"
N#include "app_error.h"
N#include "app_util.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define BLE_STACK_EVT_MSG_BUF_SIZE       (sizeof(ble_evt_t) + (GATT_MTU_SIZE_DEFAULT))     /**< Size of BLE event message buffer. This will be provided to the SoftDevice while fetching an event. */
N#define BLE_STACK_HANDLER_SCHED_EVT_SIZE 0                                                 /**< The size of the scheduler event used by SoftDevice handler when passing BLE events using the @ref app_scheduler. */
N
N/**@brief Application stack event handler type. */
Ntypedef void (*ble_evt_handler_t) (ble_evt_t * p_ble_evt);
N
N/**@brief     Function for registering for BLE events.
N *
N * @details   The application should use this function to register for receiving BLE events from
N *            the SoftDevice. If the application does not call this function, then any BLE event
N *            that may be generated by the SoftDevice will NOT be fetched. Once the application has
N *            registered for the events, it is not possible to cancel the registration.
N *            However, it is possible to register a different function for handling the events at
N *            any point of time.
N *
N * @param[in] ble_evt_handler Function to be called for each received BLE event.
N *
N * @retval    NRF_SUCCESS     Successful registration.
N * @retval    NRF_ERROR_NULL  Null pointer provided as input.
N */
Nuint32_t softdevice_ble_evt_handler_set(ble_evt_handler_t ble_evt_handler);
N
N#else
S
S#define BLE_STACK_EVT_MSG_BUF_SIZE        0                                                /**< Since the BLE stack support is not required, this is equated to 0, so that the @ref softdevice_handler.h can compute the internal event buffer size without having to care for BLE events.*/
S#define BLE_STACK_HANDLER_SCHED_EVT_SIZE  0
S
N#endif // BLE_STACK_SUPPORT_REQD
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // BLE_STACK_HANDLER_TYPES_H__
N
N/** @} */
L 41 "..\..\..\..\..\..\components\softdevice\common\softdevice_handler\softdevice_handler.h" 2
N#include "ant_stack_handler_types.h"
L 1 "..\..\..\..\..\..\components\softdevice\common\softdevice_handler\ant_stack_handler_types.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**@file
N *
N * @defgroup ant_stack_handler_types Types definitions for ANT support in SoftDevice handler.
N * @{
N * @ingroup  softdevice_handler
N * @brief    This file contains the declarations of types required for ANT stack support. These
N *           types will be defined when the preprocessor define ANT_STACK_SUPPORT_REQD is defined.
N */
N
N#ifndef ANT_STACK_HANDLER_TYPES_H__
N#define ANT_STACK_HANDLER_TYPES_H__
N
N#ifdef ANT_STACK_SUPPORT_REQD
S
S#include <stdlib.h>
S#include <stdint.h>
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S#define ANT_STACK_EVT_MSG_BUF_SIZE      32                                                /**< Size of ANT event message buffer. This will be provided to the SoftDevice while fetching an event. */
S#define ANT_STACK_EVT_STRUCT_SIZE       (sizeof(ant_evt_t))                               /**< Size of the @ref ant_evt_t structure. This will be used by the @ref softdevice_handler to internal event buffer size needed. */
S
S/**@brief ANT stack event type. */
Stypedef struct
S{
S    union
S    {
S        uint32_t ulForceAlign;                           ///< force the evt_buffer to be 4-byte aligned, required for some casting to ANT_MESSAGE.
S        uint8_t  evt_buffer[ANT_STACK_EVT_MSG_BUF_SIZE]; ///< Event message buffer.
S    } msg;
S    uint8_t channel;                                     ///< Channel number.
S    uint8_t event;                                       ///< Event code.
S} ant_evt_t;
S
S/**@brief Application ANT stack event handler type. */
Stypedef void (*ant_evt_handler_t) (ant_evt_t * p_ant_evt);
S
S/**@brief     Function for registering for ANT events.
S *
S * @details   The application should use this function to register for receiving ANT events from
S *            the SoftDevice. If the application does not call this function, then any ANT event
S *            that may be generated by the SoftDevice will NOT be fetched. Once the application has
S *            registered for the events, it is not possible to  possible to cancel the registration.
S *            However, it is possible to register a different function for handling the events at
S *            any point of time.
S *
S * @param[in] ant_evt_handler Function to be called for each received ANT event.
S *
S * @retval    NRF_SUCCESS     Successful registration.
S * @retval    NRF_ERROR_NULL  Null pointer provided as input.
S */
Suint32_t softdevice_ant_evt_handler_set(ant_evt_handler_t ant_evt_handler);
S
N#else
N
N// The ANT Stack support is not required.
N
N#define ANT_STACK_EVT_STRUCT_SIZE       0                                                 /**< Since the ANT stack support is not required, this is equated to 0, so that the @ref softdevice_handler.h can compute the internal event buffer size without having to care for ANT events.*/
N
N#endif // ANT_STACK_SUPPORT_REQD
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // ANT_STACK_HANDLER_TYPES_H__
N
N/** @} */
L 42 "..\..\..\..\..\..\components\softdevice\common\softdevice_handler\softdevice_handler.h" 2
N#if defined(BLE_STACK_SUPPORT_REQD)
X#if 1L
N    #include "ble.h"
N#endif
N#include "app_ram_base.h"
L 1 "..\..\..\..\..\..\components\softdevice\common\softdevice_handler\app_ram_base.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N// ble_enable param app_ram_base
N
N#ifndef APP_RAM_BASE_H__
N#define APP_RAM_BASE_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#ifdef S130
S    #define APP_RAM_BASE_CENTRAL_LINKS_0_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20001870
S    #define APP_RAM_BASE_CENTRAL_LINKS_0_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20001900
S    #define APP_RAM_BASE_CENTRAL_LINKS_0_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20001fe8
S    #define APP_RAM_BASE_CENTRAL_LINKS_0_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20002078
S    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20001ce0
S    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20001d70
S    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20001eb0
S    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20001f40
S    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002418
S    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x200024a8
S    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x200025e0
S    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002670
S    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002110
S    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x200021a0
S    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x200022d8
S    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002368
S    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002840
S    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x200028d0
S    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20002a10
S    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002aa0
S    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002538
S    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x200025c8
S    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20002708
S    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002798
S    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002c70
S    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20002d00
S    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20002e40
S    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002ed0
S    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002968
S    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x200029f8
S    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20002b30
S    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002bc0
S    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x200030a0
S    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003130
S    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003268
S    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x200032f8
S    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002d98
S    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20002e28
S    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20002f60
S    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002ff0
S    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x200034c8
S    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003558
S    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003698
S    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003728
S    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x200031c0
S    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003250
S    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003390
S    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003420
S    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x200038f8
S    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003988
S    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003ac0
S    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003b50
S    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x200035f0
S    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003680
S    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x200037b8
S    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003848
S    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20003d28
S    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003db8
S    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003ef0
S    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003f80
S    #define APP_RAM_BASE_CENTRAL_LINKS_8_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20003a18
S    #define APP_RAM_BASE_CENTRAL_LINKS_8_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003aa8
S    #define APP_RAM_BASE_CENTRAL_LINKS_8_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003be8
S    #define APP_RAM_BASE_CENTRAL_LINKS_8_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003c78
N#elif defined(S132) || defined(S332)
X#elif 1L || 0L
N    #define APP_RAM_BASE_CENTRAL_LINKS_0_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20001930
N    #define APP_RAM_BASE_CENTRAL_LINKS_0_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x200019c0
N    #define APP_RAM_BASE_CENTRAL_LINKS_0_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002128
N    #define APP_RAM_BASE_CENTRAL_LINKS_0_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x200021b8
N    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20001e18
N    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20001ea8
N    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20001fe8
N    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002078
N    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x200025d0
N    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20002660
N    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20002798
N    #define APP_RAM_BASE_CENTRAL_LINKS_1_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002828
N    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x200022c0
N    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20002350
N    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20002490
N    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002520
N    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002a78
N    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20002b08
N    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20002c40
N    #define APP_RAM_BASE_CENTRAL_LINKS_2_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002cd0
N    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002768
N    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x200027f8
N    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20002938
N    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x200029c8
N    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002f20
N    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20002fb0
N    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x200030e8
N    #define APP_RAM_BASE_CENTRAL_LINKS_3_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003178
N    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20002c10
N    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20002ca0
N    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20002de0
N    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20002e70
N    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x200033c8
N    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003458
N    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003590
N    #define APP_RAM_BASE_CENTRAL_LINKS_4_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003620
N    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x200030b8
N    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003148
N    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003288
N    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003318
N    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20003870
N    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003900
N    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003a38
N    #define APP_RAM_BASE_CENTRAL_LINKS_5_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003ac8
N    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20003560
N    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x200035f0
N    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003730
N    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x200037c0
N    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20003d18
N    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003da8
N    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003ee0
N    #define APP_RAM_BASE_CENTRAL_LINKS_6_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003f70
N    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20003a08
N    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003a98
N    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20003bd8
N    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20003c68
N    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x200041c0
N    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_1_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20004250
N    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20004388
N    #define APP_RAM_BASE_CENTRAL_LINKS_7_PERIPH_LINKS_1_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20004418
N    #define APP_RAM_BASE_CENTRAL_LINKS_8_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_1_MID_BW 0x20003eb0
N    #define APP_RAM_BASE_CENTRAL_LINKS_8_PERIPH_LINKS_0_SEC_COUNT_0_VS_UUID_COUNT_10_MID_BW 0x20003f40
N    #define APP_RAM_BASE_CENTRAL_LINKS_8_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_1_MID_BW 0x20004080
N    #define APP_RAM_BASE_CENTRAL_LINKS_8_PERIPH_LINKS_0_SEC_COUNT_1_VS_UUID_COUNT_10_MID_BW 0x20004110
N#endif
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_RAM_BASE_H__
L 46 "..\..\..\..\..\..\components\softdevice\common\softdevice_handler\softdevice_handler.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N#define SOFTDEVICE_SCHED_EVT_SIZE       0                                                 /**< Size of button events being passed through the scheduler (is to be used for computing the maximum size of scheduler events). For SoftDevice events, this size is 0, since the events are being pulled in the event handler. */
N#define SYS_EVT_MSG_BUF_SIZE            sizeof(uint32_t)                                  /**< Size of System (SOC) event message buffer. */
N
N
N
N/** @brief Macro for checking the RAM requirement of the SoftDevice.  */
N#define CHECK_RAM_START_ADDR(C_LINK_CNT, P_LINK_CNT)
N
N
N/**@brief     Function for checking the RAM requirement of the SoftDevice.
N *
N * @details   Call this function to check if the project settings have the correct RAM start address in respect to what the SoftDevice requires.
N *
N * @note      This function is called using the CHECK_RAM_START_ADDR_INTERN macro and should not be called directly.
N */
Nuint32_t sd_check_ram_start(uint32_t sd_req_ram_start);
N
N/**@brief Type of function for passing events from the stack handler module to the scheduler. */
Ntypedef uint32_t (*softdevice_evt_schedule_func_t) (void);
N
N/**@brief Application System (SOC) event handler type. */
Ntypedef void (*sys_evt_handler_t) (uint32_t evt_id);
N
N
N/**@brief     Macro for initializing the stack event handler.
N *
N * @details   It will handle dimensioning and allocation of the memory buffer required for reading
N *            events from the stack, making sure the buffer is correctly aligned. It will also
N *            connect the stack event handler to the scheduler/RTOS (if specified).
N *
N * @param[in] CLOCK_SOURCE     Low frequency clock source and accuracy (type nrf_clock_lf_cfg_t_t,
N *                             see sd_softdevice_enable() for details).
N * @param[in] EVT_HANDLER      scheduler/RTOS event handler function.
N *
N * @note      Since this macro allocates a buffer, it must only be called once (it is OK to call it
N *            several times as long as it is from the same location, that is to do a
N *            reinitialization).
N */
N/*lint -emacro(506, SOFTDEVICE_HANDLER_INIT) */ /* Suppress "Constant value Boolean */
N#define SOFTDEVICE_HANDLER_INIT(CLOCK_SOURCE,                                                      \
N                                EVT_HANDLER)                                                       \
N    do                                                                                             \
N    {                                                                                              \
N        static uint32_t BLE_EVT_BUFFER[CEIL_DIV(BLE_STACK_EVT_MSG_BUF_SIZE, sizeof(uint32_t))];    \
N        uint32_t ERR_CODE;                                                                         \
N        ERR_CODE = softdevice_handler_init((CLOCK_SOURCE),                                         \
N                                           BLE_EVT_BUFFER,                                         \
N                                           sizeof(BLE_EVT_BUFFER),                                 \
N                                           EVT_HANDLER);                                           \
N        APP_ERROR_CHECK(ERR_CODE);                                                                 \
N    } while (0)
X#define SOFTDEVICE_HANDLER_INIT(CLOCK_SOURCE,                                                                                      EVT_HANDLER)                                                           do                                                                                                 {                                                                                                      static uint32_t BLE_EVT_BUFFER[CEIL_DIV(BLE_STACK_EVT_MSG_BUF_SIZE, sizeof(uint32_t))];            uint32_t ERR_CODE;                                                                                 ERR_CODE = softdevice_handler_init((CLOCK_SOURCE),                                                                                    BLE_EVT_BUFFER,                                                                                    sizeof(BLE_EVT_BUFFER),                                                                            EVT_HANDLER);                                                   APP_ERROR_CHECK(ERR_CODE);                                                                     } while (0)
N
N/**
N * @brief Function for retrieving the information about SD state
N *
N * The information about current state of softdevice.
N * @retval false SD is not initialized and SD commands should not be called.
N * @retval true  SD is already initialized
N */
Nbool softdevice_handler_is_enabled(void);
X_Bool softdevice_handler_is_enabled(void);
N
N/**@brief      Function for initializing the stack handler module.
N *
N * @details    Enables the SoftDevice and the stack event interrupt handler.
N *
N * @note       This function must be called before calling any function in the SoftDevice API.
N *
N * @note       Normally initialization should be done using the SOFTDEVICE_HANDLER_INIT() macro,
N *             as that will both allocate the event buffer, and also align the buffer correctly.
N *
N * @param[in]  p_clock_lf_cfg      Low frequency clock source to be used by the SoftDevice.
N * @param[in]  p_ble_evt_buffer    Buffer for holding one BLE stack event. Since heap is not being
N *                                 used, this buffer must be provided by the application. The
N *                                 buffer must be large enough to hold the biggest stack event the
N *                                 application is supposed to handle. The buffer must be aligned to
N *                                 a 4 byte boundary. This parameter is unused if BLE stack support
N *                                 is not required.
N * @param[in]  ble_evt_buffer_size Size of SoftDevice BLE event buffer. This parameter is unused if
N *                                 BLE stack support is not required.
N * @param[in]  evt_schedule_func   Function for passing events to the scheduler. Point to
N *                                 ble_ant_stack_evt_schedule() to connect to the scheduler.
N *                                 Set to NULL to make the stack handler module call the event
N *                                 handler directly from the stack event interrupt handler.
N *
N * @retval     NRF_SUCCESS               Successful initialization.
N * @retval     NRF_ERROR_INVALID_PARAM   Invalid parameter (buffer not aligned to a 4 byte
N *                                       boundary) or NULL.
N */
Nuint32_t softdevice_handler_init(nrf_clock_lf_cfg_t *              p_clock_lf_cfg,
N                                 void *                            p_ble_evt_buffer,
N                                 uint16_t                          ble_evt_buffer_size,
N                                 softdevice_evt_schedule_func_t    evt_schedule_func);
N
N
N/**@brief     Function for disabling the SoftDevice.
N *
N * @details   This function will disable the SoftDevice. It will also update the internal state
N *            of this module.
N */
Nuint32_t softdevice_handler_sd_disable(void);
N
N/**@brief     Function for suspending the event handler.
N *
N * @details   When event handler is disabled, no new events are pulled from SoftDevice.
N *            Application can suspend pulling incoming events when its event queue is full.
N */
Nvoid softdevice_handler_suspend(void);
N
N/**@brief     Function for re-enabling the event handler after suspending.
N */
Nvoid softdevice_handler_resume(void);
N
N/**@brief Function for retrieving the information about the event handler state
N *
N * @retval false Event handler is active.
N * @retval true  Event handler is suspended and events from SD will not be pulled.
N */
Nbool softdevice_handler_is_suspended(void);
X_Bool softdevice_handler_is_suspended(void);
N
N
N/**@brief     Function for registering for System (SOC) events.
N *
N * @details   The application should use this function to register for receiving System (SOC)
N *            events from the SoftDevice. If the application does not call this function, then any
N *            System (SOC) events that may be generated by the SoftDevice will NOT be fetched. Once
N *            the application has registered for the events, it is not possible to  possible to
N *            cancel the registration. However, it is possible to register a different function for
N *            handling the events at any point of time.
N *
N * @param[in] sys_evt_handler Function to be called for each received System (SOC) event.
N *
N * @retval    NRF_SUCCESS     Successful registration.
N * @retval    NRF_ERROR_NULL  Null pointer provided as input.
N */
Nuint32_t softdevice_sys_evt_handler_set(sys_evt_handler_t sys_evt_handler);
N
N#if defined(BLE_STACK_SUPPORT_REQD)
X#if 1L
N/**@brief     Function for fetching the default enable parameters for the SoftDevice.
N *
N * @details   The default enable parameters will work for most projects in the SDK.
N *            They are not optimized with regards to RAM use. This function is meant as a way to abstract the
N *            details of p_ble_enable_params needed by @ref softdevice_enable. You might want to tweak
N *            the struct returned by this function or fill in the entire ble_enable_params_t
N *            instead of fetching it from this function.
N *
N * @param[in]  central_links_count Number of central links used by the application.
N * @param[in]  periph_links_count Number of peripheral links used by the application.
N * @param[out] p_ble_enable_params Default ble_enable_params_t to be used by @ref softdevice_enable.
N *
N * @retval    NRF_SUCCESS     If the operation was successful.
N */
Nuint32_t softdevice_enable_get_default_config(uint8_t central_links_count,
N                                              uint8_t periph_links_count,
N                                              ble_enable_params_t * p_ble_enable_params);
N
N/**@brief     Function for enabling the SoftDevice.
N *
N * @details   This function calls the @ref sd_ble_enable SVC call. It has been abstracted to give
N *            feedback on the app_ram_base. If the app_ram_base is too low, this function will
N *            return an error. Using a app_ram_base that is too high will not fail, but will
N *            result in RAM that is never used. If the DEBUG macro is enabled, this
N *            function will provide the correct app_ram_base as mandated by the SoftDevice.
N *            This is useful to tweak the RAM use of your application.
N *
N * @param[in]  p_ble_enable_params Parameters for configuring links and bandwidths.
N *
N * @retval    NRF_SUCCESS     If the operation was successful.
N */
Nuint32_t softdevice_enable(ble_enable_params_t * p_ble_enable_params);
N#endif //BLE_STACK_SUPPORT_REQD
N// Functions for connecting the Stack Event Handler to the scheduler:
N/**@cond NO_DOXYGEN */
Nvoid intern_softdevice_events_execute(void);
N
N
N/**@endcond */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // SOFTDEVICE_HANDLER_H__
N
N/** @} */
L 43 "..\..\..\main.c" 2
N#include "app_timer.h"
L 1 "..\..\..\..\..\..\components\libraries\timer\app_timer.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup app_timer Application Timer
N * @{
N * @ingroup app_common
N *
N * @brief Application timer functionality.
N *
N * @details This module enables the application to create multiple timer instances based on the RTC1
N *          peripheral. Checking for time-outs and invocation of user time-out handlers is performed
N *          in the RTC1 interrupt handler. List handling is done using a software interrupt (SWI0).
N *          Both interrupt handlers are running in APP_LOW priority level.
N *
N * @details When calling app_timer_start() or app_timer_stop(), the timer operation is just queued,
N *          and the software interrupt is triggered. The actual timer start/stop operation is
N *          executed by the SWI0 interrupt handler. Since the SWI0 interrupt is running in APP_LOW,
N *          if the application code calling the timer function is running in APP_LOW or APP_HIGH,
N *          the timer operation will not be performed until the application handler has returned.
N *          This will be the case, for example, when stopping a timer from a time-out handler when not using
N *          the scheduler.
N *
N * @details Use the USE_SCHEDULER parameter of the APP_TIMER_INIT() macro to select if the
N *          @ref app_scheduler should be used or not. Even if the scheduler is
N *          not used, app_timer.h will include app_scheduler.h, so when
N *          compiling, app_scheduler.h must be available in one of the compiler include paths.
N */
N
N#ifndef APP_TIMER_H__
N#define APP_TIMER_H__
N#include "sdk_config.h"
L 1 "..\config\sdk_config.h" 1
N
N
N#ifndef SDK_CONFIG_H
N#define SDK_CONFIG_H
N// <<< Use Configuration Wizard in Context Menu >>>\n
N#ifdef USE_APP_CONFIG
S#include "app_config.h"
N#endif
N// <h> nRF_BLE 
N
N//==========================================================
N// <q> BLE_ADVERTISING_ENABLED  - ble_advertising - Advertising module
N 
N
N#ifndef BLE_ADVERTISING_ENABLED
N#define BLE_ADVERTISING_ENABLED 1
N#endif
N
N// <q> BLE_DTM_ENABLED  - ble_dtm - Module for testing RF/PHY using DTM commands
N 
N
N#ifndef BLE_DTM_ENABLED
N#define BLE_DTM_ENABLED 0
N#endif
N
N// <q> BLE_RACP_ENABLED  - ble_racp - Record Access Control Point library
N 
N
N#ifndef BLE_RACP_ENABLED
N#define BLE_RACP_ENABLED 0
N#endif
N
N// <q> NRF_BLE_QWR_ENABLED  - nrf_ble_qwr - Queued writes support module (prepare/execute write)
N 
N
N#ifndef NRF_BLE_QWR_ENABLED
N#define NRF_BLE_QWR_ENABLED 1
N#endif
N
N// <q> PEER_MANAGER_ENABLED  - peer_manager - Peer Manager
N 
N
N#ifndef PEER_MANAGER_ENABLED
N#define PEER_MANAGER_ENABLED 1
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_BLE_Services 
N
N//==========================================================
N// <q> BLE_ANCS_C_ENABLED  - ble_ancs_c - Apple Notification Service Client
N 
N
N#ifndef BLE_ANCS_C_ENABLED
N#define BLE_ANCS_C_ENABLED 0
N#endif
N
N// <q> BLE_ANS_C_ENABLED  - ble_ans_c - Alert Notification Service Client
N 
N
N#ifndef BLE_ANS_C_ENABLED
N#define BLE_ANS_C_ENABLED 0
N#endif
N
N// <q> BLE_BAS_C_ENABLED  - ble_bas_c - Battery Service Client
N 
N
N#ifndef BLE_BAS_C_ENABLED
N#define BLE_BAS_C_ENABLED 0
N#endif
N
N// <q> BLE_BAS_ENABLED  - ble_bas - Battery Service
N 
N
N#ifndef BLE_BAS_ENABLED
N#define BLE_BAS_ENABLED 1
N#endif
N
N// <q> BLE_CSCS_ENABLED  - ble_cscs - Cycling Speed and Cadence Service
N 
N
N#ifndef BLE_CSCS_ENABLED
N#define BLE_CSCS_ENABLED 0
N#endif
N
N// <q> BLE_CTS_C_ENABLED  - ble_cts_c - Current Time Service Client
N 
N
N#ifndef BLE_CTS_C_ENABLED
N#define BLE_CTS_C_ENABLED 0
N#endif
N
N// <q> BLE_DIS_ENABLED  - ble_dis - Device Information Service
N 
N
N#ifndef BLE_DIS_ENABLED
N#define BLE_DIS_ENABLED 0
N#endif
N
N// <q> BLE_GLS_ENABLED  - ble_gls - Glucose Service
N 
N
N#ifndef BLE_GLS_ENABLED
N#define BLE_GLS_ENABLED 0
N#endif
N
N// <q> BLE_HIDS_ENABLED  - ble_hids - Human Interface Device Service
N 
N
N#ifndef BLE_HIDS_ENABLED
N#define BLE_HIDS_ENABLED 0
N#endif
N
N// <q> BLE_HRS_C_ENABLED  - ble_hrs_c - Heart Rate Service Client
N 
N
N#ifndef BLE_HRS_C_ENABLED
N#define BLE_HRS_C_ENABLED 0
N#endif
N
N// <q> BLE_HRS_ENABLED  - ble_hrs - Heart Rate Service
N 
N
N#ifndef BLE_HRS_ENABLED
N#define BLE_HRS_ENABLED 1
N#endif
N
N// <q> BLE_HTS_ENABLED  - ble_hts - Health Thermometer Service
N 
N
N#ifndef BLE_HTS_ENABLED
N#define BLE_HTS_ENABLED 0
N#endif
N
N// <q> BLE_IAS_C_ENABLED  - ble_ias_c - Immediate Alert Service Client
N 
N
N#ifndef BLE_IAS_C_ENABLED
N#define BLE_IAS_C_ENABLED 0
N#endif
N
N// <q> BLE_IAS_ENABLED  - ble_ias - Immediate Alert Service
N 
N
N#ifndef BLE_IAS_ENABLED
N#define BLE_IAS_ENABLED 0
N#endif
N
N// <q> BLE_LBS_C_ENABLED  - ble_lbs_c - Nordic LED Button Service Client
N 
N
N#ifndef BLE_LBS_C_ENABLED
N#define BLE_LBS_C_ENABLED 0
N#endif
N
N// <q> BLE_LBS_ENABLED  - ble_lbs - LED Button Service
N 
N
N#ifndef BLE_LBS_ENABLED
N#define BLE_LBS_ENABLED 0
N#endif
N
N// <q> BLE_LLS_ENABLED  - ble_lls - Link Loss Service
N 
N
N#ifndef BLE_LLS_ENABLED
N#define BLE_LLS_ENABLED 0
N#endif
N
N// <q> BLE_NUS_C_ENABLED  - ble_nus_c - Nordic UART Central Service
N 
N
N#ifndef BLE_NUS_C_ENABLED
N#define BLE_NUS_C_ENABLED 0
N#endif
N
N// <q> BLE_NUS_ENABLED  - ble_nus - Nordic UART Service
N 
N
N#ifndef BLE_NUS_ENABLED
N#define BLE_NUS_ENABLED 0
N#endif
N
N// <q> BLE_RSCS_C_ENABLED  - ble_rscs_c - Running Speed and Cadence Client
N 
N
N#ifndef BLE_RSCS_C_ENABLED
N#define BLE_RSCS_C_ENABLED 0
N#endif
N
N// <q> BLE_RSCS_ENABLED  - ble_rscs - Running Speed and Cadence Service
N 
N
N#ifndef BLE_RSCS_ENABLED
N#define BLE_RSCS_ENABLED 0
N#endif
N
N// <q> BLE_TPS_ENABLED  - ble_tps - TX Power Service
N 
N
N#ifndef BLE_TPS_ENABLED
N#define BLE_TPS_ENABLED 0
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Drivers 
N
N//==========================================================
N// <e> ADC_ENABLED - nrf_drv_adc - Driver for ADC peripheral (nRF51)
N//==========================================================
N#ifndef ADC_ENABLED
N#define ADC_ENABLED 0
N#endif
N#if  ADC_ENABLED
X#if  0
S// <o> ADC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef ADC_CONFIG_IRQ_PRIORITY
S#define ADC_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //ADC_ENABLED
N// </e>
N
N// <e> CLOCK_ENABLED - nrf_drv_clock - CLOCK peripheral driver
N//==========================================================
N#ifndef CLOCK_ENABLED
N#define CLOCK_ENABLED 1
N#endif
N#if  CLOCK_ENABLED
X#if  1
N// <o> CLOCK_CONFIG_XTAL_FREQ  - HF XTAL Frequency
N 
N// <0=> Default (64 MHz) 
N
N#ifndef CLOCK_CONFIG_XTAL_FREQ
N#define CLOCK_CONFIG_XTAL_FREQ 0
N#endif
N
N// <o> CLOCK_CONFIG_LF_SRC  - LF Clock Source
N 
N// <0=> RC 
N// <1=> XTAL 
N// <2=> Synth 
N
N#ifndef CLOCK_CONFIG_LF_SRC
N#define CLOCK_CONFIG_LF_SRC 1
N#endif
N
N// <o> CLOCK_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef CLOCK_CONFIG_IRQ_PRIORITY
N#define CLOCK_CONFIG_IRQ_PRIORITY 6
N#endif
N
N#endif //CLOCK_ENABLED
N// </e>
N
N// <e> COMP_ENABLED - nrf_drv_comp - COMP peripheral driver
N//==========================================================
N#ifndef COMP_ENABLED
N#define COMP_ENABLED 0
N#endif
N#if  COMP_ENABLED
X#if  0
S// <o> COMP_CONFIG_REF  - Reference voltage
S 
S// <0=> Internal 1.2V 
S// <1=> Internal 1.8V 
S// <2=> Internal 2.4V 
S// <4=> VDD 
S// <7=> ARef 
S
S#ifndef COMP_CONFIG_REF
S#define COMP_CONFIG_REF 1
S#endif
S
S// <o> COMP_CONFIG_MAIN_MODE  - Main mode
S 
S// <0=> Single ended 
S// <1=> Differential 
S
S#ifndef COMP_CONFIG_MAIN_MODE
S#define COMP_CONFIG_MAIN_MODE 0
S#endif
S
S// <o> COMP_CONFIG_SPEED_MODE  - Speed mode
S 
S// <0=> Low power 
S// <1=> Normal 
S// <2=> High speed 
S
S#ifndef COMP_CONFIG_SPEED_MODE
S#define COMP_CONFIG_SPEED_MODE 2
S#endif
S
S// <o> COMP_CONFIG_HYST  - Hystheresis
S 
S// <0=> No 
S// <1=> 50mV 
S
S#ifndef COMP_CONFIG_HYST
S#define COMP_CONFIG_HYST 0
S#endif
S
S// <o> COMP_CONFIG_ISOURCE  - Current Source
S 
S// <0=> Off 
S// <1=> 2.5 uA 
S// <2=> 5 uA 
S// <3=> 10 uA 
S
S#ifndef COMP_CONFIG_ISOURCE
S#define COMP_CONFIG_ISOURCE 0
S#endif
S
S// <o> COMP_CONFIG_INPUT  - Analog input
S 
S// <0=> 0 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef COMP_CONFIG_INPUT
S#define COMP_CONFIG_INPUT 0
S#endif
S
S// <o> COMP_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef COMP_CONFIG_IRQ_PRIORITY
S#define COMP_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //COMP_ENABLED
N// </e>
N
N// <q> EGU_ENABLED  - nrf_drv_swi - SWI(EGU) peripheral driver
N 
N
N#ifndef EGU_ENABLED
N#define EGU_ENABLED 0
N#endif
N
N// <e> GPIOTE_ENABLED - nrf_drv_gpiote - GPIOTE peripheral driver
N//==========================================================
N#ifndef GPIOTE_ENABLED
N#define GPIOTE_ENABLED 1
N#endif
N#if  GPIOTE_ENABLED
X#if  1
N// <o> GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS - Number of lower power input pins 
N#ifndef GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS
N#define GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS 4
N#endif
N
N// <o> GPIOTE_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef GPIOTE_CONFIG_IRQ_PRIORITY
N#define GPIOTE_CONFIG_IRQ_PRIORITY 6
N#endif
N
N#endif //GPIOTE_ENABLED
N// </e>
N
N// <e> I2S_ENABLED - nrf_drv_i2s - I2S peripheral driver
N//==========================================================
N#ifndef I2S_ENABLED
N#define I2S_ENABLED 0
N#endif
N#if  I2S_ENABLED
X#if  0
S// <o> I2S_CONFIG_SCK_PIN - SCK pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SCK_PIN
S#define I2S_CONFIG_SCK_PIN 31
S#endif
S
S// <o> I2S_CONFIG_LRCK_PIN - LRCK pin  <1-31> 
S
S
S#ifndef I2S_CONFIG_LRCK_PIN
S#define I2S_CONFIG_LRCK_PIN 30
S#endif
S
S// <o> I2S_CONFIG_MCK_PIN - MCK pin 
S#ifndef I2S_CONFIG_MCK_PIN
S#define I2S_CONFIG_MCK_PIN 255
S#endif
S
S// <o> I2S_CONFIG_SDOUT_PIN - SDOUT pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SDOUT_PIN
S#define I2S_CONFIG_SDOUT_PIN 29
S#endif
S
S// <o> I2S_CONFIG_SDIN_PIN - SDIN pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SDIN_PIN
S#define I2S_CONFIG_SDIN_PIN 28
S#endif
S
S// <o> I2S_CONFIG_MASTER  - Mode
S 
S// <0=> Master 
S// <1=> Slave 
S
S#ifndef I2S_CONFIG_MASTER
S#define I2S_CONFIG_MASTER 0
S#endif
S
S// <o> I2S_CONFIG_FORMAT  - Format
S 
S// <0=> I2S 
S// <1=> Aligned 
S
S#ifndef I2S_CONFIG_FORMAT
S#define I2S_CONFIG_FORMAT 0
S#endif
S
S// <o> I2S_CONFIG_ALIGN  - Alignment
S 
S// <0=> Left 
S// <1=> Right 
S
S#ifndef I2S_CONFIG_ALIGN
S#define I2S_CONFIG_ALIGN 0
S#endif
S
S// <o> I2S_CONFIG_SWIDTH  - Sample width (bits)
S 
S// <0=> 8 
S// <1=> 16 
S// <2=> 24 
S
S#ifndef I2S_CONFIG_SWIDTH
S#define I2S_CONFIG_SWIDTH 1
S#endif
S
S// <o> I2S_CONFIG_CHANNELS  - Channels
S 
S// <0=> Stereo 
S// <1=> Left 
S// <2=> Right 
S
S#ifndef I2S_CONFIG_CHANNELS
S#define I2S_CONFIG_CHANNELS 1
S#endif
S
S// <o> I2S_CONFIG_MCK_SETUP  - MCK behavior
S 
S// <0=> Disabled 
S// <2147483648=> 32MHz/2 
S// <1342177280=> 32MHz/3 
S// <1073741824=> 32MHz/4 
S// <805306368=> 32MHz/5 
S// <671088640=> 32MHz/6 
S// <536870912=> 32MHz/8 
S// <402653184=> 32MHz/10 
S// <369098752=> 32MHz/11 
S// <285212672=> 32MHz/15 
S// <268435456=> 32MHz/16 
S// <201326592=> 32MHz/21 
S// <184549376=> 32MHz/23 
S// <142606336=> 32MHz/30 
S// <138412032=> 32MHz/31 
S// <134217728=> 32MHz/32 
S// <100663296=> 32MHz/42 
S// <68157440=> 32MHz/63 
S// <34340864=> 32MHz/125 
S
S#ifndef I2S_CONFIG_MCK_SETUP
S#define I2S_CONFIG_MCK_SETUP 536870912
S#endif
S
S// <o> I2S_CONFIG_RATIO  - MCK/LRCK ratio
S 
S// <0=> 32x 
S// <1=> 48x 
S// <2=> 64x 
S// <3=> 96x 
S// <4=> 128x 
S// <5=> 192x 
S// <6=> 256x 
S// <7=> 384x 
S// <8=> 512x 
S
S#ifndef I2S_CONFIG_RATIO
S#define I2S_CONFIG_RATIO 2000
S#endif
S
S// <o> I2S_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef I2S_CONFIG_IRQ_PRIORITY
S#define I2S_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //I2S_ENABLED
N// </e>
N
N// <e> LPCOMP_ENABLED - nrf_drv_lpcomp - LPCOMP peripheral driver
N//==========================================================
N#ifndef LPCOMP_ENABLED
N#define LPCOMP_ENABLED 0
N#endif
N#if  LPCOMP_ENABLED
X#if  0
S// <o> LPCOMP_CONFIG_REFERENCE  - Reference voltage
S 
S// <0=> Supply 1/8 
S// <1=> Supply 2/8 
S// <2=> Supply 3/8 
S// <3=> Supply 4/8 
S// <4=> Supply 5/8 
S// <5=> Supply 6/8 
S// <6=> Supply 7/8 
S// <8=> Supply 1/16 (nRF52) 
S// <9=> Supply 3/16 (nRF52) 
S// <10=> Supply 5/16 (nRF52) 
S// <11=> Supply 7/16 (nRF52) 
S// <12=> Supply 9/16 (nRF52) 
S// <13=> Supply 11/16 (nRF52) 
S// <14=> Supply 13/16 (nRF52) 
S// <15=> Supply 15/16 (nRF52) 
S// <7=> External Ref 0 
S// <65543=> External Ref 1 
S
S#ifndef LPCOMP_CONFIG_REFERENCE
S#define LPCOMP_CONFIG_REFERENCE 3
S#endif
S
S// <o> LPCOMP_CONFIG_DETECTION  - Detection
S 
S// <0=> Crossing 
S// <1=> Up 
S// <2=> Down 
S
S#ifndef LPCOMP_CONFIG_DETECTION
S#define LPCOMP_CONFIG_DETECTION 2
S#endif
S
S// <o> LPCOMP_CONFIG_INPUT  - Analog input
S 
S// <0=> 0 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef LPCOMP_CONFIG_INPUT
S#define LPCOMP_CONFIG_INPUT 0
S#endif
S
S// <o> LPCOMP_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef LPCOMP_CONFIG_IRQ_PRIORITY
S#define LPCOMP_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //LPCOMP_ENABLED
N// </e>
N
N// <e> PDM_ENABLED - nrf_drv_pdm - PDM peripheral driver
N//==========================================================
N#ifndef PDM_ENABLED
N#define PDM_ENABLED 0
N#endif
N#if  PDM_ENABLED
X#if  0
S// <o> PDM_CONFIG_MODE  - Mode
S 
S// <0=> Stereo 
S// <1=> Mono 
S
S#ifndef PDM_CONFIG_MODE
S#define PDM_CONFIG_MODE 1
S#endif
S
S// <o> PDM_CONFIG_EDGE  - Edge
S 
S// <0=> Left falling 
S// <1=> Left rising 
S
S#ifndef PDM_CONFIG_EDGE
S#define PDM_CONFIG_EDGE 0
S#endif
S
S// <o> PDM_CONFIG_CLOCK_FREQ  - Clock frequency
S 
S// <134217728=> 1000k 
S// <138412032=> 1032k (default) 
S// <142606336=> 1067k 
S
S#ifndef PDM_CONFIG_CLOCK_FREQ
S#define PDM_CONFIG_CLOCK_FREQ 138412032
S#endif
S
S// <o> PDM_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef PDM_CONFIG_IRQ_PRIORITY
S#define PDM_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //PDM_ENABLED
N// </e>
N
N// <q> PERIPHERAL_RESOURCE_SHARING_ENABLED  - nrf_drv_common - Peripheral drivers common module
N 
N
N#ifndef PERIPHERAL_RESOURCE_SHARING_ENABLED
N#define PERIPHERAL_RESOURCE_SHARING_ENABLED 0
N#endif
N
N// <q> PPI_ENABLED  - nrf_drv_ppi - PPI peripheral driver
N 
N
N#ifndef PPI_ENABLED
N#define PPI_ENABLED 0
N#endif
N
N// <e> PWM_ENABLED - nrf_drv_pwm - PWM peripheral driver
N//==========================================================
N#ifndef PWM_ENABLED
N#define PWM_ENABLED 0
N#endif
N#if  PWM_ENABLED
X#if  0
S// <o> PWM_DEFAULT_CONFIG_OUT0_PIN - Out0 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT0_PIN
S#define PWM_DEFAULT_CONFIG_OUT0_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT1_PIN - Out1 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT1_PIN
S#define PWM_DEFAULT_CONFIG_OUT1_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT2_PIN - Out2 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT2_PIN
S#define PWM_DEFAULT_CONFIG_OUT2_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT3_PIN - Out3 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT3_PIN
S#define PWM_DEFAULT_CONFIG_OUT3_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_BASE_CLOCK  - Base clock
S 
S// <0=> 16 MHz 
S// <1=> 8 MHz 
S// <2=> 4 MHz 
S// <3=> 2 MHz 
S// <4=> 1 MHz 
S// <5=> 500 kHz 
S// <6=> 250 kHz 
S// <7=> 125 MHz 
S
S#ifndef PWM_DEFAULT_CONFIG_BASE_CLOCK
S#define PWM_DEFAULT_CONFIG_BASE_CLOCK 4
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_COUNT_MODE  - Count mode
S 
S// <0=> Up 
S// <1=> Up and Down 
S
S#ifndef PWM_DEFAULT_CONFIG_COUNT_MODE
S#define PWM_DEFAULT_CONFIG_COUNT_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_TOP_VALUE - Top value 
S#ifndef PWM_DEFAULT_CONFIG_TOP_VALUE
S#define PWM_DEFAULT_CONFIG_TOP_VALUE 1000
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_LOAD_MODE  - Load mode
S 
S// <0=> Common 
S// <1=> Grouped 
S// <2=> Individual 
S// <3=> Waveform 
S
S#ifndef PWM_DEFAULT_CONFIG_LOAD_MODE
S#define PWM_DEFAULT_CONFIG_LOAD_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_STEP_MODE  - Step mode
S 
S// <0=> Auto 
S// <1=> Triggered 
S
S#ifndef PWM_DEFAULT_CONFIG_STEP_MODE
S#define PWM_DEFAULT_CONFIG_STEP_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef PWM_DEFAULT_CONFIG_IRQ_PRIORITY
S#define PWM_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> PWM0_ENABLED  - Enable PWM0 instance
S 
S
S#ifndef PWM0_ENABLED
S#define PWM0_ENABLED 0
S#endif
S
S// <q> PWM1_ENABLED  - Enable PWM1 instance
S 
S
S#ifndef PWM1_ENABLED
S#define PWM1_ENABLED 0
S#endif
S
S// <q> PWM2_ENABLED  - Enable PWM2 instance
S 
S
S#ifndef PWM2_ENABLED
S#define PWM2_ENABLED 0
S#endif
S
N#endif //PWM_ENABLED
N// </e>
N
N// <e> QDEC_ENABLED - nrf_drv_qdec - QDEC peripheral driver
N//==========================================================
N#ifndef QDEC_ENABLED
N#define QDEC_ENABLED 0
N#endif
N#if  QDEC_ENABLED
X#if  0
S// <o> QDEC_CONFIG_REPORTPER  - Report period
S 
S// <0=> 10 Samples 
S// <1=> 40 Samples 
S// <2=> 80 Samples 
S// <3=> 120 Samples 
S// <4=> 160 Samples 
S// <5=> 200 Samples 
S// <6=> 240 Samples 
S// <7=> 280 Samples 
S
S#ifndef QDEC_CONFIG_REPORTPER
S#define QDEC_CONFIG_REPORTPER 0
S#endif
S
S// <o> QDEC_CONFIG_SAMPLEPER  - Sample period
S 
S// <0=> 128 us 
S// <1=> 256 us 
S// <2=> 512 us 
S// <3=> 1024 us 
S// <4=> 2048 us 
S// <5=> 4096 us 
S// <6=> 8192 us 
S// <7=> 16384 us 
S
S#ifndef QDEC_CONFIG_SAMPLEPER
S#define QDEC_CONFIG_SAMPLEPER 7
S#endif
S
S// <o> QDEC_CONFIG_PIO_A - A pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_A
S#define QDEC_CONFIG_PIO_A 31
S#endif
S
S// <o> QDEC_CONFIG_PIO_B - B pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_B
S#define QDEC_CONFIG_PIO_B 31
S#endif
S
S// <o> QDEC_CONFIG_PIO_LED - LED pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_LED
S#define QDEC_CONFIG_PIO_LED 31
S#endif
S
S// <o> QDEC_CONFIG_LEDPRE - LED pre 
S#ifndef QDEC_CONFIG_LEDPRE
S#define QDEC_CONFIG_LEDPRE 511
S#endif
S
S// <o> QDEC_CONFIG_LEDPOL  - LED polarity
S 
S// <0=> Active low 
S// <1=> Active high 
S
S#ifndef QDEC_CONFIG_LEDPOL
S#define QDEC_CONFIG_LEDPOL 1
S#endif
S
S// <q> QDEC_CONFIG_DBFEN  - Debouncing enable
S 
S
S#ifndef QDEC_CONFIG_DBFEN
S#define QDEC_CONFIG_DBFEN 0
S#endif
S
S// <q> QDEC_CONFIG_SAMPLE_INTEN  - Sample ready interrupt enable
S 
S
S#ifndef QDEC_CONFIG_SAMPLE_INTEN
S#define QDEC_CONFIG_SAMPLE_INTEN 0
S#endif
S
S// <o> QDEC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef QDEC_CONFIG_IRQ_PRIORITY
S#define QDEC_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //QDEC_ENABLED
N// </e>
N
N// <e> RNG_ENABLED - nrf_drv_rng - RNG peripheral driver
N//==========================================================
N#ifndef RNG_ENABLED
N#define RNG_ENABLED 0
N#endif
N#if  RNG_ENABLED
X#if  0
S// <q> RNG_CONFIG_ERROR_CORRECTION  - Error correction
S 
S
S#ifndef RNG_CONFIG_ERROR_CORRECTION
S#define RNG_CONFIG_ERROR_CORRECTION 0
S#endif
S
S// <o> RNG_CONFIG_POOL_SIZE - Pool size 
S#ifndef RNG_CONFIG_POOL_SIZE
S#define RNG_CONFIG_POOL_SIZE 8
S#endif
S
S// <o> RNG_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef RNG_CONFIG_IRQ_PRIORITY
S#define RNG_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //RNG_ENABLED
N// </e>
N
N// <e> RTC_ENABLED - nrf_drv_rtc - RTC peripheral driver
N//==========================================================
N#ifndef RTC_ENABLED
N#define RTC_ENABLED 0
N#endif
N#if  RTC_ENABLED
X#if  0
S// <o> RTC_DEFAULT_CONFIG_FREQUENCY - Frequency  <16-32768> 
S
S
S#ifndef RTC_DEFAULT_CONFIG_FREQUENCY
S#define RTC_DEFAULT_CONFIG_FREQUENCY 32768
S#endif
S
S// <q> RTC_DEFAULT_CONFIG_RELIABLE  - Ensures safe compare event triggering
S 
S
S#ifndef RTC_DEFAULT_CONFIG_RELIABLE
S#define RTC_DEFAULT_CONFIG_RELIABLE 0
S#endif
S
S// <o> RTC_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef RTC_DEFAULT_CONFIG_IRQ_PRIORITY
S#define RTC_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> RTC0_ENABLED  - Enable RTC0 instance
S 
S
S#ifndef RTC0_ENABLED
S#define RTC0_ENABLED 0
S#endif
S
S// <q> RTC1_ENABLED  - Enable RTC1 instance
S 
S
S#ifndef RTC1_ENABLED
S#define RTC1_ENABLED 0
S#endif
S
S// <q> RTC2_ENABLED  - Enable RTC2 instance
S 
S
S#ifndef RTC2_ENABLED
S#define RTC2_ENABLED 0
S#endif
S
S// <o> NRF_MAXIMUM_LATENCY_US - Maximum possible time[us] in highest priority interrupt 
S#ifndef NRF_MAXIMUM_LATENCY_US
S#define NRF_MAXIMUM_LATENCY_US 2000
S#endif
S
N#endif //RTC_ENABLED
N// </e>
N
N// <e> SAADC_ENABLED - nrf_drv_saadc - SAADC peripheral driver
N//==========================================================
N#ifndef SAADC_ENABLED
N#define SAADC_ENABLED 0
N#endif
N#if  SAADC_ENABLED
X#if  0
S// <o> SAADC_CONFIG_RESOLUTION  - Resolution
S 
S// <0=> 8 bit 
S// <1=> 10 bit 
S// <2=> 12 bit 
S// <3=> 14 bit 
S
S#ifndef SAADC_CONFIG_RESOLUTION
S#define SAADC_CONFIG_RESOLUTION 1
S#endif
S
S// <o> SAADC_CONFIG_OVERSAMPLE  - Sample period
S 
S// <0=> Disabled 
S// <1=> 2x 
S// <2=> 4x 
S// <3=> 8x 
S// <4=> 16x 
S// <5=> 32x 
S// <6=> 64x 
S// <7=> 128x 
S// <8=> 256x 
S
S#ifndef SAADC_CONFIG_OVERSAMPLE
S#define SAADC_CONFIG_OVERSAMPLE 0
S#endif
S
S// <q> SAADC_CONFIG_LP_MODE  - Enabling low power mode
S 
S
S#ifndef SAADC_CONFIG_LP_MODE
S#define SAADC_CONFIG_LP_MODE 0
S#endif
S
S// <o> SAADC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef SAADC_CONFIG_IRQ_PRIORITY
S#define SAADC_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //SAADC_ENABLED
N// </e>
N
N// <e> SPIS_ENABLED - nrf_drv_spis - SPI Slave driver
N//==========================================================
N#ifndef SPIS_ENABLED
N#define SPIS_ENABLED 0
N#endif
N#if  SPIS_ENABLED
X#if  0
S// <o> SPIS_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef SPIS_DEFAULT_CONFIG_IRQ_PRIORITY
S#define SPIS_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <o> SPIS_DEFAULT_MODE  - Mode
S 
S// <0=> MODE_0 
S// <1=> MODE_1 
S// <2=> MODE_2 
S// <3=> MODE_3 
S
S#ifndef SPIS_DEFAULT_MODE
S#define SPIS_DEFAULT_MODE 0
S#endif
S
S// <o> SPIS_DEFAULT_BIT_ORDER  - SPIS default bit order
S 
S// <0=> MSB first 
S// <1=> LSB first 
S
S#ifndef SPIS_DEFAULT_BIT_ORDER
S#define SPIS_DEFAULT_BIT_ORDER 0
S#endif
S
S// <o> SPIS_DEFAULT_DEF - SPIS default DEF character  <0-255> 
S
S
S#ifndef SPIS_DEFAULT_DEF
S#define SPIS_DEFAULT_DEF 255
S#endif
S
S// <o> SPIS_DEFAULT_ORC - SPIS default ORC character  <0-255> 
S
S
S#ifndef SPIS_DEFAULT_ORC
S#define SPIS_DEFAULT_ORC 255
S#endif
S
S// <q> SPIS0_ENABLED  - Enable SPIS0 instance
S 
S
S#ifndef SPIS0_ENABLED
S#define SPIS0_ENABLED 0
S#endif
S
S// <q> SPIS1_ENABLED  - Enable SPIS1 instance
S 
S
S#ifndef SPIS1_ENABLED
S#define SPIS1_ENABLED 0
S#endif
S
S// <q> SPIS2_ENABLED  - Enable SPIS2 instance
S 
S
S#ifndef SPIS2_ENABLED
S#define SPIS2_ENABLED 0
S#endif
S
N#endif //SPIS_ENABLED
N// </e>
N
N// <e> SPI_ENABLED - nrf_drv_spi - SPI/SPIM peripheral driver
N//==========================================================
N#ifndef SPI_ENABLED
N#define SPI_ENABLED 1
N#endif
N#if  SPI_ENABLED
X#if  1
N// <e> SPI_CONFIG_LOG_ENABLED - Enables logging in the module.
N//==========================================================
N#ifndef SPI_CONFIG_LOG_ENABLED
N#define SPI_CONFIG_LOG_ENABLED 0
N#endif
N#if  SPI_CONFIG_LOG_ENABLED
X#if  0
S// <o> SPI_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef SPI_CONFIG_LOG_LEVEL
S#define SPI_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> SPI_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SPI_CONFIG_INFO_COLOR
S#define SPI_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> SPI_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SPI_CONFIG_DEBUG_COLOR
S#define SPI_CONFIG_DEBUG_COLOR 0
S#endif
S
N#endif //SPI_CONFIG_LOG_ENABLED
N// </e>
N
N// <o> SPI_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef SPI_DEFAULT_CONFIG_IRQ_PRIORITY
N#define SPI_DEFAULT_CONFIG_IRQ_PRIORITY 6
N#endif
N
N// <e> SPI0_ENABLED - Enable SPI0 instance
N//==========================================================
N#ifndef SPI0_ENABLED
N#define SPI0_ENABLED 1
N#endif
N#if  SPI0_ENABLED
X#if  1
N// <q> SPI0_USE_EASY_DMA  - Use EasyDMA
N 
N
N#ifndef SPI0_USE_EASY_DMA
N#define SPI0_USE_EASY_DMA 0
N#endif
N
N// <o> SPI_SCK_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_SCK_PIN
N#define SPI0_SCK_PIN 25
N#endif
N
N// <o> SPI_MISO_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_MISO_PIN
N#define SPI0_MISO_PIN 26
N#endif
N
N// <o> SPI_MOSI_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_MOSI_PIN
N#define SPI0_MOSI_PIN 23
N#endif
N
N// <o> SPI_SS_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_SS_PIN
N#define SPI0_SS_PIN 24
N#endif
N#endif //SPI0_ENABLED
N// </e>
N
N// <e> SPI1_ENABLED - Enable SPI1 instance
N//==========================================================
N#ifndef SPI1_ENABLED
N#define SPI1_ENABLED 0
N#endif
N#if  SPI1_ENABLED
X#if  0
S// <q> SPI1_USE_EASY_DMA  - Use EasyDMA
S 
S
S#ifndef SPI1_USE_EASY_DMA
S#define SPI1_USE_EASY_DMA 1
S#endif
S
N#endif //SPI1_ENABLED
N// </e>
N
N// <e> SPI2_ENABLED - Enable SPI2 instance
N//==========================================================
N#ifndef SPI2_ENABLED
N#define SPI2_ENABLED 0
N#endif
N#if  SPI2_ENABLED
X#if  0
S// <q> SPI2_USE_EASY_DMA  - Use EasyDMA
S 
S
S#ifndef SPI2_USE_EASY_DMA
S#define SPI2_USE_EASY_DMA 1
S#endif
S
N#endif //SPI2_ENABLED
N// </e>
N
N#endif //SPI_ENABLED
N// </e>
N
N// <e> TIMER_ENABLED - nrf_drv_timer - TIMER periperal driver
N//==========================================================
N#ifndef TIMER_ENABLED
N#define TIMER_ENABLED 0
N#endif
N#if  TIMER_ENABLED
X#if  0
S// <o> TIMER_DEFAULT_CONFIG_FREQUENCY  - Timer frequency if in Timer mode
S 
S// <0=> 16 MHz 
S// <1=> 8 MHz 
S// <2=> 4 MHz 
S// <3=> 2 MHz 
S// <4=> 1 MHz 
S// <5=> 500 kHz 
S// <6=> 250 kHz 
S// <7=> 125 kHz 
S// <8=> 62.5 kHz 
S// <9=> 31.25 kHz 
S
S#ifndef TIMER_DEFAULT_CONFIG_FREQUENCY
S#define TIMER_DEFAULT_CONFIG_FREQUENCY 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_MODE  - Timer mode or operation
S 
S// <0=> Timer 
S// <1=> Counter 
S
S#ifndef TIMER_DEFAULT_CONFIG_MODE
S#define TIMER_DEFAULT_CONFIG_MODE 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_BIT_WIDTH  - Timer counter bit width
S 
S// <0=> 16 bit 
S// <1=> 8 bit 
S// <2=> 24 bit 
S// <3=> 32 bit 
S
S#ifndef TIMER_DEFAULT_CONFIG_BIT_WIDTH
S#define TIMER_DEFAULT_CONFIG_BIT_WIDTH 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef TIMER_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TIMER_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> TIMER0_ENABLED  - Enable TIMER0 instance
S 
S
S#ifndef TIMER0_ENABLED
S#define TIMER0_ENABLED 0
S#endif
S
S// <q> TIMER1_ENABLED  - Enable TIMER1 instance
S 
S
S#ifndef TIMER1_ENABLED
S#define TIMER1_ENABLED 0
S#endif
S
S// <q> TIMER2_ENABLED  - Enable TIMER2 instance
S 
S
S#ifndef TIMER2_ENABLED
S#define TIMER2_ENABLED 0
S#endif
S
S// <q> TIMER3_ENABLED  - Enable TIMER3 instance
S 
S
S#ifndef TIMER3_ENABLED
S#define TIMER3_ENABLED 0
S#endif
S
S// <q> TIMER4_ENABLED  - Enable TIMER4 instance
S 
S
S#ifndef TIMER4_ENABLED
S#define TIMER4_ENABLED 0
S#endif
S
N#endif //TIMER_ENABLED
N// </e>
N
N// <e> TWIS_ENABLED - nrf_drv_twis - TWIS peripheral driver
N//==========================================================
N#ifndef TWIS_ENABLED
N#define TWIS_ENABLED 0
N#endif
N#if  TWIS_ENABLED
X#if  0
S// <o> TWIS_DEFAULT_CONFIG_ADDR0 - Address0 
S#ifndef TWIS_DEFAULT_CONFIG_ADDR0
S#define TWIS_DEFAULT_CONFIG_ADDR0 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_ADDR1 - Address1 
S#ifndef TWIS_DEFAULT_CONFIG_ADDR1
S#define TWIS_DEFAULT_CONFIG_ADDR1 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_SCL_PULL  - SCL pin pull configuration
S 
S// <0=> Disabled 
S// <1=> Pull down 
S// <3=> Pull up 
S
S#ifndef TWIS_DEFAULT_CONFIG_SCL_PULL
S#define TWIS_DEFAULT_CONFIG_SCL_PULL 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_SDA_PULL  - SDA pin pull configuration
S 
S// <0=> Disabled 
S// <1=> Pull down 
S// <3=> Pull up 
S
S#ifndef TWIS_DEFAULT_CONFIG_SDA_PULL
S#define TWIS_DEFAULT_CONFIG_SDA_PULL 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef TWIS_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TWIS_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> TWIS0_ENABLED  - Enable TWIS0 instance
S 
S
S#ifndef TWIS0_ENABLED
S#define TWIS0_ENABLED 0
S#endif
S
S// <q> TWIS1_ENABLED  - Enable TWIS1 instance
S 
S
S#ifndef TWIS1_ENABLED
S#define TWIS1_ENABLED 0
S#endif
S
S// <q> TWIS_ASSUME_INIT_AFTER_RESET_ONLY  - Assume that any instance would be initialized only once
S 
S
S// <i> Optimization flag. Registers used by TWIS are shared by other peripherals. Normally, during initialization driver tries to clear all registers to known state before doing the initialization itself. This gives initialization safe procedure, no matter when it would be called. If you activate TWIS only once and do never uninitialize it - set this flag to 1 what gives more optimal code.
S
S#ifndef TWIS_ASSUME_INIT_AFTER_RESET_ONLY
S#define TWIS_ASSUME_INIT_AFTER_RESET_ONLY 0
S#endif
S
S// <q> TWIS_NO_SYNC_MODE  - Remove support for synchronous mode
S 
S
S// <i> Synchronous mode would be used in specific situations. And it uses some additional code and data memory to safely process state machine by polling it in status functions. If this functionality is not required it may be disabled to free some resources.
S
S#ifndef TWIS_NO_SYNC_MODE
S#define TWIS_NO_SYNC_MODE 0
S#endif
S
N#endif //TWIS_ENABLED
N// </e>
N
N// <e> TWI_ENABLED - nrf_drv_twi - TWI/TWIM peripheral driver
N//==========================================================
N#ifndef TWI_ENABLED
N#define TWI_ENABLED 0
N#endif
N#if  TWI_ENABLED
X#if  0
S// <o> TWI_DEFAULT_CONFIG_FREQUENCY  - Frequency
S 
S// <26738688=> 100k 
S// <67108864=> 250k 
S// <104857600=> 400k 
S
S#ifndef TWI_DEFAULT_CONFIG_FREQUENCY
S#define TWI_DEFAULT_CONFIG_FREQUENCY 26738688
S#endif
S
S// <q> TWI_DEFAULT_CONFIG_CLR_BUS_INIT  - Enables bus clearing procedure during init
S 
S
S#ifndef TWI_DEFAULT_CONFIG_CLR_BUS_INIT
S#define TWI_DEFAULT_CONFIG_CLR_BUS_INIT 0
S#endif
S
S// <q> TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT  - Enables bus holding after uninit
S 
S
S#ifndef TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT
S#define TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT 0
S#endif
S
S// <o> TWI_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef TWI_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TWI_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <e> TWI0_ENABLED - Enable TWI0 instance
S//==========================================================
S#ifndef TWI0_ENABLED
S#define TWI0_ENABLED 0
S#endif
S#if  TWI0_ENABLED
S// <q> TWI0_USE_EASY_DMA  - Use EasyDMA (if present)
S 
S
S#ifndef TWI0_USE_EASY_DMA
S#define TWI0_USE_EASY_DMA 0
S#endif
S
S#endif //TWI0_ENABLED
S// </e>
S
S// <e> TWI1_ENABLED - Enable TWI1 instance
S//==========================================================
S#ifndef TWI1_ENABLED
S#define TWI1_ENABLED 0
S#endif
S#if  TWI1_ENABLED
S// <q> TWI1_USE_EASY_DMA  - Use EasyDMA (if present)
S 
S
S#ifndef TWI1_USE_EASY_DMA
S#define TWI1_USE_EASY_DMA 0
S#endif
S
S#endif //TWI1_ENABLED
S// </e>
S
N#endif //TWI_ENABLED
N// </e>
N
N// <e> UART_ENABLED - nrf_drv_uart - UART/UARTE peripheral driver
N//==========================================================
N#ifndef UART_ENABLED
N#define UART_ENABLED 1
N#endif
N#if  UART_ENABLED
X#if  1
N// <o> UART_DEFAULT_CONFIG_HWFC  - Hardware Flow Control
N 
N// <0=> Disabled 
N// <1=> Enabled 
N
N#ifndef UART_DEFAULT_CONFIG_HWFC
N#define UART_DEFAULT_CONFIG_HWFC 0
N#endif
N
N// <o> UART_DEFAULT_CONFIG_PARITY  - Parity
N 
N// <0=> Excluded 
N// <14=> Included 
N
N#ifndef UART_DEFAULT_CONFIG_PARITY
N#define UART_DEFAULT_CONFIG_PARITY 0
N#endif
N
N// <o> UART_DEFAULT_CONFIG_BAUDRATE  - Default Baudrate
N 
N// <323584=> 1200 baud 
N// <643072=> 2400 baud 
N// <1290240=> 4800 baud 
N// <2576384=> 9600 baud 
N// <3862528=> 14400 baud 
N// <5152768=> 19200 baud 
N// <7716864=> 28800 baud 
N// <10289152=> 38400 baud 
N// <15400960=> 57600 baud 
N// <20615168=> 76800 baud 
N// <30801920=> 115200 baud 
N// <61865984=> 230400 baud 
N// <67108864=> 250000 baud 
N// <121634816=> 460800 baud 
N// <251658240=> 921600 baud 
N// <268435456=> 57600 baud 
N
N#ifndef UART_DEFAULT_CONFIG_BAUDRATE
N#define UART_DEFAULT_CONFIG_BAUDRATE 30801920
N#endif
N
N// <o> UART_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef UART_DEFAULT_CONFIG_IRQ_PRIORITY
N#define UART_DEFAULT_CONFIG_IRQ_PRIORITY 6
N#endif
N
N// <q> UART0_CONFIG_USE_EASY_DMA  - Default setting for using EasyDMA
N 
N
N#ifndef UART0_CONFIG_USE_EASY_DMA
N#define UART0_CONFIG_USE_EASY_DMA 1
N#endif
N
N// <q> UART_EASY_DMA_SUPPORT  - Driver supporting EasyDMA
N 
N
N#ifndef UART_EASY_DMA_SUPPORT
N#define UART_EASY_DMA_SUPPORT 1
N#endif
N
N// <q> UART_LEGACY_SUPPORT  - Driver supporting Legacy mode
N 
N
N#ifndef UART_LEGACY_SUPPORT
N#define UART_LEGACY_SUPPORT 1
N#endif
N
N#endif //UART_ENABLED
N// </e>
N
N// <e> WDT_ENABLED - nrf_drv_wdt - WDT peripheral driver
N//==========================================================
N#ifndef WDT_ENABLED
N#define WDT_ENABLED 0
N#endif
N#if  WDT_ENABLED
X#if  0
S// <o> WDT_CONFIG_BEHAVIOUR  - WDT behavior in CPU SLEEP or HALT mode
S 
S// <1=> Run in SLEEP, Pause in HALT 
S// <8=> Pause in SLEEP, Run in HALT 
S// <9=> Run in SLEEP and HALT 
S// <0=> Pause in SLEEP and HALT 
S
S#ifndef WDT_CONFIG_BEHAVIOUR
S#define WDT_CONFIG_BEHAVIOUR 1
S#endif
S
S// <o> WDT_CONFIG_RELOAD_VALUE - Reload value  <15-4294967295> 
S
S
S#ifndef WDT_CONFIG_RELOAD_VALUE
S#define WDT_CONFIG_RELOAD_VALUE 2000
S#endif
S
S// <o> WDT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef WDT_CONFIG_IRQ_PRIORITY
S#define WDT_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //WDT_ENABLED
N// </e>
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Libraries 
N
N//==========================================================
N// <q> APP_FIFO_ENABLED  - app_fifo - Software FIFO implementation
N 
N 
N#define APPL_LOG app_trace_log  
N
N#ifndef APP_FIFO_ENABLED
N#define APP_FIFO_ENABLED 1
N#endif
N
N// <q> APP_MAILBOX_ENABLED  - app_mailbox - Thread safe mailbox
N 
N
N#ifndef APP_MAILBOX_ENABLED
N#define APP_MAILBOX_ENABLED 0
N#endif
N
N// <q> APP_PWM_ENABLED  - app_pwm - PWM functionality
N 
N
N#ifndef APP_PWM_ENABLED
N#define APP_PWM_ENABLED 0
N#endif
N
N// <e> APP_SCHEDULER_ENABLED - app_scheduler - Events scheduler
N//==========================================================
N#ifndef APP_SCHEDULER_ENABLED
N#define APP_SCHEDULER_ENABLED 0
N#endif
N#if  APP_SCHEDULER_ENABLED
X#if  0
S// <q> APP_SCHEDULER_WITH_PAUSE  - Enabling pause feature
S 
S
S#ifndef APP_SCHEDULER_WITH_PAUSE
S#define APP_SCHEDULER_WITH_PAUSE 0
S#endif
S
S// <q> APP_SCHEDULER_WITH_PROFILER  - Enabling scheduler profiling
S 
S
S#ifndef APP_SCHEDULER_WITH_PROFILER
S#define APP_SCHEDULER_WITH_PROFILER 0
S#endif
S
N#endif //APP_SCHEDULER_ENABLED
N// </e>
N
N// <e> APP_TIMER_ENABLED - app_timer - Application timer functionality
N//==========================================================
N#ifndef APP_TIMER_ENABLED
N#define APP_TIMER_ENABLED 1
N#endif
N#if  APP_TIMER_ENABLED
X#if  1
N// <q> APP_TIMER_WITH_PROFILER  - Enable app_timer profiling
N 
N
N#ifndef APP_TIMER_WITH_PROFILER
N#define APP_TIMER_WITH_PROFILER 0
N#endif
N
N// <q> APP_TIMER_KEEPS_RTC_ACTIVE  - Enable RTC always on
N 
N
N// <i> If option is enabled RTC is kept running even if there is no active timers.
N// <i> This option can be used when app_timer is used for timestamping.
N
N#ifndef APP_TIMER_KEEPS_RTC_ACTIVE
N#define APP_TIMER_KEEPS_RTC_ACTIVE 0
N#endif
N
N#endif //APP_TIMER_ENABLED
N// </e>
N
N// <q> APP_TWI_ENABLED  - app_twi - TWI transaction manager
N 
N
N#ifndef APP_TWI_ENABLED
N#define APP_TWI_ENABLED 0
N#endif
N
N// <e> APP_UART_ENABLED - app_uart - UART driver
N//==========================================================
N#ifndef APP_UART_ENABLED
N#define APP_UART_ENABLED 0
N#endif
N#if  APP_UART_ENABLED
X#if  0
S// <o> APP_UART_DRIVER_INSTANCE  - UART instance used
S 
S// <0=> 0 
S
S#ifndef APP_UART_DRIVER_INSTANCE
S#define APP_UART_DRIVER_INSTANCE 0
S#endif
S
N#endif //APP_UART_ENABLED
N// </e>
N
N// <q> BUTTON_ENABLED  - app_button - buttons handling module
N 
N
N#ifndef BUTTON_ENABLED
N#define BUTTON_ENABLED 1
N#endif
N
N// <q> CRC16_ENABLED  - crc16 - CRC16 calculation routines
N 
N
N#ifndef CRC16_ENABLED
N#define CRC16_ENABLED 1
N#endif
N
N// <q> CRC32_ENABLED  - crc32 - CRC32 calculation routines
N 
N
N#ifndef CRC32_ENABLED
N#define CRC32_ENABLED 0
N#endif
N
N// <q> ECC_ENABLED  - ecc - Elliptic Curve Cryptography Library
N 
N
N#ifndef ECC_ENABLED
N#define ECC_ENABLED 0
N#endif
N
N// <e> FDS_ENABLED - fds - Flash data storage module
N//==========================================================
N#ifndef FDS_ENABLED
N#define FDS_ENABLED 1
N#endif
N#if  FDS_ENABLED
X#if  1
N// <o> FDS_OP_QUEUE_SIZE - Size of the internal queue. 
N#ifndef FDS_OP_QUEUE_SIZE
N#define FDS_OP_QUEUE_SIZE 4
N#endif
N
N// <o> FDS_CHUNK_QUEUE_SIZE - Determines how many @ref fds_record_chunk_t structures can be buffered at any time. 
N#ifndef FDS_CHUNK_QUEUE_SIZE
N#define FDS_CHUNK_QUEUE_SIZE 8
N#endif
N
N// <o> FDS_MAX_USERS - Maximum number of callbacks that can be registered. 
N#ifndef FDS_MAX_USERS
N#define FDS_MAX_USERS 8
N#endif
N
N// <o> FDS_VIRTUAL_PAGES - Number of virtual flash pages to use. 
N// <i> One of the virtual pages is reserved by the system for garbage collection.
N// <i> Therefore, the minimum is two virtual pages: one page to store data and
N// <i> one page to be used by the system for garbage collection. The total amount
N// <i> of flash memory that is used by FDS amounts to @ref FDS_VIRTUAL_PAGES
N// <i> @ref FDS_VIRTUAL_PAGE_SIZE * 4 bytes.
N
N#ifndef FDS_VIRTUAL_PAGES
N#define FDS_VIRTUAL_PAGES 3
N#endif
N
N// <o> FDS_VIRTUAL_PAGE_SIZE  - The size of a virtual page of flash memory, expressed in number of 4-byte words.
N 
N
N// <i> By default, a virtual page is the same size as a physical page.
N// <i> The size of a virtual page must be a multiple of the size of a physical page.
N// <1024=> 1024 
N// <2048=> 2048 
N
N#ifndef FDS_VIRTUAL_PAGE_SIZE
N#define FDS_VIRTUAL_PAGE_SIZE 1024
N#endif
N
N#endif //FDS_ENABLED
N// </e>
N
N// <e> FSTORAGE_ENABLED - fstorage - Flash storage module
N//==========================================================
N#ifndef FSTORAGE_ENABLED
N#define FSTORAGE_ENABLED 1
N#endif
N#if  FSTORAGE_ENABLED
X#if  1
N// <o> FS_QUEUE_SIZE - Configures the size of the internal queue. 
N// <i> Increase this if there are many users, or if it is likely that many
N// <i> operation will be queued at once without waiting for the previous operations
N// <i> to complete. In general, increase the queue size if you frequently receive
N// <i> @ref FS_ERR_QUEUE_FULL errors when calling @ref fs_store or @ref fs_erase.
N
N#ifndef FS_QUEUE_SIZE
N#define FS_QUEUE_SIZE 4
N#endif
N
N// <o> FS_OP_MAX_RETRIES - Number attempts to execute an operation if the SoftDevice fails. 
N// <i> Increase this value if events return the @ref FS_ERR_OPERATION_TIMEOUT
N// <i> error often. The SoftDevice may fail to schedule flash access due to high BLE activity.
N
N#ifndef FS_OP_MAX_RETRIES
N#define FS_OP_MAX_RETRIES 3
N#endif
N
N// <o> FS_MAX_WRITE_SIZE_WORDS - Maximum number of words to be written to flash in a single operation. 
N// <i> Tweaking this value can increase the chances of the SoftDevice being
N// <i> able to fit flash operations in between radio activity. This value is bound by the
N// <i> maximum number of words which the SoftDevice can write to flash in a single call to
N// <i> @ref sd_flash_write, which is 256 words for nRF51 ICs and 1024 words for nRF52 ICs.
N
N#ifndef FS_MAX_WRITE_SIZE_WORDS
N#define FS_MAX_WRITE_SIZE_WORDS 1024
N#endif
N
N#endif //FSTORAGE_ENABLED
N// </e>
N
N// <q> HARDFAULT_HANDLER_ENABLED  - hardfault_default - HardFault default handler for debugging and release
N 
N
N#ifndef HARDFAULT_HANDLER_ENABLED
N#define HARDFAULT_HANDLER_ENABLED 0
N#endif
N
N// <e> HCI_MEM_POOL_ENABLED - hci_mem_pool - memory pool implementation used by HCI
N//==========================================================
N#ifndef HCI_MEM_POOL_ENABLED
N#define HCI_MEM_POOL_ENABLED 0
N#endif
N#if  HCI_MEM_POOL_ENABLED
X#if  0
S// <o> HCI_TX_BUF_SIZE - TX buffer size in bytes. 
S#ifndef HCI_TX_BUF_SIZE
S#define HCI_TX_BUF_SIZE 600
S#endif
S
S// <o> HCI_RX_BUF_SIZE - RX buffer size in bytes. 
S#ifndef HCI_RX_BUF_SIZE
S#define HCI_RX_BUF_SIZE 600
S#endif
S
S// <o> HCI_RX_BUF_QUEUE_SIZE - RX buffer queue size. 
S#ifndef HCI_RX_BUF_QUEUE_SIZE
S#define HCI_RX_BUF_QUEUE_SIZE 4
S#endif
S
N#endif //HCI_MEM_POOL_ENABLED
N// </e>
N
N// <e> HCI_SLIP_ENABLED - hci_slip - SLIP protocol implementation used by HCI
N//==========================================================
N#ifndef HCI_SLIP_ENABLED
N#define HCI_SLIP_ENABLED 0
N#endif
N#if  HCI_SLIP_ENABLED
X#if  0
S// <o> HCI_UART_BAUDRATE  - Default Baudrate
S 
S// <323584=> 1200 baud 
S// <643072=> 2400 baud 
S// <1290240=> 4800 baud 
S// <2576384=> 9600 baud 
S// <3862528=> 14400 baud 
S// <5152768=> 19200 baud 
S// <7716864=> 28800 baud 
S// <10289152=> 38400 baud 
S// <15400960=> 57600 baud 
S// <20615168=> 76800 baud 
S// <30801920=> 115200 baud 
S// <61865984=> 230400 baud 
S// <67108864=> 250000 baud 
S// <121634816=> 460800 baud 
S// <251658240=> 921600 baud 
S// <268435456=> 57600 baud 
S
S#ifndef HCI_UART_BAUDRATE
S#define HCI_UART_BAUDRATE 30801920
S#endif
S
S// <o> HCI_UART_FLOW_CONTROL  - Hardware Flow Control
S 
S// <0=> Disabled 
S// <1=> Enabled 
S
S#ifndef HCI_UART_FLOW_CONTROL
S#define HCI_UART_FLOW_CONTROL 0
S#endif
S
S// <o> HCI_UART_RX_PIN - UART RX pin 
S#ifndef HCI_UART_RX_PIN
S#define HCI_UART_RX_PIN 8
S#endif
S
S// <o> HCI_UART_TX_PIN - UART TX pin 
S#ifndef HCI_UART_TX_PIN
S#define HCI_UART_TX_PIN 6
S#endif
S
S// <o> HCI_UART_RTS_PIN - UART RTS pin 
S#ifndef HCI_UART_RTS_PIN
S#define HCI_UART_RTS_PIN 5
S#endif
S
S// <o> HCI_UART_CTS_PIN - UART CTS pin 
S#ifndef HCI_UART_CTS_PIN
S#define HCI_UART_CTS_PIN 7
S#endif
S
N#endif //HCI_SLIP_ENABLED
N// </e>
N
N// <e> HCI_TRANSPORT_ENABLED - hci_transport - HCI transport
N//==========================================================
N#ifndef HCI_TRANSPORT_ENABLED
N#define HCI_TRANSPORT_ENABLED 0
N#endif
N#if  HCI_TRANSPORT_ENABLED
X#if  0
S// <o> HCI_MAX_PACKET_SIZE_IN_BITS - Maximum size of a single application packet in bits. 
S#ifndef HCI_MAX_PACKET_SIZE_IN_BITS
S#define HCI_MAX_PACKET_SIZE_IN_BITS 8000
S#endif
S
N#endif //HCI_TRANSPORT_ENABLED
N// </e>
N
N// <q> LED_SOFTBLINK_ENABLED  - led_softblink - led_softblink module
N 
N
N#ifndef LED_SOFTBLINK_ENABLED
N#define LED_SOFTBLINK_ENABLED 0
N#endif
N
N// <q> LOW_POWER_PWM_ENABLED  - low_power_pwm - low_power_pwm module
N 
N
N#ifndef LOW_POWER_PWM_ENABLED
N#define LOW_POWER_PWM_ENABLED 0
N#endif
N
N// <e> MEM_MANAGER_ENABLED - mem_manager - Dynamic memory allocator
N//==========================================================
N#ifndef MEM_MANAGER_ENABLED
N#define MEM_MANAGER_ENABLED 0
N#endif
N#if  MEM_MANAGER_ENABLED
X#if  0
S// <o> MEMORY_MANAGER_SMALL_BLOCK_COUNT - Size of each memory blocks identified as 'small' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_SMALL_BLOCK_COUNT
S#define MEMORY_MANAGER_SMALL_BLOCK_COUNT 1
S#endif
S
S// <o> MEMORY_MANAGER_SMALL_BLOCK_SIZE -  Size of each memory blocks identified as 'small' block. 
S// <i>  Size of each memory blocks identified as 'small' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_SMALL_BLOCK_SIZE
S#define MEMORY_MANAGER_SMALL_BLOCK_SIZE 32
S#endif
S
S// <o> MEMORY_MANAGER_MEDIUM_BLOCK_COUNT - Size of each memory blocks identified as 'medium' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_MEDIUM_BLOCK_COUNT
S#define MEMORY_MANAGER_MEDIUM_BLOCK_COUNT 0
S#endif
S
S// <o> MEMORY_MANAGER_MEDIUM_BLOCK_SIZE -  Size of each memory blocks identified as 'medium' block. 
S// <i>  Size of each memory blocks identified as 'medium' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_MEDIUM_BLOCK_SIZE
S#define MEMORY_MANAGER_MEDIUM_BLOCK_SIZE 256
S#endif
S
S// <o> MEMORY_MANAGER_LARGE_BLOCK_COUNT - Size of each memory blocks identified as 'large' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_LARGE_BLOCK_COUNT
S#define MEMORY_MANAGER_LARGE_BLOCK_COUNT 0
S#endif
S
S// <o> MEMORY_MANAGER_LARGE_BLOCK_SIZE -  Size of each memory blocks identified as 'large' block. 
S// <i>  Size of each memory blocks identified as 'large' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_LARGE_BLOCK_SIZE
S#define MEMORY_MANAGER_LARGE_BLOCK_SIZE 256
S#endif
S
S// <q> MEM_MANAGER_ENABLE_LOGS  - Enable debug trace in the module.
S 
S
S#ifndef MEM_MANAGER_ENABLE_LOGS
S#define MEM_MANAGER_ENABLE_LOGS 0
S#endif
S
S// <q> MEM_MANAGER_DISABLE_API_PARAM_CHECK  - Disable API parameter checks in the module.
S 
S
S#ifndef MEM_MANAGER_DISABLE_API_PARAM_CHECK
S#define MEM_MANAGER_DISABLE_API_PARAM_CHECK 0
S#endif
S
N#endif //MEM_MANAGER_ENABLED
N// </e>
N
N// <e> NRF_CSENSE_ENABLED - nrf_csense - nrf_csense module
N//==========================================================
N#ifndef NRF_CSENSE_ENABLED
N#define NRF_CSENSE_ENABLED 0
N#endif
N#if  NRF_CSENSE_ENABLED
X#if  0
S// <o> NRF_CSENSE_PAD_HYSTERESIS - Minimal value of change to decide that pad was touched. 
S#ifndef NRF_CSENSE_PAD_HYSTERESIS
S#define NRF_CSENSE_PAD_HYSTERESIS 15
S#endif
S
S// <o> NRF_CSENSE_PAD_DEVIATION - Minimal value measured on pad to take its value while calculating step. 
S#ifndef NRF_CSENSE_PAD_DEVIATION
S#define NRF_CSENSE_PAD_DEVIATION 70
S#endif
S
S// <o> NRF_CSENSE_MIN_PAD_VALUE - Minimum normalized value on pad to take its value into account. 
S#ifndef NRF_CSENSE_MIN_PAD_VALUE
S#define NRF_CSENSE_MIN_PAD_VALUE 20
S#endif
S
S// <o> NRF_CSENSE_MAX_PADS_NUMBER - Maximum number of pads used for one instance. 
S#ifndef NRF_CSENSE_MAX_PADS_NUMBER
S#define NRF_CSENSE_MAX_PADS_NUMBER 20
S#endif
S
S// <o> NRF_CSENSE_MAX_VALUE - Maximum normalized value got from measurement. 
S#ifndef NRF_CSENSE_MAX_VALUE
S#define NRF_CSENSE_MAX_VALUE 1000
S#endif
S
S// <o> NRF_CSENSE_OUTPUT_PIN - Output pin used by lower module. 
S// <i> This is only used when running on NRF51.
S
S#ifndef NRF_CSENSE_OUTPUT_PIN
S#define NRF_CSENSE_OUTPUT_PIN 30
S#endif
S
N#endif //NRF_CSENSE_ENABLED
N// </e>
N
N// <e> NRF_DRV_CSENSE_ENABLED - nrf_drv_csense - Capacitive sensor module
N//==========================================================
N#ifndef NRF_DRV_CSENSE_ENABLED
N#define NRF_DRV_CSENSE_ENABLED 0
N#endif
N#if  NRF_DRV_CSENSE_ENABLED
X#if  0
S// <o> TIMER0_FOR_CSENSE - First TIMER instance used by the driver (except nRF51) 
S#ifndef TIMER0_FOR_CSENSE
S#define TIMER0_FOR_CSENSE 1
S#endif
S
S// <o> TIMER1_FOR_CSENSE - Second TIMER instance used by the driver (except nRF51) 
S#ifndef TIMER1_FOR_CSENSE
S#define TIMER1_FOR_CSENSE 2
S#endif
S
S// <o> MEASUREMENT_PERIOD - Single measurement period. 
S// <i> Time of single measurement can be calculated as T = (1/2)*MEASUREMENT_PERIOD*(1/f_OSC) where f_OSC = I_SOURCE / (2C*(VUP-VDOWN) ). I_SOURCE, VUP and VDOWN are values used to initialize COMP and C is capacitance of used pad.
S
S#ifndef MEASUREMENT_PERIOD
S#define MEASUREMENT_PERIOD 20
S#endif
S
N#endif //NRF_DRV_CSENSE_ENABLED
N// </e>
N
N// <q> SLIP_ENABLED  - slip - SLIP encoding decoding
N 
N
N#ifndef SLIP_ENABLED
N#define SLIP_ENABLED 0
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Log 
N
N//==========================================================
N// <e> NRF_LOG_ENABLED - nrf_log - Logging
N//==========================================================
N#ifndef NRF_LOG_ENABLED
N#define NRF_LOG_ENABLED 0
N#endif
N#if  NRF_LOG_ENABLED
X#if  0
S// <e> NRF_LOG_USES_COLORS - If enabled then ANSI escape code for colors is prefixed to every string
S//==========================================================
S#ifndef NRF_LOG_USES_COLORS
S#define NRF_LOG_USES_COLORS 0
S#endif
S#if  NRF_LOG_USES_COLORS
S// <o> NRF_LOG_COLOR_DEFAULT  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef NRF_LOG_COLOR_DEFAULT
S#define NRF_LOG_COLOR_DEFAULT 0
S#endif
S
S// <o> NRF_LOG_ERROR_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef NRF_LOG_ERROR_COLOR
S#define NRF_LOG_ERROR_COLOR 0
S#endif
S
S// <o> NRF_LOG_WARNING_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef NRF_LOG_WARNING_COLOR
S#define NRF_LOG_WARNING_COLOR 0
S#endif
S
S#endif //NRF_LOG_USES_COLORS
S// </e>
S
S// <o> NRF_LOG_DEFAULT_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef NRF_LOG_DEFAULT_LEVEL
S#define NRF_LOG_DEFAULT_LEVEL 3
S#endif
S
S// <e> NRF_LOG_DEFERRED - Enable deffered logger.
S
S// <i> Log data is buffered and can be processed in idle.
S//==========================================================
S#ifndef NRF_LOG_DEFERRED
S#define NRF_LOG_DEFERRED 1
S#endif
S#if  NRF_LOG_DEFERRED
S// <o> NRF_LOG_DEFERRED_BUFSIZE - Size of the buffer for logs in words. 
S// <i> Must be power of 2
S
S#ifndef NRF_LOG_DEFERRED_BUFSIZE
S#define NRF_LOG_DEFERRED_BUFSIZE 256
S#endif
S
S#endif //NRF_LOG_DEFERRED
S// </e>
S
S// <q> NRF_LOG_USES_TIMESTAMP  - Enable timestamping
S 
S
S// <i> Function for getting the timestamp is provided by the user
S
S#ifndef NRF_LOG_USES_TIMESTAMP
S#define NRF_LOG_USES_TIMESTAMP 0
S#endif
S
N#endif //NRF_LOG_ENABLED
N// </e>
N
N// <h> nrf_log_backend - Logging sink
N
N//==========================================================
N// <o> NRF_LOG_BACKEND_MAX_STRING_LENGTH - Buffer for storing single output string 
N// <i> Logger backend RAM usage is determined by this value.
N
N#ifndef NRF_LOG_BACKEND_MAX_STRING_LENGTH
N#define NRF_LOG_BACKEND_MAX_STRING_LENGTH 256
N#endif
N
N// <o> NRF_LOG_TIMESTAMP_DIGITS - Number of digits for timestamp 
N// <i> If higher resolution timestamp source is used it might be needed to increase that
N
N#ifndef NRF_LOG_TIMESTAMP_DIGITS
N#define NRF_LOG_TIMESTAMP_DIGITS 8
N#endif
N
N// <e> NRF_LOG_BACKEND_SERIAL_USES_UART - If enabled data is printed over UART
N//==========================================================
N#ifndef NRF_LOG_BACKEND_SERIAL_USES_UART
N#define NRF_LOG_BACKEND_SERIAL_USES_UART 1
N#endif
N#if  NRF_LOG_BACKEND_SERIAL_USES_UART
X#if  1
N// <o> NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE  - Default Baudrate
N 
N// <323584=> 1200 baud 
N// <643072=> 2400 baud 
N// <1290240=> 4800 baud 
N// <2576384=> 9600 baud 
N// <3862528=> 14400 baud 
N// <5152768=> 19200 baud 
N// <7716864=> 28800 baud 
N// <10289152=> 38400 baud 
N// <15400960=> 57600 baud 
N// <20615168=> 76800 baud 
N// <30801920=> 115200 baud 
N// <61865984=> 230400 baud 
N// <67108864=> 250000 baud 
N// <121634816=> 460800 baud 
N// <251658240=> 921600 baud 
N// <268435456=> 57600 baud 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE
N#define NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE 30801920
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_TX_PIN - UART TX pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_TX_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_TX_PIN 6
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_RX_PIN - UART RX pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_RX_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_RX_PIN 8
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN - UART RTS pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN 5
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN - UART CTS pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN 7
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL  - Hardware Flow Control
N 
N// <0=> Disabled 
N// <1=> Enabled 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL
N#define NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL 0
N#endif
N
N// <o> NRF_LOG_BACKEND_UART_INSTANCE  - UART instance used
N 
N// <0=> 0 
N
N#ifndef NRF_LOG_BACKEND_UART_INSTANCE
N#define NRF_LOG_BACKEND_UART_INSTANCE 0
N#endif
N
N#endif //NRF_LOG_BACKEND_SERIAL_USES_UART
N// </e>
N
N// <q> NRF_LOG_BACKEND_SERIAL_USES_RTT  - If enabled data is printed using RTT
N 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_USES_RTT
N#define NRF_LOG_BACKEND_SERIAL_USES_RTT 0
N#endif
N
N// </h> 
N//==========================================================
N
N// </h> 
N//==========================================================
N
N// <<< end of configuration section >>>
N#endif //SDK_CONFIG_H
N
L 43 "..\..\..\..\..\..\components\libraries\timer\app_timer.h" 2
N#include "app_error.h"
N#include "app_util.h"
N#include "compiler_abstraction.h"
N#include <stdint.h>
N#include <stdbool.h>
N#include <stdio.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define APP_TIMER_CLOCK_FREQ         32768                      /**< Clock frequency of the RTC timer used to implement the app timer module. */
N#define APP_TIMER_MIN_TIMEOUT_TICKS  5                          /**< Minimum value of the timeout_ticks parameter of app_timer_start(). */
N
N#define APP_TIMER_NODE_SIZE          32                         /**< Size of app_timer.timer_node_t (used to allocate data). */
N#define APP_TIMER_USER_OP_SIZE       24                         /**< Size of app_timer.timer_user_op_t (only for use inside APP_TIMER_BUF_SIZE()). */
N
N/**@brief Compute number of bytes required to hold the application timer data structures.
N *
N * @param[in]  OP_QUEUE_SIZE   Size of the queue holding timer operations that are pending execution.
N *                             Note that due to the queue implementation, this size must be one more
N *                             than the size that is actually needed.
N *
N * @return     Required application timer buffer size (in bytes).
N */
N#define APP_TIMER_BUF_SIZE(OP_QUEUE_SIZE)                                  \
N    (                                                                      \
N        (                                                                  \
N            (((OP_QUEUE_SIZE) + 1) * APP_TIMER_USER_OP_SIZE)               \
N        )                                                                  \
N    )
X#define APP_TIMER_BUF_SIZE(OP_QUEUE_SIZE)                                      (                                                                              (                                                                              (((OP_QUEUE_SIZE) + 1) * APP_TIMER_USER_OP_SIZE)                       )                                                                      )
N
N/**@brief Convert milliseconds to timer ticks.
N *
N * This macro uses 64-bit integer arithmetic, but as long as the macro parameters are
N *       constants (i.e. defines), the computation will be done by the preprocessor.
N *
N * When using this macro, ensure that the
N *         values provided as input result in an output value that is supported by the
N *         @ref app_timer_start function. For example, when the ticks for 1 ms is needed, the
N *         maximum possible value of PRESCALER must be 6, when @ref APP_TIMER_CLOCK_FREQ is 32768.
N *         This will result in a ticks value as 5. Any higher value for PRESCALER will result in a
N *         ticks value that is not supported by this module.
N *
N * @param[in]  MS          Milliseconds.
N * @param[in]  PRESCALER   Value of the RTC1 PRESCALER register (must be the same value that was
N *                         passed to APP_TIMER_INIT()).
N *
N * @return     Number of timer ticks.
N */
N#define APP_TIMER_TICKS(MS, PRESCALER)\
N            ((uint32_t)ROUNDED_DIV((MS) * (uint64_t)APP_TIMER_CLOCK_FREQ, ((PRESCALER) + 1) * 1000))
X#define APP_TIMER_TICKS(MS, PRESCALER)            ((uint32_t)ROUNDED_DIV((MS) * (uint64_t)APP_TIMER_CLOCK_FREQ, ((PRESCALER) + 1) * 1000))
N
Ntypedef struct app_timer_t { uint32_t data[CEIL_DIV(APP_TIMER_NODE_SIZE, sizeof(uint32_t))]; } app_timer_t;
Xtypedef struct app_timer_t { uint32_t data[(((32) + (sizeof(uint32_t)) - 1) / (sizeof(uint32_t)))]; } app_timer_t;
N
N/**@brief Timer ID type.
N * Never declare a variable of this type, but use the macro @ref APP_TIMER_DEF instead.*/
Ntypedef app_timer_t * app_timer_id_t;
N
N/**
N * @brief Create a timer identifier and statically allocate memory for the timer.
N *
N * @param timer_id Name of the timer identifier variable that will be used to control the timer.
N */
N#define APP_TIMER_DEF(timer_id)                                  \
N    static app_timer_t timer_id##_data = { {0} };                  \
N    static const app_timer_id_t timer_id = &timer_id##_data
X#define APP_TIMER_DEF(timer_id)                                      static app_timer_t timer_id##_data = { {0} };                      static const app_timer_id_t timer_id = &timer_id##_data
N
N
N/**@brief Application time-out handler type. */
Ntypedef void (*app_timer_timeout_handler_t)(void * p_context);
N
N/**@brief Type of function for passing events from the timer module to the scheduler. */
Ntypedef uint32_t (*app_timer_evt_schedule_func_t) (app_timer_timeout_handler_t timeout_handler,
N                                                   void *                      p_context);
N
N/**@brief Timer modes. */
Ntypedef enum
N{
N    APP_TIMER_MODE_SINGLE_SHOT,                 /**< The timer will expire only once. */
N    APP_TIMER_MODE_REPEATED                     /**< The timer will restart each time it expires. */
N} app_timer_mode_t;
N
N/**@brief Initialize the application timer module.
N *
N * @details This macro handles dimensioning and allocation of the memory buffer required by the timer,
N *          making sure that the buffer is correctly aligned. It will also connect the timer module
N *          to the scheduler (if specified).
N *
N * @note    This module assumes that the LFCLK is already running. If it is not, the module will
N *          be non-functional, since the RTC will not run. If you do not use a SoftDevice, you
N *          must start the LFCLK manually. See the rtc_example's lfclk_config() function
N *          for an example of how to do this. If you use a SoftDevice, the LFCLK is started on
N *          SoftDevice init.
N *
N *
N * @param[in]  PRESCALER        Value of the RTC1 PRESCALER register. This will decide the
N *                              timer tick rate. Set to 0 for no prescaling.
N * @param[in]  OP_QUEUE_SIZE    Size of the queue holding timer operations that are pending execution.
N * @param[in]  SCHEDULER_FUNC   Pointer to scheduler event handler
N *
N * @note Since this macro allocates a buffer, it must only be called once (it is OK to call it
N *       several times as long as it is from the same location, for example, to do a re-initialization).
N */
N/*lint -emacro(506, APP_TIMER_INIT) */ /* Suppress "Constant value Boolean */
N#define APP_TIMER_INIT(PRESCALER, OP_QUEUE_SIZE, SCHEDULER_FUNC)                  \
N    do                                                                            \
N    {                                                                             \
N        static uint32_t APP_TIMER_BUF[CEIL_DIV(APP_TIMER_BUF_SIZE(OP_QUEUE_SIZE), \
N                                               sizeof(uint32_t))];                \
N        uint32_t ERR_CODE = app_timer_init((PRESCALER),                           \
N                                           (OP_QUEUE_SIZE) + 1,                   \
N                                           APP_TIMER_BUF,                         \
N                                           SCHEDULER_FUNC);                       \
N        APP_ERROR_CHECK(ERR_CODE);                                                \
N    } while (0)
X#define APP_TIMER_INIT(PRESCALER, OP_QUEUE_SIZE, SCHEDULER_FUNC)                      do                                                                                {                                                                                     static uint32_t APP_TIMER_BUF[CEIL_DIV(APP_TIMER_BUF_SIZE(OP_QUEUE_SIZE),                                                sizeof(uint32_t))];                        uint32_t ERR_CODE = app_timer_init((PRESCALER),                                                                      (OP_QUEUE_SIZE) + 1,                                                              APP_TIMER_BUF,                                                                    SCHEDULER_FUNC);                               APP_ERROR_CHECK(ERR_CODE);                                                    } while (0)
N
N
N
N/**@brief Function for initializing the timer module.
N *
N * Normally, initialization should be done using the APP_TIMER_INIT() macro, because that macro will both
N *       allocate the buffers needed by the timer module (including aligning the buffers correctly)
N *       and take care of connecting the timer module to the scheduler (if specified).
N *
N * @param[in]  prescaler           Value of the RTC1 PRESCALER register. Set to 0 for no prescaling.
N * @param[in]  op_queue_size       Size of the queue holding timer operations that are pending
N *                                 execution. Note that due to the queue implementation, this size must
N *                                 be one more than the size that is actually needed.
N * @param[in]  p_buffer            Pointer to memory buffer for internal use in the app_timer
N *                                 module. The size of the buffer can be computed using the
N *                                 APP_TIMER_BUF_SIZE() macro. The buffer must be aligned to a
N *                                 4 byte boundary.
N * @param[in]  evt_schedule_func   Function for passing time-out events to the scheduler. Point to
N *                                 app_timer_evt_schedule() to connect to the scheduler. Set to NULL
N *                                 to make the timer module call the time-out handler directly from
N *                                 the timer interrupt handler.
N *
N * @retval     NRF_SUCCESS               If the module was initialized successfully.
N * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid (buffer not aligned to a 4 byte
N *                                       boundary or NULL).
N */
Nuint32_t app_timer_init(uint32_t                      prescaler,
N                        uint8_t                       op_queue_size,
N                        void *                        p_buffer,
N                        app_timer_evt_schedule_func_t evt_schedule_func);
N
N/**@brief Function for creating a timer instance.
N *
N * @param[in]  p_timer_id        Pointer to timer identifier.
N * @param[in]  mode              Timer mode.
N * @param[in]  timeout_handler   Function to be executed when the timer expires.
N *
N * @retval     NRF_SUCCESS               If the timer was successfully created.
N * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid.
N * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized or
N *                                       the timer is running.
N *
N * @note This function does the timer allocation in the caller's context. It is also not protected
N *       by a critical region. Therefore care must be taken not to call it from several interrupt
N *       levels simultaneously.
N * @note The function can be called again on the timer instance and will re-initialize the instance if
N *       the timer is not running.
N * @attention The FreeRTOS and RTX app_timer implementation does not allow app_timer_create to
N *       be called on the previously initialized instance.
N */
Nuint32_t app_timer_create(app_timer_id_t const *      p_timer_id,
N                          app_timer_mode_t            mode,
N                          app_timer_timeout_handler_t timeout_handler);
N
N/**@brief Function for starting a timer.
N *
N * @param[in]       timer_id      Timer identifier.
N * @param[in]       timeout_ticks Number of ticks (of RTC1, including prescaling) to time-out event
N *                                (minimum 5 ticks).
N * @param[in]       p_context     General purpose pointer. Will be passed to the time-out handler when
N *                                the timer expires.
N *
N * @retval     NRF_SUCCESS               If the timer was successfully started.
N * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid.
N * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized or the timer
N *                                       has not been created.
N * @retval     NRF_ERROR_NO_MEM          If the timer operations queue was full.
N *
N * @note The minimum timeout_ticks value is 5.
N * @note For multiple active timers, time-outs occurring in close proximity to each other (in the
N *       range of 1 to 3 ticks) will have a positive jitter of maximum 3 ticks.
N * @note When calling this method on a timer that is already running, the second start operation
N *       is ignored.
N */
Nuint32_t app_timer_start(app_timer_id_t timer_id, uint32_t timeout_ticks, void * p_context);
N
N/**@brief Function for stopping the specified timer.
N *
N * @param[in]  timer_id                  Timer identifier.
N *
N * @retval     NRF_SUCCESS               If the timer was successfully stopped.
N * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid.
N * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized or the timer
N *                                       has not been created.
N * @retval     NRF_ERROR_NO_MEM          If the timer operations queue was full.
N */
Nuint32_t app_timer_stop(app_timer_id_t timer_id);
N
N/**@brief Function for stopping all running timers.
N *
N * @retval     NRF_SUCCESS               If all timers were successfully stopped.
N * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized.
N * @retval     NRF_ERROR_NO_MEM          If the timer operations queue was full.
N */
Nuint32_t app_timer_stop_all(void);
N
N/**@brief Function for returning the current value of the RTC1 counter.
N *
N * @return    Current value of the RTC1 counter.
N */
Nuint32_t app_timer_cnt_get(void);
N
N/**@brief Function for computing the difference between two RTC1 counter values.
N *
N * @param[in]  ticks_to       Value returned by app_timer_cnt_get().
N * @param[in]  ticks_from     Value returned by app_timer_cnt_get().
N * @param[out] p_ticks_diff   Number of ticks from ticks_from to ticks_to.
N *
N * @retval     NRF_SUCCESS   If the counter difference was successfully computed.
N */
Nuint32_t app_timer_cnt_diff_compute(uint32_t   ticks_to,
N                                    uint32_t   ticks_from,
N                                    uint32_t * p_ticks_diff);
N
N
N/**@brief Function for getting the maximum observed operation queue utilization.
N *
N * Function for tuning the module and determining OP_QUEUE_SIZE value and thus module RAM usage.
N *
N * @note APP_TIMER_WITH_PROFILER must be enabled to use this functionality.
N *
N * @return Maximum number of events in queue observed so far.
N */
Nuint8_t app_timer_op_queue_utilization_get(void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_TIMER_H__
N
N/** @} */
L 44 "..\..\..\main.c" 2
N#include "peer_manager.h"
L 1 "..\..\..\..\..\..\components\ble\peer_manager\peer_manager.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N
N/**
N * @file peer_manager.h
N *
N * @defgroup peer_manager Peer Manager
N * @ingroup ble_sdk_lib
N * @{
N * @brief Module for managing BLE bonding, which includes controlling encryption and pairing
N *        procedures as well as persistently storing different pieces of data that must be stored
N *        when bonded.
N *
N * @details The API consists of functions for configuring the pairing and encryption behavior of the
N *          device and functions for manipulating the stored data.
N */
N
N
N#ifndef PEER_MANAGER_H__
N#define PEER_MANAGER_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "sdk_common.h"
L 1 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @cond */
N/**@file
N *
N * @ingroup experimental_api
N * @defgroup sdk_common SDK Common Header
N * @brief All common headers needed for SDK examples will be included here so that application
N *       developer does not have to include headers on him/herself.
N * @{
N */
N
N#ifndef SDK_COMMON_H__
N#define SDK_COMMON_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <string.h>
N#include "nordic_common.h"
N#include "compiler_abstraction.h"
N#include "sdk_os.h"
L 1 "..\..\..\..\..\..\components\libraries\util\sdk_os.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N /** @cond */
N/**@file
N *
N * @defgroup sdk_os SDK OS Abstraction
N * @ingroup experimental_api
N * @details In order to made SDK modules independent of use of an embedded OS, and permit
N *          application with varied task architecture, SDK abstracts the OS specific
N *          elements here in order to make all other modules agnostic to the OS or task
N *          architecture.
N * @{
N */
N
N#ifndef SDK_OS_H__
N#define SDK_OS_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define SDK_MUTEX_DEFINE(X)
N#define SDK_MUTEX_INIT(X)
N#define SDK_MUTEX_LOCK(X)
N#define SDK_MUTEX_UNLOCK(X)
N
N/**
N * @defgroup os_data_type Data types.
N */
N
N/** @} */
N/** @endcond */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // SDK_OS_H__
N
L 32 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N#include "sdk_errors.h"
N#include "app_util.h"
N#include "sdk_macros.h"
L 1 "..\..\..\..\..\..\components\libraries\util\sdk_macros.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**@file
N *
N
N * @defgroup sdk_common_macros SDK Common Header
N * @ingroup app_common
N * @brief Macros for parameter checking and similar tasks
N * @{
N */
N
N#ifndef SDK_MACROS_H__
N#define SDK_MACROS_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**@brief Macro for verifying statement to be true. It will cause the exterior function to return
N *        err_code if the statement is not true.
N *
N * @param[in]   statement   Statement to test.
N * @param[in]   err_code    Error value to return if test was invalid.
N *
N * @retval      nothing, but will cause the exterior function to return @p err_code if @p statement
N *              is false.
N */
N#define VERIFY_TRUE(statement, err_code)    \
Ndo                                          \
N{                                           \
N    if (!(statement))                       \
N    {                                       \
N        return err_code;                    \
N    }                                       \
N} while (0)
X#define VERIFY_TRUE(statement, err_code)    do                                          {                                               if (!(statement))                           {                                               return err_code;                        }                                       } while (0)
N
N
N/**@brief Macro for verifying statement to be true. It will cause the exterior function to return
N *        if the statement is not true.
N *
N * @param[in]   statement   Statement to test.
N */
N#define VERIFY_TRUE_VOID(statement) VERIFY_TRUE((statement), )
N
N
N/**@brief Macro for verifying statement to be false. It will cause the exterior function to return
N *        err_code if the statement is not false.
N *
N * @param[in]   statement   Statement to test.
N * @param[in]   err_code    Error value to return if test was invalid.
N *
N * @retval      nothing, but will cause the exterior function to return @p err_code if @p statement
N *              is true.
N */
N#define VERIFY_FALSE(statement, err_code)   \
Ndo                                          \
N{                                           \
N    if ((statement))                        \
N    {                                       \
N        return err_code;                    \
N    }                                       \
N} while (0)
X#define VERIFY_FALSE(statement, err_code)   do                                          {                                               if ((statement))                            {                                               return err_code;                        }                                       } while (0)
N
N
N/**@brief Macro for verifying statement to be false. It will cause the exterior function to return
N *        if the statement is not false.
N *
N * @param[in]   statement    Statement to test.
N */
N#define VERIFY_FALSE_VOID(statement) VERIFY_FALSE((statement), )
N
N
N/**@brief Macro for verifying that a function returned NRF_SUCCESS. It will cause the exterior
N *        function to return err_code if the err_code is not @ref NRF_SUCCESS.
N *
N * @param[in] err_code The error code to check.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_SUCCESS()
N#else
N#define VERIFY_SUCCESS(err_code) VERIFY_TRUE((err_code) == NRF_SUCCESS, (err_code))
N#endif /* DISABLE_PARAM_CHECK */
N
N
N/**@brief Macro for verifying that a function returned NRF_SUCCESS. It will cause the exterior
N *        function to return if the err_code is not @ref NRF_SUCCESS.
N *
N * @param[in] err_code The error code to check.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_SUCCESS_VOID()
N#else
N#define VERIFY_SUCCESS_VOID(err_code) VERIFY_TRUE_VOID((err_code) == NRF_SUCCESS)
N#endif /* DISABLE_PARAM_CHECK */
N
N
N/**@brief Macro for verifying that the module is initialized. It will cause the exterior function to
N *        return @ref NRF_ERROR_INVALID_STATE if not.
N *
N * @note MODULE_INITIALIZED must be defined in each module using this macro. MODULE_INITIALIZED
N *       should be true if the module is initialized, false if not.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_MODULE_INITIALIZED()
N#else
N#define VERIFY_MODULE_INITIALIZED() VERIFY_TRUE((MODULE_INITIALIZED), NRF_ERROR_INVALID_STATE)
N#endif /* DISABLE_PARAM_CHECK */
N
N
N/**@brief Macro for verifying that the module is initialized. It will cause the exterior function to
N *        return if not.
N *
N * @note MODULE_INITIALIZED must be defined in each module using this macro. MODULE_INITIALIZED
N *       should be true if the module is initialized, false if not.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_MODULE_INITIALIZED_VOID()
N#else
N#define VERIFY_MODULE_INITIALIZED_VOID() VERIFY_TRUE_VOID((MODULE_INITIALIZED))
N#endif /* DISABLE_PARAM_CHECK */
N
N
N/**@brief Macro for verifying that the module is initialized. It will cause the exterior function to
N *        return if not.
N *
N * @param[in] param  The variable to check if is NULL.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_PARAM_NOT_NULL()
N#else
N#define VERIFY_PARAM_NOT_NULL(param) VERIFY_FALSE(((param) == NULL), NRF_ERROR_NULL)
N#endif /* DISABLE_PARAM_CHECK */
N
N
N/**@brief Macro for verifying that the module is initialized. It will cause the exterior function to
N *        return if not.
N *
N * @param[in] param  The variable to check if is NULL.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_PARAM_NOT_NULL_VOID()
N#else
N#define VERIFY_PARAM_NOT_NULL_VOID(param) VERIFY_FALSE_VOID(((param) == NULL))
N#endif /* DISABLE_PARAM_CHECK */
N
N/** @} */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // SDK_MACROS_H__
N
L 35 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/** @} */
N/** @endcond */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // SDK_COMMON_H__
N
L 35 "..\..\..\..\..\..\components\ble\peer_manager\peer_manager.h" 2
N#include "ble.h"
N#include "ble_gap.h"
N#include "peer_manager_types.h"
L 1 "..\..\..\..\..\..\components\ble\peer_manager\peer_manager_types.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N
N/**
N * @file peer_manager_types.h
N *
N * @addtogroup peer_manager
N * @{
N */
N
N#ifndef PEER_MANAGER_TYPES_H__
N#define PEER_MANAGER_TYPES_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060016
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 27 "..\..\..\..\..\..\components\ble\peer_manager\peer_manager_types.h" 2
N#include "nrf.h"
N#include "ble_gap.h"
N#include "ble_hci.h"
N#include "ble_gatt_db.h"
L 1 "..\..\..\..\..\..\components\ble\common\ble_gatt_db.h" 1
N/* Copyright (c) 2016 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N */
N
N /**@file
N *
N * @defgroup ble_sdk_lib_gatt_db GATT Database Service Structure
N * @{
N * @ingroup  app_common
N */
N
N#ifndef BLE_GATT_DB_H__
N#define BLE_GATT_DB_H__
N
N#include <stdint.h>
N#include "ble.h"
N#include "ble_gattc.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define BLE_GATT_DB_MAX_CHARS 5       /**< The maximum number of characteristics present in a service record. */
N
N/**@brief Structure for holding the characteristic and the handle of its CCCD present on a server.
N */
Ntypedef struct
N{
N    ble_gattc_char_t characteristic;  /**< Structure containing information about the characteristic. */
N    uint16_t         cccd_handle;     /**< CCCD Handle value for this characteristic. This will be set to BLE_GATT_HANDLE_INVALID if a CCCD is not present at the server. */
N} ble_gatt_db_char_t;
N
N/**@brief Structure for holding information about the service and the characteristics present on a
N *        server.
N */
Ntypedef struct
N{
N    ble_uuid_t               srv_uuid;                                  /**< UUID of the service. */
N    uint8_t                  char_count;                                /**< Number of characteristics present in the service. */
N    ble_gattc_handle_range_t handle_range;                              /**< Service Handle Range. */
N    ble_gatt_db_char_t       charateristics[BLE_GATT_DB_MAX_CHARS];     /**< Array of information related to the characteristics present in the service. This list can extend further than one. */
X    ble_gatt_db_char_t       charateristics[5];      
N} ble_gatt_db_srv_t;
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* BLE_GATT_DB_H__ */
N
N/** @} */
L 31 "..\..\..\..\..\..\components\ble\peer_manager\peer_manager_types.h" 2
N#include "app_util.h"
N#include "app_util_platform.h"
L 1 "..\..\..\..\..\..\components\libraries\util\app_util_platform.h" 1
N/* Copyright (c) 2014 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**@file
N *
N * @defgroup app_util_platform Utility Functions and Definitions (Platform)
N * @{
N * @ingroup app_common
N *
N * @brief Various types and definitions available to all applications when using SoftDevice.
N */
N
N#ifndef APP_UTIL_PLATFORM_H__
N#define APP_UTIL_PLATFORM_H__
N
N#include <stdint.h>
N#include "compiler_abstraction.h"
N#include "nrf.h"
N#ifdef SOFTDEVICE_PRESENT
N#include "nrf_soc.h"
N#include "nrf_nvic.h"
L 1 "..\..\..\..\..\..\components\softdevice\s132\headers\nrf_nvic.h" 1
N/*
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N *
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N *
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N *
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N/**
N * @defgroup nrf_nvic_api SoftDevice NVIC API
N * @{
N *
N * @note In order to use this module, the following code has to be added to a .c file:
N *     \code
N *     nrf_nvic_state_t nrf_nvic_state = {0};
N *     \endcode
N *
N * @note Definitions and declarations starting with __ (double underscore) in this header file are
N * not intended for direct use by the application.
N *
N * @brief APIs for the accessing NVIC when using a SoftDevice.
N *
N */
N
N#ifndef NRF_NVIC_H__
N#define NRF_NVIC_H__
N
N#include <stdint.h>
N#include "nrf.h"
N
N#include "nrf_error_soc.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**@addtogroup NRF_NVIC_DEFINES Defines
N * @{ */
N
N/**@defgroup NRF_NVIC_ISER_DEFINES SoftDevice NVIC internal definitions
N * @{ */
N
N#define __NRF_NVIC_NVMC_IRQn (30) /**< The peripheral ID of the NVMC. IRQ numbers are used to identify peripherals, but the NVMC doesn't have an IRQ number in the MDK. */
N
N#ifdef NRF51
S  #define __NRF_NVIC_ISER_COUNT (1) /**< The number of ISER/ICER registers in the NVIC that are used. */
S
S  /**@brief Interrupts used by the SoftDevice. */
S  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)( \
S        (1U << POWER_CLOCK_IRQn) \
S      | (1U << RADIO_IRQn) \
S      | (1U << RTC0_IRQn) \
S      | (1U << TIMER0_IRQn) \
S      | (1U << RNG_IRQn) \
S      | (1U << ECB_IRQn) \
S      | (1U << CCM_AAR_IRQn) \
S      | (1U << TEMP_IRQn) \
S      | (1U << __NRF_NVIC_NVMC_IRQn) \
S      | (1U << (uint32_t)SWI4_IRQn) \
S      | (1U << (uint32_t)SWI5_IRQn) \
S    ))
X  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)(         (1U << POWER_CLOCK_IRQn)       | (1U << RADIO_IRQn)       | (1U << RTC0_IRQn)       | (1U << TIMER0_IRQn)       | (1U << RNG_IRQn)       | (1U << ECB_IRQn)       | (1U << CCM_AAR_IRQn)       | (1U << TEMP_IRQn)       | (1U << __NRF_NVIC_NVMC_IRQn)       | (1U << (uint32_t)SWI4_IRQn)       | (1U << (uint32_t)SWI5_IRQn)     ))
S
S  /**@brief Interrupts available for to application. */
S  #define __NRF_NVIC_APP_IRQS_0 (~__NRF_NVIC_SD_IRQS_0)
N#endif
N
N#ifdef NRF52
N  #define __NRF_NVIC_ISER_COUNT (2) /**< The number of ISER/ICER registers in the NVIC that are used. */
N
N  /**@brief Interrupts used by the SoftDevice. */
N  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)( \
N        (1U << POWER_CLOCK_IRQn) \
N      | (1U << RADIO_IRQn) \
N      | (1U << RTC0_IRQn) \
N      | (1U << TIMER0_IRQn) \
N      | (1U << RNG_IRQn) \
N      | (1U << ECB_IRQn) \
N      | (1U << CCM_AAR_IRQn) \
N      | (1U << TEMP_IRQn) \
N      | (1U << __NRF_NVIC_NVMC_IRQn) \
N      | (1U << (uint32_t)SWI4_EGU4_IRQn) \
N      | (1U << (uint32_t)SWI5_EGU5_IRQn) \
N    ))
X  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)(         (1U << POWER_CLOCK_IRQn)       | (1U << RADIO_IRQn)       | (1U << RTC0_IRQn)       | (1U << TIMER0_IRQn)       | (1U << RNG_IRQn)       | (1U << ECB_IRQn)       | (1U << CCM_AAR_IRQn)       | (1U << TEMP_IRQn)       | (1U << __NRF_NVIC_NVMC_IRQn)       | (1U << (uint32_t)SWI4_EGU4_IRQn)       | (1U << (uint32_t)SWI5_EGU5_IRQn)     ))
N  #define __NRF_NVIC_SD_IRQS_1 ((uint32_t)0)
N
N  /**@brief Interrupts available for to application. */
N  #define __NRF_NVIC_APP_IRQS_0 (~__NRF_NVIC_SD_IRQS_0)
N  #define __NRF_NVIC_APP_IRQS_1 (~__NRF_NVIC_SD_IRQS_1)
N#endif
N/**@} */
N
N/**@} */
N
N/**@addtogroup NRF_NVIC_VARIABLES Variables
N * @{ */
N
N/**@brief Type representing the state struct for the SoftDevice NVIC module. */
Ntypedef struct
N{
N  uint32_t volatile __irq_masks[__NRF_NVIC_ISER_COUNT]; /**< IRQs enabled by the application in the NVIC. */
X  uint32_t volatile __irq_masks[(2)];  
N  uint32_t volatile __cr_flag;                          /**< Non-zero if already in a critical region */
N} nrf_nvic_state_t;
N
N/**@brief Variable keeping the state for the SoftDevice NVIC module. This must be declared in an
N * application source file. */
Nextern nrf_nvic_state_t nrf_nvic_state;
N
N/**@} */
N
N/**@addtogroup NRF_NVIC_INTERNAL_FUNCTIONS SoftDevice NVIC internal functions
N * @{ */
N
N/**@brief Disables IRQ interrupts globally, including the SoftDevice's interrupts.
N *
N * @retval  The value of PRIMASK prior to disabling the interrupts.
N */
Nstatic inline int __sd_nvic_irq_disable(void)
N{
N  int pm = __get_PRIMASK();
N  __disable_irq();
N  return pm;
N}
N
N/**@brief Enables IRQ interrupts globally, including the SoftDevice's interrupts.
N */
Nstatic inline void __sd_nvic_irq_enable(void)
N{
N  __enable_irq();
N}
N
N/**@brief Checks if IRQn is available to application
N * @param[in]  IRQn  irq to check
N *
N * @retval  1 (true) if the irq to check is available to the application
N */
Nstatic inline uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn)
N{
N  if (IRQn < 32)
N  {
N    return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
X    return ((1UL<<IRQn) & (~((uint32_t)( (1U << POWER_CLOCK_IRQn) | (1U << RADIO_IRQn) | (1U << RTC0_IRQn) | (1U << TIMER0_IRQn) | (1U << RNG_IRQn) | (1U << ECB_IRQn) | (1U << CCM_AAR_IRQn) | (1U << TEMP_IRQn) | (1U << (30)) | (1U << (uint32_t)SWI4_EGU4_IRQn) | (1U << (uint32_t)SWI5_EGU5_IRQn) )))) != 0;
N  }
N#ifdef NRF52
N  else if (IRQn < 64)
N  {
N    return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
X    return ((1UL<<(IRQn-32)) & (~((uint32_t)0))) != 0;
N  }
N#endif
N  else
N  {
N    return 1;
N  }
N}
N
N/**@brief Checks if IRQn is available to application
N * @param[in]  priority  priority to check
N *
N * @retval  1 (true) if the priority to check is available to the application
N */
Nstatic inline uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority)
N{
N  if(priority >= (1 << __NVIC_PRIO_BITS))
X  if(priority >= (1 << 3))
N  {
N    return 0;
N  }
N#ifdef NRF51
S  if(   priority == 0
S     || priority == 2
S     )
S  {
S    return 0;
S  }
N#endif
N#ifdef NRF52
N  if(   priority == 0
N     || priority == 1
N     || priority == 4
N     || priority == 5
N     )
N  {
N    return 0;
N  }
N#endif
N  return 1;
N}
N
N/**@} */
N
N/**@addtogroup NRF_NVIC_FUNCTIONS SoftDevice NVIC public functions
N * @{ */
N
N/**@brief Enable External Interrupt.
N * @note Corresponds to NVIC_EnableIRQ in CMSIS.
N *
N * @pre IRQn is valid and not reserved by the stack.
N *
N * @param[in] IRQn See the NVIC_EnableIRQ documentation in CMSIS.
N *
N * @retval ::NRF_SUCCESS The interrupt was enabled.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE The interrupt is not available for the application.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED The interrupt has a priority not available for the application.
N */
Nstatic inline uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn)
N{
N  if (!__sd_nvic_app_accessible_irq(IRQn))
N  {
N    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
X    return ((0x2000) + 1);
N  }
N  if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
N  {
N    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
X    return ((0x2000) + 2);
N  }
N
N  if (nrf_nvic_state.__cr_flag)
N  {
N    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
N  }
N  else
N  {
N    NVIC_EnableIRQ(IRQn);
N  }
N  return NRF_SUCCESS;
X  return ((0x0) + 0);
N}
N
N/**@brief  Disable External Interrupt.
N * @note Corresponds to NVIC_DisableIRQ in CMSIS.
N *
N * @pre IRQn is valid and not reserved by the stack.
N *
N * @param[in] IRQn See the NVIC_DisableIRQ documentation in CMSIS.
N *
N * @retval ::NRF_SUCCESS The interrupt was disabled.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE The interrupt is not available for the application.
N */
Nstatic inline uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn)
N{
N  if (!__sd_nvic_app_accessible_irq(IRQn))
N  {
N    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
X    return ((0x2000) + 1);
N  }
N
N  if (nrf_nvic_state.__cr_flag)
N  {
N    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] &= ~(1UL << ((uint32_t)(IRQn) & 0x1F));
N  }
N  else
N  {
N    NVIC_DisableIRQ(IRQn);
N  }
N
N  return NRF_SUCCESS;
X  return ((0x0) + 0);
N}
N
N/**@brief  Get Pending Interrupt.
N * @note Corresponds to NVIC_GetPendingIRQ in CMSIS.
N *
N * @pre IRQn is valid and not reserved by the stack.
N *
N * @param[in]   IRQn          See the NVIC_GetPendingIRQ documentation in CMSIS.
N * @param[out]  p_pending_irq Return value from NVIC_GetPendingIRQ.
N *
N * @retval ::NRF_SUCCESS The interrupt is available for the application.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
N */
Nstatic inline uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq)
N{
N  if (__sd_nvic_app_accessible_irq(IRQn))
N  {
N    *p_pending_irq = NVIC_GetPendingIRQ(IRQn);
N    return NRF_SUCCESS;
X    return ((0x0) + 0);
N  }
N  else
N  {
N    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
X    return ((0x2000) + 1);
N  }
N}
N
N/**@brief  Set Pending Interrupt.
N * @note Corresponds to NVIC_SetPendingIRQ in CMSIS.
N *
N * @pre IRQn is valid and not reserved by the stack.
N *
N * @param[in] IRQn See the NVIC_SetPendingIRQ documentation in CMSIS.
N *
N * @retval ::NRF_SUCCESS The interrupt is set pending.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
N */
Nstatic inline uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if (__sd_nvic_app_accessible_irq(IRQn))
N  {
N    NVIC_SetPendingIRQ(IRQn);
N    return NRF_SUCCESS;
X    return ((0x0) + 0);
N  }
N  else
N  {
N    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
X    return ((0x2000) + 1);
N  }
N}
N
N/**@brief  Clear Pending Interrupt.
N * @note Corresponds to NVIC_ClearPendingIRQ in CMSIS.
N *
N * @pre IRQn is valid and not reserved by the stack.
N *
N * @param[in] IRQn See the NVIC_ClearPendingIRQ documentation in CMSIS.
N *
N * @retval ::NRF_SUCCESS The interrupt pending flag is cleared.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
N */
Nstatic inline uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if (__sd_nvic_app_accessible_irq(IRQn))
N  {
N    NVIC_ClearPendingIRQ(IRQn);
N    return NRF_SUCCESS;
X    return ((0x0) + 0);
N  }
N  else
N  {
N    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
X    return ((0x2000) + 1);
N  }
N}
N
N/**@brief Set Interrupt Priority.
N * @note Corresponds to NVIC_SetPriority in CMSIS.
N *
N * @pre IRQn is valid and not reserved by the stack.
N * @pre Priority is valid and not reserved by the stack.
N *
N * @param[in] IRQn      See the NVIC_SetPriority documentation in CMSIS.
N * @param[in] priority  A valid IRQ priority for use by the application.
N *
N * @retval ::NRF_SUCCESS The interrupt and priority level is available for the application.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED The interrupt priority is not available for the application.
N */
Nstatic inline uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if (!__sd_nvic_app_accessible_irq(IRQn))
N  {
N    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
X    return ((0x2000) + 1);
N  }
N
N  if (!__sd_nvic_is_app_accessible_priority(priority))
N  {
N    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
X    return ((0x2000) + 2);
N  }
N
N  NVIC_SetPriority(IRQn, (uint32_t)priority);
N  return NRF_SUCCESS;
X  return ((0x0) + 0);
N}
N
N/**@brief Get Interrupt Priority.
N * @note Corresponds to NVIC_GetPriority in CMSIS.
N *
N * @pre IRQn is valid and not reserved by the stack.
N *
N * @param[in]  IRQn         See the NVIC_GetPriority documentation in CMSIS.
N * @param[out] p_priority   Return value from NVIC_GetPriority.
N *
N * @retval ::NRF_SUCCESS The interrupt priority is returned in p_priority.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE - IRQn is not available for the application.
N */
Nstatic inline uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority)
N{
N  if (__sd_nvic_app_accessible_irq(IRQn))
N  {
N    *p_priority = (NVIC_GetPriority(IRQn) & 0xFF);
N    return NRF_SUCCESS;
X    return ((0x0) + 0);
N  }
N  else
N  {
N    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
X    return ((0x2000) + 1);
N  }
N}
N
N/**@brief System Reset.
N * @note Corresponds to NVIC_SystemReset in CMSIS.
N *
N * @retval ::NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN
N */
Nstatic inline uint32_t sd_nvic_SystemReset(void)
N{
N  NVIC_SystemReset();
N  return NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN;
X  return ((0x2000) + 3);
N}
N
N/**@brief Enters critical region.
N *
N * @post Application interrupts will be disabled.
N * @note sd_nvic_critical_region_enter() and ::sd_nvic_critical_region_exit() must be called in matching pairs inside each
N * execution context
N * @sa sd_nvic_critical_region_exit
N *
N * @param[out] p_is_nested_critical_region If 1, the application is now in a nested critical region.
N *
N * @retval ::NRF_SUCCESS
N */
Nstatic inline uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region)
N{
N  int was_masked = __sd_nvic_irq_disable();
N  if (!nrf_nvic_state.__cr_flag)
N  {
N    nrf_nvic_state.__cr_flag = 1;
N    nrf_nvic_state.__irq_masks[0] = ( NVIC->ICER[0] & __NRF_NVIC_APP_IRQS_0 );
X    nrf_nvic_state.__irq_masks[0] = ( ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] & (~((uint32_t)( (1U << POWER_CLOCK_IRQn) | (1U << RADIO_IRQn) | (1U << RTC0_IRQn) | (1U << TIMER0_IRQn) | (1U << RNG_IRQn) | (1U << ECB_IRQn) | (1U << CCM_AAR_IRQn) | (1U << TEMP_IRQn) | (1U << (30)) | (1U << (uint32_t)SWI4_EGU4_IRQn) | (1U << (uint32_t)SWI5_EGU5_IRQn) ))) );
N    NVIC->ICER[0] = __NRF_NVIC_APP_IRQS_0;
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (~((uint32_t)( (1U << POWER_CLOCK_IRQn) | (1U << RADIO_IRQn) | (1U << RTC0_IRQn) | (1U << TIMER0_IRQn) | (1U << RNG_IRQn) | (1U << ECB_IRQn) | (1U << CCM_AAR_IRQn) | (1U << TEMP_IRQn) | (1U << (30)) | (1U << (uint32_t)SWI4_EGU4_IRQn) | (1U << (uint32_t)SWI5_EGU5_IRQn) )));
N    #ifdef NRF52
N    nrf_nvic_state.__irq_masks[1] = ( NVIC->ICER[1] & __NRF_NVIC_APP_IRQS_1 );
X    nrf_nvic_state.__irq_masks[1] = ( ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[1] & (~((uint32_t)0)) );
N    NVIC->ICER[1] = __NRF_NVIC_APP_IRQS_1;
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[1] = (~((uint32_t)0));
N    #endif
N    *p_is_nested_critical_region = 0;
N  }
N  else
N  {
N    *p_is_nested_critical_region = 1;
N  }
N  if (!was_masked)
N  {
N    __sd_nvic_irq_enable();
N  }
N  return NRF_SUCCESS;
X  return ((0x0) + 0);
N}
N
N/**@brief Exit critical region.
N *
N * @pre Application has entered a critical region using ::sd_nvic_critical_region_enter.
N * @post If not in a nested critical region, the application interrupts will restored to the state before ::sd_nvic_critical_region_enter was called.
N *
N * @param[in] is_nested_critical_region If this is set to 1, the critical region won't be exited. @sa sd_nvic_critical_region_enter.
N *
N * @retval ::NRF_SUCCESS
N */
Nstatic inline uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region)
N{
N  if (nrf_nvic_state.__cr_flag && (is_nested_critical_region == 0))
N  {
N    int was_masked = __sd_nvic_irq_disable();
N    NVIC->ISER[0] = nrf_nvic_state.__irq_masks[0];
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = nrf_nvic_state.__irq_masks[0];
N    #ifdef NRF52
N    NVIC->ISER[1] = nrf_nvic_state.__irq_masks[1];
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[1] = nrf_nvic_state.__irq_masks[1];
N    #endif
N    nrf_nvic_state.__cr_flag = 0;
N    if (!was_masked)
N    {
N      __sd_nvic_irq_enable();
N    }
N  }
N
N  return NRF_SUCCESS;
X  return ((0x0) + 0);
N}
N/**@} */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // NRF_NVIC_H__
N
N/**@} */
L 31 "..\..\..\..\..\..\components\libraries\util\app_util_platform.h" 2
N#endif
N#include "nrf_assert.h"
L 1 "..\..\..\..\..\..\components\libraries\util\nrf_assert.h" 1
N/*
N * Copyright (c) 2006 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N
N/** @file
N * @brief Utilities for verifying program logic
N */
N
N#ifndef NRF_ASSERT_H_
N#define NRF_ASSERT_H_
N
N#include <stdint.h>
N#include "nrf.h"
N#include "app_error.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @brief Function for handling assertions.
N *
N *
N * @note
N * This function is called when an assertion has triggered.
N *
N * @note
N * This function is deprecated and will be removed in future releases.
N * Use app_error_fault_handler instead.
N *
N *
N * @post
N * All hardware is put into an idle non-emitting state (in particular the radio is highly
N * important to switch off since the radio might be in a state that makes it send
N * packets continiously while a typical final infinit ASSERT loop is executing).
N *
N *
N * @param line_num The line number where the assertion is called
N * @param file_name Pointer to the file name
N */
N//lint -save -esym(14, assert_nrf_callback)
Nvoid assert_nrf_callback(uint16_t line_num, const uint8_t *file_name);
N//lint -restore
N
N#if defined(DEBUG_NRF) || defined(DEBUG_NRF_USER)
X#if 0L || 0L
S
S/*lint -emacro(506, ASSERT) */ /* Suppress "Constant value Boolean */
S/*lint -emacro(774, ASSERT) */ /* Suppress "Boolean within 'if' always evaluates to True" */ \
S
X    
S/** @brief Function for checking intended for production code.
S *
S * Check passes if "expr" evaluates to true. */
S
S#ifdef _lint
S#define ASSERT(expr) \
Sif (expr)                                                                     \
S{                                                                             \
S}                                                                             \
Selse                                                                          \
S{                                                                             \
S    while(1);             \
S}
X#define ASSERT(expr) if (expr)                                                                     {                                                                             }                                                                             else                                                                          {                                                                                 while(1);             }
S#else
S#define ASSERT(expr) \
Sif (expr)                                                                     \
S{                                                                             \
S}                                                                             \
Selse                                                                          \
S{                                                                             \
S    assert_nrf_callback((uint16_t)__LINE__, (uint8_t *)__FILE__);             \
S}
X#define ASSERT(expr) if (expr)                                                                     {                                                                             }                                                                             else                                                                          {                                                                                 assert_nrf_callback((uint16_t)__LINE__, (uint8_t *)__FILE__);             }
S#endif
N#else
N#define ASSERT(expr) //!< Assert empty when disabled
N#endif /* defined(DEBUG_NRF) || defined(DEBUG_NRF_USER) */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* NRF_ASSERT_H_ */
L 33 "..\..\..\..\..\..\components\libraries\util\app_util_platform.h" 2
N#include "app_error.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if __CORTEX_M == (0x00U)
X#if (0x04U) == (0x00U)
S#define _PRIO_SD_HIGH       0
S#define _PRIO_APP_HIGH      1
S#define _PRIO_APP_MID       1
S#define _PRIO_SD_LOW        2
S#define _PRIO_APP_LOW       3
S#define _PRIO_APP_LOWEST    3
S#define _PRIO_THREAD        4
N#elif __CORTEX_M == (0x04U)
X#elif (0x04U) == (0x04U)
N#define _PRIO_SD_HIGH       0
N#define _PRIO_SD_MID        1
N#define _PRIO_APP_HIGH      2
N#define _PRIO_APP_MID       3
N#define _PRIO_SD_LOW        4
N#define _PRIO_SD_LOWEST     5
N#define _PRIO_APP_LOW       6
N#define _PRIO_APP_LOWEST    7
N#define _PRIO_THREAD        15
N#else
S    #error "No platform defined"
N#endif
N
N
N//lint -save -e113 -e452
N/**@brief The interrupt priorities available to the application while the SoftDevice is active. */
Ntypedef enum
N{
N#ifndef SOFTDEVICE_PRESENT
S    APP_IRQ_PRIORITY_HIGHEST = _PRIO_SD_HIGH,
N#else
N    APP_IRQ_PRIORITY_HIGHEST = _PRIO_APP_HIGH,
X    APP_IRQ_PRIORITY_HIGHEST = 2,
N#endif
N    APP_IRQ_PRIORITY_HIGH    = _PRIO_APP_HIGH,
X    APP_IRQ_PRIORITY_HIGH    = 2,
N#ifndef SOFTDEVICE_PRESENT
S    APP_IRQ_PRIORITY_MID     = _PRIO_SD_LOW,
N#else
N    APP_IRQ_PRIORITY_MID     = _PRIO_APP_MID,
X    APP_IRQ_PRIORITY_MID     = 3,
N#endif
N    APP_IRQ_PRIORITY_LOW     = _PRIO_APP_LOW,
X    APP_IRQ_PRIORITY_LOW     = 6,
N    APP_IRQ_PRIORITY_LOWEST  = _PRIO_APP_LOWEST,
X    APP_IRQ_PRIORITY_LOWEST  = 7,
N    APP_IRQ_PRIORITY_THREAD  = _PRIO_THREAD     /**< "Interrupt level" when running in Thread Mode. */
X    APP_IRQ_PRIORITY_THREAD  = 15      
N} app_irq_priority_t;
N//lint -restore
N
N
N/*@brief The privilege levels available to applications in Thread Mode */
Ntypedef enum
N{
N    APP_LEVEL_UNPRIVILEGED,
N    APP_LEVEL_PRIVILEGED
N} app_level_t;
N
N/**@cond NO_DOXYGEN */
N#define EXTERNAL_INT_VECTOR_OFFSET 16
N/**@endcond */
N
N/**@brief Macro for setting a breakpoint.
N */
N#if defined(__GNUC__)
X#if 0L
S#define NRF_BREAKPOINT __builtin_trap()
N#else
N#define NRF_BREAKPOINT __BKPT(0)
N#endif
N
N#define PACKED(TYPE) __packed TYPE
N
Nvoid app_util_critical_region_enter (uint8_t *p_nested);
Nvoid app_util_critical_region_exit (uint8_t nested);
N
N/**@brief Macro for entering a critical region.
N *
N * @note Due to implementation details, there must exist one and only one call to
N *       CRITICAL_REGION_EXIT() for each call to CRITICAL_REGION_ENTER(), and they must be located
N *       in the same scope.
N */
N#ifdef SOFTDEVICE_PRESENT
N#define CRITICAL_REGION_ENTER()                                                             \
N    {                                                                                       \
N        uint8_t __CR_NESTED = 0;                                                            \
N        app_util_critical_region_enter(&__CR_NESTED);
X#define CRITICAL_REGION_ENTER()                                                                 {                                                                                               uint8_t __CR_NESTED = 0;                                                                    app_util_critical_region_enter(&__CR_NESTED);
N#else
S#define CRITICAL_REGION_ENTER() app_util_critical_region_enter(NULL)
N#endif
N
N/**@brief Macro for leaving a critical region.
N *
N * @note Due to implementation details, there must exist one and only one call to
N *       CRITICAL_REGION_EXIT() for each call to CRITICAL_REGION_ENTER(), and they must be located
N *       in the same scope.
N */
N#ifdef SOFTDEVICE_PRESENT
N#define CRITICAL_REGION_EXIT()                                                              \
N        app_util_critical_region_exit(__CR_NESTED);                                         \
N    }
X#define CRITICAL_REGION_EXIT()                                                                      app_util_critical_region_exit(__CR_NESTED);                                             }
N#else
S#define CRITICAL_REGION_EXIT() app_util_critical_region_exit(0)
N#endif
N
N/* Workaround for Keil 4 */
N#ifndef IPSR_ISR_Msk
S#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N#endif
N
N
N
N/**@brief Macro to enable anonymous unions from a certain point in the code.
N */
N#if defined(__CC_ARM)
X#if 1L
N    #define ANON_UNIONS_ENABLE _Pragma("push") \
N                               _Pragma("anon_unions")
X    #define ANON_UNIONS_ENABLE _Pragma("push")                                _Pragma("anon_unions")
N#elif defined(__ICCARM__)
S    #define ANON_UNIONS_ENABLE _Pragma("language=extended")
S#else
S    #define ANON_UNIONS_ENABLE
S    // No action will be taken.
S    // For GCC anonymous unions are enabled by default.
N#endif
N
N/**@brief Macro to disable anonymous unions from a certain point in the code.
N * @note Call only after first calling @ref ANON_UNIONS_ENABLE.
N */
N#if defined(__CC_ARM)
X#if 1L
N    #define ANON_UNIONS_DISABLE _Pragma("pop")
N#elif defined(__ICCARM__)
S    #define ANON_UNIONS_DISABLE
S    // for IAR leave anonymous unions enabled
S#else
S    #define ANON_UNIONS_DISABLE
S    // No action will be taken.
S    // For GCC anonymous unions are enabled by default.
N#endif
N
N
N/* Workaround for Keil 4 */
N#ifndef CONTROL_nPRIV_Msk
S#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N#endif
N
N/**@brief Function for finding the current interrupt level.
N *
N * @return   Current interrupt level.
N * @retval   APP_IRQ_PRIORITY_HIGH    We are running in Application High interrupt level.
N * @retval   APP_IRQ_PRIORITY_LOW     We are running in Application Low interrupt level.
N * @retval   APP_IRQ_PRIORITY_THREAD  We are running in Thread Mode.
N */
Nstatic __INLINE uint8_t current_int_priority_get(void)
Xstatic __inline uint8_t current_int_priority_get(void)
N{
N    uint32_t isr_vector_num = __get_IPSR() & IPSR_ISR_Msk ;
X    uint32_t isr_vector_num = __get_IPSR() & (0x1FFUL ) ;
N    if (isr_vector_num > 0)
N    {
N        int32_t irq_type = ((int32_t)isr_vector_num - EXTERNAL_INT_VECTOR_OFFSET);
X        int32_t irq_type = ((int32_t)isr_vector_num - 16);
N        return (NVIC_GetPriority((IRQn_Type)irq_type) & 0xFF);
N    }
N    else
N    {
N        return APP_IRQ_PRIORITY_THREAD;
N    }
N}
N
N/**@brief Function for finding out the current privilege level.
N *
N * @return   Current privilege level.
N * @retval   APP_LEVEL_UNPRIVILEGED    We are running in unprivileged level.
N * @retval   APP_LEVEL_PRIVILEGED    We are running in privileged level.
N */
Nstatic __INLINE uint8_t privilege_level_get(void)
Xstatic __inline uint8_t privilege_level_get(void)
N{
N#if __CORTEX_M == (0x00U) || defined(_WIN32) || defined(__unix) || defined(__APPLE__)
X#if (0x04U) == (0x00U) || 0L || 0L || 0L
S    /* the Cortex-M0 has no concept of privilege */
S    return APP_LEVEL_PRIVILEGED;
N#elif __CORTEX_M == (0x04U)
X#elif (0x04U) == (0x04U)
N    uint32_t isr_vector_num = __get_IPSR() & IPSR_ISR_Msk ;
X    uint32_t isr_vector_num = __get_IPSR() & (0x1FFUL ) ;
N    if (0 == isr_vector_num)
N    {
N        /* Thread Mode, check nPRIV */
N        int32_t control = __get_CONTROL();
N        return control & CONTROL_nPRIV_Msk ? APP_LEVEL_UNPRIVILEGED : APP_LEVEL_PRIVILEGED;
X        return control & (1UL ) ? APP_LEVEL_UNPRIVILEGED : APP_LEVEL_PRIVILEGED;
N    }
N    else
N    {
N        /* Handler Mode, always privileged */
N        return APP_LEVEL_PRIVILEGED;
N    }
N#endif
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_UTIL_PLATFORM_H__
N
N/** @} */
L 33 "..\..\..\..\..\..\components\ble\peer_manager\peer_manager_types.h" 2
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**@brief Handle to uniquely identify a peer for which we have persistently stored data.
N */
Ntypedef uint16_t pm_peer_id_t;
N
N/**@brief Type that is used for write prepares (used to reserve space in flash).
N */
Ntypedef uint32_t pm_prepare_token_t;
N
N/**@brief Type that is used to hold a reference to a stored item in flash.
N */
Ntypedef uint32_t pm_store_token_t;
N
N/**@brief Errors from security procedures in Peer Manager.
N *
N * @details Possible values are defined in @ref PM_SEC_ERRORS and @ref BLE_GAP_SEC_STATUS.
N */
Ntypedef uint16_t pm_sec_error_code_t;
N
N
N//lint -emacro(516,PM_LOCAL_DB_LEN_OVERHEAD_BYTES)
N
N#define PM_PEER_ID_INVALID              0xFFFF                                         /**< @brief Invalid value for @ref pm_peer_id_t. */
N#define PM_STORE_TOKEN_INVALID          0                                              /**< @brief Invalid value for store token. */
N#define PM_PEER_ID_N_AVAILABLE_IDS      256                                            /**< @brief The number of available peer IDs. */
N#define PM_LOCAL_DB_LEN_OVERHEAD_BYTES  offsetof(pm_peer_data_local_gatt_db_t, data)   /**< @brief The static-length part of the local GATT data struct. */
N
N
N#define PM_CONN_SEC_ERROR_BASE 0x1000  /**< @brief The base for Peer Manager defined errors. See @ref PM_SEC_ERRORS and @ref pm_sec_error_code_t. */
N
N
N/**@defgroup PM_SEC_ERRORS Peer Manager defined security errors
N *
N * @details The first 256 numbers in this range correspond to the status codes in
N *          @ref BLE_HCI_STATUS_CODES.
N * @{ */
N#define PM_CONN_SEC_ERROR_PIN_OR_KEY_MISSING (PM_CONN_SEC_ERROR_BASE + 0x06)  /**< @brief Encryption failed because the peripheral has lost the LTK for this bond. See also @ref BLE_HCI_STATUS_CODE_PIN_OR_KEY_MISSING and Table 3.7 ("Pairing Failed Reason Codes") in the Bluetooth Core Specification 4.2, section 3.H.3.5.5 (@linkBLEcore).  */
N#define PM_CONN_SEC_ERROR_MIC_FAILURE        (PM_CONN_SEC_ERROR_BASE + 0x3D)  /**< @brief Encryption ended with disconnection because of mismatching keys or a stray packet during a procedure. See the SoftDevice GAP Message Sequence Charts on encryption (@linkBLEMSCgap), the Bluetooth Core Specification 4.2, sections 6.B.5.1.3.1 and 3.H.3.5.5 (@linkBLEcore), and @ref BLE_HCI_CONN_TERMINATED_DUE_TO_MIC_FAILURE. */
N#define PM_CONN_SEC_ERROR_DISCONNECT         (PM_CONN_SEC_ERROR_BASE + 0x100) /**< @brief Pairing or encryption did not finish before the link disconnected for an unrelated reason. */
N#define PM_CONN_SEC_ERROR_SMP_TIMEOUT        (PM_CONN_SEC_ERROR_BASE + 0x101) /**< @brief Pairing/bonding could not start because an SMP time-out has already happened on this link. This means that no more pairing or bonding can happen on this link. To be able to pair or bond, the link must be disconnected and then reconnected. See Bluetooth Core Specification 4.2 section 3.H.3.4 (@linkBLEcore). */
N /** @} */
N
N
N
N/**@defgroup PM_PEER_ID_VERSIONS All versions of Peer IDs.
N * @brief The data ID for each iteration of the data formats in flash.
N * @details Each time the format (in flash) of a piece of peer data changes, the data ID will also
N *          be updated. This list of defines is a record of each data ID that has ever existed, and
N *          code that caters to legacy formats can find the relevant IDs here.
N * @{ */
N#define PM_PEER_DATA_ID_FIRST_VX                   0     /**< @brief The smallest data ID. */
N#define PM_PEER_DATA_ID_BONDING_V1                 0     /**< @brief The data ID of the first version of bonding data. */
N#define PM_PEER_DATA_ID_BONDING_V2                 7     /**< @brief The data ID of the second version of bonding data. */
N#define PM_PEER_DATA_ID_SERVICE_CHANGED_PENDING_V1 1     /**< @brief The data ID of the first version of the service changed pending flag. */
N#define PM_PEER_DATA_ID_GATT_LOCAL_V1              2     /**< @brief The data ID of the first version of local GATT data. */
N#define PM_PEER_DATA_ID_GATT_LOCAL_V2              8     /**< @brief The data ID of the second version of local GATT data. */
N#define PM_PEER_DATA_ID_GATT_REMOTE_V1             3     /**< @brief The data ID of the first version of remote GATT data. */
N#define PM_PEER_DATA_ID_APPLICATION_V1             4     /**< @brief The data ID of the first version of application data. */
N#define PM_PEER_DATA_ID_GATT_REMOTE_V2             5     /**< @brief The data ID of the second version of remote GATT data. */
N#define PM_PEER_DATA_ID_PEER_RANK_V1               6     /**< @brief The data ID of the first version of the rank. */
N#define PM_PEER_DATA_ID_LAST_VX                    9     /**< @brief The data ID after the last valid one. */
N#define PM_PEER_DATA_ID_INVALID_VX                 0xFF  /**< @brief A data ID guaranteed to be invalid. */
N/**@}*/
N
N
N/**@brief The different types of data associated with a peer.
N */
Ntypedef enum
N{
N    PM_PEER_DATA_ID_FIRST                   = PM_PEER_DATA_ID_FIRST_VX,                   /**< @brief The smallest data ID. */
X    PM_PEER_DATA_ID_FIRST                   = 0,                    
N    PM_PEER_DATA_ID_BONDING                 = PM_PEER_DATA_ID_BONDING_V2,                 /**< @brief The data ID for bonding data. See @ref pm_peer_data_bonding_t. */
X    PM_PEER_DATA_ID_BONDING                 = 7,                  
N    PM_PEER_DATA_ID_SERVICE_CHANGED_PENDING = PM_PEER_DATA_ID_SERVICE_CHANGED_PENDING_V1, /**< @brief The data ID for service changed state. */
X    PM_PEER_DATA_ID_SERVICE_CHANGED_PENDING = 1,  
N    PM_PEER_DATA_ID_GATT_LOCAL              = PM_PEER_DATA_ID_GATT_LOCAL_V2,              /**< @brief The data ID for local GATT data (sys attributes). See @ref pm_peer_data_local_gatt_db_t. */
X    PM_PEER_DATA_ID_GATT_LOCAL              = 8,               
N    PM_PEER_DATA_ID_GATT_REMOTE             = PM_PEER_DATA_ID_GATT_REMOTE_V2,             /**< @brief The data ID for remote GATT data. */
X    PM_PEER_DATA_ID_GATT_REMOTE             = 5,              
N    PM_PEER_DATA_ID_PEER_RANK               = PM_PEER_DATA_ID_PEER_RANK_V1,               /**< @brief The data ID for peer rank. See @ref pm_peer_rank_highest. */
X    PM_PEER_DATA_ID_PEER_RANK               = 6,                
N    PM_PEER_DATA_ID_APPLICATION             = PM_PEER_DATA_ID_APPLICATION_V1,             /**< @brief The data ID for application data. */
X    PM_PEER_DATA_ID_APPLICATION             = 4,              
N    PM_PEER_DATA_ID_LAST                    = PM_PEER_DATA_ID_LAST_VX,                    /**< @brief One more than the highest data ID. */
X    PM_PEER_DATA_ID_LAST                    = 9,                     
N    PM_PEER_DATA_ID_INVALID                 = PM_PEER_DATA_ID_INVALID_VX,                 /**< @brief A data ID guaranteed to be invalid. */
X    PM_PEER_DATA_ID_INVALID                 = 0xFF,                  
N} pm_peer_data_id_t;
N
N
N/**@brief Different procedures that can lead to an encrypted link.
N */
Ntypedef enum
N{
N    PM_LINK_SECURED_PROCEDURE_ENCRYPTION, /**< @brief Using an LTK that was shared during a previous bonding procedure to encrypt the link. */
N    PM_LINK_SECURED_PROCEDURE_BONDING,    /**< @brief A pairing procedure, followed by a bonding procedure. */
N    PM_LINK_SECURED_PROCEDURE_PAIRING,    /**< @brief A pairing procedure with no bonding. */
N} pm_conn_sec_procedure_t;
N
N
N/**@brief Configuration of a security procedure.
N */
Ntypedef struct
N{
N    bool allow_repairing; /** @brief Whether to allow the peer to pair if it wants to, but is already bonded. If this is false, the procedure is rejected, and no more events are sent. Default: false. */
X    _Bool allow_repairing;  
N} pm_conn_sec_config_t;
N
N
N/**@brief Data associated with a bond to a peer.
N */
Ntypedef struct
N{
N    uint8_t           own_role; /**< @brief The role of the local device during bonding. */
N    ble_gap_id_key_t  peer_id;  /**< @brief The peer's peer address and identity resolution key. */
N    ble_gap_enc_key_t peer_ltk; /**< @brief The peer's long-term encryption key. */
N    ble_gap_enc_key_t own_ltk;  /**< @brief Locally generated long-term encryption key, distributed to the peer. */
N} pm_peer_data_bonding_t;
N
N
N/**@brief Data on a local GATT database.
N */
Ntypedef struct
N{
N    uint32_t flags;       /**< @brief Flags that describe the database attributes. */
N    uint16_t len;         /**< @brief Size of the attribute array. */
N    uint8_t  data[];      /**< @brief Array to hold the database attributes. */
N} pm_peer_data_local_gatt_db_t;
N
N
N/**@brief Device Privacy.
N *
N *        The privacy feature provides a way for the device to avoid being tracked over a period of
N *        time. The privacy feature, when enabled, hides the local device identity and replaces it
N *        with a private address that is automatically refreshed at a specified interval.
N *
N *        If a device still wants to be recognized by other peers, it needs to share it's Identity
N *        Resolving Key (IRK). With this key, a device can generate a random private address that
N *        can only be recognized by peers in possession of that key, and devices can establish
N *        connections without revealing their real identities.
N *
N * @note  If the device IRK is updated, the new IRK becomes the one to be distributed in all
N *        bonding procedures performed after @ref sd_ble_gap_privacy_set returns.
N *        The IRK distributed during bonding procedure is the device IRK that is active when @ref
N *        sd_ble_gap_sec_params_reply is called.
N */
N#if (NRF_SD_BLE_API_VERSION < 3)
X#if (3 < 3)
S
Stypedef struct
S{
S    uint8_t         privacy_mode;           /**< Privacy mode, see @ref BLE_GAP_PRIVACY_MODES. Default is @ref BLE_GAP_PRIVACY_MODE_OFF. */
S    uint8_t         private_addr_type;      /**< The private address type must be either @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE or @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE. */
S    uint16_t        private_addr_cycle_s;   /**< Private address cycle interval in seconds. Providing an address cycle value of 0 will use the default value defined by @ref BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S. */
S    ble_gap_irk_t * p_device_irk;           /**< When used as input, pointer to IRK structure that will be used as the default IRK. If NULL, the device default IRK will be used.
S                                                 When used as output, pointer to IRK structure where the current default IRK will be written to. If NULL, this argument is ignored.
S                                                 By default, the default IRK is used to generate random private resolvable addresses for the local device unless instructed otherwise. */
S} pm_privacy_params_t;
S
S
S/**@defgroup BLE_GAP_PRIVACY_MODES Privacy modes
S * @{ */
S#define BLE_GAP_PRIVACY_MODE_OFF                0x00 /**< Device will send and accept its identity address for its own address. */
S#define BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY     0x01 /**< Device will send and accept only private addresses for its own address. */
S/**@} */
S
N#else
N
Ntypedef ble_gap_privacy_params_t pm_privacy_params_t;
N
N#endif
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PEER_MANAGER_TYPES_H__ */
N
N/** @} */
L 38 "..\..\..\..\..\..\components\ble\peer_manager\peer_manager.h" 2
N#include "peer_database.h"
L 1 "..\..\..\..\..\..\components\ble\peer_manager\peer_database.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N
N#ifndef PEER_DATABASE_H__
N#define PEER_DATABASE_H__
N
N#include <stdint.h>
N#include "peer_manager_types.h"
N#include "peer_manager_internal.h"
L 1 "..\..\..\..\..\..\components\ble\peer_manager\peer_manager_internal.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N
N#ifndef PEER_MANAGER_INTERNAL_H__
N#define PEER_MANAGER_INTERNAL_H__
N
N#include <stdint.h>
N#include "sdk_errors.h"
N#include "ble.h"
N#include "ble_gap.h"
N#include "peer_manager_types.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * @cond NO_DOXYGEN
N * @file peer_manager_types.h
N *
N * @addtogroup peer_manager
N * @brief File containing definitions used solely inside the Peer Manager's modules.
N * @{
N */
N
NANON_UNIONS_ENABLE
X_Pragma("push") _Pragma("anon_unions")
N
N/**@brief One piece of data associated with a peer, together with its type.
N *
N * @note This type is deprecated.
N */
Ntypedef struct
N{
N    uint16_t              length_words; /**< @brief The length of the data in words. */
N    pm_peer_data_id_t     data_id;      /**< @brief ID that specifies the type of data (defines which member of the union is used). */
N    union
N    {
N        pm_peer_data_bonding_t       * p_bonding_data;            /**< @brief The exchanged bond information in addition to metadata of the bonding. */
N        uint32_t                     * p_peer_rank;               /**< @brief A value locally assigned to this peer. Its interpretation is up to the user. The rank is not set automatically by the Peer Manager, but it is assigned by the user using either @ref pm_peer_rank_highest or a @ref PM_PEER_DATA_FUNCTIONS function. */
N        bool                         * p_service_changed_pending; /**< @brief Whether a service changed indication should be sent to the peer. */
X        _Bool                         * p_service_changed_pending;  
N        pm_peer_data_local_gatt_db_t * p_local_gatt_db;           /**< @brief Persistent information pertaining to a peer GATT client. */
N        ble_gatt_db_srv_t            * p_remote_gatt_db;          /**< @brief Persistent information pertaining to a peer GATT server. */
N        uint8_t                      * p_application_data;        /**< @brief Arbitrary data to associate with the peer. This data can be freely used by the application. */
N        void                         * p_all_data;                /**< @brief Generic access pointer to the data. It is used only to handle the data without regard to type. */
N    }; /**< @brief The data. */
N} pm_peer_data_t;
N
N
N/**@brief Immutable version of @ref pm_peer_data_t.
N *
N * @note This type is deprecated.
N */
Ntypedef struct
N{
N    uint16_t                    length_words; /**< @brief The length of the data in words. */
N    pm_peer_data_id_t           data_id;      /**< @brief ID that specifies the type of data (defines which member of the union is used). */
N    union
N    {
N        pm_peer_data_bonding_t       const * p_bonding_data;            /**< @brief Immutable @ref pm_peer_data_t::p_bonding_data. */
N        uint32_t                     const * p_peer_rank;               /**< @brief Immutable @ref pm_peer_data_t::p_peer_rank. */
N        bool                         const * p_service_changed_pending; /**< @brief Immutable @ref pm_peer_data_t::p_service_changed_pending. */
X        _Bool                         const * p_service_changed_pending;  
N        pm_peer_data_local_gatt_db_t const * p_local_gatt_db;           /**< @brief Immutable @ref pm_peer_data_t::p_local_gatt_db. */
N        ble_gatt_db_srv_t            const * p_remote_gatt_db;          /**< @brief Immutable @ref pm_peer_data_t::p_remote_gatt_db. */
N        uint8_t                      const * p_application_data;        /**< @brief Immutable @ref pm_peer_data_t::p_application_data. */
N        void                         const * p_all_data;                /**< @brief Immutable @ref pm_peer_data_t::p_all_data. */
N    }; /**< @brief The data. */
N} pm_peer_data_const_t;
N
NANON_UNIONS_DISABLE
X_Pragma("pop")
N
N
N/**@brief Version of @ref pm_peer_data_t that reflects the structure of peer data in flash.
N *
N * @note This type is deprecated.
N */
Ntypedef pm_peer_data_const_t pm_peer_data_flash_t;
N
N
N/**@brief Macro for calculating the flash size of bonding data.
N *
N * @return The number of words that the data takes in flash.
N */
N#define PM_BONDING_DATA_N_WORDS() BYTES_TO_WORDS(sizeof(pm_peer_data_bonding_t))
N
N
N/**@brief Macro for calculating the flash size of service changed pending state.
N *
N * @return The number of words that the data takes in flash.
N */
N#define PM_SC_STATE_N_WORDS() BYTES_TO_WORDS(sizeof(bool))
N
N
N/**@brief Macro for calculating the flash size of local GATT database data.
N *
N * @param[in]  local_db_len  The length, in bytes, of the database as reported by the SoftDevice.
N *
N * @return The number of words that the data takes in flash.
N */
N#define PM_LOCAL_DB_N_WORDS(local_db_len) \
N                                    BYTES_TO_WORDS((local_db_len) + PM_LOCAL_DB_LEN_OVERHEAD_BYTES)
X#define PM_LOCAL_DB_N_WORDS(local_db_len)                                     BYTES_TO_WORDS((local_db_len) + PM_LOCAL_DB_LEN_OVERHEAD_BYTES)
N
N
N/**@brief Macro for calculating the length of a local GATT database attribute array.
N *
N * @param[in]  n_words  The number of words that the data takes in flash.
N *
N * @return The length of the database attribute array.
N */
N#define PM_LOCAL_DB_LEN(n_words) (((n_words) * BYTES_PER_WORD) - PM_LOCAL_DB_LEN_OVERHEAD_BYTES)
N
N
N/**@brief Macro for calculating the flash size of remote GATT database data.
N *
N * @param[in]  service_count  The number of services in the service array.
N *
N * @return The number of words that the data takes in flash.
N */
N#define PM_REMOTE_DB_N_WORDS(service_count) BYTES_TO_WORDS(sizeof(ble_gatt_db_srv_t) * (service_count))
N
N
N/**@brief Macro for calculating the flash size of remote GATT database data.
N *
N * @param[in]  n_words  The length in number of words.
N *
N * @return The number of words that the data takes in flash.
N */
N#define PM_REMOTE_DB_N_SERVICES(n_words) (((n_words) * BYTES_PER_WORD) / sizeof(ble_gatt_db_srv_t))
N
N
N/**@brief Function for calculating the flash size of the usage index.
N *
N * @return The number of words that the data takes in flash.
N */
N#define PM_USAGE_INDEX_N_WORDS() BYTES_TO_WORDS(sizeof(uint32_t))
N
N/** @}
N * @endcond
N */
N
N
N#ifdef NRF_PM_DEBUG
S
S    #define NRF_PM_DEBUG_CHECK(condition)   \
S        if (!(condition))                   \
S        {                                   \
S            __asm("bkpt #0");               \
S        }
X    #define NRF_PM_DEBUG_CHECK(condition)           if (!(condition))                           {                                               __asm("bkpt #0");                       }
S
N#else
N
N    // Prevent "variable set but never used" compiler warnings.
N    #define NRF_PM_DEBUG_CHECK(condition)   (void)(condition)
N
N#endif
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PEER_MANAGER_INTERNAL_H__ */
L 20 "..\..\..\..\..\..\components\ble\peer_manager\peer_database.h" 2
N#include "sdk_errors.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @cond NO_DOXYGEN
N * @defgroup peer_database Peer Database
N * @ingroup peer_manager
N * @{
N * @brief An internal module of @ref peer_manager. A module for simple management of reading and
N *        writing of peer data into persistent storage.
N *
N */
N
N#define PDB_WRITE_BUF_SIZE (sizeof(pm_peer_data_bonding_t))
N
N/**@brief Events that can come from the peer_database module.
N */
Ntypedef enum
N{
N    PDB_EVT_WRITE_BUF_STORED,   /**< A @ref pdb_write_buf_store operation has completed successfully. */
N    PDB_EVT_RAW_STORED,         /**< A @ref pdb_raw_store operation has completed successfully. */
N    PDB_EVT_RAW_STORE_FAILED,   /**< A @ref pdb_raw_store operation has failed. */
N    PDB_EVT_CLEARED,            /**< A @ref pdb_clear operation has completed successfully. */
N    PDB_EVT_CLEAR_FAILED,       /**< A @ref pdb_clear operation has failed. */
N    PDB_EVT_PEER_FREED,         /**< A @ref pdb_peer_free operation has completed successfully. All associated data has been erased. */
N    PDB_EVT_PEER_FREE_FAILED,   /**< A @ref pdb_peer_free operation has failed. */
N    PDB_EVT_COMPRESSED,         /**< A compress procedure has completed. */
N    PDB_EVT_ERROR_NO_MEM,       /**< An operation is blocked because the flash is full. It will be reattempted automatically after the next compress procedure. */
N    PDB_EVT_ERROR_UNEXPECTED,   /**< An unexpected error occurred. This is a fatal error. */
N} pdb_evt_id_t;
N
N/**@brief Events that can come from the peer_database module.
N */
Ntypedef struct
N{
N    pdb_evt_id_t      evt_id;  /**< The event that has happened. */
N    pm_peer_id_t      peer_id; /**< The id of the peer the event pertains to. */
N    pm_peer_data_id_t data_id; /**< The data the event pertains to. */
N    union
N    {
N        struct
N        {
N            bool update;                   /**< If true, an existing value was overwritten. */
X            _Bool update;                    
N        } write_buf_stored_evt;            /**< Additional information pertaining to the @ref PDB_EVT_WRITE_BUF_STORED event. */
N        struct
N        {
N            pm_store_token_t store_token;  /**< A token identifying the store operation this event pertains to. */
N        } raw_stored_evt;                  /**< Additional information pertaining to the @ref PDB_EVT_RAW_STORED event. */
N        struct
N        {
N            pm_store_token_t store_token;  /**< A token identifying the store operation this event pertains to. */
N            ret_code_t       err_code;     /**< Error code specifying what went wrong. */
N        } error_raw_store_evt;             /**< Additional information pertaining to the @ref PDB_EVT_RAW_STORE_FAILED event. */
N        struct
N        {
N            ret_code_t err_code;           /**< The error that occurred. */
N        } clear_failed_evt;                /**< Additional information pertaining to the @ref PDB_EVT_CLEAR_FAILED event. */
N        struct
N        {
N            ret_code_t err_code;           /**< The error that occurred. */
N        } peer_free_failed_evt;            /**< Additional information pertaining to the @ref PDB_EVT_PEER_FREE_FAILED event. */
N        struct
N        {
N            ret_code_t err_code;           /**< The unexpected error that occurred. */
N        } error_unexpected;                /**< Additional information pertaining to the @ref PDB_EVT_ERROR_UNEXPECTED event. */
N    } params;
N} pdb_evt_t;
N
N/**@brief Event handler for events from the peer_data_storage module.
N *
N * @param[in]  p_event   The event that has happened.
N */
Ntypedef void (*pdb_evt_handler_t)(pdb_evt_t const * p_event);
N
N
N/**@brief Function for initializing the module.
N *
N * @retval NRF_SUCCESS          If initialization was successful.
N * @retval NRF_ERROR_INTERNAL   An unexpected error happened.
N */
Nret_code_t pdb_init(void);
N
N
N/**@brief Function for allocating persistent bond storage for a peer.
N *
N * @return  The ID of the newly allocated storage.
N * @retval  PM_PEER_ID_INVALID  If no peer ID is available.
N */
Npm_peer_id_t pdb_peer_allocate(void);
N
N
N/**@brief Function for freeing a peer's persistent bond storage.
N *
N * @note This function will call @ref pdb_write_buf_release on the data for this peer.
N *
N * @param[in] peer_id  ID to be freed.
N *
N * @retval NRF_SUCCESS              Peer ID was released and clear operation was initiated successfully.
N * @retval NRF_ERROR_INVALID_PARAM  Peer ID was invalid.
N * @retval NRF_ERROR_INVALID_STATE  Module is not initialized.
N */
Nret_code_t pdb_peer_free(pm_peer_id_t peer_id);
N
N
N/**@brief Function for retrieving a pointer to peer data in flash (read-only).
N *
N * @note  Dereferencing this pointer is not the safest thing to do if interrupts are enabled,
N *        because Flash Data Storage garbage collection might move the data around. Either disable
N *        interrupts while using the data, or use @ref pdb_peer_data_load.
N *
N * @param[in]  peer_id      The peer the data belongs to.
N * @param[in]  data_id      The data to read.
N * @param[out] p_peer_data  The peer data, read-only.
N *
N * @retval NRF_SUCCESS              If the pointer to the data was retrieved successfully.
N * @retval NRF_ERROR_INVALID_PARAM  If either @p peer_id or @p data_id are invalid.
N * @retval NRF_ERROR_NOT_FOUND      If data was not found in flash.
N */
Nret_code_t pdb_peer_data_ptr_get(pm_peer_id_t                 peer_id,
N                                 pm_peer_data_id_t            data_id,
N                                 pm_peer_data_flash_t * const p_peer_data);
N
N
N/**@brief Function for retrieving pointers to a write buffer for peer data.
N *
N * @details This function will provide pointers to a buffer of the data. The data buffer will not be
N *          written to persistent storage until @ref pdb_write_buf_store is called. The buffer is
N *          released by calling either @ref pdb_write_buf_release, @ref pdb_write_buf_store, or
N *          @ref pdb_peer_free.
N *
N *          When the data_id refers to a variable length data type, the available size is written
N *          to the data, both the top-level, and any internal length fields.
N *
N * @note Calling this function on a peer_id/data_id pair that already has a buffer created will
N *       give the same buffer, not create a new one. If n_bufs was increased since last time, the
N *       buffer might be relocated to be able to provide additional room. In this case, the data
N *       will be copied. If n_bufs was increased since last time, this function might return @ref
N *       NRF_ERROR_BUSY. In that case, the buffer is automatically released.
N *
N * @param[in]  peer_id      ID of peer to get a write buffer for.
N * @param[in]  data_id      Which piece of data to get.
N * @param[in]  n_bufs       The number of contiguous buffers needed.
N * @param[out] p_peer_data  Pointers to mutable peer data.
N *
N * @retval NRF_SUCCESS              Data retrieved successfully.
N * @retval NRF_ERROR_INVALID_PARAM  Data ID or Peer ID was invalid or unallocated, or n_bufs was 0
N *                                  or more than the total available buffers.
N * @retval NRF_ERROR_NULL           p_peer_data was NULL.
N * @retval NRF_ERROR_BUSY           Not enough buffer(s) available.
N * @retval NRF_ERROR_INTERNAL       Unexpected internal error.
N * @retval NRF_ERROR_INVALID_STATE  Module is not initialized.
N */
Nret_code_t pdb_write_buf_get(pm_peer_id_t      peer_id,
N                             pm_peer_data_id_t data_id,
N                             uint32_t          n_bufs,
N                             pm_peer_data_t  * p_peer_data);
N
N
N/**@brief Function for freeing a write buffer allocated with @ref pdb_write_buf_get.
N *
N * @note This function will not write peer data to persistent memory. Data in released buffer will
N *       be lost.
N *
N * @note This function will undo any previous call to @ref pdb_write_buf_store_prepare for this
N *       piece of data.
N *
N * @param[in]  peer_id  ID of peer to release buffer for.
N * @param[in]  data_id  Which piece of data to release buffer for.
N *
N * @retval NRF_SUCCESS              Successfully released buffer.
N * @retval NRF_ERROR_NOT_FOUND      No buffer was allocated for this peer ID/data ID pair.
N * @retval NRF_ERROR_INVALID_STATE  Module is not initialized.
N * @retval NRF_ERROR_INTERNAL       Unexpected internal error.
N */
Nret_code_t pdb_write_buf_release(pm_peer_id_t peer_id, pm_peer_data_id_t data_id);
N
N
N/**@brief Function for reserving space in persistent storage for data in a buffer.
N *
N * @note This function only works for data which has a write buffer allocated. If the write buffer
N *       is released, this prepare is undone.
N *
N * @note If space has already been reserved for this data, nothing is done.
N *
N * @param[in]  peer_id  The peer whose data to reserve space for.
N * @param[in]  data_id  The type of data to reserve space for.
N *
N * @retval NRF_SUCCESS              Successfully reserved space in persistent storage.
N * @retval NRF_ERROR_NO_MEM         Not enough room in persistent storage.
N * @retval NRF_ERROR_BUSY           Could not process request at this time. Reattempt later.
N * @retval NRF_ERROR_NOT_FOUND      No buffer has been allocated for this peer ID/data ID pair.
N * @retval NRF_ERROR_INVALID_PARAM  Data ID or Peer ID was invalid or unallocated.
N * @retval NRF_ERROR_INVALID_STATE  Module is not initialized.
N */
Nret_code_t pdb_write_buf_store_prepare(pm_peer_id_t peer_id, pm_peer_data_id_t data_id);
N
N
N/**@brief Function for writing data into persistent storage. Writing happens asynchronously.
N *
N * @note This will unlock the data after it has been written.
N *
N * @param[in]  peer_id      ID of peer to store data for.
N * @param[in]  data_id      Which piece of data to store.
N *
N * @retval NRF_SUCCESS              Data storing was successfully started.
N * @retval NRF_ERROR_NO_MEM         No space available in persistent storage. Please clear some
N *                                  space, the operation will be reattempted after the next compress
N *                                  procedure. This error will not happen if
N *                                  @ref pdb_write_buf_store_prepare is called beforehand.
N * @retval NRF_ERROR_INVALID_PARAM  Data ID was invalid.
N * @retval NRF_ERROR_NOT_FOUND      No buffer has been allocated for this peer ID/data ID pair.
N * @retval NRF_ERROR_INVALID_STATE  Module is not initialized.
N * @retval NRF_ERROR_INTERNAL       Unexpected internal error.
N */
Nret_code_t pdb_write_buf_store(pm_peer_id_t      peer_id,
N                               pm_peer_data_id_t data_id);
N
N
N/**@brief Function for clearing data from persistent storage.
N *
N * @param[in]  peer_id  ID of peer to clear data for.
N * @param[in]  data_id  Which piece of data to clear.
N *
N * @retval NRF_SUCCESS              The clear was initiated successfully.
N * @retval NRF_ERROR_INVALID_PARAM  Data ID or peer ID was invalid.
N * @retval NRF_ERROR_NOT_FOUND      Nothing to clear for this peer ID/data ID combination.
N * @retval NRF_ERROR_BUSY           Underlying modules are busy and can't take any more requests at
N *                                  this moment.
N * @retval NRF_ERROR_INVALID_STATE  Module is not initialized.
N * @retval NRF_ERROR_INTERNAL       Internal error.
N */
Nret_code_t pdb_clear(pm_peer_id_t peer_id, pm_peer_data_id_t data_id);
N
N
N/**@brief Function for querying the number of valid peer IDs available. I.E the number of peers
N *        in persistent storage.
N *
N * @return  The number of valid peer IDs.
N */
Nuint32_t pdb_n_peers(void);
N
N
N/**@brief Function for getting the next peer ID in the sequence of all used peer IDs. Can be
N *        used to loop through all used peer IDs.
N *
N * @note @ref PM_PEER_ID_INVALID is considered to be before the first and after the last ordinary
N *       peer ID.
N *
N * @param[in]  prev_peer_id  The previous peer ID.
N *
N * @return  The next peer ID.
N * @return  The first ordinary peer ID  if prev_peer_id was @ref PM_PEER_ID_INVALID.
N * @retval  PM_PEER_ID_INVALID          if prev_peer_id was the last ordinary peer ID.
N */
Npm_peer_id_t pdb_next_peer_id_get(pm_peer_id_t prev_peer_id);
N
N
N/**@brief Function for getting the next peer ID in the sequence of all peer IDs pending deletion.
N *        Can be used to loop through all used peer IDs.
N *
N * @note @ref PM_PEER_ID_INVALID is considered to be before the first and after the last ordinary
N *       peer ID.
N *
N * @param[in]  prev_peer_id  The previous peer ID.
N *
N * @return  The next peer ID pending deletion.
N * @return  The first ordinary peer ID  if prev_peer_id was @ref PM_PEER_ID_INVALID.
N * @retval  PM_PEER_ID_INVALID          if prev_peer_id was the last ordinary peer ID.
N */
Npm_peer_id_t pdb_next_deleted_peer_id_get(pm_peer_id_t prev_peer_id);
N
N
N/**@brief Function for updating currently stored peer data to a new version
N *
N * @details Updating happens asynchronously.
N *          Expect a @ref PDS_EVT_STORED or @ref PDS_EVT_ERROR_STORE for the store token
N *          and a @ref PDS_EVT_ERROR_CLEAR or @ref PDS_EVT_ERROR_CLEAR for the old token
N *
N * @param[in]   peer_data           New data
N * @param[in]   old_token           Store token for the old data
N * @param[out]  p_store_token       Store token for the new data
N *
N * @retval NRF_SUCESS               The update was initiated successfully
N * @retval NRF_ERROR_NOT_FOUND      The old store token was invalid.
N * @retval NRF_ERROR_NULL           Data contained a NULL pointer.
N * @retval NRF_ERROR_NO_MEM         No space available in persistent storage.
N * @retval NRF_ERROR_BUSY           FDS or underlying modules are busy and can't take any
N *                                  more requests
N * @retval NRF_ERROR_INVALID_STATE  Module is not initialized.
N */
Nret_code_t pdb_peer_data_update(pm_peer_data_const_t        peer_data,
N                                pm_store_token_t            old_token,
N                                pm_store_token_t          * p_store_token);
N
N
N/**@brief Function for copy peer data from flash into a provided buffer.
N *
N * @param[in]    peer_id      The peer the data belongs to.
N * @param[in]    data_id      The data to read.
N * @param[inout] p_peer_data  The buffer where to copy data into. The field @c length_words in this
N *                            parameter must represent the buffer length in words.
N *
N * @note Actually, it represents the buffer length in bytes upon entering the function,
N * and upon exit it represents the length of the data in words.. not good. Fix this.
N *
N * @retval NRF_SUCCESS              If the operation was successful.
N * @retval NRF_ERROR_INVALID_PARAM  If @p peer_id or @p data_id are invalid.
N * @retval NRF_ERROR_NOT_FOUND      If the data was not found in flash.
N * @retval NRF_ERROR_NO_MEM         If the provided buffer is too small.
N */
Nret_code_t pdb_peer_data_load(pm_peer_id_t              peer_id,
N                              pm_peer_data_id_t         data_id,
N                              pm_peer_data_t    * const p_peer_data);
N
N
N/**@brief Function for writing data directly to persistent storage from external memory.
N *
N * @param[in]  peer_id        ID of peer to write data for.
N * @param[in]  p_peer_data    Data to store.
N * @param[out] p_store_token  A token identifying this particular store operation. The token can be
N *                            used to identify events pertaining to this operation.
N *
N * @retval NRF_SUCCESS               Data successfully written.
N * @retval NRF_ERROR_INVALID_PARAM   Data ID or Peer ID was invalid or unallocated.
N * @retval NRF_ERROR_NULL            p_peer_data contained a NULL pointer.
N * @retval NRF_ERROR_NO_MEM          No space available in persistent storage.
N * @retval NRF_ERROR_INVALID_LENGTH  Data length above the maximum allowed.
N * @retval NRF_ERROR_BUSY            Unable to perform operation at this time.
N */
Nret_code_t pdb_raw_store(pm_peer_id_t           peer_id,
N                         pm_peer_data_const_t * p_peer_data,
N                         pm_store_token_t     * p_store_token);
N
N/** @}
N * @endcond
N */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PEER_DATABASE_H__ */
N
N
L 39 "..\..\..\..\..\..\components\ble\peer_manager\peer_manager.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N
N/**@brief Security status of a connection.
N */
Ntypedef struct
N{
N    uint8_t connected      : 1; /**< @brief The connection is active (not disconnected). */
N    uint8_t encrypted      : 1; /**< @brief Communication on this link is encrypted. */
N    uint8_t mitm_protected : 1; /**< @brief The encrypted communication is also protected against man-in-the-middle attacks. */
N    uint8_t bonded         : 1; /**< @brief The peer is bonded with us. */
N} pm_conn_sec_status_t;
N
N
N/**@brief Types of events that can come from the @ref peer_manager module.
N */
Ntypedef enum
N{
N    PM_EVT_BONDED_PEER_CONNECTED,           /**< @brief A connected peer has been identified as one with which we have a bond. When performing bonding with a peer for the first time, this event will not be sent until a new connection is established with the peer. When we are central, this event is always sent when the Peer Manager receives the @ref BLE_GAP_EVT_CONNECTED event. When we are peripheral, this event might in rare cases arrive later. */
N    PM_EVT_CONN_SEC_START,                  /**< @brief A security procedure has started on a link, initiated either locally or remotely. The security procedure is using the last parameters provided via @ref pm_sec_params_set. This event is always followed by either a @ref PM_EVT_CONN_SEC_SUCCEEDED or a @ref PM_EVT_CONN_SEC_FAILED event. This is an informational event; no action is needed for the procedure to proceed. */
N    PM_EVT_CONN_SEC_SUCCEEDED,              /**< @brief A link has been encrypted, either as a result of a call to @ref pm_conn_secure or a result of an action by the peer. The event structure contains more information about the circumstances. This event might contain a peer ID with the value @ref PM_PEER_ID_INVALID, which means that the peer (central) used an address that could not be identified, but it used an encryption key (LTK) that is present in the database. */
N    PM_EVT_CONN_SEC_FAILED,                 /**< @brief A pairing or encryption procedure has failed. In some cases, this means that security is not possible on this link (temporarily or permanently). How to handle this error depends on the application. */
N    PM_EVT_CONN_SEC_CONFIG_REQ,             /**< @brief The peer (central) has requested pairing, but a bond already exists with that peer. Reply by calling @ref pm_conn_sec_config_reply before the event handler returns. If no reply is sent, a default is used. */
N    PM_EVT_STORAGE_FULL,                    /**< @brief There is no more room for peer data in flash storage. To solve this problem, delete data that is not needed anymore and run a garbage collection procedure in FDS. */
N    PM_EVT_ERROR_UNEXPECTED,                /**< @brief An unrecoverable error happened inside Peer Manager. An operation failed with the provided error. */
N    PM_EVT_PEER_DATA_UPDATE_SUCCEEDED,      /**< @brief A piece of peer data was stored, updated, or cleared in flash storage. This event is sent for all successful changes to peer data, also those initiated internally in Peer Manager. To identify an operation, compare the store token in the event with the store token received during the initiating function call. Events from internally initiated changes might have invalid store tokens. */
N    PM_EVT_PEER_DATA_UPDATE_FAILED,         /**< @brief A piece of peer data could not be stored, updated, or cleared in flash storage. This event is sent instead of @ref PM_EVT_PEER_DATA_UPDATE_SUCCEEDED for the failed operation. */
N    PM_EVT_PEER_DELETE_SUCCEEDED,           /**< @brief A peer was cleared from flash storage, for example because a call to @ref pm_peer_delete succeeded. This event can also be sent as part of a call to @ref pm_peers_delete or internal cleanup. */
N    PM_EVT_PEER_DELETE_FAILED,              /**< @brief A peer could not be cleared from flash storage. This event is sent instead of @ref PM_EVT_PEER_DELETE_SUCCEEDED for the failed operation. */
N    PM_EVT_PEERS_DELETE_SUCCEEDED,          /**< @brief A call to @ref pm_peers_delete has completed successfully. Flash storage now contains no peer data. */
N    PM_EVT_PEERS_DELETE_FAILED,             /**< @brief A call to @ref pm_peers_delete has failed, which means that at least one of the peers could not be deleted. Other peers might have been deleted, or might still be queued to be deleted. No more @ref PM_EVT_PEERS_DELETE_SUCCEEDED or @ref PM_EVT_PEERS_DELETE_FAILED events are sent until the next time @ref pm_peers_delete is called. */
N    PM_EVT_LOCAL_DB_CACHE_APPLIED,          /**< @brief Local database values for a peer (taken from flash storage) have been provided to the SoftDevice. */
N    PM_EVT_LOCAL_DB_CACHE_APPLY_FAILED,     /**< @brief Local database values for a peer (taken from flash storage) were rejected by the SoftDevice, which means that either the database has changed or the user has manually set the local database to an invalid value (using @ref pm_peer_data_store). */
N    PM_EVT_SERVICE_CHANGED_IND_SENT,        /**< @brief A service changed indication has been sent to a peer, as a result of a call to @ref pm_local_database_has_changed. This event will be followed by a @ref PM_EVT_SERVICE_CHANGED_IND_CONFIRMED event if the peer acknowledges the indication. */
N    PM_EVT_SERVICE_CHANGED_IND_CONFIRMED,   /**< @brief A service changed indication that was sent has been confirmed by a peer. The peer can now be considered aware that the local database has changed. */
N} pm_evt_id_t;
N
N
N/**@brief Parameters specific to the @ref PM_EVT_CONN_SEC_SUCCEEDED event.
N */
Ntypedef struct
N{
N    pm_conn_sec_procedure_t procedure; /**< @brief The procedure that led to securing the link. */
N} pm_conn_secured_evt_t;
N
N
N/**@brief Parameters specific to the @ref PM_EVT_CONN_SEC_FAILED event.
N */
Ntypedef struct
N{
N    pm_conn_sec_procedure_t  procedure; /**< @brief The procedure that failed. */
N    pm_sec_error_code_t error;          /**< @brief An error code that describes the failure. */
N    uint8_t             error_src;      /**< @brief The party that raised the error, see @ref BLE_GAP_SEC_STATUS_SOURCES. */
N} pm_conn_secure_failed_evt_t;
N
N
N/**@brief Actions that can be performed to peer data in persistent storage.
N */
Ntypedef enum
N{
N    PM_PEER_DATA_OP_UPDATE, /**< @brief Writing or overwriting the data. */
N    PM_PEER_DATA_OP_DELETE, /**< @brief Removing the data. */
N} pm_peer_data_op_t;
N
N
N/**@brief Parameters specific to the @ref PM_EVT_PEER_DATA_UPDATE_SUCCEEDED event.
N */
Ntypedef struct
N{
N    pm_peer_data_id_t data_id;           /**< @brief The type of the data that was changed. */
N    pm_peer_data_op_t action;            /**< @brief What happened to the data. */
N    uint8_t           flash_changed : 1; /**< @brief If this is false, no operation was done in flash, because the value was already what it should be. Please note that in certain scenarios, this flag will be true even if the new value is the same as the old. */
N    pm_store_token_t  token;             /**< @brief Token that identifies the operation. For @ref PM_PEER_DATA_OP_DELETE actions, this token can be disregarded. For @ref PM_PEER_DATA_OP_UPDATE actions, compare this token with the token that is received from a call to a @ref PM_PEER_DATA_FUNCTIONS function. */
N} pm_peer_data_update_succeeded_evt_t;
N
N
N/**@brief Parameters specific to the @ref PM_EVT_PEER_DATA_UPDATE_FAILED event.
N */
Ntypedef struct
N{
N    pm_peer_data_id_t data_id; /**< @brief The type of the data that was supposed to be changed. */
N    pm_peer_data_op_t action;  /**< @brief The action that failed. */
N    pm_store_token_t  token;   /**< @brief Token that identifies the operation. For @ref PM_PEER_DATA_OP_DELETE actions, this token can be disregarded. For @ref PM_PEER_DATA_OP_UPDATE actions, compare this token with the token that is received from a call to a @ref PM_PEER_DATA_FUNCTIONS function. */
N    ret_code_t        error;   /**< @brief An error code that describes the failure. */
N} pm_peer_data_update_failed_t;
N
N
N/**@brief Standard parameters for failure events.
N */
Ntypedef struct
N{
N    ret_code_t error; /**< @brief The error that occurred. */
N} pm_failure_evt_t;
N
N
N/**@brief An event from the @ref peer_manager module.
N *
N * @details The structure contains both standard parameters and parameters that are specific to some events.
N */
Ntypedef struct
N{
N    pm_evt_id_t  evt_id;      /**< @brief The type of the event. */
N    uint16_t     conn_handle; /**< @brief The connection that this event pertains to, or @ref BLE_CONN_HANDLE_INVALID. */
N    pm_peer_id_t peer_id;     /**< @brief The bonded peer that this event pertains to, or @ref PM_PEER_ID_INVALID. */
N    union
N    {
N        pm_conn_secured_evt_t               conn_sec_succeeded;         /**< @brief Parameters specific to the @ref PM_EVT_CONN_SEC_SUCCEEDED event. */
N        pm_conn_secure_failed_evt_t         conn_sec_failed;            /**< @brief Parameters specific to the @ref PM_EVT_CONN_SEC_FAILED event. */
N        pm_peer_data_update_succeeded_evt_t peer_data_update_succeeded; /**< @brief Parameters specific to the @ref PM_EVT_PEER_DATA_UPDATE_SUCCEEDED event. */
N        pm_peer_data_update_failed_t        peer_data_update_failed;    /**< @brief Parameters specific to the @ref PM_EVT_PEER_DATA_UPDATE_FAILED event. */
N        pm_failure_evt_t                    peer_delete_failed;         /**< @brief Parameters specific to the @ref PM_EVT_PEER_DELETE_FAILED event. */
N        pm_failure_evt_t                    peers_delete_failed_evt;    /**< @brief Parameters specific to the @ref PM_EVT_PEERS_DELETE_FAILED event. */
N        pm_failure_evt_t                    error_unexpected;           /**< @brief Parameters specific to the @ref PM_EVT_PEER_DELETE_FAILED event. */
N    } params;
N} pm_evt_t;
N
N
N/**@brief Event handler for events from the @ref peer_manager module.
N *
N * @sa pm_register
N *
N * @param[in]  p_event  The event that has occurred.
N */
Ntypedef void (*pm_evt_handler_t)(pm_evt_t const * p_event);
N
N
N/**@brief Function for initializing the Peer Manager.
N *
N * @details You must initialize the Peer Manager before you can call any other Peer Manager
N *          functions.
N *
N * @retval NRF_SUCCESS              If initialization was successful.
N * @retval NRF_ERROR_INTERNAL       If an internal error occurred.
N */
Nret_code_t pm_init(void);
N
N
N/**@brief Function for registering an event handler with the Peer Manager.
N *
N * @param[in] event_handler  Callback for events from the @ref peer_manager module. @p event_handler
N *                           is called for every event that the Peer Manager sends after this
N *                           function is called.
N *
N * @retval NRF_SUCCESS              If initialization was successful.
N * @retval NRF_ERROR_NULL           If @p event_handler was NULL.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N */
Nret_code_t pm_register(pm_evt_handler_t event_handler);
N
N
N/**@brief Function for providing pairing and bonding parameters to use for pairing procedures.
N *
N * @details Until this function is called, all bonding procedures that are initiated by the
N *          peer are rejected.
N *
N *          This function can be called multiple times with different parameters, even with NULL as
N *          @p p_sec_params, in which case the Peer Manager starts rejecting all procedures again.
N *
N * @param[in]  p_sec_params  Security parameters to be used for subsequent security procedures.
N *
N * @retval NRF_SUCCESS              If the parameters were set successfully.
N * @retval NRF_ERROR_INVALID_PARAM  If the combination of parameters is invalid.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N * @retval NRF_ERROR_INTERNAL       If an internal error occurred.
N */
Nret_code_t pm_sec_params_set(ble_gap_sec_params_t * p_sec_params);
N
N
N/**@brief Function for passing BLE events to the Peer Manager.
N *
N * @details For the module to work as expected, this function must be called with each BLE event
N *          from the SoftDevice. It must be called after @ref ble_conn_state_on_ble_evt, but before
N *          the application processes the event.
N *
N *          Calling this function before @ref pm_init is safe, but without effect.
N *
N * @param[in]  p_ble_evt  BLE stack event that is dispatched to the function.
N */
Nvoid pm_on_ble_evt(ble_evt_t * p_ble_evt);
N
N
N/**@brief Function for establishing encryption on a connection, and optionally establishing a bond.
N *
N * @details This function attempts to secure the link that is specified by @p conn_handle. It uses
N *          the parameters that were previously provided in a call to @ref pm_sec_params_set.
N *
N *          If the connection is a master connection, calling this function starts a security
N *          procedure on the link. If we have keys from a previous bonding procedure with this peer
N *          and the keys meet the security requirements in the currently active sec_params, the
N *          function attempts to establish encryption with the existing keys. If no key exists, the
N *          function attempts to pair and bond according to the currently active sec_params.
N *
N *          If the function completes successfully, a @ref PM_EVT_CONN_SEC_START event is sent.
N *          The procedure might be queued, in which case the @ref PM_EVT_CONN_SEC_START event is
N *          delayed until the procedure is initiated in the SoftDevice.
N *
N *          If the connection is a slave connection, the function sends a security request to
N *          the peer (master). It is up to the peer then to initiate pairing or encryption.
N *          If the peer ignores the request, a @ref BLE_GAP_EVT_TIMEOUT event occurs
N *          with the source @ref BLE_GAP_TIMEOUT_SRC_SECURITY_REQUEST. Otherwise, the peer initiates
N *          security, in which case things happen as if the peer had initiated security itself.
N *          See @ref PM_EVT_CONN_SEC_START for information about peer-initiated security.
N *
N * @param[in]  conn_handle      Connection handle of the link as provided by the SoftDevice.
N * @param[in]  force_repairing  Whether to force a pairing procedure even if there is an existing
N *                              encryption key. This argument is relevant only for
N *                              the central role. Recommended value: false.
N *
N * @retval NRF_SUCCESS                    If the operation completed successfully.
N * @retval NRF_ERROR_TIMEOUT              If there was an SMP time-out, so that no more SMP
N *                                        operations can be performed on this link.
N * @retval BLE_ERROR_INVALID_CONN_HANDLE  If the connection handle is invalid.
N * @retval NRF_ERROR_NOT_FOUND            If the security parameters have not been set.
N * @retval NRF_ERROR_NO_MEM               If there is no more space in flash.
N * @retval NRF_ERROR_INVALID_STATE        If the Peer Manager is not initialized, or the peer is
N *                                        disconnected or in the process of disconnecting.
N * @retval NRF_ERROR_INTERNAL             If an internal error occurred.
N */
Nret_code_t pm_conn_secure(uint16_t conn_handle, bool force_repairing);
Xret_code_t pm_conn_secure(uint16_t conn_handle, _Bool force_repairing);
N
N
N/**@brief Function for providing security configuration for a link.
N *
N * @details This function is optional, and must be called in reply to a @ref
N *          PM_EVT_CONN_SEC_CONFIG_REQ event, before the Peer Manager event handler returns. If it
N *          is not called in time, a default configuration is used. See @ref pm_conn_sec_config_t
N *          for the value of the default.
N *
N * @param[in]  conn_handle        The connection to set the configuration for.
N * @param[in]  p_conn_sec_config  The configuration.
N */
Nvoid pm_conn_sec_config_reply(uint16_t conn_handle, pm_conn_sec_config_t * p_conn_sec_config);
N
N
N/**@brief Function for manually informing that the local database has changed.
N *
N * @details This function sends a service changed indication to all bonded and/or connected peers
N *          that subscribe to this indication. If a bonded peer is not connected, the indication is
N *          sent when it reconnects. Every time an indication is sent, a @ref
N *          PM_EVT_SERVICE_CHANGED_IND_SENT event occurs, followed by a @ref
N *          PM_EVT_SERVICE_CHANGED_IND_CONFIRMED when the peer sends its confirmation. Peers that
N *          are not subscribed to the service changed indication when this function is called do not
N *          receive an indication, and no events are sent to the user. Likewise, if the service
N *          changed characteristic is not present in the local database, this no indications are
N *          sent peers, and no events are sent to the user.
N */
Nvoid pm_local_database_has_changed(void);
N
N
N/**@brief Function for getting the security status of a connection.
N *
N * @param[in]  conn_handle    Connection handle of the link as provided by the SoftDevice.
N * @param[out] p_conn_sec_status  Security status of the link.
N *
N * @retval NRF_SUCCESS                    If pairing was initiated successfully.
N * @retval BLE_ERROR_INVALID_CONN_HANDLE  If the connection handle is invalid.
N * @retval NRF_ERROR_NULL                 If @p p_conn_sec_status was NULL.
N * @retval NRF_ERROR_INVALID_STATE        If the Peer Manager is not initialized.
N */
Nret_code_t pm_conn_sec_status_get(uint16_t conn_handle, pm_conn_sec_status_t * p_conn_sec_status);
N
N
N/**@brief Experimental function for specifying the public key to use for LESC operations.
N *
N * @details This function can be called multiple times. The specified public key will be used for
N *          all subsequent LESC (LE Secure Connections) operations until the next time this function
N *          is called.
N *
N * @note The key must continue to reside in application memory as it is not copied by Peer Manager.
N *
N * @param[in]  p_public_key  The public key to use for all subsequent LESC operations.
N *
N * @retval NRF_SUCCESS                    If pairing was initiated successfully.
N * @retval NRF_ERROR_INVALID_STATE        If the Peer Manager is not initialized.
N */
Nret_code_t pm_lesc_public_key_set(ble_gap_lesc_p256_pk_t * p_public_key);
N
N
N/**@brief Function for setting or clearing the whitelist.
N *
N * When using the S13x SoftDevice v3.x, this function sets or clears the whitelist.
N * When using the S13x SoftDevice v2.x, this function caches a list of
N * peers that can be retrieved later by @ref pm_whitelist_get to pass to the @ref lib_ble_advertising.
N *
N * To clear the current whitelist, pass either NULL as @p p_peers or zero as @p peer_cnt.
N *
N * @param[in] p_peers   The peers to add to the whitelist. Pass NULL to clear the current whitelist.
N * @param[in] peer_cnt  The number of peers to add to the whitelist. The number must not be greater than
N *                      @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT. Pass zero to clear the current
N *                      whitelist.
N *
N * @retval NRF_SUCCESS                      If the whitelist was successfully set or cleared.
N * @retval BLE_GAP_ERROR_WHITELIST_IN_USE   If a whitelist is already in use and cannot be set.
N * @retval BLE_ERROR_GAP_INVALID_BLE_ADDR   If a peer in @p p_peers has an address that cannot
N *                                          be used for whitelisting.
N * @retval NRF_ERROR_NOT_FOUND              If any of the peers in @p p_peers cannot be found.
N * @retval NRF_ERROR_DATA_SIZE              If @p peer_cnt is greater than
N *                                          @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT.
N * @retval NRF_ERROR_INVALID_STATE          If the Peer Manager is not initialized.
N */
Nret_code_t pm_whitelist_set(pm_peer_id_t const * p_peers,
N                            uint32_t             peer_cnt);
N
N
N/**@brief Function for retrieving the previously set whitelist.
N *
N * The function retrieves the whitelist of GAP addresses and IRKs that was
N * previously set by @ref pm_whitelist_set.
N *
N * To retrieve only GAP addresses or only IRKs, provide only one of the
N * buffers. If a buffer is provided, its size must be specified.
N *
N * @param[out]   p_addrs    The buffer where to store GAP addresses. Pass NULL to retrieve
N *                          only IRKs (in that case, @p p_irks must not be NULL).
N * @param[in,out] p_addr_cnt In: The size of the @p p_addrs buffer.
N *                          May be NULL if and only if @p p_addrs is NULL.
N *                          Out: The number of GAP addresses copied into the buffer.
N *                          If @p p_addrs is NULL, this parameter remains unchanged.
N * @param[out]   p_irks     The buffer where to store IRKs. Pass NULL to retrieve
N *                          only GAP addresses (in that case, @p p_addrs must not NULL).
N * @param[in,out] p_irk_cnt  In: The size of the @p p_irks buffer.
N *                          May be NULL if and only if @p p_irks is NULL.
N *                          Out: The number of IRKs copied into the buffer.
N *                          If @p p_irks is NULL, this paramater remains unchanged.
N *
N * @retval NRF_SUCCESS                      If the whitelist was successfully retrieved.
N * @retval BLE_ERROR_GAP_INVALID_BLE_ADDR   If a peer has an address that cannot be used for
N *                                          whitelisting (this error can occur only
N *                                          when using the S13x SoftDevice v2.x).
N * @retval NRF_ERROR_NULL                   If a required parameter is NULL.
N * @retval NRF_ERROR_NO_MEM                 If the provided buffers are too small.
N * @retval NRF_ERROR_NOT_FOUND              If the data for any of the cached whitelisted peers
N *                                          cannot be found. It might have been deleted.
N * @retval NRF_ERROR_INVALID_STATE          If the Peer Manager is not initialized.
N */
Nret_code_t pm_whitelist_get(ble_gap_addr_t * p_addrs,
N                            uint32_t       * p_addr_cnt,
N                            ble_gap_irk_t  * p_irks,
N                            uint32_t       * p_irk_cnt);
N
N
N/**@brief Function for setting and clearing the device identities list.
N *
N * @param[in]   p_peers     The peers to add to the device identities list. Pass NULL to clear
N *                          the device identities list.
N * @param[in]   peer_cnt    The number of peers. Pass zero to clear the device identities list.
N *
N * @retval NRF_SUCCESS                              If the device identities list was successfully
N *                                                  set or cleared.
N * @retval NRF_ERROR_NOT_FOUND                      If a peer is invalid or its data could not
N *                                                  be found in flash.
N * @retval BLE_ERROR_GAP_INVALID_BLE_ADDR           If a peer has an address that cannot be
N *                                                  used for whitelisting.
N * @retval BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE   If the device identities list is in use and
N *                                                  cannot be set.
N * @retval NRF_ERROR_INVALID_STATE                  If the Peer Manager is not initialized.
N * @retval NRF_ERROR_NOT_SUPPORTED                  If using a SoftDevice that does not support
N *                                                  device identities, e.g. S130 v2.0.
N */
Nret_code_t pm_device_identities_list_set(pm_peer_id_t const * p_peers,
N                                         uint32_t             peer_cnt);
N
N
N/**@brief Function for setting the local <em>Bluetooth</em> identity address.
N *
N * @details The local <em>Bluetooth</em> identity address is the address that identifies the device to other
N * peers. The address type must be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref
N * BLE_GAP_ADDR_TYPE_RANDOM_STATIC. The identity address cannot be changed while roles are
N * running.
N *
N * The SoftDevice sets a default address of type @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC
N * when it is enabled. This default address is a random number that is populated during
N * the IC manufacturing process. It remains unchanged for the lifetime of each IC, but the application can assign a different identity address.
N *
N * The identity address is distributed to the peer during bonding.
N * If the address changes, the address stored in the peer device will not be valid and the
N * ability to reconnect using the old address will be lost.
N *
N *
N * @note The SoftDevice functions @ref sd_ble_gap_address_set (S13x v2.x), @ref sd_ble_gap_addr_set
N *       (S13x v3.x), and @ref sd_ble_gap_privacy_set (S13x v3.x) must not be called when using the Peer Manager.
N *       Use this function instead.
N *
N * @param[in] p_addr The GAP address to be set.
N *
N * @retval NRF_SUCCESS                     If the identity address was set successfully.
N * @retval NRF_ERROR_NULL                  If @p p_addr is NULL.
N * @retval NRF_ERROR_INVALID_ADDR          If the @p p_addr pointer is invalid.
N * @retval BLE_ERROR_GAP_INVALID_BLE_ADDR  If the BLE address is invalid.
N * @retval NRF_ERROR_BUSY                  If the SoftDevice was busy. Process SoftDevice events
N *                                         and retry.
N * @retval NRF_ERROR_INVALID_STATE         If the Peer Manager is not initialized or if this function
N *                                         was called while advertising, scanning, or while connected.
N * @retval NRF_ERROR_INTERNAL              If an internal error occurred.
N */
Nret_code_t pm_id_addr_set(ble_gap_addr_t const * p_addr);
N
N
N/**@brief Function for retrieving the local <em>Bluetooth</em> identity address.
N *
N * This function always returns the identity address, irrespective of the privacy settings.
N * This means that the address type will always be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref
N * BLE_GAP_ADDR_TYPE_RANDOM_STATIC.
N *
N * @param[out] p_addr Pointer to the address structure to be filled in.
N *
N * @retval NRF_SUCCESS             If the address was retrieved successfully.
N * @retval NRF_ERROR_NULL          If @p p_addr is NULL.
N * @retval NRF_ERROR_INVALID_STATE If the Peer Manager is not initialized.
N */
Nret_code_t pm_id_addr_get(ble_gap_addr_t * p_addr);
N
N
N/**@brief Function for configuring privacy settings.
N *
N * The privacy settings cannot be configured while advertising, scanning, or while in a connection.
N *
N * @note The SoftDevice functions @ref sd_ble_gap_address_set (S13x v2.x), @ref sd_ble_gap_addr_set
N *       (S13x v3.x), and @ref sd_ble_gap_privacy_set (S13x v3.x) must not be called when using the Peer Manager.
N *       Use this function instead.
N *
N * @param[in] p_privacy_params Privacy settings.
N *
N * @retval NRF_SUCCESS                     If the privacy settings were configured successfully.
N * @retval NRF_ERROR_NULL                  If @p p_privacy_params is NULL.
N * @retval NRF_ERROR_BUSY                  If the operation could not be performed at this time.
N *                                         Process SoftDevice events and retry.
N * @retval NRF_ERROR_INVALID_PARAM         If the address type is invalid.
N * @retval NRF_ERROR_INVALID_STATE         If this function is called while BLE roles using
N *                                         privacy are enabled.
N * @retval NRF_ERROR_INVALID_STATE         If the Peer Manager is not initialized.
N */
Nret_code_t pm_privacy_set(pm_privacy_params_t const * p_privacy_params);
N
N
N/**@brief Function for retrieving privacy settings.
N *
N * The privacy settings that are returned include the current IRK as well.
N *
N * @param[out] p_privacy_params Privacy settings.
N *
N * @retval NRF_SUCCESS              If the privacy settings were retrieved successfully.
N * @retval NRF_ERROR_NULL           If @p p_privacy_params or @p p_privacy_params->p_device_irk is
N *                                  NULL.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N */
Nret_code_t pm_privacy_get(pm_privacy_params_t * p_privacy_params);
N
N
N/**@brief Function for getting the connection handle of the connection with a bonded peer.
N *
N * @param[in]  peer_id        The peer ID of the bonded peer.
N * @param[out] p_conn_handle  Connection handle, or @ref BLE_ERROR_INVALID_CONN_HANDLE if the peer
N *                            is not connected.
N *
N * @retval NRF_SUCCESS              If the connection handle was retrieved successfully.
N * @retval NRF_ERROR_NULL           If @p p_conn_handle was NULL.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N */
Nret_code_t pm_conn_handle_get(pm_peer_id_t peer_id, uint16_t * p_conn_handle);
N
N
N/**@brief Function for retrieving the ID of a peer, given its connection handle.
N *
N * @param[in]  conn_handle  The connection handle of the peer.
N * @param[out] p_peer_id    The peer ID, or @ref PM_PEER_ID_INVALID if the peer is not bonded or
N *                          @p conn_handle does not refer to a valid connection.
N *
N * @retval NRF_SUCCESS              If the peer ID was retrieved successfully.
N * @retval NRF_ERROR_NULL           If @p p_peer_id was NULL.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N */
Nret_code_t pm_peer_id_get(uint16_t conn_handle, pm_peer_id_t * p_peer_id);
N
N
N/**@brief Function for getting the next peer ID in the sequence of all used peer IDs.
N *
N * @details This function can be used to loop through all used peer IDs. The order in which
N *          peer IDs are returned should be considered unpredictable. @ref PM_PEER_ID_INVALID
N *          is considered to be before the first and after the last used peer ID.
N *
N * @details To loop through all peer IDs exactly once, use the following constuct:
N *          @code{c}
N *              pm_peer_id_t current_peer_id = pm_next_peer_id_get(PM_PEER_ID_INVALID);
N *              while (current_peer_id != PM_PEER_ID_INVALID)
N *              {
N *                  // Do something with current_peer_id.
N *                  current_peer_id = pm_next_peer_id_get(current_peer_id)
N *              }
N *          @endcode
N *
N * @param[in]  prev_peer_id  The previous peer ID.
N *
N * @return  The next peer ID. If @p prev_peer_id was @ref PM_PEER_ID_INVALID, the
N *          next peer ID is the first used peer ID. If @p prev_peer_id was the last
N *          used peer ID, the function returns @ref PM_PEER_ID_INVALID.
N */
Npm_peer_id_t pm_next_peer_id_get(pm_peer_id_t prev_peer_id);
N
N
N/**@brief Function for querying the number of valid peer IDs that are available.
N *
N * @details This function returns the number of peers for which there is data in persistent storage.
N *
N * @return  The number of valid peer IDs.
N */
Nuint32_t pm_peer_count(void);
N
N
N
N
N/**@anchor PM_PEER_DATA_FUNCTIONS
N * @name Functions (Peer Data)
N * Functions for manipulating peer data.
N * @{
N */
N
N/**
N * @{
N */
N
N/**@brief Function for retrieving stored data of a peer.
N *
N * @note The length of the provided buffer must be a multiple of 4.
N *
N * @param[in]    peer_id   Peer ID to get data for.
N * @param[in]    data_id   Which type of data to read.
N * @param[out]   p_data    Where to put the retrieved data.
N * @param[inout] p_len     In: The length in bytes of @p p_data.
N *                         Out: The length in bytes of the read data, if the read was successful.
N *
N * @retval NRF_SUCCESS              If the data was read successfully.
N * @retval NRF_ERROR_INVALID_PARAM  If the the data type or the peer ID was invalid or unallocated,
N *                                  or if the length in @p p_length was not a multiple of 4.
N * @retval NRF_ERROR_NULL           If a pointer parameter was NULL.
N * @retval NRF_ERROR_NOT_FOUND      If no stored data was found for this peer ID/data ID combination.
N * @retval NRF_ERROR_DATA_SIZE      If the provided buffer was not large enough.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N */
Nret_code_t pm_peer_data_load(pm_peer_id_t      peer_id,
N                             pm_peer_data_id_t data_id,
N                             void            * p_data,
N                             uint16_t        * p_len);
N
N/**@brief Function for reading a peer's bonding data (@ref PM_PEER_DATA_ID_BONDING).
N * @details See @ref pm_peer_data_load for parameters and return values. */
Nret_code_t pm_peer_data_bonding_load(pm_peer_id_t             peer_id,
N                                     pm_peer_data_bonding_t * p_data);
N
N/**@brief Function for reading a peer's remote DB values. (@ref PM_PEER_DATA_ID_GATT_REMOTE).
N * @details See @ref pm_peer_data_load for parameters and return values. */
Nret_code_t pm_peer_data_remote_db_load(pm_peer_id_t        peer_id,
N                                       ble_gatt_db_srv_t * p_data,
N                                       uint16_t          * p_len);
N
N/**@brief Function for reading a peer's application data. (@ref PM_PEER_DATA_ID_APPLICATION).
N * @details See @ref pm_peer_data_load for parameters and return values. */
Nret_code_t pm_peer_data_app_data_load(pm_peer_id_t peer_id,
N                                      uint8_t    * p_data,
N                                      uint16_t   * p_len);
N/** @}*/
N
N
N/**
N * @{
N */
N
N/**@brief Function for setting or updating stored data of a peer.
N *
N * @note Writing the data to persistent storage happens asynchronously. Therefore, the buffer
N *       that contains the data must be kept alive until the operation has completed.
N *
N * @note The data written using this function might later be overwritten as a result of internal
N *       operations in the Peer Manager. A Peer Manager event is sent each time data is updated,
N *       regardless of whether the operation originated internally or from action by the user.
N *
N * @param[in]  peer_id  Peer ID to set data for.
N * @param[in]  data_id  Which type of data to set.
N * @param[in]  p_data   New value to set.
N * @param[in]  len      The length in bytes of @p p_data.
N * @param[out] p_token  A token that identifies this particular store operation. The token can be
N *                      used to identify events that pertain to this operation. This parameter can
N *                      be NULL.
N *
N * @retval NRF_SUCCESS              If the data is scheduled to be written to persistent storage.
N * @retval NRF_ERROR_NULL           If @p p_data is NULL.
N * @retval NRF_ERROR_NOT_FOUND      If no peer was found for the peer ID.
N * @retval NRF_ERROR_BUSY           If the underlying flash handler is busy with other flash
N *                                  operations. Try again after receiving a Peer Manager event.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N */
Nret_code_t pm_peer_data_store(pm_peer_id_t       peer_id,
N                              pm_peer_data_id_t  data_id,
N                              void       const * p_data,
N                              uint16_t           len,
N                              pm_store_token_t * p_token);
N
N/**@brief Function for setting or updating a peer's bonding data (@ref PM_PEER_DATA_ID_BONDING).
N * @details See @ref pm_peer_data_store for parameters and return values. */
Nret_code_t pm_peer_data_bonding_store(pm_peer_id_t                   peer_id,
N                                      pm_peer_data_bonding_t const * p_data,
N                                      pm_store_token_t             * p_token);
N
N/**@brief Function for setting or updating a peer's remote DB values. (@ref PM_PEER_DATA_ID_GATT_REMOTE).
N * @details See @ref pm_peer_data_store for parameters and return values. */
Nret_code_t pm_peer_data_remote_db_store(pm_peer_id_t              peer_id,
N                                        ble_gatt_db_srv_t const * p_data,
N                                        uint16_t                  len,
N                                        pm_store_token_t        * p_token);
N
N/**@brief Function for setting or updating a peer's application data. (@ref PM_PEER_DATA_ID_APPLICATION).
N * @details See @ref pm_peer_data_store for parameters and return values. */
Nret_code_t pm_peer_data_app_data_store(pm_peer_id_t       peer_id,
N                                       uint8_t    const * p_data,
N                                       uint16_t           len,
N                                       pm_store_token_t * p_token);
N/** @}*/
N
N
N/**
N * @{
N */
N
N/**@brief Function for deleting a peer's stored pieces of data.
N *
N * @details This function deletes specific data that is stored for a peer. Note that bonding data
N *          cannot be cleared separately.
N *
N *          To delete all data for a peer (including bonding data), use @ref pm_peer_delete.
N *
N * @note Clearing data in persistent storage happens asynchronously.
N *
N * @param[in]  peer_id  Peer ID to clear data for.
N * @param[in]  data_id  Which data to clear.
N *
N * @retval NRF_SUCCESS              If the clear procedure was initiated successfully.
N * @retval NRF_ERROR_INVALID_PARAM  If @p data_id was PM_PEER_DATA_ID_BONDING or invalid, or
N *                                  @p peer_id was invalid.
N * @retval NRF_ERROR_NOT_FOUND      If there was no data to clear for this peer ID/data ID combination.
N * @retval NRF_ERROR_BUSY           If the underlying flash handler is busy with other flash
N *                                  operations. Try again after receiving a Peer Manager event.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N * @retval NRF_ERROR_INTERNAL       If an internal error occurred.
N */
Nret_code_t pm_peer_data_delete(pm_peer_id_t peer_id, pm_peer_data_id_t data_id);
N
N
N/**@brief Function for manually adding a peer to the persistent storage.
N *
N * @details This function allocates a new peer ID and stores bonding data for the new peer. The
N *          bonding data is necessary to prevent ambiguity/inconsistency in peer data.
N *
N * @param[in]  p_bonding_data  The bonding data of the new peer (must contain a public/static
N *                             address or a non-zero IRK).
N * @param[out] p_new_peer_id   Peer ID for the new peer, or an existing peer if a match was found.
N * @param[out] p_token         A token that identifies this particular store operation (storing the
N *                             bonding data). The token can be used to identify events that pertain
N *                             to this operation. This parameter can be NULL.
N *
N * @retval NRF_SUCCESS              If the store operation for bonding data was initiated successfully.
N * @retval NRF_ERROR_NULL           If @p p_bonding_data or @p p_new_peer_id is NULL.
N * @retval NRF_ERROR_NO_MEM         If there is no more space in persistent storage, or peer IDs
N *                                  have been exhausted.
N * @retval NRF_ERROR_BUSY           If the underlying flash filesystem is busy with other flash
N *                                  operations. Try again after receiving a Peer Manager event.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N * @retval NRF_ERROR_INTERNAL       If an internal error occurred.
N */
Nret_code_t pm_peer_new(pm_peer_id_t           * p_new_peer_id,
N                       pm_peer_data_bonding_t * p_bonding_data,
N                       pm_store_token_t       * p_token);
N
N
N/**@brief Function for freeing persistent storage for a peer.
N *
N * @details This function deletes every piece of data that is associated with the specified peer and
N *          frees the peer ID to be used for another peer. The deletion happens asynchronously, and
N *          the peer ID is not freed until the data is deleted. When the operation finishes, a @ref
N *          PM_EVT_PEER_DELETE_SUCCEEDED or @ref PM_EVT_PEER_DELETE_FAILED event is sent.
N *
N * @warning Use this function only when not connected to or connectable for the peer that is being
N *          deleted. If the peer is or becomes connected or data is manually written in flash during
N *          this procedure (until the success or failure event happens), the behavior is undefined.
N *
N * @param[in]  peer_id  Peer ID to be freed and have all associated data deleted.
N *
N * @retval NRF_SUCCESS              If the operation was initiated successfully.
N * @retval NRF_ERROR_INVALID_PARAM  If the peer ID was not valid.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N */
Nret_code_t pm_peer_delete(pm_peer_id_t peer_id);
N
N
N/**@brief Function for deleting all data stored for all peers.
N *
N * @details This function sends either a @ref PM_EVT_PEERS_DELETE_SUCCEEDED or a @ref
N *          PM_EVT_PEERS_DELETE_FAILED event. In addition, a @ref PM_EVT_PEER_DELETE_SUCCEEDED or
N *          @ref PM_EVT_PEER_DELETE_FAILED event is sent for each deleted peer.
N *
N * @note No event is sent when there is no peer data in flash.
N *
N * @warning Use this function only when not connected or connectable. If a peer is or becomes
N *          connected or a @ref PM_PEER_DATA_FUNCTIONS function is used during this procedure (until
N *          the success or failure event happens), the behavior is undefined.
N *
N * @retval NRF_SUCCESS              If the deletion process was initiated successfully.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N * @retval NRF_ERROR_INTERNAL       If an internal error occurred.
N */
Nret_code_t pm_peers_delete(void);
N/** @}*/
N
N
N/**
N * @{
N */
N
N
N/**@brief Function for finding the highest and lowest ranked peers.
N *
N * @details The rank is saved in persistent storage under the data ID @ref PM_PEER_DATA_ID_PEER_RANK.
N *
N * @details The interpretation of rank is up to the user, because the rank is only updated by
N *          calling @ref pm_peer_rank_highest or by manipulating the value using a @ref
N *          PM_PEER_DATA_FUNCTIONS function.
N *
N * @note Any argument that is NULL is ignored.
N *
N * @param[out] p_highest_ranked_peer  The peer ID with the highest rank of all peers, for example,
N *                                    the most recently used peer.
N * @param[out] p_highest_rank         The highest rank.
N * @param[out] p_lowest_ranked_peer   The peer ID with the lowest rank of all peers, for example,
N *                                    the least recently used peer.
N * @param[out] p_lowest_rank          The lowest rank.
N *
N * @retval NRF_SUCCESS              If the operation completed successfully.
N * @retval NRF_ERROR_NOT_FOUND      If no peers were found.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N * @retval NRF_ERROR_INTERNAL       If an internal error occurred.
N */
Nret_code_t pm_peer_ranks_get(pm_peer_id_t * p_highest_ranked_peer,
N                             uint32_t     * p_highest_rank,
N                             pm_peer_id_t * p_lowest_ranked_peer,
N                             uint32_t     * p_lowest_rank);
N
N
N/**@brief Function for updating the rank of a peer to be highest among all stored peers.
N *
N * @details If this function returns @ref NRF_SUCCESS, either a @ref PM_EVT_PEER_DATA_UPDATE_SUCCEEDED or a
N *          @ref PM_EVT_PEER_DATA_UPDATE_FAILED event is sent with a @ref
N *          PM_STORE_TOKEN_INVALID store token when the operation is complete. Until the operation
N *          is complete, this function returns @ref NRF_ERROR_BUSY.
N *
N *          When the operation is complete, the peer is the highest ranked peer as reported by
N *          @ref pm_peer_ranks_get.
N *
N * @note The @ref PM_EVT_PEER_DATA_UPDATE_SUCCEEDED event can arrive before the function returns if the peer
N *       is already ranked highest. In this case, the @ref pm_peer_data_update_succeeded_evt_t::flash_changed flag
N *       in the event will be false.
N *
N * @param[in]  peer_id  The peer to rank highest.
N *
N * @retval NRF_SUCCESS              If the peer's rank is, or will be updated to be highest.
N * @retval NRF_ERROR_BUSY           If the underlying flash handler is busy with other flash
N *                                  operations, or if a previous call to this function has not
N *                                  completed. Try again after receiving a Peer Manager event.
N * @retval NRF_ERROR_INVALID_STATE  If the Peer Manager is not initialized.
N * @retval NRF_ERROR_INTERNAL       If an internal error occurred.
N */
Nret_code_t pm_peer_rank_highest(pm_peer_id_t peer_id);
N
N/** @}*/
N
N/** @} */
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // PEER_MANAGER_H__
L 45 "..\..\..\main.c" 2
N#include "fds.h"
L 1 "..\..\..\..\..\..\components\libraries\fds\fds.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#ifndef FDS_H__
N#define FDS_H__
N
N/**
N * @defgroup fds Flash Data Storage
N * @ingroup app_common
N * @{
N *
N * @brief   Flash Data Storage (FDS).
N *
N * @details Flash Data Storage is a minimalistic, record-oriented file system for the on-chip
N *          flash. Files are stored as a collection of  records of variable length. FDS supports
N *          synchronous read operations and asynchronous write operations (write, update,
N *          and delete). FDS can be used from multiple threads.
N */
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "sdk_errors.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**@brief   Invalid file ID.
N *
N * This value must not be used as a file ID by the application.
N */
N#define FDS_FILE_ID_INVALID     (0xFFFF)
N
N
N/**@brief   Record key for deleted records.
N *
N * This key is used to flag a record as "dirty", which means that it should be removed during
N * the next garbage collection. This value must not be used as a record key by the application.
N */
N#define FDS_RECORD_KEY_DIRTY    (0x0000)
N
N
N/**@brief   FDS return values.
N */
Nenum
N{
N    FDS_SUCCESS = NRF_SUCCESS,  //!< The operation completed successfully.
X    FDS_SUCCESS = ((0x0) + 0),  
N    FDS_ERR_OPERATION_TIMEOUT,  //!< Error. The operation timed out.
N    FDS_ERR_NOT_INITIALIZED,    //!< Error. The module has not been initialized.
N    FDS_ERR_UNALIGNED_ADDR,     //!< Error. The input data is not aligned to a word boundary.
N    FDS_ERR_INVALID_ARG,        //!< Error. The parameter contains invalid data.
N    FDS_ERR_NULL_ARG,           //!< Error. The parameter is NULL.
N    FDS_ERR_NO_OPEN_RECORDS,    //!< Error. The record is not open, so it cannot be closed.
N    FDS_ERR_NO_SPACE_IN_FLASH,  //!< Error. There is no space in flash memory.
N    FDS_ERR_NO_SPACE_IN_QUEUES, //!< Error. There is no space in the internal queues.
N    FDS_ERR_RECORD_TOO_LARGE,   //!< Error. The record exceeds the maximum allowed size.
N    FDS_ERR_NOT_FOUND,          //!< Error. The record was not found.
N    FDS_ERR_NO_PAGES,           //!< Error. No flash pages are available.
N    FDS_ERR_USER_LIMIT_REACHED, //!< Error. The maximum number of users has been reached.
N    FDS_ERR_CRC_CHECK_FAILED,   //!< Error. The CRC check failed.
N    FDS_ERR_BUSY,               //!< Error. The underlying flash subsystem was busy.
N    FDS_ERR_INTERNAL,           //!< Error. An internal error occurred.
N};
N
N
N/**@brief   Part of the record metadata.
N *
N * Contains the record key and the length of the record data.
N */
Ntypedef struct
N{
N    uint16_t record_key;    //!< The record key (must be in the range 0x0001 - 0xBFFF).
N    uint16_t length_words;  //!< The length of the record data (in 4-byte words).
N} fds_tl_t;
N
N
N/**@brief   Part of the record metadata.
N *
N * Contains the ID of the file that the record belongs to and the CRC16 check value of the record.
N */
Ntypedef struct
N{
N    uint16_t file_id;   //!< The ID of the file that the record belongs to.
N
N    /**@brief   CRC16 check value.
N     *
N     * The CRC is calculated over the entire record as stored in flash (including the record
N     * metadata except the CRC field itself). The CRC standard employed is CRC-16-CCITT.
N     */
N    uint16_t crc16;
N} fds_ic_t;
N
N
N/**@brief   The record metadata as stored in flash.
N */
Ntypedef struct
N{
N    fds_tl_t tl;        //!< See @ref fds_tl_t.
N    fds_ic_t ic;        //!< See @ref fds_ic_t.
N    uint32_t record_id; //!< The unique record ID (32 bits).
N} fds_header_t;
N
N
N/**@brief   The record descriptor structure that is used to manipulate records.
N *
N * This structure is used by the FDS module. You must provide the descriptor to the module when
N * you manipulate existing records. However, you should never modify it or use any of its fields.
N *
N * @note Never reuse the same descriptor for different records.
N */
Ntypedef struct
N{
N    uint32_t         record_id;         //!< The unique record ID.
N    uint32_t const * p_record;          //!< The last known location of the record in flash.
N    uint16_t         gc_run_count;      //!< Number of times garbage collection has been run.
N    bool             record_is_open;    //!< Whether the record is currently open.
X    _Bool             record_is_open;    
N} fds_record_desc_t;
N
N
N/**@brief   Structure that can be used to read the contents of a record stored in flash.
N *
N * This structure does not reflect the physical layout of a record in flash, but it points
N * to the locations where the record header (metadata) and the record data are stored.
N */
Ntypedef struct
N{
N    fds_header_t const * p_header;  //!< Location of the record header in flash.
N    void         const * p_data;    //!< Location of the record data in flash.
N} fds_flash_record_t;
N
N
N/**@brief   A chunk of record data to be written to flash.
N *
N * @p p_data must be aligned to a word boundary. Make sure to keep it in
N * memory until the operation has completed, which is indicated by the respective FDS event.
N */
Ntypedef struct
N{
N    void     const * p_data;        //!< Pointer to the data to store. Must be word-aligned.
N    uint16_t         length_words;  //!< Length of data pointed to by @p p_data (in 4-byte words).
N} fds_record_chunk_t;
N
N
N/**@brief   A record to be written to flash.
N */
Ntypedef struct
N{
N    uint16_t file_id;                           //!< The ID of the file that the record belongs to.
N    uint16_t key;                               //!< The record key.
N    struct
N    {
N        fds_record_chunk_t const * p_chunks;    //!< The chunks that make up the record data.
N        uint16_t                   num_chunks;  //!< The number of chunks that make up the data.
N    } data;
N} fds_record_t;
N
N
N/**@brief   A token to a reserved space in flash, created by @ref fds_reserve.
N *
N * This token can be used to write the record in the reserved space (@ref fds_record_write_reserved)
N * or to cancel the reservation (@ref fds_reserve_cancel).
N */
Ntypedef struct
N{
N    uint16_t page;           //!< The logical ID of the page where space was reserved.
N    uint16_t length_words;   //!< The amount of space reserved (in 4-byte words).
N} fds_reserve_token_t;
N
N
N/**@brief   A token to keep information about the progress of @ref fds_record_find,
N *          @ref fds_record_find_by_key, and @ref fds_record_find_in_file.
N *
N * @note    Always zero-initialize the token before using it for the first time.
N * @note    Never reuse the same token to search for different records.
N */
Ntypedef struct
N{
N    uint32_t const * p_addr;
N    uint16_t         page;
N} fds_find_token_t;
N
N
N/**@brief   FDS event IDs.
N */
Ntypedef enum
N{
N    FDS_EVT_INIT,       //!< Event for @ref fds_init.
N    FDS_EVT_WRITE,      //!< Event for @ref fds_record_write and @ref fds_record_write_reserved.
N    FDS_EVT_UPDATE,     //!< Event for @ref fds_record_update.
N    FDS_EVT_DEL_RECORD, //!< Event for @ref fds_record_delete.
N    FDS_EVT_DEL_FILE,   //!< Event for @ref fds_file_delete.
N    FDS_EVT_GC          //!< Event for @ref fds_gc.
N} fds_evt_id_t;
N
N
N#if defined(__CC_ARM)
X#if 1L
N    #pragma push
N    #pragma anon_unions
N#elif defined(__ICCARM__)
S    #pragma language=extended
S#elif defined(__GNUC__)
S    /* anonymous unions are enabled by default */
N#endif
N
N/**@brief   An FDS event.
N */
Ntypedef struct
N{
N    fds_evt_id_t id;        //!< The event ID. See @ref fds_evt_id_t.
N    ret_code_t   result;    //!< The result of the operation related to this event.
N    union
N    {
N        struct
N        {
N            /* Currently not used. */
N            uint16_t pages_not_mounted;
N        } init;
N        struct
N        {
N            uint32_t record_id;
N            uint16_t file_id;
N            uint16_t record_key;
N            bool     is_record_updated;
X            _Bool     is_record_updated;
N        } write; //!< Information for @ref FDS_EVT_WRITE and @ref FDS_EVT_UPDATE events.
N        struct
N        {
N            uint32_t record_id;
N            uint16_t file_id;
N            uint16_t record_key;
N            uint16_t records_deleted_count;
N        } del; //!< Information for @ref FDS_EVT_DEL_RECORD and @ref FDS_EVT_DEL_FILE events.
N        struct
N        {
N            /* Currently not used. */
N            uint16_t pages_skipped;
N            uint16_t space_reclaimed;
N        } gc;
N    };
N} fds_evt_t;
N
N#if defined(__CC_ARM)
X#if 1L
N    #pragma pop
N#elif defined(__ICCARM__)
S    /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S    /* anonymous unions are enabled by default */
N#endif
N
N
N/**@brief   File system statistics. */
Ntypedef struct
N{
N    uint16_t open_records;      //!< The number of open records.
N    uint16_t valid_records;     //!< The number of valid records.
N    uint16_t dirty_records;     //!< The number of deleted ("dirty") records.
N    uint16_t words_reserved;    //!< The number of words reserved by @ref fds_reserve().
N
N    /**@brief The number of words written to flash, including those reserved for future writes.
N     */
N    uint16_t words_used;
N
N    /**@brief The largest number of free contiguous words in the file system.
N     *
N     * This number determines the largest record that can be stored by FDS.
N     * It takes into account all reservations for future writes.
N     */
N    uint16_t largest_contig;
N
N    /**@brief The largest number of words that can be reclaimed by garbage collection.
N     *
N     * The actual amount of space freed by garbage collection might be less than this value if
N     * records are open while garbage collection is run.
N     */
N    uint16_t freeable_words;
N} fds_stat_t;
N
N
N/**@brief   FDS event handler function prototype.
N *
N * @param   p_evt   The event.
N */
Ntypedef void (*fds_cb_t)(fds_evt_t const * const p_evt);
N
N
N/**@brief   Function for registering an FDS event handler.
N *
N * The maximum amount of handlers that can be registered can be configured by changing the value
N * of @ref FDS_MAX_USERS in fds_config.h.
N *
N * @param[in]   cb  The event handler function.
N *
N * @retval  FDS_SUCCESS                 If the event handler was registered successfully.
N * @retval  FDS_ERR_USER_LIMIT_REACHED  If the maximum number of registered callbacks is reached.
N */
Nret_code_t fds_register(fds_cb_t cb);
N
N
N/**@brief   Function for initializing the module.
N *
N * This function initializes the module and installs the file system (unless it is installed
N * already).
N *
N * This function is asynchronous. Completion is reported through an event. Make sure to call
N * @ref fds_register before calling @ref fds_init so that you receive the completion event.
N *
N * @retval  FDS_SUCCESS         If the operation was queued successfully.
N * @retval  FDS_ERR_NO_PAGES    If there is no space available in flash memory to install the
N *                              file system.
N */
Nret_code_t fds_init(void);
N
N
N/**@brief   Function for writing a record to flash.
N *
N * There are no restrictions on the file ID and the record key, except that the record key must be
N * different from @ref FDS_RECORD_KEY_DIRTY and the file ID must be different from
N * @ref FDS_FILE_ID_INVALID. In particular, no restrictions are made regarding the uniqueness of
N * the file ID or the record key. All records with the same file ID are grouped into one file.
N * If no file with the specified ID exists, it is created. There can be multiple records with the
N * same record key in a file.
N *
N * Record data can consist of multiple chunks. The data must be aligned to a 4 byte boundary, and
N * because it is not buffered internally, it must be kept in memory until the callback for the
N * operation has been received. The length of the data must not exceed @ref FDS_VIRTUAL_PAGE_SIZE
N * words minus 14 bytes.
N *
N * This function is asynchronous. Completion is reported through an event that is sent to
N * the registered event handler function.
N *
N * @param[out]  p_desc      The descriptor of the record that was written. Pass NULL if you do not
N *                          need the descriptor.
N * @param[in]   p_record    The record to be written to flash.
N *
N * @retval  FDS_SUCCESS                 If the operation was queued successfully.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_NULL_ARG            If @p p_record is NULL.
N * @retval  FDS_ERR_INVALID_ARG         If the file ID or the record key is invalid.
N * @retval  FDS_ERR_UNALIGNED_ADDR      If the record data is not aligned to a 4 byte boundary.
N * @retval  FDS_ERR_RECORD_TOO_LARGE    If the record data exceeds the maximum length.
N * @retval  FDS_ERR_NO_SPACE_IN_QUEUES  If the operation queue is full or there are more record
N *                                      chunks than can be buffered.
N * @retval  FDS_ERR_NO_SPACE_IN_FLASH   If there is not enough free space in flash to store the
N *                                      record.
N */
Nret_code_t fds_record_write(fds_record_desc_t       * const p_desc,
N                            fds_record_t      const * const p_record);
N
N
N/**@brief   Function for reserving space in flash.
N *
N * This function can be used to reserve space in flash memory. To write a record into the reserved
N * space, use @ref fds_record_write_reserved. Alternatively, use @ref fds_reserve_cancel to cancel
N * a reservation.
N *
N * Note that this function does not write any data to flash.
N *
N * @param[out]  p_token         A token that can be used to write a record in the reserved space or
N *                              cancel the reservation.
N * @param[in]   length_words    The length of the record data (in 4-byte words).
N *
N * @retval  FDS_SUCCESS                 If the flash space was reserved successfully.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_NULL_ARG            If @p p_token is NULL instead of a valid token address.
N * @retval  FDS_ERR_RECORD_TOO_LARGE    If the record length exceeds the maximum length.
N * @retval  FDS_ERR_NO_SPACE_IN_FLASH   If there is not enough free space in flash to store the
N *                                      record.
N */
Nret_code_t fds_reserve(fds_reserve_token_t * const p_token, uint16_t length_words);
N
N
N/**@brief   Function for canceling an @ref fds_reserve operation.
N *
N * @param[in]   p_token     The token that identifies the reservation, produced by @ref fds_reserve.
N *
N * @retval  FDS_SUCCESS             If the reservation was canceled.
N * @retval  FDS_ERR_NOT_INITIALIZED If the module is not initialized.
N * @retval  FDS_ERR_NULL_ARG        If @p p_token is NULL instead of a valid token address.
N * @retval  FDS_ERR_INVALID_ARG     If @p p_token contains invalid data.
N */
Nret_code_t fds_reserve_cancel(fds_reserve_token_t * const p_token);
N
N
N/**@brief   Function for writing a record to a space in flash that was reserved using
N *          @ref fds_reserve.
N *
N * There are no restrictions on the file ID and the record key, except that the record key must be
N * different from @ref FDS_RECORD_KEY_DIRTY and the file ID must be different from
N * @ref FDS_FILE_ID_INVALID. In particular, no restrictions are made regarding the uniqueness of
N * the file ID or the record key. All records with the same file ID are grouped into one file.
N * If no file with the specified ID exists, it is created. There can be multiple records with the
N * same record key in a file.
N *
N * Record data can consist of multiple chunks. The data must be aligned to a 4 byte boundary, and
N * because it is not buffered internally, it must be kept in memory until the callback for the
N * operation has been received. The length of the data must not exceed @ref FDS_VIRTUAL_PAGE_SIZE
N * words minus 14 bytes.
N *
N * This function is asynchronous. Completion is reported through an event that is sent to the
N * registered event handler function.
N *
N * @note
N * This function behaves similarly to @ref fds_record_write, with the exception that it never
N * fails with the error @ref FDS_ERR_NO_SPACE_IN_FLASH.
N *
N * @param[out]  p_desc      The descriptor of the record that was written. Pass NULL if you do not
N *                          need the descriptor.
N * @param[in]   p_record    The record to be written to flash.
N * @param[in]   p_token     The token that identifies the space reserved in flash.
N *
N * @retval  FDS_SUCCESS                 If the operation was queued successfully.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_NULL_ARG            If @p p_token is NULL instead of a valid token address.
N * @retval  FDS_ERR_INVALID_ARG         If the file ID or the record key is invalid.
N * @retval  FDS_ERR_UNALIGNED_ADDR      If the record data is not aligned to a 4 byte boundary.
N * @retval  FDS_ERR_RECORD_TOO_LARGE    If the record data exceeds the maximum length.
N * @retval  FDS_ERR_NO_SPACE_IN_QUEUES  If the operation queue is full or there are more record
N *                                      chunks than can be buffered.
N */
Nret_code_t fds_record_write_reserved(fds_record_desc_t         * const p_desc,
N                                     fds_record_t        const * const p_record,
N                                     fds_reserve_token_t const * const p_token);
N
N
N/**@brief   Function for deleting a record.
N *
N * Deleted records cannot be located using @ref fds_record_find, @ref fds_record_find_by_key, or
N * @ref fds_record_find_in_file. Additionally, they can no longer be opened using
N * @ref fds_record_open.
N *
N * Note that deleting a record does not free the space it occupies in flash memory.
N * To reclaim flash space used by deleted records, call @ref fds_gc to run garbage collection.
N *
N * This function is asynchronous. Completion is reported through an event that is sent to the
N * registered event handler function.
N *
N * @param[in]   p_desc      The descriptor of the record that should be deleted.
N *
N * @retval  FDS_SUCCESS                 If the operation was queued successfully.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_NULL_ARG            If the specified record descriptor @p p_desc is NULL.
N * @retval  FDS_ERR_NO_SPACE_IN_QUEUES  If the operation queue is full.
N */
Nret_code_t fds_record_delete(fds_record_desc_t * const p_desc);
N
N
N/**@brief   Function for deleting all records in a file.
N *
N * This function deletes a file, including all its records. Deleted records cannot be located
N * using @ref fds_record_find, @ref fds_record_find_by_key, or @ref fds_record_find_in_file.
N * Additionally, they can no longer be opened using @ref fds_record_open.
N *
N * Note that deleting records does not free the space they occupy in flash memory.
N * To reclaim flash space used by deleted records, call @ref fds_gc to run garbage collection.
N *
N * This function is asynchronous. Completion is reported through an event that is sent to the
N * registered event handler function.
N *
N * @param[in]   file_id     The ID of the file to be deleted.
N *
N * @retval  FDS_SUCCESS                 If the operation was queued successfully.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_INVALID_ARG         If the specified @p file_id is invalid.
N * @retval  FDS_ERR_NO_SPACE_IN_QUEUES  If the operation queue is full.
N */
Nret_code_t fds_file_delete(uint16_t file_id);
N
N
N/**@brief   Function for updating a record.
N *
N * Updating a record first writes a new record (@p p_record) to flash and then deletes the
N * old record (identified by @p p_desc).
N *
N * There are no restrictions on the file ID and the record key, except that the record key must be
N * different from @ref FDS_RECORD_KEY_DIRTY and the file ID must be different from
N * @ref FDS_FILE_ID_INVALID. In particular, no restrictions are made regarding the uniqueness of
N * the file ID or the record key. All records with the same file ID are grouped into one file.
N * If no file with the specified ID exists, it is created. There can be multiple records with the
N * same record key in a file.
N *
N * Record data can consist of multiple chunks. The data must be aligned to a 4 byte boundary, and
N * because it is not buffered internally, it must be kept in memory until the callback for the
N * operation has been received. The length of the data must not exceed @ref FDS_VIRTUAL_PAGE_SIZE
N * words minus 14 bytes.
N *
N * This function is asynchronous. Completion is reported through an event that is sent to the
N * registered event handler function.
N *
N * @param[in, out]  p_desc      The descriptor of the record to update. When the function
N *                              returns with FDS_SUCCESS, this parameter contains the
N *                              descriptor of the newly written record.
N * @param[in]       p_record    The updated record to be written to flash.
N *
N * @retval  FDS_SUCCESS                 If the operation was queued successfully.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_INVALID_ARG         If the file ID or the record key is invalid.
N * @retval  FDS_ERR_UNALIGNED_ADDR      If the record data is not aligned to a 4 byte boundary.
N * @retval  FDS_ERR_RECORD_TOO_LARGE    If the record data exceeds the maximum length.
N * @retval  FDS_ERR_NO_SPACE_IN_QUEUES  If the operation queue is full or there are more record
N *                                      chunks than can be buffered.
N * @retval  FDS_ERR_NO_SPACE_IN_FLASH   If there is not enough free space in flash to store the
N *                                      updated record.
N */
Nret_code_t fds_record_update(fds_record_desc_t       * const p_desc,
N                             fds_record_t      const * const p_record);
N
N
N/**@brief   Function for iterating through all records in flash.
N *
N * To search for the next record, call the function again and supply the same @ref fds_find_token_t
N * structure to resume searching from the last record that was found.
N *
N * Note that the order with which records are iterated is not defined.
N *
N * @param[out]  p_desc      The descriptor of the record that was found.
N * @param[out]  p_token     A token containing information about the progress of the operation.
N *
N * @retval  FDS_SUCCESS                 If a record was found.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_NULL_ARG            If @p p_desc or @p p_token is NULL.
N * @retval  FDS_ERR_NOT_FOUND           If no matching record was found.
N */
Nret_code_t fds_record_iterate(fds_record_desc_t * const p_desc,
N                              fds_find_token_t  * const p_token);
N
N
N/**@brief   Function for searching for records with a given record key in a file.
N *
N * This function finds the first record in a file that has the given record key. To search for the
N * next record with the same key in the file, call the function again and supply the same
N * @ref fds_find_token_t structure to resume searching from the last record that was found.
N *
N * @param[in]   file_id     The file ID.
N * @param[in]   record_key  The record key.
N * @param[out]  p_desc      The descriptor of the record that was found.
N * @param[out]  p_token     A token containing information about the progress of the operation.
N *
N * @retval  FDS_SUCCESS                 If a record was found.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_NULL_ARG            If @p p_desc or @p p_token is NULL.
N * @retval  FDS_ERR_NOT_FOUND           If no matching record was found.
N */
Nret_code_t fds_record_find(uint16_t                  file_id,
N                           uint16_t                  record_key,
N                           fds_record_desc_t * const p_desc,
N                           fds_find_token_t  * const p_token);
N
N
N/**@brief   Function for searching for records with a given record key.
N *
N * This function finds the first record with a given record key, independent of the file it
N * belongs to. To search for the next record with the same key, call the function again and supply
N * the same @ref fds_find_token_t structure to resume searching from the last record that was found.
N *
N * @param[in]   record_key  The record key.
N * @param[out]  p_desc      The descriptor of the record that was found.
N * @param[out]  p_token     A token containing information about the progress of the operation.
N *
N * @retval  FDS_SUCCESS                 If a record was found.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_NULL_ARG            If @p p_desc or @p p_token is NULL.
N * @retval  FDS_ERR_NOT_FOUND           If no record with the given key was found.
N */
Nret_code_t fds_record_find_by_key(uint16_t                  record_key,
N                                  fds_record_desc_t * const p_desc,
N                                  fds_find_token_t  * const p_token);
N
N
N/**@brief   Function for searching for any record in a file.
N *
N * This function finds the first record in a file, independent of its record key.
N * To search for the next record in the same file, call the function again and supply the same
N * @ref fds_find_token_t structure to resume searching from the last record that was found.
N *
N * @param[in]   file_id     The file ID.
N * @param[out]  p_desc      The descriptor of the record that was found.
N * @param[out]  p_token     A token containing information about the progress of the operation.
N *
N * @retval  FDS_SUCCESS                 If a record was found.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_NULL_ARG            If @p p_desc or @p p_token is NULL.
N * @retval  FDS_ERR_NOT_FOUND           If no matching record was found.
N */
Nret_code_t fds_record_find_in_file(uint16_t                  file_id,
N                                   fds_record_desc_t * const p_desc,
N                                   fds_find_token_t  * const p_token);
N
N
N/**@brief   Function for opening a record for reading.
N *
N * This function opens a record that is stored in flash, so that it can be read. The function
N * initializes an @ref fds_flash_record_t structure, which can be used to access the record data as
N * well as its associated metadata. The pointers provided in the @ref fds_flash_record_t structure
N * are pointers to flash memory.
N *
N * Opening a record with @ref fds_record_open prevents garbage collection to run on the virtual
N * flash page in which record is stored, so that the contents of the memory pointed by fields in
N * @ref fds_flash_record_t are guaranteed to remain unmodified as long as the record is kept open.
N *
N * When you are done reading a record, call @ref fds_record_close to close it. Garbage collection
N * can then reclaim space on the virtual page where the record is stored. Note that you must
N * provide the same descriptor for @ref fds_record_close as you did for this function.
N *
N * @param[in]   p_desc          The descriptor of the record to open.
N * @param[out]  p_flash_record  The record, as stored in flash.
N *
N * @retval  FDS_SUCCESS                 If the record was opened successfully.
N * @retval  FDS_ERR_NULL_ARG            If @p p_desc or @p p_flash_record is NULL.
N * @retval  FDS_ERR_NOT_FOUND           If the record was not found. It might have been deleted, or
N *                                      it might not have been written yet.
N * @retval  FDS_ERR_CRC_CHECK_FAILED    If the CRC check for the record failed.
N */
Nret_code_t fds_record_open(fds_record_desc_t  * const p_desc,
N                           fds_flash_record_t * const p_flash_record);
N
N
N/**@brief   Function for closing a record.
N *
N * Closing a record allows garbage collection to run on the virtual page in which the record is
N * stored (if no other records remain open on that page). The descriptor passed as an argument
N * must be the same as the one used to open the record using @ref fds_record_open.
N *
N * Note that closing a record does not invalidate its descriptor. You can still supply the
N * descriptor to all functions that accept a record descriptor as a parameter.
N *
N * @param[in]   p_desc  The descriptor of the record to close.
N *
N * @retval  FDS_SUCCESS             If the record was closed successfully.
N * @retval  FDS_ERR_NULL_ARG        If @p p_desc is NULL.
N * @retval  FDS_ERR_NO_OPEN_RECORDS If the record is not open.
N * @retval  FDS_ERR_NOT_FOUND       If the record could not be found.
N */
Nret_code_t fds_record_close(fds_record_desc_t * const p_desc);
N
N
N/**@brief   Function for running garbage collection.
N *
N * Garbage collection reclaims the flash space that is occupied by records that have been deleted,
N * or that failed to be completely written due to, for example, a power loss.
N *
N * This function is asynchronous. Completion is reported through an event that is sent to the
N * registered event handler function.
N *
N * @retval  FDS_SUCCESS                 If the operation was queued successfully.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_NO_SPACE_IN_QUEUES  If the operation queue is full.
N */
Nret_code_t fds_gc(void);
N
N
N/**@brief   Function for obtaining a descriptor from a record ID.
N *
N * This function can be used to reconstruct a descriptor from a record ID, like the one that is
N * passed to the callback function.
N *
N * @note
N * This function does not check whether a record with the given record ID exists.
N * If a non-existing record ID is supplied, the resulting descriptor is invalid and will cause
N * other functions to fail when it is supplied as parameter.
N *
N * @param[out]  p_desc      The descriptor of the record with the given record ID.
N * @param[in]   record_id   The record ID for which a descriptor should be returned.
N *
N * @retval  FDS_SUCCESS         If a descriptor was returned.
N * @retval  FDS_ERR_NULL_ARG    If @p p_desc is NULL.
N */
Nret_code_t fds_descriptor_from_rec_id(fds_record_desc_t * const p_desc,
N                                      uint32_t                  record_id);
N
N
N/**@brief   Function for obtaining a record ID from a record descriptor.
N *
N * This function can be used to extract a record ID from a descriptor. For example, you could use
N * it in the callback function to compare the record ID of an event to the record IDs of the
N * records for which you have a descriptor.
N *
N * @warning
N * This function does not check whether the record descriptor is valid. If the descriptor is not
N * initialized or has been tampered with, the resulting record ID might be invalid.
N *
N * @param[in]   p_desc          The descriptor from which the record ID should be extracted.
N * @param[out]  p_record_id     The record ID that is contained in the given descriptor.
N *
N * @retval  FDS_SUCCESS         If a record ID was returned.
N * @retval  FDS_ERR_NULL_ARG    If @p p_desc or @p p_record_id is NULL.
N */
Nret_code_t fds_record_id_from_desc(fds_record_desc_t const * const p_desc,
N                                   uint32_t                * const p_record_id);
N
N
N/**@brief   Function for retrieving file system statistics.
N *
N * This function retrieves file system statistics, such as the number of open records, the space
N * that can be reclaimed by garbage collection, and others.
N *
N * @param[out]  p_stat      File system statistics.
N *
N * @retval  FDS_SUCCESS                 If the statistics were returned successfully.
N * @retval  FDS_ERR_NOT_INITIALIZED     If the module is not initialized.
N * @retval  FDS_ERR_NULL_ARG            If @p p_stat is NULL.
N */
Nret_code_t fds_stat(fds_stat_t * const p_stat);
N
N
N#if defined(FDS_CRC_ENABLED)
X#if 0L
S
S/**@brief   Function for enabling and disabling CRC verification for write operations.
S *
S * CRC verification ensures that data that is queued for writing does not change before the write
S * actually happens. Use this function to enable or disable CRC verification. If verification is
S * enabled, the error @ref FDS_ERR_CRC_CHECK_FAILED is returned in the event for
S * @ref fds_record_write, @ref fds_record_write_reserved, or @ref fds_record_update if
S * verification fails.
S *
S * @note
S * CRC verification is enabled or disabled globally, thus for all users of the FDS module.
S *
S * @param[in]   enabled     1 to enable CRC verification. 0 to disable CRC verification.
S *
S * @retval  FDS_SUCCESS     If CRC verification was enabled or disabled successfully.
S */
Sret_code_t fds_verify_crc_on_writes(bool enabled);
S
N#endif
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // FDS_H__
L 46 "..\..\..\main.c" 2
N#include "fstorage.h"
L 1 "..\..\..\..\..\..\components\libraries\fstorage\fstorage.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#ifndef FSTORAGE_H__
N#define FSTORAGE_H__
N
N/**
N * @defgroup fstorage fstorage
N * @ingroup app_common
N * @{
N *
N * @brief   Module which provides functionality to store data to flash and erase flash pages.
N */
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "section_vars.h"
L 1 "..\..\..\..\..\..\components\libraries\experimental_section_vars\section_vars.h" 1
N/* Copyright (c) 2016 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#ifndef SECTION_VARS_H__
N#define SECTION_VARS_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * @defgroup section_vars Section variables
N * @ingroup app_common
N * @{
N *
N * @brief Section variables.
N */
N
N
N#if defined(__ICCARM__)
X#if 0L
S// Enable IAR language extensions
S#pragma language=extended
N#endif
N
N
N// Macro to delay macro expansion.
N#define NRF_PRAGMA(x)                                       _Pragma(#x)
N
N
N//lint -save -e27 Illegal character (0x24)
N
N
N/**@brief   Macro to obtain the symbol marking the beginning of a given section.
N *
N * @details The symbol that this macro resolves to is used to obtain a section start address.
N *
N * @param[in]   section_name    Name of the section.
N */
N#if defined(__CC_ARM)
X#if 1L
N
N#define NRF_SECTION_VARS_START_SYMBOL(section_name)         section_name ## $$Base
N
N#elif defined(__GNUC__)
S
S#define NRF_SECTION_VARS_START_SYMBOL(section_name)         __start_ ## section_name
S
S#elif defined(__ICCARM__)
S
S#define NRF_SECTION_VARS_START_SYMBOL(section_name)         __section_begin(#section_name)
S
N#endif
N
N
N/**@brief   Macro to obtain the symbol marking the end of a given section.
N *
N * @details The symbol that this macro resolves to is used to obtain a section stop address.
N *
N * @param[in]   section_name    Name of the section.
N */
N#if defined(__CC_ARM)
X#if 1L
N
N#define NRF_SECTION_VARS_END_SYMBOL(section_name)           section_name ## $$Limit
N
N#elif defined(__GNUC__)
S
S#define NRF_SECTION_VARS_END_SYMBOL(section_name)           __stop_ ## section_name
S
S#elif defined(__ICCARM__)
S
S#define NRF_SECTION_VARS_END_SYMBOL(section_name)           __section_end(#section_name)
S
N#endif
N
N
N//lint -restore
N
N
N/**@brief   Macro for retrieving the length of a given section, in bytes.
N *
N * @param[in]   section_name    Name of the section.
N */
N#if defined(__CC_ARM)
X#if 1L
N
N#define NRF_SECTION_VARS_LENGTH(section_name) \
N    ((uint32_t)&NRF_SECTION_VARS_END_SYMBOL(section_name) - (uint32_t)&NRF_SECTION_VARS_START_SYMBOL(section_name))
X#define NRF_SECTION_VARS_LENGTH(section_name)     ((uint32_t)&NRF_SECTION_VARS_END_SYMBOL(section_name) - (uint32_t)&NRF_SECTION_VARS_START_SYMBOL(section_name))
N
N#elif defined(__GNUC__)
S
S #define NRF_SECTION_VARS_LENGTH(section_name) \
S    ((uint32_t)&NRF_SECTION_VARS_END_SYMBOL(section_name) - (uint32_t)&NRF_SECTION_VARS_START_SYMBOL(section_name))
X #define NRF_SECTION_VARS_LENGTH(section_name)     ((uint32_t)&NRF_SECTION_VARS_END_SYMBOL(section_name) - (uint32_t)&NRF_SECTION_VARS_START_SYMBOL(section_name))
S
S#elif defined(__ICCARM__)
S
S #define NRF_SECTION_VARS_LENGTH(section_name) \
S    ((uint32_t)NRF_SECTION_VARS_END_SYMBOL(section_name) - (uint32_t)NRF_SECTION_VARS_START_SYMBOL(section_name))
X #define NRF_SECTION_VARS_LENGTH(section_name)     ((uint32_t)NRF_SECTION_VARS_END_SYMBOL(section_name) - (uint32_t)NRF_SECTION_VARS_START_SYMBOL(section_name))
S
N#endif
N
N
N/**@brief   Macro to obtain the address of the beginning of a section.
N *
N * param[in]    section_name    Name of the section.
N */
N#if defined(__CC_ARM)
X#if 1L
N
N#define NRF_SECTION_VARS_START_ADDR(section_name)       (uint32_t)&NRF_SECTION_VARS_START_SYMBOL(section_name)
N
N#elif defined(__GNUC__)
S
S#define NRF_SECTION_VARS_START_ADDR(section_name)       (uint32_t)&NRF_SECTION_VARS_START_SYMBOL(section_name)
S
S#elif defined(__ICCARM__)
S
S#define NRF_SECTION_VARS_START_ADDR(section_name)       (uint32_t)iar_ ## section_name ## _start
S
N#endif
N
N
N/**@brief    Macro to obtain the address of end of a section.
N *
N * @param[in]   section_name    Name of the section.
N */
N#if defined(__CC_ARM)
X#if 1L
N
N#define NRF_SECTION_VARS_END_ADDR(section_name)         (uint32_t)&NRF_SECTION_VARS_END_SYMBOL(section_name)
N
N#elif defined(__GNUC__)
S
S#define NRF_SECTION_VARS_END_ADDR(section_name)         (uint32_t)&NRF_SECTION_VARS_END_SYMBOL(section_name)
S
S#elif defined(__ICCARM__)
S
S#define NRF_SECTION_VARS_END_ADDR(section_name)         (uint32_t)iar_ ## section_name ## _end
S
N#endif
N
N
N//lint -save -e19 -esym(526, fs_dataBase) -esym(526, fs_dataLimit) -esym(526, dfu_transBase) -esym(526, dfu_transLimit)
N
N/**@brief   Macro to create a section to register variables in.
N *
N * @param[in]   data_type       The data type of the variables to be registered in the section.
N * @param[in]   section_name    Name of the section.
N *
N * @warning The data type must be word aligned to prevent padding.
N */
N#if defined(__CC_ARM)
X#if 1L
N
N#define NRF_SECTION_VARS_CREATE_SECTION(section_name, data_type)    \
N    extern data_type * NRF_SECTION_VARS_START_SYMBOL(section_name); \
N    extern void      * NRF_SECTION_VARS_END_SYMBOL(section_name)
X#define NRF_SECTION_VARS_CREATE_SECTION(section_name, data_type)        extern data_type * NRF_SECTION_VARS_START_SYMBOL(section_name);     extern void      * NRF_SECTION_VARS_END_SYMBOL(section_name)
N
N#elif defined(__GNUC__)
S
S#define NRF_SECTION_VARS_CREATE_SECTION(section_name, data_type)    \
S    extern data_type * NRF_SECTION_VARS_START_SYMBOL(section_name); \
S    extern void      * NRF_SECTION_VARS_END_SYMBOL(section_name)
X#define NRF_SECTION_VARS_CREATE_SECTION(section_name, data_type)        extern data_type * NRF_SECTION_VARS_START_SYMBOL(section_name);     extern void      * NRF_SECTION_VARS_END_SYMBOL(section_name)
S
S#elif defined(__ICCARM__)
S
S// No symbol registration required for IAR.
S#define NRF_SECTION_VARS_CREATE_SECTION(section_name, data_type)                    \
S    NRF_PRAGMA(section = #section_name);                                            \
S    extern void * iar_ ## section_name ## _start = __section_begin(#section_name);  \
S    extern void * iar_ ## section_name ## _end   = __section_end(#section_name)
X#define NRF_SECTION_VARS_CREATE_SECTION(section_name, data_type)                        NRF_PRAGMA(section = #section_name);                                                extern void * iar_ ## section_name ## _start = __section_begin(#section_name);      extern void * iar_ ## section_name ## _end   = __section_end(#section_name)
S
N#endif
N
N//lint -restore
N
N
N/**@brief   Macro to declare a variable and register it in a section.
N *
N * @details Declares a variable and registers it in a named section. This macro ensures that the
N *          variable is not stripped away when using optimizations.
N *
N * @note The order with which variables are placed in a section is dependant on the order with
N *       which the linker encouters the variables during linking.
N *
N * @param[in]   section_name    Name of the section.
N * @param[in]   section_var     The variable to register in the given section.
N */
N#if defined(__CC_ARM)
X#if 1L
N
N#define NRF_SECTION_VARS_REGISTER_VAR(section_name, section_var) \
N    static section_var __attribute__ ((section(#section_name))) __attribute__((used))
X#define NRF_SECTION_VARS_REGISTER_VAR(section_name, section_var)     static section_var __attribute__ ((section(#section_name))) __attribute__((used))
N
N#elif defined(__GNUC__)
S
S#define NRF_SECTION_VARS_REGISTER_VAR(section_name, section_var) \
S    static section_var __attribute__ ((section("."#section_name))) __attribute__((used))
X#define NRF_SECTION_VARS_REGISTER_VAR(section_name, section_var)     static section_var __attribute__ ((section("."#section_name))) __attribute__((used))
S
S#elif defined(__ICCARM__)
S
S#define NRF_SECTION_VARS_REGISTER_VAR(section_name, section_var) \
S    __root section_var @ #section_name
X#define NRF_SECTION_VARS_REGISTER_VAR(section_name, section_var)     __root section_var @ #section_name
S
N#endif
N
N
N/**@brief   Macro to retrieve a variable from a section.
N *
N * @warning     The stored symbol can only be resolved using this macro if the
N *              type of the data is word aligned. The operation of acquiring
N *              the stored symbol relies on sizeof of the stored type, no
N *              padding can exist in the named section in between individual
N *              stored items or this macro will fail.
N *
N * @param[in]   i               Index of the variable in section.
N * @param[in]   data_type       Data type of the variable.
N * @param[in]   section_name    Name of the section.
N */
N#if defined(__CC_ARM)
X#if 1L
N
N#define NRF_SECTION_VARS_GET(i, data_type, section_name) \
N    (data_type*)(NRF_SECTION_VARS_START_ADDR(section_name) + i * sizeof(data_type))
X#define NRF_SECTION_VARS_GET(i, data_type, section_name)     (data_type*)(NRF_SECTION_VARS_START_ADDR(section_name) + i * sizeof(data_type))
N
N#elif defined(__GNUC__)
S
S#define NRF_SECTION_VARS_GET(i, data_type, section_name) \
S    (data_type*)(NRF_SECTION_VARS_START_ADDR(section_name) + i * sizeof(data_type))
X#define NRF_SECTION_VARS_GET(i, data_type, section_name)     (data_type*)(NRF_SECTION_VARS_START_ADDR(section_name) + i * sizeof(data_type))
S
S#elif defined(__ICCARM__)
S
S#define NRF_SECTION_VARS_GET(i, data_type, section_name) \
S    (data_type*)(NRF_SECTION_VARS_START_ADDR(section_name) + i * sizeof(data_type))
X#define NRF_SECTION_VARS_GET(i, data_type, section_name)     (data_type*)(NRF_SECTION_VARS_START_ADDR(section_name) + i * sizeof(data_type))
S
N#endif
N
N
N/**@brief   Macro to get number of variables registered in a section.
N *
N * @param[in]   data_type       Data type of the variables in the section.
N * @param[in]   section_name    Name of the section.
N */
N#define NRF_SECTION_VARS_COUNT(data_type, section_name) \
N    NRF_SECTION_VARS_LENGTH(section_name) / sizeof(data_type)
X#define NRF_SECTION_VARS_COUNT(data_type, section_name)     NRF_SECTION_VARS_LENGTH(section_name) / sizeof(data_type)
N
N/** @} */
N
N
N//lint -restore Illegal character (0x24)
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // SECTION_VARS_H__
L 27 "..\..\..\..\..\..\components\libraries\fstorage\fstorage.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**@brief   fstorage return values. */
Ntypedef enum
N{
N    FS_SUCCESS,
N    FS_ERR_NOT_INITIALIZED,     //!< Error. The module is not initialized.
N    FS_ERR_INVALID_CFG,         //!< Error. Invalid fstorage configuration.
N    FS_ERR_NULL_ARG,            //!< Error. Argument is NULL.
N    FS_ERR_INVALID_ARG,         //!< Error. Argument contains invalid data.
N    FS_ERR_INVALID_ADDR,        //!< Error. Address out of bounds.
N    FS_ERR_UNALIGNED_ADDR,      //!< Error. Unaligned address.
N    FS_ERR_QUEUE_FULL,          //!< Error. Queue is full.
N    FS_ERR_OPERATION_TIMEOUT,   //!< Error. The operation has timed out.
N    FS_ERR_INTERNAL,            //!< Error. Internal error.
N    FS_ERR_FAILURE_SINCE_LAST   //!< Error. Uncleared error since last call
N} fs_ret_t;
N
N
N/**@brief   fstorage event IDs. */
Ntypedef enum
N{
N    FS_EVT_STORE,   //!< Event for @ref fs_store.
N    FS_EVT_ERASE    //!< Event for @ref fs_erase.
N} fs_evt_id_t;
N
N
N#if defined(__CC_ARM)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined(__ICCARM__)
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
N#endif
N
N/**@brief   An fstorage event. */
Ntypedef struct
N{
N    fs_evt_id_t id;                         //!< The event ID.
N    void *      p_context;                  //!< User-defined context passed to the interrupt handler.
N    union
N    {
N        struct
N        {
N            uint32_t const * p_data;        //!< Pointer to the data stored in flash.
N            uint16_t         length_words;  //!< Length of the data, in 4-byte words.
N        } store;
N        struct
N        {
N            uint16_t first_page;            //!< First page erased.
N            uint16_t last_page;             //!< Last page erased.
N        } erase;
N    };
N} fs_evt_t;
N
N#if defined(__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined(__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
N#endif
N
N
N/**@brief   fstorage event handler function prototype.
N *
N * @param[in]   evt     The event.
N * @param[in]   result  The result of the operation.
N */
Ntypedef void (*fs_cb_t)(fs_evt_t const * const evt, fs_ret_t result);
N
N
N/**@brief   fstorage application-specific configuration.
N *
N * @details Specifies the callback to invoke when an operation completes, the number of flash pages
N *          requested by the application and the priority with which these are to be assigned, with
N *          respect to other applications. Additionally, the configuration specifies the boundaries
N *          of the flash space assigned to an application. The configuration must be provided as an
N *          argument when invoking @ref fs_store and @ref fs_erase.
N *
N * @note    The fields @p p_start_addr and @p p_end_address are set by @ref fs_init, based on the
N *          value of the field @p priority.
N */
Ntypedef struct
N{
N    /**@brief   The beginning of the flash space assigned to the application which registered this
N     *          configuration. This field is set by @ref fs_init. It can also be set manually.
N     */
N    uint32_t const * p_start_addr;
N
N    /**@brief   The end of the flash space assigned to the application which registered this
N     *          configuration. This field is set by @ref fs_init. It can also be set manually.
N     */
N    uint32_t const * p_end_addr;
N
N    fs_cb_t  const   callback;    //!< Callback to run when a flash operation has completed.
N    uint8_t  const   num_pages;   //!< The number of flash pages requested.
N
N    /**@brief   The priority with which fstorage should assign flash pages to this application,
N     *          with respect to other applications. Applications with higher priority will be
N     *          assigned flash pages with a higher memory address. The highest priority is
N     *          reserved. Must be unique among configurations.
N     */
N    uint8_t  const   priority;
N} fs_config_t;
N
N
N/**@brief   Macro for registering an fstorage configuration variable.
N *          Applications which use fstorage must register with the module using this macro.
N *          Registering involves defining a variable which holds the configuration of fstorage
N *          specific to the application which invokes the macro.
N *
N * @details This macro places the configuration variable in a section named "fs_data" that
N *          fstorage uses during initialization and regular operation.
N *
N * @param[in]   cfg_var     A @e definition of a @ref fs_config_t variable.
N */
N#define FS_REGISTER_CFG(cfg_var) NRF_SECTION_VARS_REGISTER_VAR(fs_data, cfg_var)
N
N
N/**@brief   Function for initializing the module.
N *
N * @details This functions assigns pages in flash according to all registered configurations.
N *
N * @retval  FS_SUCCESS    If the module was successfully initialized.
N */
Nfs_ret_t fs_init(void);
N
N
Nfs_ret_t fs_fake_init(void);
N
Nbool fs_check_addr(uint32_t const * const p_dest, uint32_t const * const p_src);
X_Bool fs_check_addr(uint32_t const * const p_dest, uint32_t const * const p_src);
N
N/**@brief   Function for storing data in flash.
N *
N * @details Copies @p length_words words from @p p_src to the location pointed by @p p_dest.
N *          If the length of the data exceeds @ref FS_MAX_WRITE_SIZE_WORDS, the data will be
N *          written down in several chunks, as necessary. Only one event will be sent to the
N *          application upon completion. Both the source and the destination of the data must be
N *          word aligned. This function is asynchronous, completion is reported via an event sent
N *          the the callback function specified in the supplied configuration.
N *
N * @warning The data to be written to flash has to be kept in memory until the operation has
N *          terminated, i.e., an event is received.
N *
N * @param[in]   p_config        fstorage configuration registered by the application.
N * @param[in]   p_dest          The address in flash memory where to store the data.
N * @param[in]   p_src           Pointer to the data to store in flash.
N * @param[in]   length_words    Length of the data to store, in words.
N * @param[in]   p_context       User-defined context passed to the interrupt handler.
N *
N * @retval  FS_SUCCESS              If the operation was queued successfully.
N * @retval  FS_ERR_NOT_INITIALIZED  If the module is not initialized.
N * @retval  FS_ERR_INVALID_CFG      If @p p_config is NULL or contains invalid data.
N * @retval  FS_ERR_NULL_ARG         If @p p_dest or @p p_src are NULL.
N * @retval  FS_ERR_INVALID_ARG      If @p length_words is zero.
N * @retval  FS_ERR_INVALID_ADDR     If @p p_dest or @p p_src are outside of the flash memory
N *                                  boundaries specified in @p p_config.
N * @retval  FS_ERR_UNALIGNED_ADDR   If @p p_dest or @p p_src are not aligned to a word boundary.
N * @retval  FS_ERR_QUEUE_FULL       If the internal operation queue is full.
N */
Nfs_ret_t fs_store(fs_config_t const * const p_config,
N                  uint32_t    const * const p_dest,
N                  uint32_t    const * const p_src,
N                  uint16_t                  length_words,
N                  void *                    p_context);
N
N
N/**@brief   Function for erasing flash pages.
N *
N * @details Starting from the page at @p p_page_addr, erases @p num_pages flash pages.
N *          @p p_page_addr must be aligned to a page boundary. All pages to be erased must be
N *          within the bounds specified in the supplied fstorage configuration.
N *          This function is asynchronous. Completion is reported via an event.
N *
N * @param[in]   p_config        fstorage configuration registered by the application.
N * @param[in]   p_page_addr     Address of the page to erase. Must be aligned to a page boundary.
N * @param[in]   num_pages       Number of pages to erase. May not be zero.
N * @param[in]   p_context       User-defined context passed to the interrupt handler.
N *
N * @retval  FS_SUCCESS              If the operation was queued successfully.
N * @retval  FS_ERR_NOT_INITIALIZED  If the module is not initialized.
N * @retval  FS_ERR_INVALID_CFG      If @p p_config is NULL or contains invalid data.
N * @retval  FS_ERR_NULL_ARG         If @p p_page_addr is NULL.
N * @retval  FS_ERR_INVALID_ARG      If @p num_pages is zero.
N * @retval  FS_ERR_INVALID_ADDR     If the operation would go beyond the flash memory boundaries
N *                                  specified in @p p_config.
N * @retval  FS_ERR_UNALIGNED_ADDR   If @p p_page_addr is not aligned to a page boundary.
N * @retval  FS_ERR_QUEUE_FULL       If the internal operation queue is full.
N */
Nfs_ret_t fs_erase(fs_config_t const * const p_config,
N                  uint32_t    const * const p_page_addr,
N                  uint16_t                  num_pages,
N                  void *                    p_context);
N
N
N/**@brief Function for retrieving the number of queued flash operations.
N *
N * @param[out]  p_op_count    The number of queued flash operations.
N *
N * @retval  FS_SUCCESS          If the number of queued operations was retrieved successfully.
N * @retval  FS_ERR_NULL_ARG     If @p p_op_count is NULL.
N */
Nfs_ret_t fs_queued_op_count_get(uint32_t * const p_op_count);
N
N
N/**@brief   Function for handling system events from the SoftDevice.
N *
N * @details If any of the modules used by the application rely on fstorage, the application should
N *          dispatch system events to fstorage using this function.
N *
N * @param[in]   sys_evt     System event from the SoftDevice.
N */
Nvoid fs_sys_event_handler(uint32_t sys_evt);
N
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // FSTORAGE_H__
L 47 "..\..\..\main.c" 2
N#include "ble_conn_state.h"
L 1 "..\..\..\..\..\..\components\ble\common\ble_conn_state.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**
N * @file
N *
N * @defgroup ble_conn_state Connection state
N * @ingroup ble_sdk_lib
N * @{
N * @brief Module for storing data on BLE connections.
N *
N * @details This module stores certain states for each connection, which can be queried by
N *          connection handle. The module uses BLE events to keep the states updated.
N *
N *          In addition to the preprogrammed states, this module can also keep track of a number of
N *          binary user states, or <i>user flags</i>. These are reset to 0 for new connections, but
N *          otherwise not touched by this module.
N *
N *          This module uses the @ref sdk_mapped_flags module, with connection handles as keys and
N *          the connection states as flags.
N *
N * @note A connection handle is not immediately invalidated when it is disconnected. Certain states,
N *       such as the role, can still be queried until the next time a new connection is established
N *       to any device.
N *
N *          To function properly, this module must be provided with BLE events from the SoftDevice
N *          through the @ref ble_conn_state_on_ble_evt() function. This module should be the first
N *          to receive BLE events if they are dispatched to multiple modules.
N */
N
N#ifndef BLE_CONN_STATE_H__
N#define BLE_CONN_STATE_H__
N
N#include <stdbool.h>
N#include <stdint.h>
N#include "ble.h"
N#include "sdk_mapped_flags.h"
L 1 "..\..\..\..\..\..\components\libraries\util\sdk_mapped_flags.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#ifndef SDK_MAPPED_FLAGS_H__
N#define SDK_MAPPED_FLAGS_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "app_util.h"
N#include "compiler_abstraction.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @file
N * @defgroup sdk_mapped_flags Mapped flags
N * @ingroup app_common
N * @{
N * @brief Module for writing and reading flags that are associated
N *        with keys.
N *
N * @details The flags are represented as bits in a bitmap called a <i>flag collection</i>. The keys
N *          are uint16_t. Each flag collection contains all flags of the same type, one flag for
N *          each key.
N *
N *          The mapped flags module does not keep the flag states, nor the list of keys. These are
N *          provided in the API calls. A key's index in the key list determines which bit in the
N *          flag collection is associated with it. This module does not ever edit the key list, and
N *          does not edit flags except in function calls that take the flag collection as a pointer.
N *
N */
N
N#define SDK_MAPPED_FLAGS_N_KEYS          8       /**< The number of keys to keep flags for. This is also the number of flags in a flag collection. If changing this value, you might also need change the width of the sdk_mapped_flags_t type. */
N#define SDK_MAPPED_FLAGS_N_KEYS_PER_BYTE 8       /**< The number of flags that fit in one byte. */
N#define SDK_MAPPED_FLAGS_INVALID_INDEX   0xFFFF  /**< A flag index guaranteed to be invalid. */
N
Ntypedef uint8_t sdk_mapped_flags_t; /**< The bitmap to hold flags. Each flag is one bit, and each bit represents the flag state associated with one key. */
N
N
N// Test whether the flag collection type is large enough to hold all the flags. If this fails,
N// reduce SDK_MAPPED_FLAGS_N_KEYS or increase the size of sdk_mapped_flags_t.
NSTATIC_ASSERT((
N    sizeof(sdk_mapped_flags_t) * SDK_MAPPED_FLAGS_N_KEYS_PER_BYTE) >= SDK_MAPPED_FLAGS_N_KEYS);
X;enum { assert_line_53 = 1 / (! !(( sizeof(sdk_mapped_flags_t) * 8) >= 8)) };
N
N
N/**@brief Type used to present a subset of the registered keys.
N */
Ntypedef struct
N{
N    uint32_t len;                                 /**< The length of the list. */
N    uint16_t flag_keys[SDK_MAPPED_FLAGS_N_KEYS];  /**< The list of keys. */
X    uint16_t flag_keys[8];   
N} sdk_mapped_flags_key_list_t;
N
N
N/**@brief Function for getting the first index at which the flag is true in the provided
N *        collection.
N *
N * @param[in]  flags   The flag collection to search for a flag set to true.
N *
N * @return  The first index that has its flag set to true. If none were found, the
N *          function returns @ref SDK_MAPPED_FLAGS_INVALID_INDEX.
N */
Nuint16_t sdk_mapped_flags_first_key_index_get(sdk_mapped_flags_t flags);
N
N
N/**@brief Function for updating the state of a flag.
N *
N * @param[in]  p_keys   The list of associated keys (assumed to have a length of
N *                      @ref SDK_MAPPED_FLAGS_N_KEYS).
N * @param[out] p_flags  The flag collection to modify.
N * @param[in]  key      The key to modify the flag of.
N * @param[in]  value    The state to set the flag to.
N */
Nvoid sdk_mapped_flags_update_by_key(uint16_t           * p_keys,
N                                    sdk_mapped_flags_t * p_flags,
N                                    uint16_t             key,
N                                    bool                 value);
X                                    _Bool                 value);
N
N
N/**@brief Function for updating the state of the same flag in multiple flag collections.
N *
N * @details The key and value are the same for all flag collections in the p_flags array.
N *
N * @param[in]  p_keys              The list of associated keys (assumed to have a length of
N *                                 @ref SDK_MAPPED_FLAGS_N_KEYS).
N * @param[out] p_flags             The flag collections to modify.
N * @param[out] n_flag_collections  The number of flag collections in p_flags.
N * @param[in]  key                 The key to modify the flag of.
N * @param[in]  value               The state to set the flag to.
N */
Nvoid sdk_mapped_flags_bulk_update_by_key(uint16_t           * p_keys,
N                                         sdk_mapped_flags_t * p_flags,
N                                         uint32_t             n_flag_collections,
N                                         uint16_t             key,
N                                         bool                 value);
X                                         _Bool                 value);
N
N
N/**@brief Function for getting the state of a specific flag.
N *
N * @param[in]  p_keys  The list of associated keys (assumed to have a length of
N *                     @ref SDK_MAPPED_FLAGS_N_KEYS).
N * @param[in]  flags   The flag collection to read from.
N * @param[in]  key     The key to get the flag for.
N *
N * @return  The state of the flag.
N */
Nbool sdk_mapped_flags_get_by_key(uint16_t * p_keys, sdk_mapped_flags_t flags, uint16_t key);
X_Bool sdk_mapped_flags_get_by_key(uint16_t * p_keys, sdk_mapped_flags_t flags, uint16_t key);
N
N
N/**@brief Function for getting a list of all keys that have a specific flag set to true.
N *
N * @param[in]  p_keys  The list of associated keys (assumed to have a length of
N *                     @ref SDK_MAPPED_FLAGS_N_KEYS).
N * @param[in]  flags   The flag collection to search.
N *
N * @return  The list of keys.
N */
Nsdk_mapped_flags_key_list_t sdk_mapped_flags_key_list_get(uint16_t           * p_keys,
N                                                          sdk_mapped_flags_t   flags);
N
N
N/**@brief Function for getting the number of keys that have a specific flag set to true.
N *
N * @param[in]  flags  The flag collection to search.
N *
N * @return  The number of keys.
N */
Nuint32_t sdk_mapped_flags_n_flags_set(sdk_mapped_flags_t flags);
N
N
N/**@brief Function for querying whether any flags in the collection are set.
N *
N * @param[in]  flags  The flag collection to query.
N *
N * @retval  true If one or more flags are set to true.
N * @retval  false Otherwise.
N */
Nstatic __INLINE bool sdk_mapped_flags_any_set(sdk_mapped_flags_t flags)
Xstatic __inline _Bool sdk_mapped_flags_any_set(sdk_mapped_flags_t flags)
N{
N    return (flags != 0);
N}
N
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SDK_MAPPED_FLAGS_H__ */
L 47 "..\..\..\..\..\..\components\ble\common\ble_conn_state.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**@brief Connection handle statuses.
N */
Ntypedef enum
N{
N    BLE_CONN_STATUS_INVALID,       /**< The connection handle is invalid. */
N    BLE_CONN_STATUS_DISCONNECTED,  /**< The connection handle refers to a connection that has been disconnected, but not yet invalidated. */
N    BLE_CONN_STATUS_CONNECTED,     /**< The connection handle refers to an active connection. */
N} ble_conn_state_status_t;
N
N#define BLE_CONN_STATE_N_USER_FLAGS 24  /**< The number of available user flags. */
N
N
N/**@brief One ID for each user flag collection.
N *
N * @details These IDs are used to identify user flag collections in the API calls.
N */
Ntypedef enum
N{
N    BLE_CONN_STATE_USER_FLAG0 = 0,
N    BLE_CONN_STATE_USER_FLAG1,
N    BLE_CONN_STATE_USER_FLAG2,
N    BLE_CONN_STATE_USER_FLAG3,
N    BLE_CONN_STATE_USER_FLAG4,
N    BLE_CONN_STATE_USER_FLAG5,
N    BLE_CONN_STATE_USER_FLAG6,
N    BLE_CONN_STATE_USER_FLAG7,
N    BLE_CONN_STATE_USER_FLAG8,
N    BLE_CONN_STATE_USER_FLAG9,
N    BLE_CONN_STATE_USER_FLAG10,
N    BLE_CONN_STATE_USER_FLAG11,
N    BLE_CONN_STATE_USER_FLAG12,
N    BLE_CONN_STATE_USER_FLAG13,
N    BLE_CONN_STATE_USER_FLAG14,
N    BLE_CONN_STATE_USER_FLAG15,
N    BLE_CONN_STATE_USER_FLAG16,
N    BLE_CONN_STATE_USER_FLAG17,
N    BLE_CONN_STATE_USER_FLAG18,
N    BLE_CONN_STATE_USER_FLAG19,
N    BLE_CONN_STATE_USER_FLAG20,
N    BLE_CONN_STATE_USER_FLAG21,
N    BLE_CONN_STATE_USER_FLAG22,
N    BLE_CONN_STATE_USER_FLAG23,
N    BLE_CONN_STATE_USER_FLAG_INVALID,
N} ble_conn_state_user_flag_id_t;
N
N
N/**
N * @defgroup ble_conn_state_functions BLE connection state functions
N * @{
N */
N
N
N/**@brief Function for initializing or resetting the module.
N *
N * @details This function sets all states to their default, removing all records of connection handles.
N */
Nvoid ble_conn_state_init(void);
N
N
N/**@brief Function for providing BLE SoftDevice events to the connection state module.
N *
N * @param[in]  p_ble_evt    The SoftDevice event.
N */
Nvoid ble_conn_state_on_ble_evt(ble_evt_t * p_ble_evt);
N
N
N/**@brief Function for querying whether a connection handle represents a valid connection.
N *
N * @details A connection might be valid and have a BLE_CONN_STATUS_DISCONNECTED status.
N *          Those connections are invalidated after a new connection occurs.
N *
N * @param[in]  conn_handle  Handle of the connection.
N *
N * @retval true   If conn_handle represents a valid connection, thus a connection for which
N                  we have a record.
N * @retval false  If conn_handle is @ref BLE_GAP_ROLE_INVALID, or if it has never been recorded.
N */
Nbool ble_conn_state_valid(uint16_t conn_handle);
X_Bool ble_conn_state_valid(uint16_t conn_handle);
N
N
N/**@brief Function for querying the role of the local device in a connection.
N *
N * @param[in]  conn_handle  Handle of the connection to get the role for.
N *
N * @return  The role of the local device in the connection (see @ref BLE_GAP_ROLES).
N *          If conn_handle is not valid, the function returns BLE_GAP_ROLE_INVALID.
N */
Nuint8_t ble_conn_state_role(uint16_t conn_handle);
N
N
N/**@brief Function for querying the status of a connection.
N *
N * @param[in]  conn_handle  Handle of the connection.
N *
N * @return  The status of the connection.
N *          If conn_handle is not valid, the function returns BLE_CONN_STATE_INVALID.
N */
Nble_conn_state_status_t ble_conn_state_status(uint16_t conn_handle);
N
N
N/**@brief Function for querying whether a connection is encrypted.
N *
N * @param[in]  conn_handle  Handle of connection to get the encryption state for.
N *
N * @retval true   If the connection is encrypted.
N * @retval false  If the connection is not encrypted or conn_handle is invalid.
N */
Nbool ble_conn_state_encrypted(uint16_t conn_handle);
X_Bool ble_conn_state_encrypted(uint16_t conn_handle);
N
N
N/**@brief Function for querying whether a connection encryption is protected from Man in the Middle
N *        attacks.
N *
N * @param[in]  conn_handle  Handle of connection to get the MITM state for.
N *
N * @retval true   If the connection is encrypted with MITM protection.
N * @retval false  If the connection is not encrypted, or encryption is not MITM protected, or
N *                conn_handle is invalid.
N */
Nbool ble_conn_state_mitm_protected(uint16_t conn_handle);
X_Bool ble_conn_state_mitm_protected(uint16_t conn_handle);
N
N
N/**@brief Function for querying the total number of connections.
N *
N * @return  The total number of valid connections for which the module has a record.
N */
Nuint32_t ble_conn_state_n_connections(void);
N
N
N/**@brief Function for querying the total number of connections in which the role of the local
N *        device is @ref BLE_GAP_ROLE_CENTRAL.
N *
N * @return  The number of connections in which the role of the local device is
N *          @ref BLE_GAP_ROLE_CENTRAL.
N */
Nuint32_t ble_conn_state_n_centrals(void);
N
N
N/**@brief Function for querying the total number of connections in which the role of the local
N *        device is @ref BLE_GAP_ROLE_PERIPH.
N *
N * @return  The number of connections in which the role of the local device is
N *          @ref BLE_GAP_ROLE_PERIPH.
N */
Nuint32_t ble_conn_state_n_peripherals(void);
N
N
N/**@brief Function for obtaining a list of all connection handles for which the module has a record.
N *
N * @details This function takes into account connections whose state is BLE_CONN_STATUS_DISCONNECTED.
N *
N * @return  A list of all valid connection handles for which the module has a record.
N */
Nsdk_mapped_flags_key_list_t ble_conn_state_conn_handles(void);
N
N
N/**@brief Function for obtaining a list of connection handles in which the role of the local
N *        device is @ref BLE_GAP_ROLE_CENTRAL.
N *
N * @details This function takes into account connections whose state is BLE_CONN_STATUS_DISCONNECTED.
N *
N * @return  A list of all valid connection handles for which the module has a record and in which
N *          the role of local device is @ref BLE_GAP_ROLE_CENTRAL.
N */
Nsdk_mapped_flags_key_list_t ble_conn_state_central_handles(void);
N
N
N/**@brief Function for obtaining the handle for the connection in which the role of the local device
N *        is @ref BLE_GAP_ROLE_PERIPH.
N *
N * @details This function takes into account connections whose state is BLE_CONN_STATUS_DISCONNECTED.
N *
N * @return  A list of all valid connection handles for which the module has a record and in which
N *          the role of local device is @ref BLE_GAP_ROLE_PERIPH.
N */
Nsdk_mapped_flags_key_list_t ble_conn_state_periph_handles(void);
N
N
N/**@brief Function for obtaining exclusive access to one of the user flag collections.
N *
N * @details The acquired collection contains one flag for each connection. These flags can be set
N *          and read individually for each connection.
N *
N *          The state of user flags will not be modified by the connection state module, except to
N *          set it to 0 for a connection when that connection is invalidated.
N *
N * @return  The ID of the acquired flag, or BLE_CONN_STATE_USER_FLAG_INVALID if none are available.
N */
Nble_conn_state_user_flag_id_t ble_conn_state_user_flag_acquire(void);
N
N
N/**@brief Function for reading the value of a user flag.
N *
N * @param[in]  conn_handle  Handle of connection to get the flag state for.
N * @param[in]  flag_id      Which flag to get the state for.
N *
N * @return  The state of the flag. If conn_handle is invalid, the function returns false.
N */
Nbool ble_conn_state_user_flag_get(uint16_t conn_handle, ble_conn_state_user_flag_id_t flag_id);
X_Bool ble_conn_state_user_flag_get(uint16_t conn_handle, ble_conn_state_user_flag_id_t flag_id);
N
N
N/**@brief Function for setting the value of a user flag.
N *
N * @param[in]  conn_handle  Handle of connection to set the flag state for.
N * @param[in]  flag_id      Which flag to set the state for.
N * @param[in]  value        Value to set the flag state to.
N */
Nvoid ble_conn_state_user_flag_set(uint16_t                      conn_handle,
N                                  ble_conn_state_user_flag_id_t flag_id,
N                                  bool                          value);
X                                  _Bool                          value);
N
N
N/**@brief Function for getting the state of a user flag for all connection handles.
N *
N * @details The returned collection can be used with the @ref sdk_mapped_flags API. The returned
N *          collection is a copy, so modifying it has no effect on the conn_state module.
N *
N * @param[in]  flag_id  Which flag to get states for.
N *
N * @return  The collection of flag states. The collection is always all zeros when the flag_id is
N *          unregistered.
N */
Nsdk_mapped_flags_t ble_conn_state_user_flag_collection(ble_conn_state_user_flag_id_t flag_id);
N
N/** @} */
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* BLE_CONN_STATE_H__ */
L 48 "..\..\..\main.c" 2
N#include "bsp.h"
L 1 "..\..\..\..\..\bsp\bsp.h" 1
N/* Copyright (c) 2014 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**@file
N *
N * @defgroup bsp Board Support Package
N * @{
N * @ingroup app_common
N *
N * @brief BSP module.
N * @details This module provides a layer of abstraction from the board.
N *          It allows the user to indicate certain states on LEDs in a simple way.
N *          Module functionality can be modified by additional defines:
N *          - BSP_SIMPLE reduces functionality of this module to enable
N *            and read state of the buttons
N *          - BSP_UART_SUPPORT enables support for UART
N */
N
N#ifndef BSP_H__
N#define BSP_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "boards.h"
N
N#if !defined(BSP_DEFINES_ONLY) && !defined(BSP_SIMPLE)
X#if !0L && !0L
N#include "app_button.h"
L 1 "..\..\..\..\..\..\components\libraries\button\app_button.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup app_button Button Handler
N * @{
N * @ingroup app_common
N *
N * @brief Buttons handling module.
N *
N * @details The button handler uses the @ref app_gpiote to detect that a button has been
N *          pushed. To handle debouncing, it will start a timer in the GPIOTE event handler.
N *          The button will only be reported as pushed if the corresponding pin is still active when
N *          the timer expires. If there is a new GPIOTE event while the timer is running, the timer
N *          is restarted.
N *
N * @note    The app_button module uses the app_timer module. The user must ensure that the queue in
N *          app_timer is large enough to hold the app_timer_stop() / app_timer_start() operations
N *          which will be executed on each event from GPIOTE module (2 operations), as well as other
N *          app_timer operations queued simultaneously in the application.
N *
N * @note    Even if the scheduler is not used, app_button.h will include app_scheduler.h, so when
N *          compiling, app_scheduler.h must be available in one of the compiler include paths.
N */
N
N#ifndef APP_BUTTON_H__
N#define APP_BUTTON_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "nrf.h"
N#include "app_error.h"
N#include "nrf_gpio.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define APP_BUTTON_PUSH        1                               /**< Indicates that a button is pushed. */
N#define APP_BUTTON_RELEASE     0                               /**< Indicates that a button is released. */
N#define APP_BUTTON_ACTIVE_HIGH 1                               /**< Indicates that a button is active high. */
N#define APP_BUTTON_ACTIVE_LOW  0                               /**< Indicates that a button is active low. */
N
N/**@brief Button event handler type. */
Ntypedef void (*app_button_handler_t)(uint8_t pin_no, uint8_t button_action);
N
N/**@brief Button configuration structure. */
Ntypedef struct
N{
N    uint8_t              pin_no;           /**< Pin to be used as a button. */
N    uint8_t              active_state;     /**< APP_BUTTON_ACTIVE_HIGH or APP_BUTTON_ACTIVE_LOW. */
N    nrf_gpio_pin_pull_t  pull_cfg;         /**< Pull-up or -down configuration. */
N    app_button_handler_t button_handler;   /**< Handler to be called when button is pushed. */
N} app_button_cfg_t;
N
N/**@brief  Pin transition direction struct. */
Ntypedef struct
N{
N    uint32_t high_to_low;   /**Pin went from high to low */
N    uint32_t low_to_high;   /**Pin went from low to high */
N} pin_transition_t;
N
N/**@brief Function for initializing the Buttons.
N *
N * @details This function will initialize the specified pins as buttons, and configure the Button
N *          Handler module as a GPIOTE user (but it will not enable button detection).
N *
N * @note Normally initialization should be done using the APP_BUTTON_INIT() macro
N *
N * @note app_button_enable() function must be called in order to enable the button detection.
N *
N * @param[in]  p_buttons           Array of buttons to be used (NOTE: Must be static!).
N * @param[in]  button_count        Number of buttons.
N * @param[in]  detection_delay     Delay from a GPIOTE event until a button is reported as pushed.
N *
N * @return   NRF_SUCCESS on success, otherwise an error code.
N */
Nuint32_t app_button_init(app_button_cfg_t const *       p_buttons,
N                         uint8_t                        button_count,
N                         uint32_t                       detection_delay);
N
N/**@brief Function for enabling button detection.
N *
N * @retval NRF_SUCCESS Module successfully enabled.
N */
Nuint32_t app_button_enable(void);
N
N/**@brief Function for disabling button detection.
N *
N * @retval  NRF_SUCCESS               Button detection successfully disabled. Error code otherwise.
N */
Nuint32_t app_button_disable(void);
N
N/**@brief Function for checking if a button is currently being pushed.
N *
N * @param[in]  button_id     Button index (in the app_button_cfg_t array given to app_button_init) to be checked.
N * @param[out] p_is_pushed   Button state.
N *
N * @retval     NRF_SUCCESS               State successfully read.
N * @retval     NRF_ERROR_INVALID_PARAM   Invalid button index.
N */
Nuint32_t app_button_is_pushed(uint8_t button_id, bool * p_is_pushed);
Xuint32_t app_button_is_pushed(uint8_t button_id, _Bool * p_is_pushed);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_BUTTON_H__
N
N/** @} */
L 37 "..\..\..\..\..\bsp\bsp.h" 2
N
N#define BSP_BUTTON_ACTION_PUSH      (APP_BUTTON_PUSH)    /**< Represents pushing a button. See @ref bsp_button_action_t. */
N#define BSP_BUTTON_ACTION_RELEASE   (APP_BUTTON_RELEASE) /**< Represents releasing a button. See @ref bsp_button_action_t. */
N#define BSP_BUTTON_ACTION_LONG_PUSH (2)                  /**< Represents pushing and holding a button for @ref BSP_LONG_PUSH_TIMEOUT_MS milliseconds. See also @ref bsp_button_action_t. */
N#endif
N
N/* BSP_UART_SUPPORT
N * This define enables UART support module.
N */
N#ifdef BSP_UART_SUPPORT
S#include "app_uart.h"
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
N#endif // BSP_UART_SUPPORT
N
N#define BUTTON_ERASE_BONDING BSP_BUTTON_0_MASK
N#define BUTTON_ERASE_ALL     BSP_BUTTON_1_MASK
N#define BUTTON_ADVERTISE     BSP_BUTTON_0_MASK
N#define BUTTON_CLEAR_EVT     BSP_BUTTON_1_MASK
N#define BUTTON_CAPSLOCK      BSP_BUTTON_2_MASK
N#define BSP_BUTTONS_ALL      0xFFFFFFFF
N#define BSP_BUTTONS_NONE     0
N
N/**@brief Types of BSP initialization.
N */
N#define BSP_INIT_NONE    0        /**< This define specifies the type of initialization without support for LEDs and buttons (@ref bsp_init).*/
N#define BSP_INIT_LED     (1 << 0) /**< This bit enables LEDs during initialization (@ref bsp_init).*/
N#define BSP_INIT_BUTTONS (1 << 1) /**< This bit enables buttons during initialization (@ref bsp_init).*/
N
N#define BSP_LONG_PUSH_TIMEOUT_MS (1000) /**< The time to hold for a long push (in milliseconds). */
N
Ntypedef uint8_t bsp_button_action_t; /**< The different actions that can be performed on a button. */
N
N#define BSP_INDICATIONS_LIST {                    \
N        "BSP_INDICATE_IDLE\r\n",                  \
N        "BSP_INDICATE_SCANNING\r\n",              \
N        "BSP_INDICATE_ADVERTISING\r\n",           \
N        "BSP_INDICATE_ADVERTISING_WHITELIST\r\n", \
N        "BSP_INDICATE_ADVERTISING_SLOW\r\n",      \
N        "BSP_INDICATE_ADVERTISING_DIRECTED\r\n",  \
N        "BSP_INDICATE_BONDING\r\n",               \
N        "BSP_INDICATE_CONNECTED\r\n",             \
N        "BSP_INDICATE_SENT_OK\r\n",               \
N        "BSP_INDICATE_SEND_ERROR\r\n",            \
N        "BSP_INDICATE_RCV_OK\r\n",                \
N        "BSP_INDICATE_RCV_ERROR\r\n",             \
N        "BSP_INDICATE_FATAL_ERROR\r\n",           \
N        "BSP_INDICATE_ALERT_0\r\n",               \
N        "BSP_INDICATE_ALERT_1\r\n",               \
N        "BSP_INDICATE_ALERT_2\r\n",               \
N        "BSP_INDICATE_ALERT_3\r\n",               \
N        "BSP_INDICATE_ALERT_OFF\r\n",             \
N        "BSP_INDICATE_USER_STATE_OFF\r\n",        \
N        "BSP_INDICATE_USER_STATE_0\r\n",          \
N        "BSP_INDICATE_USER_STATE_1\r\n",          \
N        "BSP_INDICATE_USER_STATE_2\r\n",          \
N        "BSP_INDICATE_USER_STATE_3\r\n",          \
N        "BSP_INDICATE_USER_STATE_ON\r\n"          \
N} /**< See @ref examples_bsp_states for a list of how these states are indicated for the PCA10028/PCA10040 board and the PCA10031 dongle.*/
X#define BSP_INDICATIONS_LIST {                            "BSP_INDICATE_IDLE\r\n",                          "BSP_INDICATE_SCANNING\r\n",                      "BSP_INDICATE_ADVERTISING\r\n",                   "BSP_INDICATE_ADVERTISING_WHITELIST\r\n",         "BSP_INDICATE_ADVERTISING_SLOW\r\n",              "BSP_INDICATE_ADVERTISING_DIRECTED\r\n",          "BSP_INDICATE_BONDING\r\n",                       "BSP_INDICATE_CONNECTED\r\n",                     "BSP_INDICATE_SENT_OK\r\n",                       "BSP_INDICATE_SEND_ERROR\r\n",                    "BSP_INDICATE_RCV_OK\r\n",                        "BSP_INDICATE_RCV_ERROR\r\n",                     "BSP_INDICATE_FATAL_ERROR\r\n",                   "BSP_INDICATE_ALERT_0\r\n",                       "BSP_INDICATE_ALERT_1\r\n",                       "BSP_INDICATE_ALERT_2\r\n",                       "BSP_INDICATE_ALERT_3\r\n",                       "BSP_INDICATE_ALERT_OFF\r\n",                     "BSP_INDICATE_USER_STATE_OFF\r\n",                "BSP_INDICATE_USER_STATE_0\r\n",                  "BSP_INDICATE_USER_STATE_1\r\n",                  "BSP_INDICATE_USER_STATE_2\r\n",                  "BSP_INDICATE_USER_STATE_3\r\n",                  "BSP_INDICATE_USER_STATE_ON\r\n"          }  
N
N
N/**@brief BSP indication states.
N *
N * @details See @ref examples_bsp_states for a list of how these states are indicated for the PCA10028/PCA10040 board and the PCA10031 dongle.
N */
Ntypedef enum
N{
N    BSP_INDICATE_FIRST = 0,
N    BSP_INDICATE_IDLE  = BSP_INDICATE_FIRST, /**< See \ref BSP_INDICATE_IDLE.*/
N    BSP_INDICATE_SCANNING,                   /**< See \ref BSP_INDICATE_SCANNING.*/
N    BSP_INDICATE_ADVERTISING,                /**< See \ref BSP_INDICATE_ADVERTISING.*/
N    BSP_INDICATE_ADVERTISING_WHITELIST,      /**< See \ref BSP_INDICATE_ADVERTISING_WHITELIST.*/
N    BSP_INDICATE_ADVERTISING_SLOW,           /**< See \ref BSP_INDICATE_ADVERTISING_SLOW.*/
N    BSP_INDICATE_ADVERTISING_DIRECTED,       /**< See \ref BSP_INDICATE_ADVERTISING_DIRECTED.*/
N    BSP_INDICATE_BONDING,                    /**< See \ref BSP_INDICATE_BONDING.*/
N    BSP_INDICATE_CONNECTED,                  /**< See \ref BSP_INDICATE_CONNECTED.*/
N    BSP_INDICATE_SENT_OK,                    /**< See \ref BSP_INDICATE_SENT_OK.*/
N    BSP_INDICATE_SEND_ERROR,                 /**< See \ref BSP_INDICATE_SEND_ERROR.*/
N    BSP_INDICATE_RCV_OK,                     /**< See \ref BSP_INDICATE_RCV_OK.*/
N    BSP_INDICATE_RCV_ERROR,                  /**< See \ref BSP_INDICATE_RCV_ERROR.*/
N    BSP_INDICATE_FATAL_ERROR,                /**< See \ref BSP_INDICATE_FATAL_ERROR.*/
N    BSP_INDICATE_ALERT_0,                    /**< See \ref BSP_INDICATE_ALERT_0.*/
N    BSP_INDICATE_ALERT_1,                    /**< See \ref BSP_INDICATE_ALERT_1.*/
N    BSP_INDICATE_ALERT_2,                    /**< See \ref BSP_INDICATE_ALERT_2.*/
N    BSP_INDICATE_ALERT_3,                    /**< See \ref BSP_INDICATE_ALERT_3.*/
N    BSP_INDICATE_ALERT_OFF,                  /**< See \ref BSP_INDICATE_ALERT_OFF.*/
N    BSP_INDICATE_USER_STATE_OFF,             /**< See \ref BSP_INDICATE_USER_STATE_OFF.*/
N    BSP_INDICATE_USER_STATE_0,               /**< See \ref BSP_INDICATE_USER_STATE_0.*/
N    BSP_INDICATE_USER_STATE_1,               /**< See \ref BSP_INDICATE_USER_STATE_1.*/
N    BSP_INDICATE_USER_STATE_2,               /**< See \ref BSP_INDICATE_USER_STATE_2.*/
N    BSP_INDICATE_USER_STATE_3,               /**< See \ref BSP_INDICATE_USER_STATE_3.*/
N    BSP_INDICATE_USER_STATE_ON,              /**< See \ref BSP_INDICATE_USER_STATE_ON.*/
N    BSP_INDICATE_LAST = BSP_INDICATE_USER_STATE_ON
N} bsp_indication_t;
N
N/**@brief BSP events.
N *
N * @note Events from BSP_EVENT_KEY_0 to BSP_EVENT_KEY_LAST are by default assigned to buttons.
N */
Ntypedef enum
N{
N    BSP_EVENT_NOTHING = 0,                  /**< Assign this event to an action to prevent the action from generating an event (disable the action). */
N    BSP_EVENT_DEFAULT,                      /**< Assign this event to an action to assign the default event to the action. */
N    BSP_EVENT_CLEAR_BONDING_DATA,           /**< Persistent bonding data should be erased. */
N    BSP_EVENT_CLEAR_ALERT,                  /**< An alert should be cleared. */
N    BSP_EVENT_DISCONNECT,                   /**< A link should be disconnected. */
N    BSP_EVENT_ADVERTISING_START,            /**< The device should start advertising. */
N    BSP_EVENT_ADVERTISING_STOP,             /**< The device should stop advertising. */
N    BSP_EVENT_WHITELIST_OFF,                /**< The device should remove its advertising whitelist. */
N    BSP_EVENT_BOND,                         /**< The device should bond to the currently connected peer. */
N    BSP_EVENT_RESET,                        /**< The device should reset. */
N    BSP_EVENT_SLEEP,                        /**< The device should enter sleep mode. */
N    BSP_EVENT_WAKEUP,                       /**< The device should wake up from sleep mode. */
N    BSP_EVENT_DFU,                          /**< The device should enter DFU mode. */
N    BSP_EVENT_KEY_0,                        /**< Default event of the push action of BSP_BUTTON_0 (only if this button is present). */
N    BSP_EVENT_KEY_1,                        /**< Default event of the push action of BSP_BUTTON_1 (only if this button is present). */
N    BSP_EVENT_KEY_2,                        /**< Default event of the push action of BSP_BUTTON_2 (only if this button is present). */
N    BSP_EVENT_KEY_3,                        /**< Default event of the push action of BSP_BUTTON_3 (only if this button is present). */
N    BSP_EVENT_KEY_4,                        /**< Default event of the push action of BSP_BUTTON_4 (only if this button is present). */
N    BSP_EVENT_KEY_5,                        /**< Default event of the push action of BSP_BUTTON_5 (only if this button is present). */
N    BSP_EVENT_KEY_6,                        /**< Default event of the push action of BSP_BUTTON_6 (only if this button is present). */
N    BSP_EVENT_KEY_7,                        /**< Default event of the push action of BSP_BUTTON_7 (only if this button is present). */
N    BSP_EVENT_KEY_LAST = BSP_EVENT_KEY_7,
N} bsp_event_t;
N
N
Ntypedef struct
N{
N    bsp_event_t push_event;      /**< The event to fire on regular button press. */
N    bsp_event_t long_push_event; /**< The event to fire on long button press. */
N    bsp_event_t release_event;   /**< The event to fire on button release. */
N} bsp_button_event_cfg_t;
N
N/**@brief BSP module event callback function type.
N *
N * @details     Upon an event in the BSP module, this callback function will be called to notify
N *              the application about the event.
N *
N * @param[in]   bsp_event_t BSP event type.
N */
Ntypedef void (* bsp_event_callback_t)(bsp_event_t);
N
N/**@brief       Function for initializing BSP.
N *
N * @details     The function initializes the board support package to allow state indication and
N *              button reaction. Default events are assigned to buttons.
N * @note        Before calling this function, you must initiate the following required modules:
N *              - @ref app_timer for LED support
N *              - @ref app_gpiote for button support
N *              - @ref app_uart for UART support
N *
N * @param[in]   type               Type of peripherals used.
N * @param[in]   ticks_per_100ms    Number of RTC ticks for 100 ms.
N * @param[in]   callback           Function to be called when button press/event is detected.
N *
N * @retval      NRF_SUCCESS               If the BSP module was successfully initialized.
N * @retval      NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized.
N * @retval      NRF_ERROR_NO_MEM          If the maximum number of timers has already been reached.
N * @retval      NRF_ERROR_INVALID_PARAM   If GPIOTE has too many users.
N * @retval      NRF_ERROR_INVALID_STATE   If button or GPIOTE has not been initialized.
N */
Nuint32_t bsp_init(uint32_t type, uint32_t ticks_per_100ms, bsp_event_callback_t callback);
N
N/**@brief       Function for getting buttons states.
N *
N * @details     This function allows to get the state of all buttons.
N *
N * @param[in]   p_buttons_state          This variable will store buttons state. Button 0 state is
N *                                       represented by bit 0 (1=pressed), Button 1 state by bit 1,
N *                                       and so on.
N *
N * @retval      NRF_SUCCESS              If buttons state was successfully read.
N */
Nuint32_t bsp_buttons_state_get(uint32_t * p_buttons_state);
N
N/**@brief       Function for checking buttons states.
N *
N * @details     This function checks if the button is pressed. If the button ID iss out of range,
N *              the function returns false.
N *
N * @param[in]   button                   Button ID to check.
N * @param[in]   p_state                  This variable will store the information whether the
N *                                       specified button is pressed (true) or not.
N *
N * @retval      NRF_SUCCESS              If the button state was successfully read.
N */
Nuint32_t bsp_button_is_pressed(uint32_t button, bool * p_state);
Xuint32_t bsp_button_is_pressed(uint32_t button, _Bool * p_state);
N
N/**@brief       Function for assigning a specific event to a button.
N *
N * @details     This function allows redefinition of standard events assigned to buttons.
N *              To unassign events, provide the event @ ref BSP_EVENT_NOTHING.
N *
N * @param[in]   button                   Button ID to be redefined.
N * @param[in]   action                   Button action to assign event to.
N * @param[in]   event                    Event to be assigned to button.
N *
N * @retval      NRF_SUCCESS              If the event was successfully assigned to button.
N * @retval      NRF_ERROR_INVALID_PARAM  If the button ID or button action was invalid.
N */
Nuint32_t bsp_event_to_button_action_assign(uint32_t button, bsp_button_action_t action, bsp_event_t event);
N
N/**@brief       Function for configuring indicators to required state.
N *
N * @details     This function indicates the required state by means of LEDs (if enabled).
N *
N * @note        Alerts are indicated independently.
N *
N * @param[in]   indicate   State to be indicated.
N *
N * @retval      NRF_SUCCESS               If the state was successfully indicated.
N * @retval      NRF_ERROR_NO_MEM          If the internal timer operations queue was full.
N * @retval      NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized,
N *                                        or internal timer has not been created.
N */
Nuint32_t bsp_indication_set(bsp_indication_t indicate);
N
N/**@brief       Function for configuring indicators to required state.
N *
N * @details     This function indicates the required state by means of LEDs (if enabled)
N *              and UART (if enabled).
N *
N * @note        Alerts are indicated independently.
N *
N * @param[in]   indicate   State to be indicated.
N * @param[in]   p_text     Text to be output on UART.
N *
N * @retval      NRF_SUCCESS               If the state was successfully indicated.
N * @retval      NRF_ERROR_NO_MEM          If the internal timer operations queue was full.
N * @retval      NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized,
N *                                        or timer has not been created.
N */
Nuint32_t bsp_indication_text_set(bsp_indication_t indicate, const char * p_text);
N
N
N/**@brief       Function for enabling all buttons.
N *
N * @details     After calling this function, all buttons will generate events when pressed, and
N *              all buttons will be able to wake the system up from sleep mode.
N *
N * @retval      NRF_SUCCESS              If the buttons were successfully enabled.
N * @retval      NRF_ERROR_NOT_SUPPORTED  If the board has no buttons or BSP_SIMPLE is defined.
N * @return      A propagated error.
N */
Nuint32_t bsp_buttons_enable(void);
N
N
N/**@brief       Function for disabling all buttons.
N *
N * @details     After calling this function, no buttons will generate events when pressed, and
N *              no buttons will be able to wake the system up from sleep mode.
N *
N * @retval      NRF_SUCCESS              If the buttons were successfully disabled.
N * @retval      NRF_ERROR_NOT_SUPPORTED  If the board has no buttons or BSP_SIMPLE is defined.
N * @return      A propagated error.
N */
Nuint32_t bsp_buttons_disable(void);
N
N
N/**@brief       Function for configuring wakeup buttons before going into sleep mode.
N *
N * @details     After calling this function, only the buttons that are set to 1 in wakeup_buttons
N *              can be used to wake up the chip. If this function is not called before going to,
N *              sleep either all or no buttons can wake up the chip.
N *
N * This function should only be called immediately before going into sleep.
N *
N * @param[in]   wakeup_buttons  Mask describing which buttons should be able to wake up the chip.
N *
N * @retval      NRF_SUCCESS              If the buttons were successfully enabled.
N * @retval      NRF_ERROR_NOT_SUPPORTED  If the board has no buttons or BSP_SIMPLE is defined.
N */
Nuint32_t bsp_wakeup_buttons_set(uint32_t wakeup_buttons);
N
N/**@brief       Function for configuring the NFCT peripheral as a wakeup source.
N *
N * @details     This function must be called before going to sleep, otherwise NFCT will not be
N *              able to wake up the chip.
N * @note        You can use this function only if NFCT is not used for other purposes than
N *              wakeup.
N *
N * This function should only be called immediately before going into sleep.
N *
N * @retval      NRF_SUCCESS              If NFCT peripheral was successfully enabled.
N * @retval      NRF_ERROR_NOT_SUPPORTED  If the board has no NFCT peripheral or NRF52 is not defined.
N */
Nuint32_t bsp_wakeup_nfc_set(void);
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // BSP_H__
N
N/** @} */
L 49 "..\..\..\main.c" 2
N#include "bsp_btn_ble.h"
L 1 "..\..\..\..\..\bsp\bsp_btn_ble.h" 1
N/* Copyright (c) 2014 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**@file
N *
N * @defgroup bsp_btn_ble BSP: BLE Button Module
N * @{
N * @ingroup bsp
N *
N * @brief Module for controlling BLE behavior through button actions.
N *
N * @details The application must propagate BLE events to the BLE Button Module.
N * Based on these events, the BLE Button Module configures the Board Support Package
N * to generate BSP events for certain button actions. These BSP events should then be
N * handled by the application's BSP event handler.
N *
N */
N
N#ifndef BSP_BTN_BLE_H__
N#define BSP_BTN_BLE_H__
N
N#include <stdint.h>
N#include "ble.h"
N#include "bsp.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**@brief BLE Button Module error handler type. */
Ntypedef void (*bsp_btn_ble_error_handler_t) (uint32_t nrf_error);
N
N/**@brief Function for initializing the BLE Button Module.
N *
N * Before calling this function, the BSP module must be initialized with buttons.
N *
N * @param[out] error_handler      Error handler to call in case of internal errors in BLE Button
N *                                Module.
N * @param[out] p_startup_bsp_evt  If not a NULL pointer, the value is filled with an event
N *                                (or BSP_EVENT_NOTHING) derived from the buttons pressed on
N *                                startup. For example, if the bond delete wakeup button was pressed
N *                                to wake up the device, *p_startup_bsp_evt is set to
N *                                @ref BSP_EVENT_CLEAR_BONDING_DATA.
N *
N * @retval NRF_SUCCESS  If initialization was successful. Otherwise, a propagated error code is
N *                      returned.
N */
Nuint32_t bsp_btn_ble_init(bsp_btn_ble_error_handler_t error_handler, bsp_event_t * p_startup_bsp_evt);
N
N/**@brief Function for setting up wakeup buttons before going into sleep mode.
N *
N * @retval NRF_SUCCESS  If the buttons were prepared successfully. Otherwise, a propagated error
N *                      code is returned.
N */
Nuint32_t bsp_btn_ble_sleep_mode_prepare(void);
N
N/**@brief Function for handling the application's BLE stack events.
N *
N * @details This function handles all events from the BLE stack that are of interest to this module.
N *
N * @param[in] p_ble_evt BLE stack event.
N */
Nvoid bsp_btn_ble_on_ble_evt(ble_evt_t * p_ble_evt);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* BSP_BTN_BLE_H__ */
N
N/** @} */
L 50 "..\..\..\main.c" 2
N#include "service_if.h"
L 1 "..\..\..\service_if.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#ifndef BLE_DS_IF_H__
N#define BLE_DS_IF_H__
N
N#include <stdint.h>
N#include "ble.h"
N#include "ble_bas.h"
L 1 "..\..\..\ble_bas.h" 1
N/* This file was generated by plugin 'Nordic Semiconductor nRF5x v.1.2.2' (BDS version 1.1.3066.0) */
N
N#ifndef BLE_BAS_H__
N#define BLE_BAS_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "ble.h"
N#include "ble_srv_common.h"
N#include "app_util_bds.h"
L 1 "..\..\..\..\..\..\components\libraries\util\app_util_bds.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup app_util Utility Functions and Definitions
N * @{
N * @ingroup app_common
N *
N * @brief Various types and definitions available to all applications.
N */
N
N#ifndef APP_UTIL_BDS_H__
N#define APP_UTIL_BDS_H__
N
N#include <stdint.h>
N#include <string.h>
N#include <stdbool.h>
N#include "compiler_abstraction.h"
N#include "app_util.h"
N#include "ble_srv_common.h"
N#include "nordic_common.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
Ntypedef uint8_t nibble_t;
Ntypedef uint32_t uint24_t;
Ntypedef uint64_t uint40_t;
N
N/**@brief IEEE 11073-20601 Regulatory Certification Data List Structure */
Ntypedef struct
N{
N    uint8_t *  p_list;                                          /**< Pointer the byte array containing the encoded opaque structure based on IEEE 11073-20601 specification. */
N    uint8_t    list_len;                                        /**< Length of the byte array. */
N} regcertdatalist_t;
N
N/**@brief SFLOAT format (IEEE-11073 16-bit FLOAT, meaning 4 bits for exponent (base 10) and 12 bits mantissa) */
Ntypedef struct
N{
N  int8_t exponent;                                             /**< Base 10 exponent, should be using only 4 bits */
N  int16_t mantissa;                                            /**< Mantissa, should be using only 12 bits */
N} sfloat_t;
N
N/**@brief Date and Time structure. */
Ntypedef struct
N{
N    uint16_t year;
N    uint8_t  month;
N    uint8_t  day;
N    uint8_t  hours;
N    uint8_t  minutes;
N    uint8_t  seconds;
N} ble_date_time_t;
N
N
N/**@brief Function for encoding a uint16 value.
N *
N * @param[in]   p_value          Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t bds_uint16_encode(const uint16_t * p_value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t bds_uint16_encode(const uint16_t * p_value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((*p_value & 0x00FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((*p_value & 0xFF00) >> 8);
N    return sizeof(uint16_t);
N}
N
Nstatic __INLINE uint8_t bds_int16_encode(const int16_t * p_value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t bds_int16_encode(const int16_t * p_value, uint8_t * p_encoded_data)
N{
N    uint16_t tmp = *p_value;
N    return bds_uint16_encode(&tmp, p_encoded_data);
N}
N
N/**@brief Function for encoding a uint24 value.
N *
N * @param[in]   p_value          Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t bds_uint24_encode(const uint32_t * p_value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t bds_uint24_encode(const uint32_t * p_value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((*p_value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((*p_value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((*p_value & 0x00FF0000) >> 16);
N    return (3);
N}
N
N
N/**@brief Function for encoding a uint32 value.
N *
N * @param[in]   p_value          Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t bds_uint32_encode(const uint32_t * p_value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t bds_uint32_encode(const uint32_t * p_value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((*p_value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((*p_value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((*p_value & 0x00FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((*p_value & 0xFF000000) >> 24);
N    return sizeof(uint32_t);
N}
N
N
N/**@brief Function for encoding a uint40 value.
N *
N * @param[in]   p_value          Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t bds_uint40_encode(const uint64_t * p_value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t bds_uint40_encode(const uint64_t * p_value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((*p_value & 0x00000000000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((*p_value & 0x000000000000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((*p_value & 0x0000000000FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((*p_value & 0x00000000FF000000) >> 24);
N    p_encoded_data[4] = (uint8_t) ((*p_value & 0x000000FF00000000) >> 32);
N    return 5;
N}
N
N/**@brief Function for encoding a sfloat value.
N *
N * @param[in]   p_value          Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t bds_sfloat_encode(const sfloat_t * p_value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t bds_sfloat_encode(const sfloat_t * p_value, uint8_t * p_encoded_data)
N{
N    uint16_t encoded_val;
N
N    encoded_val = ((p_value->exponent << 12) & 0xF000) |
N                            ((p_value->mantissa <<  0) & 0x0FFF);
N
N    return(bds_uint16_encode(&encoded_val, p_encoded_data));
N}
N
N
N/**@brief Function for encoding a uint8_array value.
N *
N * @param[in]   p_value          Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N */
Nstatic __INLINE uint8_t bds_uint8_array_encode(const uint8_array_t * p_value,
Xstatic __inline uint8_t bds_uint8_array_encode(const uint8_array_t * p_value,
N                                               uint8_t             * p_encoded_data)
N{
N    memcpy(p_encoded_data, p_value->p_data, p_value->size);
N    return p_value->size;
N}
N
N
N/**@brief Function for encoding a utf8_str value.
N *
N * @param[in]   p_value          Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N
N */
Nstatic __INLINE uint8_t bds_ble_srv_utf8_str_encode(const ble_srv_utf8_str_t * p_value,
Xstatic __inline uint8_t bds_ble_srv_utf8_str_encode(const ble_srv_utf8_str_t * p_value,
N                                                    uint8_t                  * p_encoded_data)
N{
N    memcpy(p_encoded_data, p_value->p_str, p_value->length);
N    return p_value->length;
N}
N
N/**@brief Function for encoding a regcertdatalist value.
N *
N * @param[in]   p_value          Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N
N */
Nstatic __INLINE uint8_t bds_regcertdatalist_encode(const regcertdatalist_t * p_value,
Xstatic __inline uint8_t bds_regcertdatalist_encode(const regcertdatalist_t * p_value,
N                                                   uint8_t                 * p_encoded_data)
N{
N    memcpy(p_encoded_data, p_value->p_list, p_value->list_len);
N    return p_value->list_len;
N}
N
N
N/**@brief Function for decoding a date_time value.
N *
N * @param[in]   p_date_time    pointer to the date_time structure to encode.
N * @param[in]   p_encoded_data pointer to the encoded data
N * @return      length of the encoded field.
N */
Nstatic __INLINE uint8_t bds_ble_date_time_encode(const ble_date_time_t * p_date_time,
Xstatic __inline uint8_t bds_ble_date_time_encode(const ble_date_time_t * p_date_time,
N                                                 uint8_t               * p_encoded_data)
N{
N    uint8_t len = bds_uint16_encode(&p_date_time->year, &p_encoded_data[0]);
N
N    p_encoded_data[len++] = p_date_time->month;
N    p_encoded_data[len++] = p_date_time->day;
N    p_encoded_data[len++] = p_date_time->hours;
N    p_encoded_data[len++] = p_date_time->minutes;
N    p_encoded_data[len++] = p_date_time->seconds;
N
N    return len;
N}
N
N
N/**@brief Function for decoding a uint16 value.
N *
N * @param[in]   len              length of the field to be decoded.
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N * @param[in]   p_decoded_val    pointer to the decoded value
N * @return      length of the decoded field.
N */
Nstatic __INLINE uint8_t bds_uint16_decode(const uint8_t len,
Xstatic __inline uint8_t bds_uint16_decode(const uint8_t len,
N                                          const uint8_t * p_encoded_data,
N                                          uint16_t      * p_decoded_val)
N{
N    UNUSED_VARIABLE(len);
X    ((void)(len));
N    *p_decoded_val = (((uint16_t)((uint8_t *)p_encoded_data)[0])) |
N                     (((uint16_t)((uint8_t *)p_encoded_data)[1]) << 8 );
N    return (sizeof(uint16_t));
N}
N
N
N/**@brief Function for decoding a int16 value.
N *
N * @param[in]   len              length of the field to be decoded.
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N * @param[in]   p_decoded_val    pointer to the decoded value
N * @return      length of the decoded field.
N */
Nstatic __INLINE uint8_t bds_int16_decode(const uint8_t len,
Xstatic __inline uint8_t bds_int16_decode(const uint8_t len,
N                                         const uint8_t * p_encoded_data,
N                                         int16_t       * p_decoded_val)
N{
N    UNUSED_VARIABLE(len);
X    ((void)(len));
N    uint16_t tmp = 0;
N    uint8_t retval = bds_uint16_decode(len, p_encoded_data, &tmp);
N    *p_decoded_val = (int16_t)tmp;
N    return retval;
N}
N
N
N/**@brief Function for decoding a uint24 value.
N *
N * @param[in]   len              length of the field to be decoded.
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N * @param[in]   p_decoded_val    pointer to the decoded value
N *
N * @return      length of the decoded field.
N */
Nstatic __INLINE uint8_t bds_uint24_decode(const uint8_t len,
Xstatic __inline uint8_t bds_uint24_decode(const uint8_t len,
N                                          const uint8_t * p_encoded_data,
N                                          uint32_t      * p_decoded_val)
N{
N    UNUSED_VARIABLE(len);
X    ((void)(len));
N    *p_decoded_val = (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N                     (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N                     (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16);
N    return (3);
N}
N
N
N/**@brief Function for decoding a uint32 value.
N *
N * @param[in]   len              length of the field to be decoded.
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N * @param[in]   p_decoded_val    pointer to the decoded value
N *
N * @return      length of the decoded field.
N */
Nstatic __INLINE uint8_t bds_uint32_decode(const uint8_t len,
Xstatic __inline uint8_t bds_uint32_decode(const uint8_t len,
N                                          const uint8_t * p_encoded_data,
N                                          uint32_t      * p_decoded_val)
N{
N    UNUSED_VARIABLE(len);
X    ((void)(len));
N    *p_decoded_val = (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N                     (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N                     (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N                     (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 24 );
N    return (sizeof(uint32_t));
N}
N
N
N/**@brief Function for decoding a uint40 value.
N *
N * @param[in]   len              length of the field to be decoded.
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N * @param[in]   p_decoded_val    pointer to the decoded value
N *
N * @return      length of the decoded field.
N */
Nstatic __INLINE uint8_t bds_uint40_decode(const uint8_t len,
Xstatic __inline uint8_t bds_uint40_decode(const uint8_t len,
N                                          const uint8_t * p_encoded_data,
N                                          uint64_t      * p_decoded_val)
N{
N    UNUSED_VARIABLE(len);
X    ((void)(len));
N    *p_decoded_val = (((uint64_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N                     (((uint64_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N                     (((uint64_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N                     (((uint64_t)((uint8_t *)p_encoded_data)[3]) << 24 )|
N                     (((uint64_t)((uint8_t *)p_encoded_data)[4]) << 32 );
N    return (40);
N}
N
N
N/**@brief Function for decoding a sfloat value.
N *
N * @param[in]   len              length of the field to be decoded.
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N * @param[in]   p_decoded_val    pointer to the decoded value
N *
N * @return      length of the decoded field.
N
N */
Nstatic __INLINE uint8_t bds_sfloat_decode(const uint8_t len,
Xstatic __inline uint8_t bds_sfloat_decode(const uint8_t len,
N                                          const uint8_t * p_encoded_data,
N                                          sfloat_t      * p_decoded_val)
N{
N
N    p_decoded_val->exponent = 0;
N    bds_uint16_decode(len, p_encoded_data, (uint16_t*)&p_decoded_val->mantissa);
N    p_decoded_val->exponent = (uint8_t)((p_decoded_val->mantissa & 0xF000) >> 12);
N    p_decoded_val->mantissa &= 0x0FFF;
N    return len;
N}
N
N
N/**@brief Function for decoding a uint8_array value.
N *
N * @param[in]   len              length of the field to be decoded.
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N * @param[in]   p_decoded_val    pointer to the decoded value
N *
N * @return      length of the decoded field.
N */
Nstatic __INLINE uint8_t bds_uint8_array_decode(const uint8_t len,
Xstatic __inline uint8_t bds_uint8_array_decode(const uint8_t len,
N                                               const uint8_t * p_encoded_data,
N                                               uint8_array_t * p_decoded_val)
N{
N    memcpy(p_decoded_val->p_data, p_encoded_data, len);
N    p_decoded_val->size = len;
N    return p_decoded_val->size;
N}
N
N
N/**@brief Function for decoding a utf8_str value.
N *
N * @param[in]   len              length of the field to be decoded.
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N * @param[in]   p_decoded_val    pointer to the decoded value
N *
N * @return      length of the decoded field.
N */
Nstatic __INLINE uint8_t bds_ble_srv_utf8_str_decode(const uint8_t      len,
Xstatic __inline uint8_t bds_ble_srv_utf8_str_decode(const uint8_t      len,
N                                                    const uint8_t      * p_encoded_data,
N                                                    ble_srv_utf8_str_t * p_decoded_val)
N{
N    p_decoded_val->p_str = (uint8_t*)p_encoded_data;
N    p_decoded_val->length = len;
N    return p_decoded_val->length;
N}
N
N
N/**@brief Function for decoding a regcertdatalist value.
N *
N * @param[in]   len              length of the field to be decoded.
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N * @param[in]   p_decoded_val    pointer to the decoded value
N *
N * @return      length of the decoded field.
N */
Nstatic __INLINE uint8_t bds_regcertdatalist_decode(const uint8_t     len,
Xstatic __inline uint8_t bds_regcertdatalist_decode(const uint8_t     len,
N                                                   const uint8_t     * p_encoded_data,
N                                                   regcertdatalist_t * p_decoded_val)
N{
N    memcpy(p_decoded_val->p_list, p_encoded_data, len);
N    p_decoded_val->list_len = len;
N    return p_decoded_val->list_len;
N}
N
N
N/**@brief Function for decoding a date_time value.
N *
N * @param[in]   len              length of the field to be decoded.
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N * @param[in]   p_date_time      pointer to the decoded value
N *
N * @return      length of the decoded field.
N */
Nstatic __INLINE uint8_t bds_ble_date_time_decode(const uint8_t   len,
Xstatic __inline uint8_t bds_ble_date_time_decode(const uint8_t   len,
N                                                 const uint8_t   * p_encoded_data,
N                                                 ble_date_time_t * p_date_time)
N{
N    UNUSED_VARIABLE(len);
X    ((void)(len));
N    uint8_t pos          = bds_uint16_decode(len, &p_encoded_data[0], &p_date_time->year);
N    p_date_time->month   = p_encoded_data[pos++];
N    p_date_time->day     = p_encoded_data[pos++];
N    p_date_time->hours   = p_encoded_data[pos++];
N    p_date_time->minutes = p_encoded_data[pos++];
N    p_date_time->seconds = p_encoded_data[pos++];
N
N    return pos;
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_UTIL_BDS_H__
N
N/** @} */
L 11 "..\..\..\ble_bas.h" 2
N
N
N
N/**@brief Battery Service event type. */
Ntypedef enum
N{ 
N    BLE_BAS_BATTERY_LEVEL_EVT_NOTIFICATION_ENABLED,  /**< Battery Level value notification enabled event. */
N    BLE_BAS_BATTERY_LEVEL_EVT_NOTIFICATION_DISABLED, /**< Battery Level value notification disabled event. */
N    BLE_BAS_BATTERY_LEVEL_EVT_CCCD_WRITE, /**< Battery Level CCCD write event. */
N} ble_bas_evt_type_t;
N
N// Forward declaration of the ble_bas_t type.
Ntypedef struct ble_bas_s ble_bas_t;
N
N
Ntypedef enum
N{ 
N    FORMAT_RESERVED_FOR_FUTURE_USE = 0, 
N    FORMAT_BOOLEAN = 1, 
N    FORMAT_UNSIGNED_2_BIT_INTEGER = 2, 
N    FORMAT_UNSIGNED_4_BIT_INTEGER = 3, 
N    FORMAT_UNSIGNED_8_BIT_INTEGER = 4, 
N    FORMAT_UNSIGNED_12_BIT_INTEGER = 5, 
N    FORMAT_UNSIGNED_16_BIT_INTEGER = 6, 
N    FORMAT_UNSIGNED_24_BIT_INTEGER = 7, 
N    FORMAT_UNSIGNED_32_BIT_INTEGER = 8, 
N    FORMAT_UNSIGNED_48_BIT_INTEGER = 9, 
N    FORMAT_UNSIGNED_64_BIT_INTEGER = 10, 
N    FORMAT_UNSIGNED_128_BIT_INTEGER = 11, 
N    FORMAT_SIGNED_8_BIT_INTEGER = 12, 
N    FORMAT_SIGNED_12_BIT_INTEGER = 13, 
N    FORMAT_SIGNED_16_BIT_INTEGER = 14, 
N    FORMAT_SIGNED_24_BIT_INTEGER = 15, 
N    FORMAT_SIGNED_32_BIT_INTEGER = 16, 
N    FORMAT_SIGNED_48_BIT_INTEGER = 17, 
N    FORMAT_SIGNED_64_BIT_INTEGER = 18, 
N    FORMAT_SIGNED_128_BIT_INTEGER = 19, 
N    FORMAT_IEEE_754_32_BIT_FLOATING_POINT = 20, 
N    FORMAT_IEEE_754_64_BIT_FLOATING_POINT = 21, 
N    FORMAT_IEEE_11073_16_BIT_SFLOAT = 22, 
N    FORMAT_IEEE_11073_32_BIT_FLOAT = 23, 
N    FORMAT_IEEE_20601_FORMAT = 24, 
N    FORMAT_UTF_8_STRING = 25, 
N    FORMAT_UTF_16_STRING = 26, 
N    FORMAT_OPAQUE_STRUCTURE = 27, 
N} enum_format_t;
N
Ntypedef struct
N{
N    enum_format_t format; 
N} bas_characteristic_presentation_format_format_t; 
Ntypedef enum
N{ 
N    NAMESPACE_BLUETOOTH_SIG_ASSIGNED_NUMBERS = 1, 
N} enum_namespace_t;
N
Ntypedef struct
N{
N    enum_namespace_t namespace; 
N} bas_characteristic_presentation_format_namespace_t; 
N
N
N/**@brief Characteristic Presentation Format structure. */
Ntypedef struct
N{
N    bas_characteristic_presentation_format_format_t format;
N    int8_t exponent;
N    uint16_t unit;
N    bas_characteristic_presentation_format_namespace_t namespace;
N    uint16_t description;
N} ble_bas_characteristic_presentation_format_t;
N
N
N
N
N
N/**@brief Battery Level structure. */
Ntypedef struct
N{
N    uint8_t level;
N    ble_bas_characteristic_presentation_format_t characteristic_presentation_format; 
N} ble_bas_battery_level_t;
N
N/**@brief Battery Service Service event. */
Ntypedef struct
N{
N    ble_bas_evt_type_t evt_type;    /**< Type of event. */
N    union {
N        uint16_t cccd_value; /**< Holds decoded data in Notify and Indicate event handler. */
N    } params;
N} ble_bas_evt_t;
N
N/**@brief Battery Service Service event handler type. */
Ntypedef void (*ble_bas_evt_handler_t) (ble_bas_t * p_bas, ble_bas_evt_t * p_evt);
N
N/**@brief Battery Service Service init structure. This contains all options and data needed for initialization of the service */
Ntypedef struct
N{
N    ble_bas_evt_handler_t     evt_handler; /**< Event handler to be called for handling events in the Battery Service Service. */
N    bool is_battery_level_notify_supported;    /**< TRUE if notification of Battery Level is supported. */
X    _Bool is_battery_level_notify_supported;     
N    ble_bas_battery_level_t ble_bas_battery_level_initial_value; /**< If not NULL, initial value of the Battery Level characteristic. */ 
N} ble_bas_init_t;
N
N/**@brief Battery Service Service structure. This contains various status information for the service.*/
Nstruct ble_bas_s
N{
N    ble_bas_evt_handler_t evt_handler; /**< Event handler to be called for handling events in the Battery Service Service. */
N    uint16_t service_handle; /**< Handle of Battery Service Service (as provided by the BLE stack). */
N    bool is_battery_level_notify_supported;    /**< TRUE if notification of Battery Level is supported. */
X    _Bool is_battery_level_notify_supported;     
N    ble_gatts_char_handles_t battery_level_handles; /**< Handles related to the Battery Level characteristic. */
N    ble_gatts_char_handles_t characteristic_presentation_format_handles; /**< Handles related to the Characteristic Presentation Format descriptor. */
N    uint16_t conn_handle; /**< Handle of the current connection (as provided by the BLE stack, is BLE_CONN_HANDLE_INVALID if not in a connection). */
N};
N
N/**@brief Function for initializing the Battery Service.
N *
N * @param[out]  p_bas       Battery Service Service structure. This structure will have to be supplied by
N *                          the application. It will be initialized by this function, and will later
N *                          be used to identify this particular service instance.
N * @param[in]   p_bas_init  Information needed to initialize the service.
N *
N * @return      NRF_SUCCESS on successful initialization of service, otherwise an error code.
N */
Nuint32_t ble_bas_init(ble_bas_t * p_bas, const ble_bas_init_t * p_bas_init);
N
N/**@brief Function for handling the Application's BLE Stack events.*/
Nvoid ble_bas_on_ble_evt(ble_bas_t * p_bas, ble_evt_t * p_ble_evt);
N
N/**@brief Function for setting the Battery Level.
N *
N * @details Sets a new value of the Battery Level characteristic. The new value will be sent
N *          to the client the next time the client reads the Battery Level characteristic.
N *          This function is only generated if the characteristic's Read property is not 'Excluded'.
N *
N * @param[in]   p_bas                 Battery Service Service structure.
N * @param[in]   p_battery_level  New Battery Level.
N *
N * @return      NRF_SUCCESS on success, otherwise an error code.
N */
Nuint32_t ble_bas_battery_level_set(ble_bas_t * p_bas, ble_bas_battery_level_t * p_battery_level);
N
N/**@brief Function for sending the Battery Level.
N *
N * @details The application calls this function after having performed a battery level.
N *          The battery level data is encoded and sent to the client.
N *          This function is only generated if the characteristic's Notify or Indicate property is not 'Excluded'.
N *
N * @param[in]   p_bas                    Battery Service Service structure.
N * @param[in]   p_battery_level               New battery level.
N *
N * @return      NRF_SUCCESS on success, otherwise an error code.
N */
Nuint32_t ble_bas_battery_level_send(ble_bas_t * p_bas, ble_bas_battery_level_t * p_battery_level);
N
N/**@brief Function for setting the Characteristic Presentation Format.
N *
N * @details Sets a new value of the Characteristic Presentation Format descriptor. The new value will be sent
N *          to the client the next time the client reads the Characteristic Presentation Format descriptor.
N *          This function is only generated if the descriptor's Read property is not 'Excluded'.
N *
N * @param[in]   p_bas                 Battery Service Service structure.
N * @param[in]   p_characteristic_presentation_format  New Characteristic Presentation Format.
N *
N * @return      NRF_SUCCESS on success, otherwise an error code.
N */
Nuint32_t ble_bas_characteristic_presentation_format_set(ble_bas_t * p_bas, ble_bas_characteristic_presentation_format_t * p_characteristic_presentation_format);
N
N#endif //_BLE_BAS_H__
L 19 "..\..\..\service_if.h" 2
N
N/**@brief Function for initializing the Services generated by Bluetooth Developer Studio.
N *
N *
N * @return      NRF_SUCCESS on successful initialization of services, otherwise an error code.
N */
Nuint32_t bluetooth_init(void);
N
N/**@brief Function for handling the Application's BLE Stack events.
N *
N * @details Handles all events from the BLE stack of interest to all Bluetooth Developer Studio generated Services.
N *
N * @param[in]   p_ble_evt  Event received from the BLE stack.
N */
Nvoid bluetooth_on_ble_evt(ble_evt_t * p_ble_evt);
N
Nble_bas_t* return_ble_bas_t(void);
N#endif // BLE_DS_IF_H__
N
N/** @} */
L 51 "..\..\..\main.c" 2
N#define NRF_LOG_MODULE_NAME "APP"
N#include "nrf_log.h"
L 1 "..\..\..\..\..\..\components\libraries\log\nrf_log.h" 1
N/* Copyright (c) 2016 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**@file
N *
N * @defgroup nrf_log Logger module
N * @{
N * @ingroup app_common
N *
N * @brief The nrf_log module interface.
N */
N
N#ifndef NRF_LOG_H_
N#define NRF_LOG_H_
N
N#include "sdk_config.h"
N
N/** @brief  Default module name prefix.
N *
N * The prefix can be defined in a module to override the default.
N */
N#ifndef NRF_LOG_MODULE_NAME
S    #define NRF_LOG_MODULE_NAME ""
N#endif
N
N/** @brief Severity level for the module.
N *
N * The severity level can be defined in a module to override the default.
N */
N#ifndef NRF_LOG_LEVEL
N    #define NRF_LOG_LEVEL NRF_LOG_DEFAULT_LEVEL
N#endif
N
N/** @brief  Color prefix of debug logs for the module.
N *
N * This color prefix can be defined in a module to override the default.
N */
N#ifndef NRF_LOG_DEBUG_COLOR
N    #define NRF_LOG_DEBUG_COLOR NRF_LOG_COLOR_DEFAULT
N#endif
N
N/** @brief  Color prefix of info logs for the module.
N *
N * This color prefix can be defined in a module to override the default.
N */
N#ifndef NRF_LOG_INFO_COLOR
N    #define NRF_LOG_INFO_COLOR NRF_LOG_COLOR_DEFAULT
N#endif
N
N#include "nrf_log_internal.h"
L 1 "..\..\..\..\..\..\components\libraries\log\src\nrf_log_internal.h" 1
N/* Copyright (c) 2016 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N#ifndef NRF_LOG_INTERNAL_H__
N#define NRF_LOG_INTERNAL_H__
N#include "sdk_config.h"
N#include "nrf.h"
N#include "nrf_error.h"
N#include "app_util.h"
N#include "nordic_common.h"
N#include <inttypes.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\inttypes.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Based on WG14/N843 (C9X) Committee Draft August 3, 1998 */
N
N#ifndef __inttypes_h
N#define __inttypes_h
N#define __ARMCLIB_VERSION 5060016
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N#include <stdint.h>
N
N#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) || 201103L <= __cplusplus
X#if !0L || 0L || 201103L <= __cplusplus
N
N#ifdef __LP64__
S  #define __PRISCN64 "l" /* 'int64_t' is 'long' */
N#else
N  #define __PRISCN64 "ll" /* 'int64_t' is 'long long' */
N#endif
N#if __sizeof_ptr == 8
X#if 4 == 8
S  #define __PRISCNPTR __PRISCN64 /* 'intptr_t' is 64-bits */
N#else
N  #define __PRISCNPTR /*nothing*/ /* 'intptr_t' is 'int' */
N#endif
N
N
N    /* 7.8.1 */
N
N#define PRId8         "d"
N#define PRId16        "d"
N#define PRId32        "d"
N#define PRId64      __PRISCN64 "d"
N#define PRIdLEAST8    "d"
N#define PRIdLEAST16   "d"
N#define PRIdLEAST32   "d"
N#define PRIdLEAST64 __PRISCN64 "d"
N#define PRIdFAST8     "d"
N#define PRIdFAST16    "d"
N#define PRIdFAST32    "d"
N#define PRIdFAST64  __PRISCN64 "d"
N#define PRIdMAX      "jd"
N#define PRIdPTR     __PRISCNPTR "d"
N
N#define PRIi8         "i"
N#define PRIi16        "i"
N#define PRIi32        "i"
N#define PRIi64      __PRISCN64 "i"
N#define PRIiLEAST8    "i"
N#define PRIiLEAST16   "i"
N#define PRIiLEAST32   "i"
N#define PRIiLEAST64 __PRISCN64 "i"
N#define PRIiFAST8     "i"
N#define PRIiFAST16    "i"
N#define PRIiFAST32    "i"
N#define PRIiFAST64  __PRISCN64 "i"
N#define PRIiMAX      "ji"
N#define PRIiPTR     __PRISCNPTR "i"
N
N#define PRIo8         "o"
N#define PRIo16        "o"
N#define PRIo32        "o"
N#define PRIo64      __PRISCN64 "o"
N#define PRIoLEAST8    "o"
N#define PRIoLEAST16   "o"
N#define PRIoLEAST32   "o"
N#define PRIoLEAST64 __PRISCN64 "o"
N#define PRIoFAST8     "o"
N#define PRIoFAST16    "o"
N#define PRIoFAST32    "o"
N#define PRIoFAST64  __PRISCN64 "o"
N#define PRIoMAX      "jo"
N#define PRIoPTR     __PRISCNPTR "o"
N
N#define PRIu8         "d"
N#define PRIu16        "d"
N#define PRIu32        "u"
N#define PRIu64      __PRISCN64 "u"
N#define PRIuLEAST8    "d"
N#define PRIuLEAST16   "d"
N#define PRIuLEAST32   "u"
N#define PRIuLEAST64 __PRISCN64 "u"
N#define PRIuFAST8     "u"
N#define PRIuFAST16    "u"
N#define PRIuFAST32    "u"
N#define PRIuFAST64  __PRISCN64 "u"
N#define PRIuMAX      "ju"
N#define PRIuPTR     __PRISCNPTR "u"
N
N#define PRIx8         "x"
N#define PRIx16        "x"
N#define PRIx32        "x"
N#define PRIx64      __PRISCN64 "x"
N#define PRIxLEAST8    "x"
N#define PRIxLEAST16   "x"
N#define PRIxLEAST32   "x"
N#define PRIxLEAST64 __PRISCN64 "x"
N#define PRIxFAST8     "x"
N#define PRIxFAST16    "x"
N#define PRIxFAST32    "x"
N#define PRIxFAST64  __PRISCN64 "x"
N#define PRIxMAX      "jx"
N#define PRIxPTR     __PRISCNPTR "x"
N
N#define PRIX8         "X"
N#define PRIX16        "X"
N#define PRIX32        "X"
N#define PRIX64      __PRISCN64 "X"
N#define PRIXLEAST8    "X"
N#define PRIXLEAST16   "X"
N#define PRIXLEAST32   "X"
N#define PRIXLEAST64 __PRISCN64 "X"
N#define PRIXFAST8     "X"
N#define PRIXFAST16    "X"
N#define PRIXFAST32    "X"
N#define PRIXFAST64  __PRISCN64 "X"
N#define PRIXMAX      "jX"
N#define PRIXPTR     __PRISCNPTR "X"
N
N#define SCNd8       "hhd"
N#define SCNd16       "hd"
N#define SCNd32        "d"
N#define SCNd64      __PRISCN64 "d"
N#define SCNdLEAST8  "hhd"
N#define SCNdLEAST16  "hd"
N#define SCNdLEAST32   "d"
N#define SCNdLEAST64 __PRISCN64 "d"
N#define SCNdFAST8     "d"
N#define SCNdFAST16    "d"
N#define SCNdFAST32    "d"
N#define SCNdFAST64  __PRISCN64 "d"
N#define SCNdMAX      "jd"
N#define SCNdPTR     __PRISCNPTR "d"
N
N#define SCNi8       "hhd"
N#define SCNi16       "hi"
N#define SCNi32        "i"
N#define SCNi64      __PRISCN64 "i"
N#define SCNiLEAST8  "hhi"
N#define SCNiLEAST16  "hi"
N#define SCNiLEAST32   "i"
N#define SCNiLEAST64 __PRISCN64 "i"
N#define SCNiFAST8     "i"
N#define SCNiFAST16    "i"
N#define SCNiFAST32    "i"
N#define SCNiFAST64  __PRISCN64 "i"
N#define SCNiMAX      "ji"
N#define SCNiPTR     __PRISCNPTR "i"
N
N#define SCNo8       "hho"
N#define SCNo16       "ho"
N#define SCNo32        "o"
N#define SCNo64      __PRISCN64 "o"
N#define SCNoLEAST8  "hho"
N#define SCNoLEAST16  "ho"
N#define SCNoLEAST32   "o"
N#define SCNoLEAST64 __PRISCN64 "o"
N#define SCNoFAST8     "o"
N#define SCNoFAST16    "o"
N#define SCNoFAST32    "o"
N#define SCNoFAST64  __PRISCN64 "o"
N#define SCNoMAX      "jo"
N#define SCNoPTR     __PRISCNPTR "o"
N
N#define SCNu8       "hhu"
N#define SCNu16       "hu"
N#define SCNu32        "u"
N#define SCNu64      __PRISCN64 "u"
N#define SCNuLEAST8  "hhu"
N#define SCNuLEAST16  "hu"
N#define SCNuLEAST32   "u"
N#define SCNuLEAST64 __PRISCN64 "u"
N#define SCNuFAST8     "u"
N#define SCNuFAST16    "u"
N#define SCNuFAST32    "u"
N#define SCNuFAST64  __PRISCN64 "u"
N#define SCNuMAX      "ju"
N#define SCNuPTR     __PRISCNPTR "u"
N
N#define SCNx8       "hhx"
N#define SCNx16       "hx"
N#define SCNx32        "x"
N#define SCNx64      __PRISCN64 "x"
N#define SCNxLEAST8  "hhx"
N#define SCNxLEAST16  "hx"
N#define SCNxLEAST32   "x"
N#define SCNxLEAST64 __PRISCN64 "x"
N#define SCNxFAST8     "x"
N#define SCNxFAST16    "x"
N#define SCNxFAST32    "x"
N#define SCNxFAST64  __PRISCN64 "x"
N#define SCNxMAX      "jx"
N#define SCNxPTR     __PRISCNPTR "x"
N
N#endif /* __STDC_FORMAT_MACROS */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* see <stddef.h> */
N    #else
N      typedef unsigned short wchar_t; /* see <stddef.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* see <stddef.h> */
S    #else
S      typedef unsigned short wchar_t; /* see <stddef.h> */
S    #endif
N  #endif
N#endif
N
Ntypedef struct imaxdiv_t { intmax_t quot, rem; } imaxdiv_t;
N   /* type of the value returned by the imaxdiv function. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N_ARMABI intmax_t strtoimax(const char * __restrict /*nptr*/,
X__declspec(__nothrow) intmax_t strtoimax(const char * __restrict  ,
N                   char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    /* as for strtol */
N_ARMABI uintmax_t strtoumax(const char * __restrict /*nptr*/,
X__declspec(__nothrow) uintmax_t strtoumax(const char * __restrict  ,
N                    char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    /* as for strtoul */
N
N_ARMABI intmax_t wcstoimax(const wchar_t * __restrict /*nptr*/,
X__declspec(__nothrow) intmax_t wcstoimax(const wchar_t * __restrict  ,
N                   wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N_ARMABI uintmax_t wcstoumax(const wchar_t * __restrict /*nptr*/,
X__declspec(__nothrow) uintmax_t wcstoumax(const wchar_t * __restrict  ,
N                    wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N
Nextern _ARMABI_PURE intmax_t imaxabs(intmax_t /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) intmax_t imaxabs(intmax_t  );
N   /*
N    * computes the absolute value of an intmax_t j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
Nextern _ARMABI_PURE imaxdiv_t imaxdiv(intmax_t /*numer*/, intmax_t /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) imaxdiv_t imaxdiv(intmax_t  , intmax_t  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type imaxdiv_t, comprising both the quotient and
N    *          the remainder. the structure shall contain the following
N    *          members, in either order.
N    *          intmax_t quot; intmax_t rem;
N    */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __inttypes_h */
N
N/* end of inttypes.h */
N
L 20 "..\..\..\..\..\..\components\libraries\log\src\nrf_log_internal.h" 2
N#include <stdbool.h>
N
N#ifndef NRF_LOG_DEFAULT_LEVEL
N#define NRF_LOG_DEFAULT_LEVEL 0
N#endif
N
N#ifndef NRF_LOG_USES_COLORS
N#define NRF_LOG_USES_COLORS        0
N#endif
N
N#define NRF_LOG_LEVEL_ERROR        1U
N#define NRF_LOG_LEVEL_WARNING      2U
N#define NRF_LOG_LEVEL_INFO         3U
N#define NRF_LOG_LEVEL_DEBUG        4U
N#define NRF_LOG_LEVEL_INTERNAL     5U
N#define NRF_LOG_LEVEL_MASK         0x07
N#define NRF_LOG_RAW_POS            4U
N#define NRF_LOG_RAW                (1U << NRF_LOG_RAW_POS)
N#define NRF_LOG_LEVEL_INFO_RAW     (NRF_LOG_RAW | NRF_LOG_LEVEL_INFO)
N
N
N#define NRF_LOG_COLOR_CODE_DEFAULT "\x1B[0m"
N#define NRF_LOG_COLOR_CODE_BLACK   "\x1B[1;30m"
N#define NRF_LOG_COLOR_CODE_RED     "\x1B[1;31m"
N#define NRF_LOG_COLOR_CODE_GREEN   "\x1B[1;32m"
N#define NRF_LOG_COLOR_CODE_YELLOW  "\x1B[1;33m"
N#define NRF_LOG_COLOR_CODE_BLUE    "\x1B[1;34m"
N#define NRF_LOG_COLOR_CODE_MAGENTA "\x1B[1;35m"
N#define NRF_LOG_COLOR_CODE_CYAN    "\x1B[1;36m"
N#define NRF_LOG_COLOR_CODE_WHITE   "\x1B[1;37m"
N
N#define NRF_LOG_COLOR_0            NRF_LOG_COLOR_CODE_DEFAULT
N#define NRF_LOG_COLOR_1            NRF_LOG_COLOR_CODE_BLACK
N#define NRF_LOG_COLOR_2            NRF_LOG_COLOR_CODE_RED
N#define NRF_LOG_COLOR_3            NRF_LOG_COLOR_CODE_GREEN
N#define NRF_LOG_COLOR_4            NRF_LOG_COLOR_CODE_YELLOW
N#define NRF_LOG_COLOR_5            NRF_LOG_COLOR_CODE_BLUE
N#define NRF_LOG_COLOR_6            NRF_LOG_COLOR_CODE_MAGENTA
N#define NRF_LOG_COLOR_7            NRF_LOG_COLOR_CODE_CYAN
N#define NRF_LOG_COLOR_8            NRF_LOG_COLOR_CODE_WHITE
N
N#define NRF_LOG_COLOR_DECODE(N) CONCAT_2(NRF_LOG_COLOR_, N)
N#if NRF_LOG_USES_COLORS
X#if 0
S#define NRF_LOG_ERROR_COLOR_CODE   NRF_LOG_COLOR_DECODE(NRF_LOG_ERROR_COLOR)
S#define NRF_LOG_WARNING_COLOR_CODE NRF_LOG_COLOR_DECODE(NRF_LOG_WARNING_COLOR)
S#define NRF_LOG_INFO_COLOR_CODE    NRF_LOG_COLOR_DECODE(NRF_LOG_INFO_COLOR)
S#define NRF_LOG_DEBUG_COLOR_CODE   NRF_LOG_COLOR_DECODE(NRF_LOG_DEBUG_COLOR)
N#else // NRF_LOG_USES_COLORS
N#define NRF_LOG_ERROR_COLOR_CODE
N#define NRF_LOG_WARNING_COLOR_CODE
N#define NRF_LOG_INFO_COLOR_CODE
N#define NRF_LOG_DEBUG_COLOR_CODE
N#endif // NRF_LOG_USES_COLORS
N
N#define LOG_INTERNAL_0(type, prefix, str) \
N    nrf_log_frontend_std_0(type, prefix str)
X#define LOG_INTERNAL_0(type, prefix, str)     nrf_log_frontend_std_0(type, prefix str)
N#define LOG_INTERNAL_1(type, prefix, str, arg0) \
N    nrf_log_frontend_std_1(type, prefix str, arg0)
X#define LOG_INTERNAL_1(type, prefix, str, arg0)     nrf_log_frontend_std_1(type, prefix str, arg0)
N#define LOG_INTERNAL_2(type, prefix, str, arg0, arg1) \
N    nrf_log_frontend_std_2(type, prefix str, arg0, arg1)
X#define LOG_INTERNAL_2(type, prefix, str, arg0, arg1)     nrf_log_frontend_std_2(type, prefix str, arg0, arg1)
N#define LOG_INTERNAL_3(type, prefix, str, arg0, arg1, arg2) \
N    nrf_log_frontend_std_3(type, prefix str, arg0, arg1, arg2)
X#define LOG_INTERNAL_3(type, prefix, str, arg0, arg1, arg2)     nrf_log_frontend_std_3(type, prefix str, arg0, arg1, arg2)
N#define LOG_INTERNAL_4(type, prefix, str, arg0, arg1, arg2, arg3) \
N    nrf_log_frontend_std_4(type, prefix str, arg0, arg1, arg2, arg3)
X#define LOG_INTERNAL_4(type, prefix, str, arg0, arg1, arg2, arg3)     nrf_log_frontend_std_4(type, prefix str, arg0, arg1, arg2, arg3)
N#define LOG_INTERNAL_5(type, prefix, str, arg0, arg1, arg2, arg3, arg4) \
N    nrf_log_frontend_std_5(type, prefix str, arg0, arg1, arg2, arg3, arg4)
X#define LOG_INTERNAL_5(type, prefix, str, arg0, arg1, arg2, arg3, arg4)     nrf_log_frontend_std_5(type, prefix str, arg0, arg1, arg2, arg3, arg4)
N#define LOG_INTERNAL_6(type, prefix, str, arg0, arg1, arg2, arg3, arg4, arg5) \
N    nrf_log_frontend_std_6(type, prefix str, arg0, arg1, arg2, arg3, arg4, arg5)
X#define LOG_INTERNAL_6(type, prefix, str, arg0, arg1, arg2, arg3, arg4, arg5)     nrf_log_frontend_std_6(type, prefix str, arg0, arg1, arg2, arg3, arg4, arg5)
N
N#define LOG_INTERNAL_X(N, ...)          CONCAT_2(LOG_INTERNAL_, N) (__VA_ARGS__)
N#define LOG_INTERNAL(type, prefix, ...) LOG_INTERNAL_X(NUM_VA_ARGS_LESS_1( \
N                                                           __VA_ARGS__), type, prefix, __VA_ARGS__)
X#define LOG_INTERNAL(type, prefix, ...) LOG_INTERNAL_X(NUM_VA_ARGS_LESS_1(                                                            __VA_ARGS__), type, prefix, __VA_ARGS__)
N
N#define NRF_LOG_BREAK      ":"
N
N#define LOG_ERROR_PREFIX   NRF_LOG_ERROR_COLOR_CODE NRF_LOG_MODULE_NAME NRF_LOG_BREAK "ERROR:"
N#define LOG_WARNING_PREFIX NRF_LOG_WARNING_COLOR_CODE NRF_LOG_MODULE_NAME NRF_LOG_BREAK "WARNING:"
N#define LOG_INFO_PREFIX    NRF_LOG_INFO_COLOR_CODE NRF_LOG_MODULE_NAME NRF_LOG_BREAK "INFO:"
N#define LOG_DEBUG_PREFIX   NRF_LOG_DEBUG_COLOR_CODE NRF_LOG_MODULE_NAME NRF_LOG_BREAK "DEBUG:"
N
N#define NRF_LOG_INTERNAL_ERROR(...)                                       \
N    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_ERROR) &&                         \
N        (NRF_LOG_LEVEL_ERROR <= NRF_LOG_DEFAULT_LEVEL))                   \
N    {                                                                     \
N        LOG_INTERNAL(NRF_LOG_LEVEL_ERROR, LOG_ERROR_PREFIX, __VA_ARGS__); \
N    }
X#define NRF_LOG_INTERNAL_ERROR(...)                                           if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_ERROR) &&                                 (NRF_LOG_LEVEL_ERROR <= NRF_LOG_DEFAULT_LEVEL))                       {                                                                             LOG_INTERNAL(NRF_LOG_LEVEL_ERROR, LOG_ERROR_PREFIX, __VA_ARGS__);     }
N#define NRF_LOG_INTERNAL_HEXDUMP_ERROR(p_data, len)                                              \
N    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_ERROR) &&                                                \
N        (NRF_LOG_LEVEL_ERROR <= NRF_LOG_DEFAULT_LEVEL))                                          \
N    {                                                                                            \
N        nrf_log_frontend_hexdump(NRF_LOG_LEVEL_ERROR, LOG_ERROR_PREFIX "\r\n", (p_data), (len)); \
N    }
X#define NRF_LOG_INTERNAL_HEXDUMP_ERROR(p_data, len)                                                  if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_ERROR) &&                                                        (NRF_LOG_LEVEL_ERROR <= NRF_LOG_DEFAULT_LEVEL))                                              {                                                                                                    nrf_log_frontend_hexdump(NRF_LOG_LEVEL_ERROR, LOG_ERROR_PREFIX "\r\n", (p_data), (len));     }
N
N#define NRF_LOG_INTERNAL_WARNING(...)                                         \
N    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_WARNING) &&                           \
N        (NRF_LOG_LEVEL_WARNING <= NRF_LOG_DEFAULT_LEVEL))                     \
N    {                                                                         \
N        LOG_INTERNAL(NRF_LOG_LEVEL_WARNING, LOG_WARNING_PREFIX, __VA_ARGS__); \
N    }
X#define NRF_LOG_INTERNAL_WARNING(...)                                             if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_WARNING) &&                                   (NRF_LOG_LEVEL_WARNING <= NRF_LOG_DEFAULT_LEVEL))                         {                                                                                 LOG_INTERNAL(NRF_LOG_LEVEL_WARNING, LOG_WARNING_PREFIX, __VA_ARGS__);     }
N#define NRF_LOG_INTERNAL_HEXDUMP_WARNING(p_data, len)                                                \
N    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_WARNING) &&                                                  \
N        (NRF_LOG_LEVEL_WARNING <= NRF_LOG_DEFAULT_LEVEL))                                            \
N    {                                                                                                \
N        nrf_log_frontend_hexdump(NRF_LOG_LEVEL_WARNING, LOG_WARNING_PREFIX "\r\n", (p_data), (len)); \
N    }
X#define NRF_LOG_INTERNAL_HEXDUMP_WARNING(p_data, len)                                                    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_WARNING) &&                                                          (NRF_LOG_LEVEL_WARNING <= NRF_LOG_DEFAULT_LEVEL))                                                {                                                                                                        nrf_log_frontend_hexdump(NRF_LOG_LEVEL_WARNING, LOG_WARNING_PREFIX "\r\n", (p_data), (len));     }
N
N#define NRF_LOG_INTERNAL_INFO(...)                                      \
N    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_INFO) &&                        \
N        (NRF_LOG_LEVEL_INFO <= NRF_LOG_DEFAULT_LEVEL))                  \
N    {                                                                   \
N        LOG_INTERNAL(NRF_LOG_LEVEL_INFO, LOG_INFO_PREFIX, __VA_ARGS__); \
N    }
X#define NRF_LOG_INTERNAL_INFO(...)                                          if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_INFO) &&                                (NRF_LOG_LEVEL_INFO <= NRF_LOG_DEFAULT_LEVEL))                      {                                                                           LOG_INTERNAL(NRF_LOG_LEVEL_INFO, LOG_INFO_PREFIX, __VA_ARGS__);     }
N
N#define NRF_LOG_INTERNAL_RAW_INFO(...)                                  \
N    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_INFO) &&                        \
N        (NRF_LOG_LEVEL_INFO <= NRF_LOG_DEFAULT_LEVEL))                  \
N    {                                                                   \
N        LOG_INTERNAL(NRF_LOG_LEVEL_INFO | NRF_LOG_RAW, "", __VA_ARGS__);          \
N    }
X#define NRF_LOG_INTERNAL_RAW_INFO(...)                                      if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_INFO) &&                                (NRF_LOG_LEVEL_INFO <= NRF_LOG_DEFAULT_LEVEL))                      {                                                                           LOG_INTERNAL(NRF_LOG_LEVEL_INFO | NRF_LOG_RAW, "", __VA_ARGS__);              }
N
N#define NRF_LOG_INTERNAL_HEXDUMP_INFO(p_data, len)                                             \
N    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_INFO) &&                                               \
N        (NRF_LOG_LEVEL_INFO <= NRF_LOG_DEFAULT_LEVEL))                                         \
N    {                                                                                          \
N        nrf_log_frontend_hexdump(NRF_LOG_LEVEL_INFO, LOG_INFO_PREFIX "\r\n", (p_data), (len)); \
N    }
X#define NRF_LOG_INTERNAL_HEXDUMP_INFO(p_data, len)                                                 if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_INFO) &&                                                       (NRF_LOG_LEVEL_INFO <= NRF_LOG_DEFAULT_LEVEL))                                             {                                                                                                  nrf_log_frontend_hexdump(NRF_LOG_LEVEL_INFO, LOG_INFO_PREFIX "\r\n", (p_data), (len));     }
N
N#define NRF_LOG_INTERNAL_RAW_HEXDUMP_INFO(p_data, len)                                             \
N    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_INFO) &&                                               \
N        (NRF_LOG_LEVEL_INFO <= NRF_LOG_DEFAULT_LEVEL))                                         \
N    {                                                                                          \
N        nrf_log_frontend_hexdump(NRF_LOG_LEVEL_INFO | NRF_LOG_RAW, "", (p_data), (len)); \
N    }
X#define NRF_LOG_INTERNAL_RAW_HEXDUMP_INFO(p_data, len)                                                 if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_INFO) &&                                                       (NRF_LOG_LEVEL_INFO <= NRF_LOG_DEFAULT_LEVEL))                                             {                                                                                                  nrf_log_frontend_hexdump(NRF_LOG_LEVEL_INFO | NRF_LOG_RAW, "", (p_data), (len));     }
N
N#define NRF_LOG_INTERNAL_DEBUG(...)                                       \
N    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_DEBUG) &&                         \
N        (NRF_LOG_LEVEL_DEBUG <= NRF_LOG_DEFAULT_LEVEL))                   \
N    {                                                                     \
N        LOG_INTERNAL(NRF_LOG_LEVEL_DEBUG, LOG_DEBUG_PREFIX, __VA_ARGS__); \
N    }
X#define NRF_LOG_INTERNAL_DEBUG(...)                                           if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_DEBUG) &&                                 (NRF_LOG_LEVEL_DEBUG <= NRF_LOG_DEFAULT_LEVEL))                       {                                                                             LOG_INTERNAL(NRF_LOG_LEVEL_DEBUG, LOG_DEBUG_PREFIX, __VA_ARGS__);     }
N#define NRF_LOG_INTERNAL_HEXDUMP_DEBUG(p_data, len)                                              \
N    if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_DEBUG) &&                                                \
N        (NRF_LOG_LEVEL_DEBUG <= NRF_LOG_DEFAULT_LEVEL))                                          \
N    {                                                                                            \
N        nrf_log_frontend_hexdump(NRF_LOG_LEVEL_DEBUG, LOG_DEBUG_PREFIX "\r\n", (p_data), (len)); \
N    }
X#define NRF_LOG_INTERNAL_HEXDUMP_DEBUG(p_data, len)                                                  if ((NRF_LOG_LEVEL >= NRF_LOG_LEVEL_DEBUG) &&                                                        (NRF_LOG_LEVEL_DEBUG <= NRF_LOG_DEFAULT_LEVEL))                                              {                                                                                                    nrf_log_frontend_hexdump(NRF_LOG_LEVEL_DEBUG, LOG_DEBUG_PREFIX "\r\n", (p_data), (len));     }
N
N#if NRF_LOG_ENABLED
X#if 0
S#define NRF_LOG_INTERNAL_GETCHAR()  nrf_log_getchar()
N#else
N#define NRF_LOG_INTERNAL_GETCHAR()  (void)
N#endif
N
N/**
N * @brief A function for logging raw string.
N *
N * @param severity Severity.
N * @param p_str    A pointer to a string.
N */
Nvoid nrf_log_frontend_std_0(uint8_t severity, char const * const p_str);
N
N/**
N * @brief A function for logging a formatted string with one argument.
N *
N * @param severity Severity.
N * @param p_str    A pointer to a formatted string.
N * @param val0     An argument.
N */
Nvoid nrf_log_frontend_std_1(uint8_t            severity,
N                            char const * const p_str,
N                            uint32_t           val0);
N
N/**
N * @brief A function for logging a formatted string with 2 arguments.
N *
N * @param severity   Severity.
N * @param p_str      A pointer to a formatted string.
N * @param val0, val1 Arguments for formatting string.
N */
Nvoid nrf_log_frontend_std_2(uint8_t            severity,
N                            char const * const p_str,
N                            uint32_t           val0,
N                            uint32_t           val1);
N
N/**
N * @brief A function for logging a formatted string with 3 arguments.
N *
N * @param severity         Severity.
N * @param p_str            A pointer to a formatted string.
N * @param val0, val1, val2 Arguments for formatting string.
N */
Nvoid nrf_log_frontend_std_3(uint8_t            severity,
N                            char const * const p_str,
N                            uint32_t           val0,
N                            uint32_t           val1,
N                            uint32_t           val2);
N
N/**
N * @brief A function for logging a formatted string with 4 arguments.
N *
N * @param severity               Severity.
N * @param p_str                  A pointer to a formatted string.
N * @param val0, val1, val2, val3 Arguments for formatting string.
N */
Nvoid nrf_log_frontend_std_4(uint8_t            severity,
N                            char const * const p_str,
N                            uint32_t           val0,
N                            uint32_t           val1,
N                            uint32_t           val2,
N                            uint32_t           val3);
N
N/**
N * @brief A function for logging a formatted string with 5 arguments.
N *
N * @param severity                     Severity.
N * @param p_str                        A pointer to a formatted string.
N * @param val0, val1, val2, val3, val4 Arguments for formatting string.
N */
Nvoid nrf_log_frontend_std_5(uint8_t            severity,
N                            char const * const p_str,
N                            uint32_t           val0,
N                            uint32_t           val1,
N                            uint32_t           val2,
N                            uint32_t           val3,
N                            uint32_t           val4);
N
N/**
N * @brief A function for logging a formatted string with 6 arguments.
N *
N * @param severity                           Severity.
N * @param p_str                              A pointer to a formatted string.
N * @param val0, val1, val2, val3, val4, val5 Arguments for formatting string.
N */
Nvoid nrf_log_frontend_std_6(uint8_t            severity,
N                            char const * const p_str,
N                            uint32_t           val0,
N                            uint32_t           val1,
N                            uint32_t           val2,
N                            uint32_t           val3,
N                            uint32_t           val4,
N                            uint32_t           val5);
N
N/**
N * @brief A function for logging raw data.
N *
N * @param severity Severity.
N * @param p_str    A pointer to a string which is prefixing the data.
N * @param p_data   A pointer to data to be dumped.
N * @param length   Length of data (in bytes).
N *
N */
Nvoid nrf_log_frontend_hexdump(uint8_t            severity,
N                              char const * const p_str,
N                              const void * const p_data,
N                              uint16_t           length);
N
N/**
N * @brief A function for reading a byte from log backend.
N *
N * @return Byte.
N */
Nuint8_t nrf_log_getchar(void);
N#endif // NRF_LOG_INTERNAL_H__
L 60 "..\..\..\..\..\..\components\libraries\log\nrf_log.h" 2
N
N/** @def NRF_LOG_ERROR
N *  @brief Macro for logging error messages. It takes a printf-like, formatted
N *  string with up to seven arguments.
N *
N *  @details This macro is compiled only if @ref NRF_LOG_LEVEL includes error logs.
N */
N
N/** @def NRF_LOG_WARNING
N *  @brief Macro for logging error messages. It takes a printf-like, formatted
N *  string with up to seven arguments.
N *
N *  @details This macro is compiled only if @ref NRF_LOG_LEVEL includes warning logs.
N */
N
N/** @def NRF_LOG_INFO
N *  @brief Macro for logging error messages. It takes a printf-like, formatted
N *  string with up to seven arguments.
N *
N *  @details This macro is compiled only if @ref NRF_LOG_LEVEL includes info logs.
N */
N
N/** @def NRF_LOG_DEBUG
N *  @brief Macro for logging error messages. It takes a printf-like, formatted
N *  string with up to seven arguments.
N *
N *  @details This macro is compiled only if @ref NRF_LOG_LEVEL includes debug logs.
N */
N
N#define NRF_LOG_ERROR(...)                     NRF_LOG_INTERNAL_ERROR(__VA_ARGS__)
N#define NRF_LOG_WARNING(...)                   NRF_LOG_INTERNAL_WARNING( __VA_ARGS__)
N#define NRF_LOG_INFO(...)                      NRF_LOG_INTERNAL_INFO( __VA_ARGS__)
N#define NRF_LOG_DEBUG(...)                     NRF_LOG_INTERNAL_DEBUG( __VA_ARGS__)
N
N/**
N * @brief A macro for logging a formatted string without any prefix or timestamp.
N */
N#define NRF_LOG_RAW_INFO(...)                  NRF_LOG_INTERNAL_RAW_INFO( __VA_ARGS__)
N
N/** @def NRF_LOG_HEXDUMP_ERROR
N *  @brief Macro for logging raw bytes.
N *  @details It is compiled in only if @ref NRF_LOG_LEVEL includes error logs.
N *
N * @param p_data     Pointer to data.
N * @param len        Data length in bytes.
N */
N/** @def NRF_LOG_HEXDUMP_WARNING
N *  @brief Macro for logging raw bytes.
N *  @details This macro is compiled only if @ref NRF_LOG_LEVEL includes warning logs.
N *
N * @param p_data     Pointer to data.
N * @param len        Data length in bytes.
N */
N/** @def NRF_LOG_HEXDUMP_INFO
N *  @brief Macro for logging raw bytes.
N *  @details This macro is compiled only if @ref NRF_LOG_LEVEL includes info logs.
N *
N * @param p_data     Pointer to data.
N * @param len        Data length in bytes.
N */
N/** @def NRF_LOG_HEXDUMP_DEBUG
N *  @brief Macro for logging raw bytes.
N *  @details This macro is compiled only if @ref NRF_LOG_LEVEL includes debug logs.
N *
N * @param p_data     Pointer to data.
N * @param len        Data length in bytes.
N */
N#define NRF_LOG_HEXDUMP_ERROR(p_data, len)   NRF_LOG_INTERNAL_HEXDUMP_ERROR(p_data, len)
N#define NRF_LOG_HEXDUMP_WARNING(p_data, len) NRF_LOG_INTERNAL_HEXDUMP_WARNING(p_data, len)
N#define NRF_LOG_HEXDUMP_INFO(p_data, len)    NRF_LOG_INTERNAL_HEXDUMP_INFO(p_data, len)
N#define NRF_LOG_HEXDUMP_DEBUG(p_data, len)   NRF_LOG_INTERNAL_HEXDUMP_DEBUG(p_data, len)
N
N/**
N * @brief Macro for logging hexdump without any prefix or timestamp.
N */
N#define NRF_LOG_RAW_HEXDUMP_INFO(p_data, len) NRF_LOG_INTERNAL_RAW_HEXDUMP_INFO(p_data, len)
N
N/**
N * @brief A macro for blocking reading from bidirectional backend used for logging.
N *
N * Macro call is blocking and returns when single byte is received.
N */
N#define NRF_LOG_GETCHAR()                    NRF_LOG_INTERNAL_GETCHAR()
N
N/**
N * @brief Function for copying a string to the internal logger buffer if logs are deferred.
N *
N * Use this function to store a string that is volatile (for example allocated
N * on stack) or that may change before the deferred logs are processed. Such string is copied
N * into the internal logger buffer and is persistent until the log is processed.
N *
N * @note If the logs are not deferred, then this function returns the input parameter.
N *
N * @param p_str Pointer to the user string.
N *
N * @return Address to the location where the string is stored in the internal logger buffer.
N */
Nuint32_t nrf_log_push(char * const p_str);
N
N/**
N * @brief Macro to be used in a formatted string to a pass float number to the log.
N *
N * Macro should be used in formatted string instead of the %f specifier together with
N * @ref NRF_LOG_FLOAT macro.
N * Example: NRF_LOG_INFO("My float number" NRF_LOG_FLOAT_MARKER "\r\n", NRF_LOG_FLOAT(f)))
N */
N#define NRF_LOG_FLOAT_MARKER "%d.%02d"
N
N/**
N * @brief Macro for dissecting a float number into two numbers (integer and residuum).
N */
N#define NRF_LOG_FLOAT(val) (int32_t)(val),                                     \
N                           (int32_t)(((val > 0) ? (val) - (int32_t)(val)       \
N                                                : (int32_t)(val) - (val))*100)
X#define NRF_LOG_FLOAT(val) (int32_t)(val),                                                                (int32_t)(((val > 0) ? (val) - (int32_t)(val)                                                       : (int32_t)(val) - (val))*100)
N
N#endif // NRF_LOG_H_
N
N/** @} */
L 53 "..\..\..\main.c" 2
N#include "nrf_log_ctrl.h"
L 1 "..\..\..\..\..\..\components\libraries\log\nrf_log_ctrl.h" 1
N/* Copyright (c) 2016 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N#ifndef NRF_LOG_CTRL_H
N#define NRF_LOG_CTRL_H
N
N/**@file
N * @addtogroup nrf_log Logger module
N * @ingroup    app_common
N *
N * @defgroup nrf_log_ctrl Functions for controlling nrf_log
N * @{
N * @ingroup  nrf_log
N * @brief    The nrf_log control interface.
N */
N
N#include "sdk_config.h"
N#include "sdk_errors.h"
N#include <stdint.h>
N#include <stdbool.h>
N#include "nrf_log_ctrl_internal.h"
L 1 "..\..\..\..\..\..\components\libraries\log\src\nrf_log_ctrl_internal.h" 1
N/* Copyright (c) 2016 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N#ifndef NRF_LOG_CTRL_INTERNAL_H
N#define NRF_LOG_CTRL_INTERNAL_H
N/**
N * @cond (NODOX)
N * @defgroup nrf_log_ctrl_internal Auxiliary internal types declarations
N * @{
N * @internal
N */
N
N
N#if NRF_LOG_ENABLED
X#if 0
S#include "nordic_common.h"
S#include "app_util_platform.h"
S
S#define NRF_LOG_INTERNAL_INIT(timestamp_func) \
S    nrf_log_init(timestamp_func)
X#define NRF_LOG_INTERNAL_INIT(timestamp_func)     nrf_log_init(timestamp_func)
S
S#if (NRF_LOG_DEFERRED == 0)
S#define NRF_LOG_INTERNAL_PROCESS() false
S#define NRF_LOG_INTERNAL_FLUSH()
S#define NRF_LOG_INTERNAL_FINAL_FLUSH()
S#else
S#define NRF_LOG_INTERNAL_PROCESS() nrf_log_frontend_dequeue()
S#define NRF_LOG_INTERNAL_FLUSH()            \
S    do {                                    \
S        while (NRF_LOG_INTERNAL_PROCESS()); \
S    } while(0)
X#define NRF_LOG_INTERNAL_FLUSH()                do {                                            while (NRF_LOG_INTERNAL_PROCESS());     } while(0)
S
S#if NRF_LOG_BACKEND_SERIAL_USES_RTT
S#define NRF_LOG_INTERNAL_BACKEND_FINAL NRF_BREAKPOINT
S#else
S#define NRF_LOG_INTERNAL_BACKEND_FINAL
S#endif
S
S#define NRF_LOG_INTERNAL_FINAL_FLUSH()      \
S    do {                                    \
S    (void)nrf_log_blocking_backend_set();   \
S        NRF_LOG_INTERNAL_FLUSH();           \
S        NRF_LOG_INTERNAL_BACKEND_FINAL;     \
S    } while(0)
X#define NRF_LOG_INTERNAL_FINAL_FLUSH()          do {                                        (void)nrf_log_blocking_backend_set();           NRF_LOG_INTERNAL_FLUSH();                   NRF_LOG_INTERNAL_BACKEND_FINAL;         } while(0)
S
S#endif
S
S#define NRF_LOG_INTERNAL_HANDLERS_SET(default_handler, bytes_handler) \
S    nrf_log_handlers_set(default_handler, bytes_handler)
X#define NRF_LOG_INTERNAL_HANDLERS_SET(default_handler, bytes_handler)     nrf_log_handlers_set(default_handler, bytes_handler)
S
N#else // NRF_LOG_ENABLED
N#define NRF_LOG_INTERNAL_PROCESS()            false
N#define NRF_LOG_INTERNAL_FLUSH()
N#define NRF_LOG_INTERNAL_INIT(timestamp_func) NRF_SUCCESS
N#define NRF_LOG_INTERNAL_HANDLERS_SET(default_handler, bytes_handler) \
N    UNUSED_PARAMETER(default_handler); UNUSED_PARAMETER(bytes_handler)
X#define NRF_LOG_INTERNAL_HANDLERS_SET(default_handler, bytes_handler)     UNUSED_PARAMETER(default_handler); UNUSED_PARAMETER(bytes_handler)
N#define NRF_LOG_INTERNAL_FINAL_FLUSH()
N#endif // NRF_LOG_ENABLED
N
N/** @}
N * @endcond
N */
N#endif // NRF_LOG_CTRL_INTERNAL_H
L 30 "..\..\..\..\..\..\components\libraries\log\nrf_log_ctrl.h" 2
N/**
N * @brief Timestamp function prototype.
N *
N * @return Timestamp value.
N */
Ntypedef uint32_t (*nrf_log_timestamp_func_t)(void);
N
N/**@brief Macro for initializing the logs.
N *
N * @note If timestamps are disabled in the configuration, then the provided pointer
N * can be NULL. Otherwise, it is expected that timestamp_getter is not NULL.
N *
N * @param timestamp_func Function that returns the timestamp.
N *
N * @return  NRF_SUCCESS after successful initialization, otherwise an error code.
N */
N#define NRF_LOG_INIT(timestamp_func) NRF_LOG_INTERNAL_INIT(timestamp_func)
N
N
N/**@brief Macro for processing a single log entry from a queue of deferred logs.
N *
N * You can call this macro from the main context or from the error handler to process
N * log entries one by one.
N *
N * @note If logs are not deferred, this call has no use and is defined as 'false'.
N *
N * @retval true    There are more logs to process in the buffer.
N * @retval false   No more logs in the buffer.
N */
N#define NRF_LOG_PROCESS()    NRF_LOG_INTERNAL_PROCESS()
N
N/** @brief Macro for processing all log entries from the buffer.
N * It blocks until all buffered entries are processed by the backend.
N *
N * @note If logs are not deferred, this call has no use and is empty.
N */
N#define NRF_LOG_FLUSH()      NRF_LOG_INTERNAL_FLUSH()
N
N/** @brief Macro for flushing log data before reset.
N *
N * @note If logs are not deferred, this call has no use and is empty.
N *
N * @note If RTT is used, then a breakpoint is hit once flushed.
N */
N#define NRF_LOG_FINAL_FLUSH() NRF_LOG_INTERNAL_FINAL_FLUSH()
N
N/** @brief Macro for changing functions that are used to handle log entries.
N *
N * @param default_handler Function for handling log entries.
N * @param bytes_handler   Function for handling hexdump entries.
N *
N */
N#define NRF_LOG_HANDLERS_SET(default_handler, bytes_handler) \
N    NRF_LOG_INTERNAL_HANDLERS_SET(default_handler, bytes_handler)
X#define NRF_LOG_HANDLERS_SET(default_handler, bytes_handler)     NRF_LOG_INTERNAL_HANDLERS_SET(default_handler, bytes_handler)
N
N/**
N * @brief Function prototype for handling a log entry.
N *
N * The backend must implement such prototype.
N *
N * @param severity_level Severity level of the entry.
N * @param p_timestamp    Pointer to the timestamp value. No timestamp if NULL.
N * @param p_str          Pointer to a formatted string.
N * @param p_args         Pointer to an array of arguments for a formatted string.
N * @param nargs          Number of arguments in p_args.
N *
N * @retval true          If entry is successfully processed.
N * @retval false         If entry is not processed.
N */
Ntypedef bool (*nrf_log_std_handler_t)(
Xtypedef _Bool (*nrf_log_std_handler_t)(
N    uint8_t                severity_level,
N    const uint32_t * const p_timestamp,
N    const char * const     p_str,
N    uint32_t             * p_args,
N    uint32_t               nargs);
N
N/**
N * @brief Function prototype for handling a bytes-dumping log entry.
N *
N * The backend must implement such prototype. Two buffers are needed because data
N * is stored internally in a circular buffer so it can be fragmented into up to
N * two pieces.
N *
N * @param severity_level Severity level of the entry.
N * @param p_timestamp    Pointer to a timestamp value. No timestamp if NULL.
N * @param p_str          Prefix string for the bytes dump.
N * @param offset         Indication of how many bytes have already been processed.
N * @param p_buf0         Pointer to the first part of data.
N * @param buf0_length    Number of bytes in the first part.
N * @param p_buf1         Pointer to the second part of data. Optional.
N * @param buf1_length    Number of bytes in the second part.
N *
N * @return Number of bytes processed. If all bytes are processed, it should be a sum of
N *         buf0_length and buf1_length
N */
Ntypedef uint32_t (*nrf_log_hexdump_handler_t)(
N    uint8_t                severity_level,
N    const uint32_t * const p_timestamp,
N    const char * const     p_str,
N    uint32_t               offset,
N    const uint8_t * const  p_buf0,
N    uint32_t               buf0_length,
N    const uint8_t * const  p_buf1,
N    uint32_t               buf1_length);
N
N
N/**
N * @brief Function for initializing the frontend and the default backend.
N *
N * @ref NRF_LOG_INIT calls this function to initialize the frontend and the backend.
N * If custom backend is used, then @ref NRF_LOG_INIT should not be called.
N * Instead, frontend and user backend should be verbosely initialized.
N *
N * @param timestamp_func Function for getting a 32-bit timestamp.
N *
N * @return Error status.
N *
N */
Nret_code_t nrf_log_init(nrf_log_timestamp_func_t timestamp_func);
N
N/**
N * @brief Function for reinitializing the backend in blocking mode.
N */
Nret_code_t nrf_log_blocking_backend_set(void);
N
N/**
N * @brief Function for initializing the logger frontend.
N *
N * The frontend is initialized with functions for handling log entries. Those
N * functions are provided by the backend.
N *
N * @note This function needs to be called directly only if the @ref NRF_LOG_INIT macro
N * is not used to initialize the logger.
N *
N * @param std_handler      Function for handling standard log entries.
N * @param hexdump_handler  Function for handling hexdump log entries.
N * @param timestamp_func   Function for getting a timestamp. It cannot be NULL
N *                         unless timestamping is disabled.
N */
Nvoid nrf_log_frontend_init(nrf_log_std_handler_t     std_handler,
N                           nrf_log_hexdump_handler_t hexdump_handler,
N                           nrf_log_timestamp_func_t  timestamp_func);
N
N/**
N * @brief Function for updating functions that handle log entries.
N *
N * @note Use this feature to change the log handling behavior in certain
N * situations, like in a fault handler.
N *
N * @param std_handler      Function for handling standard log entries.
N * @param hexdump_handler  Function for handling hexdump log entries.
N */
Nvoid nrf_log_handlers_set(nrf_log_std_handler_t     std_handler,
N                          nrf_log_hexdump_handler_t hexdump_handler);
N
N/**
N * @brief Function for handling a single log entry.
N *
N * Use this function only if the logs are buffered. It takes a single entry from the
N * buffer and attempts to process it.
N *
N * @retval true  If there are more entries to process.
N * @retval false If there are no more entries to process.
N */
Nbool nrf_log_frontend_dequeue(void);
X_Bool nrf_log_frontend_dequeue(void);
N
N
N#endif // NRF_LOG_CTRL_H
N
N/**
N *@}
N **/
L 54 "..\..\..\main.c" 2
N#include "nrf_ble_qwr.h"
L 1 "..\..\..\..\..\..\components\ble\nrf_ble_qwr\nrf_ble_qwr.h" 1
N/* Copyright (c) 2016 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup nrf_ble_qwr Queued Writes module
N * @{
N * @ingroup ble_sdk_lib
N * @brief Module for handling Queued Write operations.
N *
N * @details This module handles prepare write, execute write, and cancel write
N * commands. It also manages memory requests related to these operations.
N *
N * @note     The application must propagate BLE stack events to this module by calling
N *           @ref nrf_ble_qwr_on_ble_evt().
N */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#ifndef NRF_BLE_QUEUED_WRITES_H__
N#define NRF_BLE_QUEUED_WRITES_H__
N
N#include <stdint.h>
N#include "nordic_common.h"
N#include "sdk_common.h"
N#include "ble.h"
N#include "ble_srv_common.h"
N
N#ifndef NRF_BLE_QWR_ATTR_LIST_SIZE
N#define NRF_BLE_QWR_ATTR_LIST_SIZE    10        //!< Maximum number of attribute handles that can be registered. This number must be adjusted according to the number of attributes for which Queued Writes will be enabled.
N#endif
N
N#define NRF_BLE_QWR_REJ_REQUEST_ERR_CODE BLE_GATT_STATUS_ATTERR_APP_BEGIN + 0                  //!< Error code used by the module to reject prepare write requests on non-registered attributes.
N
N/**@brief Queued Writes module event types. */
Ntypedef enum
N{
N    NRF_BLE_QWR_EVT_EXECUTE_WRITE,              //!< Event that indicates that an execute write command was received for a registered handle and that the received data was actually written and is now ready.
N    NRF_BLE_QWR_EVT_AUTH_REQUEST,               //!< Event that indicates that an execute write command was received for a registered handle and that the write request must now be accepted or rejected.
N} nrf_ble_qwr_evt_type_t;
N
N
N/**@brief Queued Writes module events. */
Ntypedef struct
N{
N    nrf_ble_qwr_evt_type_t evt_type;            //!< Type of the event.
N    uint16_t               attr_handle;         //!< Handle of the attribute to which the event relates.
N} nrf_ble_qwr_evt_t;
N
N
N// Forward declaration of the nrf_ble_qwr_t type.
Nstruct nrf_ble_qwr_t;
N
N/**@brief Queued Writes module event handler type.
N *
N * If the provided event is of type @ref NRF_BLE_QWR_EVT_AUTH_REQUEST,
N * this function must accept or reject the execute write request by returning
N * one of the @ref BLE_GATT_STATUS_CODES.*/
Ntypedef uint16_t (* nrf_ble_qwr_evt_handler_t) (struct nrf_ble_qwr_t * p_qwr,
N                                                nrf_ble_qwr_evt_t    * p_evt);
N
N
N/**@brief Queued Writes structure.
N * @details This structure contains status information for the Queued Writes module. */
Ntypedef struct nrf_ble_qwr_t
N{
N    uint8_t                       initialized;                                                  //!< Flag that indicates whether the module has been initialized.
N    uint16_t                      attr_handles[NRF_BLE_QWR_ATTR_LIST_SIZE];                     //!< List of handles for registered attributes, for which the module accepts and handles prepare write operations.
X    uint16_t                      attr_handles[10];                     
N    uint8_t                       nb_registered_attr;                                           //!< Number of registered attributes.
N    uint16_t                      written_attr_handles[NRF_BLE_QWR_ATTR_LIST_SIZE];             //!< List of attribute handles that have been written to during the current prepare write or execute write operation.
X    uint16_t                      written_attr_handles[10];             
N    uint8_t                       nb_written_handles;                                           //!< Number of attributes that have been written to during the current prepare write or execute write operation.
N    ble_user_mem_block_t          mem_buffer;                                                   //!< Memory buffer that is provided to the SoftDevice on an ON_USER_MEM_REQUEST event.
N    ble_srv_error_handler_t       error_handler;                                                //!< Error handler.
N    bool                          is_user_mem_reply_pending;                                    //!< Flag that indicates whether a mem_reply is pending (because a previous attempt returned busy).
X    _Bool                          is_user_mem_reply_pending;                                    
N    uint16_t                      conn_handle;                                                  //!< Connection handle.
N    nrf_ble_qwr_evt_handler_t     callback;                                                     //!< Event handler function that is called for events concerning the handles of all registered attributes.
N} nrf_ble_qwr_t;
N
N
N/**@brief Queued Writes init structure.
N * @details This structure contains all information
N *          that is needed to initialize the Queued Writes module. */
Ntypedef struct
N{
N    ble_srv_error_handler_t   error_handler;        //!< Error handler.
N    ble_user_mem_block_t      mem_buffer;           //!< Memory buffer that is provided to the SoftDevice on an ON_USER_MEM_REQUEST event.
N    nrf_ble_qwr_evt_handler_t callback;             //!< Event handler function that is called for events concerning the handles of all registered attributes.
N} nrf_ble_qwr_init_t;
N
N
N/**@brief Function for initializing the Queued Writes module.
N *
N * @details Call this function in the main entry of your application to
N * initialize the Queued Writes module. It must be called only once with a
N * given Queued Writes structure.
N *
N * @param[out]  p_qwr     Queued Writes structure. This structure must be
N *                        supplied by the application. It is initialized by this function
N *                        and is later used to identify the particular Queued Writes instance.
N * @param[in]  p_qwr_init Initialization structure.
N *
N * @retval NRF_SUCCESS             If the Queued Writes module was initialized successfully.
N * @retval NRF_ERROR_NULL          If any of the given pointers is NULL.
N * @retval NRF_ERROR_INVALID_STATE If the given context has already been initialized.
N */
Nret_code_t nrf_ble_qwr_init(nrf_ble_qwr_t            * p_qwr,
N                            nrf_ble_qwr_init_t const * p_qwr_init);
N
N
N/**@brief Function for registering an attribute with the Queued Writes module.
N *
N * @details Call this function for each attribute that you want to enable for
N * Queued Writes (thus a series of prepare write and execute write operations).
N *
N * @param[in]  p_qwr       Queued Writes structure.
N * @param[in]  attr_handle Handle of the attribute to register.
N *
N * @retval NRF_SUCCESS             If the registration was successful.
N * @retval NRF_ERROR_NO_MEM        If no more memory is available to add this registration.
N * @retval NRF_ERROR_NULL          If any of the given pointers is NULL.
N * @retval NRF_ERROR_INVALID_STATE If the given context has not been initialized.
N */
Nret_code_t nrf_ble_qwr_attr_register(nrf_ble_qwr_t * p_qwr, uint16_t attr_handle);
N
N
N/**@brief Function for handling BLE stack events.
N *
N * @details Handles all events from the BLE stack that are of interest to the Queued Writes module.
N *
N * @param[in]  p_qwr      Queued Writes structure.
N * @param[in]  p_ble_evt  Event received from the BLE stack.
N */
Nvoid nrf_ble_qwr_on_ble_evt(nrf_ble_qwr_t * p_qwr, ble_evt_t * p_ble_evt);
N
N
N/**@brief Function for retrieving the received data for a given attribute.
N *
N * @details Call this function after receiving an @ref NRF_BLE_QWR_EVT_AUTH_REQUEST
N * event to retrieve a linear copy of the data that was received for the given attribute.
N *
N * @param[in]     p_qwr       Queued Writes structure.
N * @param[in]     attr_handle Handle of the attribute.
N * @param[out]    p_mem       Pointer to the application buffer where the received data will be copied.
N * @param[in,out] p_len       Input: length of the input buffer. Output: length of the received data.
N *
N *
N * @retval NRF_SUCCESS             If the data was retrieved and stored successfully.
N * @retval NRF_ERROR_NO_MEM        If the provided buffer was smaller than the received data.
N * @retval NRF_ERROR_NULL          If any of the given pointers is NULL.
N * @retval NRF_ERROR_INVALID_STATE If the given context has not been initialized.
N */
Nret_code_t nrf_ble_qwr_value_get(nrf_ble_qwr_t * p_qwr,
N                                 uint16_t        attr_handle,
N                                 uint8_t       * p_mem,
N                                 uint16_t      * p_len);
N
N
N/**@brief Function for assigning a connection handle to a given instance of the Queued Writes module.
N *
N * @details   Call this function when a link with a peer has been established to
N *            associate this link to the instance of the module. This makes it
N *            possible to handle several links and associate each link to a particular
N *            instance of this module.
N *
N * @param[in]  p_qwr       Queued Writes structure.
N * @param[in]  conn_handle Connection handle to be associated with the given Queued Writes instance.
N *
N * @retval NRF_SUCCESS             If the assignment was successful.
N * @retval NRF_ERROR_NULL          If any of the given pointers is NULL.
N * @retval NRF_ERROR_INVALID_STATE If the given context has not been initialized.
N */
Nret_code_t nrf_ble_qwr_conn_handle_assign(nrf_ble_qwr_t * p_qwr,
N                                          uint16_t        conn_handle);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // NRF_BLE_QUEUED_WRITES_H__
N
N/** @} */
L 55 "..\..\..\main.c" 2
N
N#include "LS013B7DH06.h"
L 1 "..\..\..\..\..\..\components\drivers_ext\LS013B7DH06\LS013B7DH06.h" 1
N#ifndef LS013B7DH06_H
N#define LS013B7DH06_H
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N#include "nrf_error.h"
N#include "nrf_drv_spi.h"
L 1 "..\..\..\..\..\..\components\drivers_nrf\spi_master\nrf_drv_spi.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**@file
N * @addtogroup nrf_spi Serial peripheral interface (SPI/SPIM)
N * @ingroup    nrf_drivers
N * @brief      Serial peripheral interface (SPI/SPIM) APIs.
N *
N */
N
N#ifndef NRF_DRV_SPI_H__
N#define NRF_DRV_SPI_H__
N
N#include "nordic_common.h"
N#include "sdk_config.h"
N#include "nrf_peripherals.h"
L 1 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_peripherals.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N
N#ifndef NRF_PERIPHERALS_H
N#define NRF_PERIPHERALS_H
N
N/*lint ++flb "Enter library region */
N
N#ifdef NRF51422
S#include "nrf51422_peripherals.h"
N#endif
N
N#ifdef NRF51802
S#include "nrf51802_peripherals.h"
N#endif
N
N#ifdef NRF51822
S#include "nrf51822_peripherals.h"
N#endif
N
N#ifdef NRF52832
N#include "nrf52832_peripherals.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include\nrf52832_peripherals.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef _NRF52832_PERIPHERALS_H
N#define _NRF52832_PERIPHERALS_H
N
N
N/* Floating Point Unit */
N#define FPU_PRESENT
N#define FPU_COUNT 1
N
N/* Systick timer */
N#define SYSTICK_PRESENT
N#define SYSTICK_COUNT 1
N
N/* Software Interrupts */
N#define SWI_PRESENT
N#define SWI_COUNT 6
N
N/* Memory Watch Unit */
N#define MWU_PRESENT
N#define MWU_COUNT 1
N
N/* GPIO */
N#define GPIO_PRESENT
N#define GPIO_COUNT 1
N
N#define P0_PIN_NUM 32
N
N/* MPU and BPROT */
N#define BPROT_PRESENT
N
N#define BPROT_REGIONS_SIZE 4096
N#define BPROT_REGIONS_NUM 128
N
N/* Radio */
N#define RADIO_PRESENT
N#define RADIO_COUNT 1
N
N/* Accelerated Address Resolver */
N#define AAR_PRESENT
N#define AAR_COUNT 1
N
N#define AAR_MAX_IRK_NUM 16
N
N/* AES Electronic CodeBook mode encryption */
N#define ECB_PRESENT
N#define ECB_COUNT 1
N
N/* AES CCM mode encryption */
N#define CCM_PRESENT
N#define CCM_COUNT 1
N
N/* NFC Tag */
N#define NFCT_PRESENT
N#define NFCT_COUNT 1
N
N/* Peripheral to Peripheral Interconnect */
N#define PPI_PRESENT
N#define PPI_COUNT 1
N
N#define PPI_CH_NUM 20
N#define PPI_GROUP_NUM 6
N#define PPI_FEATURE_FORKS_PRESENT
N
N/* Event Generator Unit */
N#define EGU_PRESENT
N#define EGU_COUNT 6
N
N#define EGU0_CH_NUM 16
N#define EGU1_CH_NUM 16
N#define EGU2_CH_NUM 16
N#define EGU3_CH_NUM 16
N#define EGU4_CH_NUM 16
N#define EGU5_CH_NUM 16
N
N/* Timer/Counter */
N#define TIMER_PRESENT
N#define TIMER_COUNT 5
N
N#define TIMER0_MAX_SIZE 32
N#define TIMER1_MAX_SIZE 32
N#define TIMER2_MAX_SIZE 32
N#define TIMER3_MAX_SIZE 32
N#define TIMER4_MAX_SIZE 32
N
N#define TIMER0_CC_NUM 4
N#define TIMER1_CC_NUM 4
N#define TIMER2_CC_NUM 4
N#define TIMER3_CC_NUM 6
N#define TIMER4_CC_NUM 6
N
N/* Real Time Counter */
N#define RTC_PRESENT
N#define RTC_COUNT 3
N
N#define RTC0_CC_NUM 3
N#define RTC1_CC_NUM 4
N#define RTC2_CC_NUM 4
N
N/* RNG */
N#define RNG_PRESENT
N#define RNG_COUNT 1
N
N/* Watchdog Timer */
N#define WDT_PRESENT
N#define WDT_COUNT 1
N
N/* Temperature Sensor */
N#define TEMP_PRESENT
N#define TEMP_COUNT 1
N
N/* Serial Peripheral Interface Master */
N#define SPI_PRESENT
N#define SPI_COUNT 3
N
N/* Serial Peripheral Interface Master with DMA */
N#define SPIM_PRESENT
N#define SPIM_COUNT 3
N
N/* Serial Peripheral Interface Slave with DMA*/
N#define SPIS_PRESENT
N#define SPIS_COUNT 3
N
N/* Two Wire Interface Master */
N#define TWI_PRESENT
N#define TWI_COUNT 2
N
N/* Two Wire Interface Master with DMA */
N#define TWIM_PRESENT
N#define TWIM_COUNT 2
N
N/* Two Wire Interface Slave with DMA */
N#define TWIS_PRESENT
N#define TWIS_COUNT 2
N
N/* Universal Asynchronous Receiver-Transmitter */
N#define UART_PRESENT
N#define UART_COUNT 1
N
N/* Universal Asynchronous Receiver-Transmitter with DMA */
N#define UARTE_PRESENT
N#define UARTE_COUNT 1
N
N/* Quadrature Decoder */
N#define QDEC_PRESENT
N#define QDEC_COUNT 1
N
N/* Successive Approximation Analog to Digital Converter */
N#define SAADC_PRESENT
N#define SAADC_COUNT 1
N
N/* GPIO Tasks and Events */
N#define GPIOTE_PRESENT
N#define GPIOTE_COUNT 1
N
N#define GPIOTE_CH_NUM 8
N
N#define GPIOTE_FEATURE_SET_PRESENT
N#define GPIOTE_FEATURE_CLR_PRESENT
N
N/* Low Power Comparator */
N#define LPCOMP_PRESENT
N#define LPCOMP_COUNT 1
N
N#define LPCOMP_REFSEL_RESOLUTION 16
N
N/* Comparator */
N#define COMP_PRESENT
N#define COMP_COUNT 1
N
N/* Pulse Width Modulator */
N#define PWM_PRESENT
N#define PWM_COUNT 3
N
N#define PWM0_CH_NUM 4
N#define PWM1_CH_NUM 4
N#define PWM2_CH_NUM 4
N
N/* Pulse Density Modulator */
N#define PDM_PRESENT
N#define PDM_COUNT 1
N
N/* Inter-IC Sound Interface */
N#define I2S_PRESENT
N#define I2S_COUNT 1
N
N
N#endif      // _NRF52832_PERIPHERALS_H
L 50 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_peripherals.h" 2
N#endif
N
N
N/*lint --flb "Leave library region" */
N
N#endif /* NRF_PERIPHERALS_H */
N
L 26 "..\..\..\..\..\..\components\drivers_nrf\spi_master\nrf_drv_spi.h" 2
N#include "nrf_spi.h"
L 1 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_spi.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**
N * @defgroup nrf_spi_hal SPI HAL
N * @{
N * @ingroup nrf_spi
N *
N * @brief Hardware access layer for accessing the SPI peripheral.
N */
N
N#ifndef NRF_SPI_H__
N#define NRF_SPI_H__
N
N#include <stddef.h>
N#include <stdbool.h>
N#include <stdint.h>
N
N#include "nrf.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * @brief This value can be used as a parameter for the @ref nrf_spi_pins_set
N *        function to specify that a given SPI signal (SCK, MOSI, or MISO)
N *        shall not be connected to a physical pin.
N */
N#define NRF_SPI_PIN_NOT_CONNECTED  0xFFFFFFFF
N
N
N/**
N * @brief SPI events.
N */
Ntypedef enum
N{
N    /*lint -save -e30*/
N    NRF_SPI_EVENT_READY = offsetof(NRF_SPI_Type, EVENTS_READY) ///< TXD byte sent and RXD byte received.
X    NRF_SPI_EVENT_READY = (( size_t)__INTADDR__(&(((NRF_SPI_Type *)0)->EVENTS_READY))) 
N    /*lint -restore*/
N} nrf_spi_event_t;
N
N/**
N * @brief SPI interrupts.
N */
Ntypedef enum
N{
N    NRF_SPI_INT_READY_MASK = SPI_INTENSET_READY_Msk ///< Interrupt on READY event.
X    NRF_SPI_INT_READY_MASK = (0x1UL << (2UL)) 
N} nrf_spi_int_mask_t;
N
N/**
N * @brief SPI data rates.
N */
Ntypedef enum
N{
N    NRF_SPI_FREQ_125K = SPI_FREQUENCY_FREQUENCY_K125,   ///< 125 kbps.
X    NRF_SPI_FREQ_125K = (0x02000000UL),   
N    NRF_SPI_FREQ_250K = SPI_FREQUENCY_FREQUENCY_K250,   ///< 250 kbps.
X    NRF_SPI_FREQ_250K = (0x04000000UL),   
N    NRF_SPI_FREQ_500K = SPI_FREQUENCY_FREQUENCY_K500,   ///< 500 kbps.
X    NRF_SPI_FREQ_500K = (0x08000000UL),   
N    NRF_SPI_FREQ_1M   = SPI_FREQUENCY_FREQUENCY_M1,     ///< 1 Mbps.
X    NRF_SPI_FREQ_1M   = (0x10000000UL),     
N    NRF_SPI_FREQ_2M   = SPI_FREQUENCY_FREQUENCY_M2,     ///< 2 Mbps.
X    NRF_SPI_FREQ_2M   = (0x20000000UL),     
N    NRF_SPI_FREQ_4M   = SPI_FREQUENCY_FREQUENCY_M4,     ///< 4 Mbps.
X    NRF_SPI_FREQ_4M   = (0x40000000UL),     
N    // [conversion to 'int' needed to prevent compilers from complaining
N    //  that the provided value (0x80000000UL) is out of range of "int"]
N    NRF_SPI_FREQ_8M   = (int)SPI_FREQUENCY_FREQUENCY_M8 ///< 8 Mbps.
X    NRF_SPI_FREQ_8M   = (int)(0x80000000UL) 
N} nrf_spi_frequency_t;
N
N/**
N * @brief SPI modes.
N */
Ntypedef enum
N{
N    NRF_SPI_MODE_0, ///< SCK active high, sample on leading edge of clock.
N    NRF_SPI_MODE_1, ///< SCK active high, sample on trailing edge of clock.
N    NRF_SPI_MODE_2, ///< SCK active low, sample on leading edge of clock.
N    NRF_SPI_MODE_3  ///< SCK active low, sample on trailing edge of clock.
N} nrf_spi_mode_t;
N
N/**
N * @brief SPI bit orders.
N */
Ntypedef enum
N{
N    NRF_SPI_BIT_ORDER_MSB_FIRST = SPI_CONFIG_ORDER_MsbFirst, ///< Most significant bit shifted out first.
X    NRF_SPI_BIT_ORDER_MSB_FIRST = (0UL), 
N    NRF_SPI_BIT_ORDER_LSB_FIRST = SPI_CONFIG_ORDER_LsbFirst  ///< Least significant bit shifted out first.
X    NRF_SPI_BIT_ORDER_LSB_FIRST = (1UL)  
N} nrf_spi_bit_order_t;
N
N
N/**
N * @brief Function for clearing a specific SPI event.
N *
N * @param[in] p_reg     Pointer to the peripheral registers structure.
N * @param[in] spi_event Event to clear.
N */
N__STATIC_INLINE void nrf_spi_event_clear(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_event_clear(NRF_SPI_Type * p_reg,
N                                         nrf_spi_event_t spi_event);
N
N/**
N * @brief Function for checking the state of a specific SPI event.
N *
N * @param[in] p_reg     Pointer to the peripheral registers structure.
N * @param[in] spi_event Event to check.
N *
N * @retval true  If the event is set.
N * @retval false If the event is not set.
N */
N__STATIC_INLINE bool nrf_spi_event_check(NRF_SPI_Type * p_reg,
Xstatic __inline _Bool nrf_spi_event_check(NRF_SPI_Type * p_reg,
N                                         nrf_spi_event_t spi_event);
N
N/**
N * @brief Function for getting the address of a specific SPI event register.
N *
N * @param[in] p_reg     Pointer to the peripheral registers structure.
N * @param[in] spi_event Requested event.
N *
N * @return Address of the specified event register.
N */
N__STATIC_INLINE uint32_t * nrf_spi_event_address_get(NRF_SPI_Type  * p_reg,
Xstatic __inline uint32_t * nrf_spi_event_address_get(NRF_SPI_Type  * p_reg,
N                                                     nrf_spi_event_t spi_event);
N
N/**
N * @brief Function for enabling specified interrupts.
N *
N * @param[in] p_reg         Pointer to the peripheral registers structure.
N * @param[in] spi_int_mask  Interrupts to enable.
N */
N__STATIC_INLINE void nrf_spi_int_enable(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_int_enable(NRF_SPI_Type * p_reg,
N                                        uint32_t spi_int_mask);
N
N/**
N * @brief Function for disabling specified interrupts.
N *
N * @param[in] p_reg         Pointer to the peripheral registers structure.
N * @param[in] spi_int_mask  Interrupts to disable.
N */
N__STATIC_INLINE void nrf_spi_int_disable(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_int_disable(NRF_SPI_Type * p_reg,
N                                         uint32_t spi_int_mask);
N
N/**
N * @brief Function for retrieving the state of a given interrupt.
N *
N * @param[in] p_reg   Pointer to the peripheral registers structure.
N * @param[in] spi_int Interrupt to check.
N *
N * @retval true  If the interrupt is enabled.
N * @retval false If the interrupt is not enabled.
N */
N__STATIC_INLINE bool nrf_spi_int_enable_check(NRF_SPI_Type * p_reg,
Xstatic __inline _Bool nrf_spi_int_enable_check(NRF_SPI_Type * p_reg,
N                                              nrf_spi_int_mask_t spi_int);
N
N/**
N * @brief Function for enabling the SPI peripheral.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N */
N__STATIC_INLINE void nrf_spi_enable(NRF_SPI_Type * p_reg);
Xstatic __inline void nrf_spi_enable(NRF_SPI_Type * p_reg);
N
N/**
N * @brief Function for disabling the SPI peripheral.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N */
N__STATIC_INLINE void nrf_spi_disable(NRF_SPI_Type * p_reg);
Xstatic __inline void nrf_spi_disable(NRF_SPI_Type * p_reg);
N
N/**
N * @brief Function for configuring SPI pins.
N *
N * If a given signal is not needed, pass the @ref NRF_SPI_PIN_NOT_CONNECTED
N * value instead of its pin number.
N *
N * @param[in] p_reg     Pointer to the peripheral registers structure.
N * @param[in] sck_pin   SCK pin number.
N * @param[in] mosi_pin  MOSI pin number.
N * @param[in] miso_pin  MISO pin number.
N */
N__STATIC_INLINE void nrf_spi_pins_set(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_pins_set(NRF_SPI_Type * p_reg,
N                                      uint32_t sck_pin,
N                                      uint32_t mosi_pin,
N                                      uint32_t miso_pin);
N
N/**
N * @brief Function for writing data to the SPI transmitter register.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N * @param[in] data  TX data to send.
N */
N__STATIC_INLINE void nrf_spi_txd_set(NRF_SPI_Type * p_reg, uint8_t data);
Xstatic __inline void nrf_spi_txd_set(NRF_SPI_Type * p_reg, uint8_t data);
N
N/**
N * @brief Function for reading data from the SPI receiver register.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N *
N * @return RX data received.
N */
N__STATIC_INLINE uint8_t nrf_spi_rxd_get(NRF_SPI_Type * p_reg);
Xstatic __inline uint8_t nrf_spi_rxd_get(NRF_SPI_Type * p_reg);
N
N/**
N * @brief Function for setting the SPI master data rate.
N *
N * @param[in] p_reg     Pointer to the peripheral registers structure.
N * @param[in] frequency SPI frequency.
N */
N__STATIC_INLINE void nrf_spi_frequency_set(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_frequency_set(NRF_SPI_Type * p_reg,
N                                           nrf_spi_frequency_t frequency);
N
N/**
N * @brief Function for setting the SPI configuration.
N *
N * @param[in] p_reg         Pointer to the peripheral registers structure.
N * @param[in] spi_mode      SPI mode.
N * @param[in] spi_bit_order SPI bit order.
N */
N__STATIC_INLINE void nrf_spi_configure(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_configure(NRF_SPI_Type * p_reg,
N                                       nrf_spi_mode_t spi_mode,
N                                       nrf_spi_bit_order_t spi_bit_order);
N
N
N#ifndef SUPPRESS_INLINE_IMPLEMENTATION
N
N__STATIC_INLINE void nrf_spi_event_clear(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_event_clear(NRF_SPI_Type * p_reg,
N                                         nrf_spi_event_t spi_event)
N{
N    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spi_event)) = 0x0UL;
N#if __CORTEX_M == 0x04
X#if (0x04U) == 0x04
N    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spi_event));
N    (void)dummy;
N#endif
N}
N
N__STATIC_INLINE bool nrf_spi_event_check(NRF_SPI_Type * p_reg,
Xstatic __inline _Bool nrf_spi_event_check(NRF_SPI_Type * p_reg,
N                                         nrf_spi_event_t spi_event)
N{
N    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spi_event);
X    return (_Bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spi_event);
N}
N
N__STATIC_INLINE uint32_t * nrf_spi_event_address_get(NRF_SPI_Type * p_reg,
Xstatic __inline uint32_t * nrf_spi_event_address_get(NRF_SPI_Type * p_reg,
N                                                     nrf_spi_event_t spi_event)
N{
N    return (uint32_t *)((uint8_t *)p_reg + (uint32_t)spi_event);
N}
N
N__STATIC_INLINE void nrf_spi_int_enable(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_int_enable(NRF_SPI_Type * p_reg,
N                                        uint32_t spi_int_mask)
N{
N    p_reg->INTENSET = spi_int_mask;
N}
N
N__STATIC_INLINE void nrf_spi_int_disable(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_int_disable(NRF_SPI_Type * p_reg,
N                                         uint32_t spi_int_mask)
N{
N    p_reg->INTENCLR = spi_int_mask;
N}
N
N__STATIC_INLINE bool nrf_spi_int_enable_check(NRF_SPI_Type * p_reg,
Xstatic __inline _Bool nrf_spi_int_enable_check(NRF_SPI_Type * p_reg,
N                                              nrf_spi_int_mask_t spi_int)
N{
N    return (bool)(p_reg->INTENSET & spi_int);
X    return (_Bool)(p_reg->INTENSET & spi_int);
N}
N
N__STATIC_INLINE void nrf_spi_enable(NRF_SPI_Type * p_reg)
Xstatic __inline void nrf_spi_enable(NRF_SPI_Type * p_reg)
N{
N    p_reg->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
X    p_reg->ENABLE = ((1UL) << (0UL));
N}
N
N__STATIC_INLINE void nrf_spi_disable(NRF_SPI_Type * p_reg)
Xstatic __inline void nrf_spi_disable(NRF_SPI_Type * p_reg)
N{
N    p_reg->ENABLE = (SPI_ENABLE_ENABLE_Disabled << SPI_ENABLE_ENABLE_Pos);
X    p_reg->ENABLE = ((0UL) << (0UL));
N}
N
N__STATIC_INLINE void nrf_spi_pins_set(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_pins_set(NRF_SPI_Type * p_reg,
N                                      uint32_t sck_pin,
N                                      uint32_t mosi_pin,
N                                      uint32_t miso_pin)
N{
N    p_reg->PSELSCK  = sck_pin;
X    p_reg->PSEL . SCK  = sck_pin;
N    p_reg->PSELMOSI = mosi_pin;
X    p_reg->PSEL . MOSI = mosi_pin;
N    p_reg->PSELMISO = miso_pin;
X    p_reg->PSEL . MISO = miso_pin;
N}
N
N__STATIC_INLINE void nrf_spi_txd_set(NRF_SPI_Type * p_reg, uint8_t data)
Xstatic __inline void nrf_spi_txd_set(NRF_SPI_Type * p_reg, uint8_t data)
N{
N    p_reg->TXD = data;
N}
N
N__STATIC_INLINE uint8_t nrf_spi_rxd_get(NRF_SPI_Type * p_reg)
Xstatic __inline uint8_t nrf_spi_rxd_get(NRF_SPI_Type * p_reg)
N{
N    return p_reg->RXD;
N}
N
N__STATIC_INLINE void nrf_spi_frequency_set(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_frequency_set(NRF_SPI_Type * p_reg,
N                                           nrf_spi_frequency_t frequency)
N{
N    p_reg->FREQUENCY = frequency;
N}
N
N__STATIC_INLINE void nrf_spi_configure(NRF_SPI_Type * p_reg,
Xstatic __inline void nrf_spi_configure(NRF_SPI_Type * p_reg,
N                                       nrf_spi_mode_t spi_mode,
N                                       nrf_spi_bit_order_t spi_bit_order)
N{
N    uint32_t config = (spi_bit_order == NRF_SPI_BIT_ORDER_MSB_FIRST ?
N        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
X        (0UL) : (1UL));
N    switch (spi_mode)
N    {
N    default:
N    case NRF_SPI_MODE_0:
N        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
X        config |= ((0UL) << (2UL)) |
N                  (SPI_CONFIG_CPHA_Leading    << SPI_CONFIG_CPHA_Pos);
X                  ((0UL)    << (1UL));
N        break;
N
N    case NRF_SPI_MODE_1:
N        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
X        config |= ((0UL) << (2UL)) |
N                  (SPI_CONFIG_CPHA_Trailing   << SPI_CONFIG_CPHA_Pos);
X                  ((1UL)   << (1UL));
N        break;
N
N    case NRF_SPI_MODE_2:
N        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
X        config |= ((1UL)  << (2UL)) |
N                  (SPI_CONFIG_CPHA_Leading    << SPI_CONFIG_CPHA_Pos);
X                  ((0UL)    << (1UL));
N        break;
N
N    case NRF_SPI_MODE_3:
N        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
X        config |= ((1UL)  << (2UL)) |
N                  (SPI_CONFIG_CPHA_Trailing   << SPI_CONFIG_CPHA_Pos);
X                  ((1UL)   << (1UL));
N        break;
N    }
N    p_reg->CONFIG = config;
N}
N
N#endif // SUPPRESS_INLINE_IMPLEMENTATION
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // NRF_SPI_H__
N
N/** @} */
L 27 "..\..\..\..\..\..\components\drivers_nrf\spi_master\nrf_drv_spi.h" 2
N#ifdef SPIM_PRESENT
N#include "nrf_spim.h"
L 1 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_spim.h" 1
N/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/**
N * @defgroup nrf_spim_hal SPIM HAL
N * @{
N * @ingroup nrf_spi
N *
N * @brief Hardware access layer for accessing the SPIM peripheral.
N */
N
N#ifndef NRF_SPIM_H__
N#define NRF_SPIM_H__
N
N#include <stddef.h>
N#include <stdbool.h>
N#include <stdint.h>
N
N#include "nrf.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * @brief This value can be used as a parameter for the @ref nrf_spim_pins_set
N *        function to specify that a given SPI signal (SCK, MOSI, or MISO)
N *        shall not be connected to a physical pin.
N */
N#define NRF_SPIM_PIN_NOT_CONNECTED  0xFFFFFFFF
N
N
N/**
N * @brief SPIM tasks.
N */
Ntypedef enum
N{
N    /*lint -save -e30*/
N    NRF_SPIM_TASK_START   = offsetof(NRF_SPIM_Type, TASKS_START),   ///< Start SPI transaction.
X    NRF_SPIM_TASK_START   = (( size_t)__INTADDR__(&(((NRF_SPIM_Type *)0)->TASKS_START))),   
N    NRF_SPIM_TASK_STOP    = offsetof(NRF_SPIM_Type, TASKS_STOP),    ///< Stop SPI transaction.
X    NRF_SPIM_TASK_STOP    = (( size_t)__INTADDR__(&(((NRF_SPIM_Type *)0)->TASKS_STOP))),    
N    NRF_SPIM_TASK_SUSPEND = offsetof(NRF_SPIM_Type, TASKS_SUSPEND), ///< Suspend SPI transaction.
X    NRF_SPIM_TASK_SUSPEND = (( size_t)__INTADDR__(&(((NRF_SPIM_Type *)0)->TASKS_SUSPEND))), 
N    NRF_SPIM_TASK_RESUME  = offsetof(NRF_SPIM_Type, TASKS_RESUME)   ///< Resume SPI transaction.
X    NRF_SPIM_TASK_RESUME  = (( size_t)__INTADDR__(&(((NRF_SPIM_Type *)0)->TASKS_RESUME)))   
N    /*lint -restore*/
N} nrf_spim_task_t;
N
N/**
N * @brief SPIM events.
N */
Ntypedef enum
N{
N    /*lint -save -e30*/
N    NRF_SPIM_EVENT_STOPPED = offsetof(NRF_SPIM_Type, EVENTS_STOPPED), ///< SPI transaction has stopped.
X    NRF_SPIM_EVENT_STOPPED = (( size_t)__INTADDR__(&(((NRF_SPIM_Type *)0)->EVENTS_STOPPED))), 
N    NRF_SPIM_EVENT_ENDRX   = offsetof(NRF_SPIM_Type, EVENTS_ENDRX),   ///< End of RXD buffer reached.
X    NRF_SPIM_EVENT_ENDRX   = (( size_t)__INTADDR__(&(((NRF_SPIM_Type *)0)->EVENTS_ENDRX))),   
N    NRF_SPIM_EVENT_END     = offsetof(NRF_SPIM_Type, EVENTS_END),     ///< End of RXD buffer and TXD buffer reached.
X    NRF_SPIM_EVENT_END     = (( size_t)__INTADDR__(&(((NRF_SPIM_Type *)0)->EVENTS_END))),     
N    NRF_SPIM_EVENT_ENDTX   = offsetof(NRF_SPIM_Type, EVENTS_ENDTX),   ///< End of TXD buffer reached.
X    NRF_SPIM_EVENT_ENDTX   = (( size_t)__INTADDR__(&(((NRF_SPIM_Type *)0)->EVENTS_ENDTX))),   
N    NRF_SPIM_EVENT_STARTED = offsetof(NRF_SPIM_Type, EVENTS_STARTED)  ///< Transaction started.
X    NRF_SPIM_EVENT_STARTED = (( size_t)__INTADDR__(&(((NRF_SPIM_Type *)0)->EVENTS_STARTED)))  
N    /*lint -restore*/
N} nrf_spim_event_t;
N
N/**
N * @brief SPIM shortcuts.
N */
Ntypedef enum
N{
N    NRF_SPIM_SHORT_END_START_MASK = SPIM_SHORTS_END_START_Msk ///< Shortcut between END event and START task.
X    NRF_SPIM_SHORT_END_START_MASK = (0x1UL << (17UL)) 
N} nrf_spim_short_mask_t;
N
N/**
N * @brief SPIM interrupts.
N */
Ntypedef enum
N{
N    NRF_SPIM_INT_STOPPED_MASK = SPIM_INTENSET_STOPPED_Msk, ///< Interrupt on STOPPED event.
X    NRF_SPIM_INT_STOPPED_MASK = (0x1UL << (1UL)), 
N    NRF_SPIM_INT_ENDRX_MASK   = SPIM_INTENSET_ENDRX_Msk,   ///< Interrupt on ENDRX event.
X    NRF_SPIM_INT_ENDRX_MASK   = (0x1UL << (4UL)),   
N    NRF_SPIM_INT_END_MASK     = SPIM_INTENSET_END_Msk,     ///< Interrupt on END event.
X    NRF_SPIM_INT_END_MASK     = (0x1UL << (6UL)),     
N    NRF_SPIM_INT_ENDTX_MASK   = SPIM_INTENSET_ENDTX_Msk,   ///< Interrupt on ENDTX event.
X    NRF_SPIM_INT_ENDTX_MASK   = (0x1UL << (8UL)),   
N    NRF_SPIM_INT_STARTED_MASK = SPIM_INTENSET_STARTED_Msk  ///< Interrupt on STARTED event.
X    NRF_SPIM_INT_STARTED_MASK = (0x1UL << (19UL))  
N} nrf_spim_int_mask_t;
N
N/**
N * @brief SPI master data rates.
N */
Ntypedef enum
N{
N    NRF_SPIM_FREQ_125K = SPIM_FREQUENCY_FREQUENCY_K125,   ///< 125 kbps.
X    NRF_SPIM_FREQ_125K = (0x02000000UL),   
N    NRF_SPIM_FREQ_250K = SPIM_FREQUENCY_FREQUENCY_K250,   ///< 250 kbps.
X    NRF_SPIM_FREQ_250K = (0x04000000UL),   
N    NRF_SPIM_FREQ_500K = SPIM_FREQUENCY_FREQUENCY_K500,   ///< 500 kbps.
X    NRF_SPIM_FREQ_500K = (0x08000000UL),   
N    NRF_SPIM_FREQ_1M   = SPIM_FREQUENCY_FREQUENCY_M1,     ///< 1 Mbps.
X    NRF_SPIM_FREQ_1M   = (0x10000000UL),     
N    NRF_SPIM_FREQ_2M   = SPIM_FREQUENCY_FREQUENCY_M2,     ///< 2 Mbps.
X    NRF_SPIM_FREQ_2M   = (0x20000000UL),     
N    NRF_SPIM_FREQ_4M   = SPIM_FREQUENCY_FREQUENCY_M4,     ///< 4 Mbps.
X    NRF_SPIM_FREQ_4M   = (0x40000000UL),     
N    // [conversion to 'int' needed to prevent compilers from complaining
N    //  that the provided value (0x80000000UL) is out of range of "int"]
N    NRF_SPIM_FREQ_8M   = (int)SPIM_FREQUENCY_FREQUENCY_M8 ///< 8 Mbps.
X    NRF_SPIM_FREQ_8M   = (int)(0x80000000UL) 
N} nrf_spim_frequency_t;
N
N/**
N * @brief SPI modes.
N */
Ntypedef enum
N{
N    NRF_SPIM_MODE_0, ///< SCK active high, sample on leading edge of clock.
N    NRF_SPIM_MODE_1, ///< SCK active high, sample on trailing edge of clock.
N    NRF_SPIM_MODE_2, ///< SCK active low, sample on leading edge of clock.
N    NRF_SPIM_MODE_3  ///< SCK active low, sample on trailing edge of clock.
N} nrf_spim_mode_t;
N
N/**
N * @brief SPI bit orders.
N */
Ntypedef enum
N{
N    NRF_SPIM_BIT_ORDER_MSB_FIRST = SPIM_CONFIG_ORDER_MsbFirst, ///< Most significant bit shifted out first.
X    NRF_SPIM_BIT_ORDER_MSB_FIRST = (0UL), 
N    NRF_SPIM_BIT_ORDER_LSB_FIRST = SPIM_CONFIG_ORDER_LsbFirst  ///< Least significant bit shifted out first.
X    NRF_SPIM_BIT_ORDER_LSB_FIRST = (1UL)  
N} nrf_spim_bit_order_t;
N
N
N/**
N * @brief Function for activating a specific SPIM task.
N *
N * @param[in] p_reg     Pointer to the peripheral registers structure.
N * @param[in] spim_task Task to activate.
N */
N__STATIC_INLINE void nrf_spim_task_trigger(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_task_trigger(NRF_SPIM_Type * p_reg,
N                                           nrf_spim_task_t spim_task);
N
N/**
N * @brief Function for getting the address of a specific SPIM task register.
N *
N * @param[in] p_reg     Pointer to the peripheral registers structure.
N * @param[in] spim_task Requested task.
N *
N * @return Address of the specified task register.
N */
N__STATIC_INLINE uint32_t nrf_spim_task_address_get(NRF_SPIM_Type * p_reg,
Xstatic __inline uint32_t nrf_spim_task_address_get(NRF_SPIM_Type * p_reg,
N                                                   nrf_spim_task_t spim_task);
N
N/**
N * @brief Function for clearing a specific SPIM event.
N *
N * @param[in] p_reg      Pointer to the peripheral registers structure.
N * @param[in] spim_event Event to clear.
N */
N__STATIC_INLINE void nrf_spim_event_clear(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_event_clear(NRF_SPIM_Type * p_reg,
N                                          nrf_spim_event_t spim_event);
N
N/**
N * @brief Function for checking the state of a specific SPIM event.
N *
N * @param[in] p_reg      Pointer to the peripheral registers structure.
N * @param[in] spim_event Event to check.
N *
N * @retval true  If the event is set.
N * @retval false If the event is not set.
N */
N__STATIC_INLINE bool nrf_spim_event_check(NRF_SPIM_Type * p_reg,
Xstatic __inline _Bool nrf_spim_event_check(NRF_SPIM_Type * p_reg,
N                                          nrf_spim_event_t spim_event);
N
N/**
N * @brief Function for getting the address of a specific SPIM event register.
N *
N * @param[in] p_reg      Pointer to the peripheral registers structure.
N * @param[in] spim_event Requested event.
N *
N * @return Address of the specified event register.
N */
N__STATIC_INLINE uint32_t nrf_spim_event_address_get(NRF_SPIM_Type  * p_reg,
Xstatic __inline uint32_t nrf_spim_event_address_get(NRF_SPIM_Type  * p_reg,
N                                                    nrf_spim_event_t spim_event);
N/**
N * @brief Function for enabling specified shortcuts.
N *
N * @param[in] p_reg            Pointer to the peripheral registers structure.
N * @param[in] spim_shorts_mask Shortcuts to enable.
N */
N__STATIC_INLINE void nrf_spim_shorts_enable(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_shorts_enable(NRF_SPIM_Type * p_reg,
N                                            uint32_t spim_shorts_mask);
N
N/**
N * @brief Function for disabling specified shortcuts.
N *
N * @param[in] p_reg            Pointer to the peripheral registers structure.
N * @param[in] spim_shorts_mask Shortcuts to disable.
N */
N__STATIC_INLINE void nrf_spim_shorts_disable(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_shorts_disable(NRF_SPIM_Type * p_reg,
N                                             uint32_t spim_shorts_mask);
N
N/**
N * @brief Function for getting shorts setting.
N *
N * @param[in] p_reg           Pointer to the peripheral registers structure.
N */
N__STATIC_INLINE uint32_t nrf_spim_shorts_get(NRF_SPIM_Type * p_reg);
Xstatic __inline uint32_t nrf_spim_shorts_get(NRF_SPIM_Type * p_reg);
N
N/**
N * @brief Function for enabling specified interrupts.
N *
N * @param[in] p_reg        Pointer to the peripheral registers structure.
N * @param[in] spim_int_mask Interrupts to enable.
N */
N__STATIC_INLINE void nrf_spim_int_enable(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_int_enable(NRF_SPIM_Type * p_reg,
N                                         uint32_t spim_int_mask);
N
N/**
N * @brief Function for disabling specified interrupts.
N *
N * @param[in] p_reg        Pointer to the peripheral registers structure.
N * @param[in] spim_int_mask Interrupts to disable.
N */
N__STATIC_INLINE void nrf_spim_int_disable(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_int_disable(NRF_SPIM_Type * p_reg,
N                                          uint32_t spim_int_mask);
N
N/**
N * @brief Function for retrieving the state of a given interrupt.
N *
N * @param[in] p_reg   Pointer to the peripheral registers structure.
N * @param[in] spim_int Interrupt to check.
N *
N * @retval true  If the interrupt is enabled.
N * @retval false If the interrupt is not enabled.
N */
N__STATIC_INLINE bool nrf_spim_int_enable_check(NRF_SPIM_Type * p_reg,
Xstatic __inline _Bool nrf_spim_int_enable_check(NRF_SPIM_Type * p_reg,
N                                               nrf_spim_int_mask_t spim_int);
N
N/**
N * @brief Function for enabling the SPIM peripheral.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N */
N__STATIC_INLINE void nrf_spim_enable(NRF_SPIM_Type * p_reg);
Xstatic __inline void nrf_spim_enable(NRF_SPIM_Type * p_reg);
N
N/**
N * @brief Function for disabling the SPIM peripheral.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N */
N__STATIC_INLINE void nrf_spim_disable(NRF_SPIM_Type * p_reg);
Xstatic __inline void nrf_spim_disable(NRF_SPIM_Type * p_reg);
N
N/**
N * @brief Function for configuring SPIM pins.
N *
N * If a given signal is not needed, pass the @ref NRF_SPIM_PIN_NOT_CONNECTED
N * value instead of its pin number.
N *
N * @param[in] p_reg    Pointer to the peripheral registers structure.
N * @param[in] sck_pin   SCK pin number.
N * @param[in] mosi_pin  MOSI pin number.
N * @param[in] miso_pin  MISO pin number.
N */
N__STATIC_INLINE void nrf_spim_pins_set(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_pins_set(NRF_SPIM_Type * p_reg,
N                                       uint32_t sck_pin,
N                                       uint32_t mosi_pin,
N                                       uint32_t miso_pin);
N
N/**
N * @brief Function for setting the SPI master data rate.
N *
N * @param[in] p_reg    Pointer to the peripheral registers structure.
N * @param[in] frequency SPI frequency.
N */
N__STATIC_INLINE void nrf_spim_frequency_set(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_frequency_set(NRF_SPIM_Type * p_reg,
N                                            nrf_spim_frequency_t frequency);
N
N/**
N * @brief Function for setting the transmit buffer.
N *
N * @param[in]  p_reg   Pointer to the peripheral registers structure.
N * @param[in]  p_buffer Pointer to the buffer with data to send.
N * @param[in]  length   Maximum number of data bytes to transmit.
N */
N__STATIC_INLINE void nrf_spim_tx_buffer_set(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_tx_buffer_set(NRF_SPIM_Type * p_reg,
N                                            uint8_t const * p_buffer,
N                                            uint8_t         length);
N
N/**
N * @brief Function for setting the receive buffer.
N *
N * @param[in] p_reg   Pointer to the peripheral registers structure.
N * @param[in] p_buffer Pointer to the buffer for received data.
N * @param[in] length   Maximum number of data bytes to receive.
N */
N__STATIC_INLINE void nrf_spim_rx_buffer_set(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_rx_buffer_set(NRF_SPIM_Type * p_reg,
N                                            uint8_t * p_buffer,
N                                            uint8_t   length);
N
N/**
N * @brief Function for setting the SPI configuration.
N *
N * @param[in] p_reg        Pointer to the peripheral registers structure.
N * @param[in] spi_mode      SPI mode.
N * @param[in] spi_bit_order SPI bit order.
N */
N__STATIC_INLINE void nrf_spim_configure(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_configure(NRF_SPIM_Type * p_reg,
N                                        nrf_spim_mode_t spi_mode,
N                                        nrf_spim_bit_order_t spi_bit_order);
N
N/**
N * @brief Function for setting the over-read character.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N * @param[in] orc    Over-read character that is clocked out in case of
N *                   an over-read of the TXD buffer.
N */
N__STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
N                                      uint8_t orc);
N
N/**
N * @brief Function for enabling the TX list feature.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N */
N__STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg);
Xstatic __inline void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg);
N
N/**
N * @brief Function for disabling the TX list feature.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N */
N__STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg);
Xstatic __inline void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg);
N
N/**
N * @brief Function for enabling the RX list feature.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N */
N__STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg);
Xstatic __inline void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg);
N
N/**
N * @brief Function for disabling the RX list feature.
N *
N * @param[in] p_reg Pointer to the peripheral registers structure.
N */
N__STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg);
Xstatic __inline void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg);
N
N#ifndef SUPPRESS_INLINE_IMPLEMENTATION
N
N__STATIC_INLINE void nrf_spim_task_trigger(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_task_trigger(NRF_SPIM_Type * p_reg,
N                                           nrf_spim_task_t spim_task)
N{
N    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spim_task)) = 0x1UL;
N}
N
N__STATIC_INLINE uint32_t nrf_spim_task_address_get(NRF_SPIM_Type * p_reg,
Xstatic __inline uint32_t nrf_spim_task_address_get(NRF_SPIM_Type * p_reg,
N                                                   nrf_spim_task_t spim_task)
N{
N    return (uint32_t)((uint8_t *)p_reg + (uint32_t)spim_task);
N}
N
N__STATIC_INLINE void nrf_spim_event_clear(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_event_clear(NRF_SPIM_Type * p_reg,
N                                          nrf_spim_event_t spim_event)
N{
N    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spim_event)) = 0x0UL;
N#if __CORTEX_M == 0x04
X#if (0x04U) == 0x04
N    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spim_event));
N    (void)dummy;
N#endif
N}
N
N__STATIC_INLINE bool nrf_spim_event_check(NRF_SPIM_Type * p_reg,
Xstatic __inline _Bool nrf_spim_event_check(NRF_SPIM_Type * p_reg,
N                                          nrf_spim_event_t spim_event)
N{
N    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spim_event);
X    return (_Bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spim_event);
N}
N
N__STATIC_INLINE uint32_t nrf_spim_event_address_get(NRF_SPIM_Type * p_reg,
Xstatic __inline uint32_t nrf_spim_event_address_get(NRF_SPIM_Type * p_reg,
N                                                    nrf_spim_event_t spim_event)
N{
N    return (uint32_t)((uint8_t *)p_reg + (uint32_t)spim_event);
N}
N
N__STATIC_INLINE void nrf_spim_shorts_enable(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_shorts_enable(NRF_SPIM_Type * p_reg,
N                                            uint32_t spim_shorts_mask)
N{
N    p_reg->SHORTS |= spim_shorts_mask;
N}
N
N__STATIC_INLINE void nrf_spim_shorts_disable(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_shorts_disable(NRF_SPIM_Type * p_reg,
N                                             uint32_t spim_shorts_mask)
N{
N    p_reg->SHORTS &= ~(spim_shorts_mask);
N}
N
N__STATIC_INLINE uint32_t nrf_spim_shorts_get(NRF_SPIM_Type * p_reg)
Xstatic __inline uint32_t nrf_spim_shorts_get(NRF_SPIM_Type * p_reg)
N{
N    return p_reg->SHORTS;
N}
N
N__STATIC_INLINE void nrf_spim_int_enable(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_int_enable(NRF_SPIM_Type * p_reg,
N                                         uint32_t spim_int_mask)
N{
N    p_reg->INTENSET = spim_int_mask;
N}
N
N__STATIC_INLINE void nrf_spim_int_disable(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_int_disable(NRF_SPIM_Type * p_reg,
N                                          uint32_t spim_int_mask)
N{
N    p_reg->INTENCLR = spim_int_mask;
N}
N
N__STATIC_INLINE bool nrf_spim_int_enable_check(NRF_SPIM_Type * p_reg,
Xstatic __inline _Bool nrf_spim_int_enable_check(NRF_SPIM_Type * p_reg,
N                                               nrf_spim_int_mask_t spim_int)
N{
N    return (bool)(p_reg->INTENSET & spim_int);
X    return (_Bool)(p_reg->INTENSET & spim_int);
N}
N
N__STATIC_INLINE void nrf_spim_enable(NRF_SPIM_Type * p_reg)
Xstatic __inline void nrf_spim_enable(NRF_SPIM_Type * p_reg)
N{
N    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
X    p_reg->ENABLE = ((7UL) << (0UL));
N}
N
N__STATIC_INLINE void nrf_spim_disable(NRF_SPIM_Type * p_reg)
Xstatic __inline void nrf_spim_disable(NRF_SPIM_Type * p_reg)
N{
N    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Disabled << SPIM_ENABLE_ENABLE_Pos);
X    p_reg->ENABLE = ((0UL) << (0UL));
N}
N
N__STATIC_INLINE void nrf_spim_pins_set(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_pins_set(NRF_SPIM_Type * p_reg,
N                                       uint32_t sck_pin,
N                                       uint32_t mosi_pin,
N                                       uint32_t miso_pin)
N{
N    p_reg->PSEL.SCK  = sck_pin;
N    p_reg->PSEL.MOSI = mosi_pin;
N    p_reg->PSEL.MISO = miso_pin;
N}
N
N__STATIC_INLINE void nrf_spim_frequency_set(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_frequency_set(NRF_SPIM_Type * p_reg,
N                                            nrf_spim_frequency_t frequency)
N{
N    p_reg->FREQUENCY = frequency;
N}
N
N__STATIC_INLINE void nrf_spim_tx_buffer_set(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_tx_buffer_set(NRF_SPIM_Type * p_reg,
N                                            uint8_t const * p_buffer,
N                                            uint8_t         length)
N{
N    p_reg->TXD.PTR    = (uint32_t)p_buffer;
N    p_reg->TXD.MAXCNT = length;
N}
N
N__STATIC_INLINE void nrf_spim_rx_buffer_set(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_rx_buffer_set(NRF_SPIM_Type * p_reg,
N                                            uint8_t * p_buffer,
N                                            uint8_t   length)
N{
N    p_reg->RXD.PTR    = (uint32_t)p_buffer;
N    p_reg->RXD.MAXCNT = length;
N}
N
N__STATIC_INLINE void nrf_spim_configure(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_configure(NRF_SPIM_Type * p_reg,
N                                        nrf_spim_mode_t spi_mode,
N                                        nrf_spim_bit_order_t spi_bit_order)
N{
N    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
N        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
X        (0UL) : (1UL));
N    switch (spi_mode)
N    {
N    default:
N    case NRF_SPIM_MODE_0:
N        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
X        config |= ((0UL) << (2UL)) |
N                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
X                  ((0UL)    << (1UL));
N        break;
N
N    case NRF_SPIM_MODE_1:
N        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
X        config |= ((0UL) << (2UL)) |
N                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
X                  ((1UL)   << (1UL));
N        break;
N
N    case NRF_SPIM_MODE_2:
N        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
X        config |= ((1UL)  << (2UL)) |
N                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
X                  ((0UL)    << (1UL));
N        break;
N
N    case NRF_SPIM_MODE_3:
N        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
X        config |= ((1UL)  << (2UL)) |
N                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
X                  ((1UL)   << (1UL));
N        break;
N    }
N    p_reg->CONFIG = config;
N}
N
N__STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
Xstatic __inline void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
N                                      uint8_t orc)
N{
N    p_reg->ORC = orc;
N}
N
N
N__STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
Xstatic __inline void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
N{
N    p_reg->TXD.LIST = 1;
N}
N
N__STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
Xstatic __inline void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
N{
N    p_reg->TXD.LIST = 0;
N}
N
N__STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
Xstatic __inline void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
N{
N    p_reg->RXD.LIST = 1;
N}
N
N__STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
Xstatic __inline void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
N{
N    p_reg->RXD.LIST = 0;
N}
N
N#endif // SUPPRESS_INLINE_IMPLEMENTATION
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // NRF_SPIM_H__
N
N/** @} */
L 29 "..\..\..\..\..\..\components\drivers_nrf\spi_master\nrf_drv_spi.h" 2
N#endif
N#include "sdk_errors.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if defined(SPIM_PRESENT)
X#if 1L
N    #define NRF_DRV_SPI_PERIPHERAL(id)           \
N        (CONCAT_3(SPI, id, _USE_EASY_DMA) == 1 ? \
N            (void *)CONCAT_2(NRF_SPIM, id)       \
N          : (void *)CONCAT_2(NRF_SPI, id))
X    #define NRF_DRV_SPI_PERIPHERAL(id)                   (CONCAT_3(SPI, id, _USE_EASY_DMA) == 1 ?             (void *)CONCAT_2(NRF_SPIM, id)                 : (void *)CONCAT_2(NRF_SPI, id))
N    #define SPI2_IRQ            SPIM2_SPIS2_SPI2_IRQn
N    #define SPI2_IRQ_HANDLER    SPIM2_SPIS2_SPI2_IRQHandler
N#else
S    #define NRF_DRV_SPI_PERIPHERAL(id)  (void *)CONCAT_2(NRF_SPI, id)
N#endif
N#define SPI0_IRQ            SPI0_TWI0_IRQn
N#define SPI0_IRQ_HANDLER    SPI0_TWI0_IRQHandler
N#define SPI1_IRQ            SPI1_TWI1_IRQn
N#define SPI1_IRQ_HANDLER    SPI1_TWI1_IRQHandler
N
N
N/**
N * @defgroup nrf_drv_spi SPI master driver
N * @{
N * @ingroup  nrf_spi
N *
N * @brief    Multi-instance SPI master driver.
N */
N
N/**
N * @brief SPI master driver instance data structure.
N */
Ntypedef struct
N{
N    void *    p_registers;  ///< Pointer to the structure with SPI/SPIM peripheral instance registers.
N    IRQn_Type irq;          ///< SPI/SPIM peripheral instance IRQ number.
N    uint8_t   drv_inst_idx; ///< Driver instance index.
N    bool      use_easy_dma; ///< True if the peripheral with EasyDMA (SPIM) shall be used.
X    _Bool      use_easy_dma; 
N} nrf_drv_spi_t;
N
N#define SPI0_INSTANCE_INDEX 0
N#define SPI1_INSTANCE_INDEX SPI0_INSTANCE_INDEX+SPI0_ENABLED
N#define SPI2_INSTANCE_INDEX SPI1_INSTANCE_INDEX+SPI1_ENABLED
N
N/**
N * @brief Macro for creating an SPI master driver instance.
N */
N#define NRF_DRV_SPI_INSTANCE(id)                        \
N{                                                       \
N    .p_registers  = NRF_DRV_SPI_PERIPHERAL(id),         \
N    .irq          = CONCAT_3(SPI, id, _IRQ),            \
N    .drv_inst_idx = CONCAT_3(SPI, id, _INSTANCE_INDEX), \
N    .use_easy_dma = CONCAT_3(SPI, id, _USE_EASY_DMA)    \
N}
X#define NRF_DRV_SPI_INSTANCE(id)                        {                                                           .p_registers  = NRF_DRV_SPI_PERIPHERAL(id),             .irq          = CONCAT_3(SPI, id, _IRQ),                .drv_inst_idx = CONCAT_3(SPI, id, _INSTANCE_INDEX),     .use_easy_dma = CONCAT_3(SPI, id, _USE_EASY_DMA)    }
N
N/**
N * @brief This value can be provided instead of a pin number for signals MOSI,
N *        MISO, and Slave Select to specify that the given signal is not used and
N *        therefore does not need to be connected to a pin.
N */
N#define NRF_DRV_SPI_PIN_NOT_USED  0xFF
N
N/**
N * @brief SPI data rates.
N */
Ntypedef enum
N{
N    NRF_DRV_SPI_FREQ_125K = NRF_SPI_FREQ_125K, ///< 125 kbps.
N    NRF_DRV_SPI_FREQ_250K = NRF_SPI_FREQ_250K, ///< 250 kbps.
N    NRF_DRV_SPI_FREQ_500K = NRF_SPI_FREQ_500K, ///< 500 kbps.
N    NRF_DRV_SPI_FREQ_1M   = NRF_SPI_FREQ_1M,   ///< 1 Mbps.
N    NRF_DRV_SPI_FREQ_2M   = NRF_SPI_FREQ_2M,   ///< 2 Mbps.
N    NRF_DRV_SPI_FREQ_4M   = NRF_SPI_FREQ_4M,   ///< 4 Mbps.
N    NRF_DRV_SPI_FREQ_8M   = NRF_SPI_FREQ_8M    ///< 8 Mbps.
N} nrf_drv_spi_frequency_t;
N
N/**
N * @brief SPI modes.
N */
Ntypedef enum
N{
N    NRF_DRV_SPI_MODE_0 = NRF_SPI_MODE_0, ///< SCK active high, sample on leading edge of clock.
N    NRF_DRV_SPI_MODE_1 = NRF_SPI_MODE_1, ///< SCK active high, sample on trailing edge of clock.
N    NRF_DRV_SPI_MODE_2 = NRF_SPI_MODE_2, ///< SCK active low, sample on leading edge of clock.
N    NRF_DRV_SPI_MODE_3 = NRF_SPI_MODE_3  ///< SCK active low, sample on trailing edge of clock.
N} nrf_drv_spi_mode_t;
N
N/**
N * @brief SPI bit orders.
N */
Ntypedef enum
N{
N    NRF_DRV_SPI_BIT_ORDER_MSB_FIRST = NRF_SPI_BIT_ORDER_MSB_FIRST, ///< Most significant bit shifted out first.
N    NRF_DRV_SPI_BIT_ORDER_LSB_FIRST = NRF_SPI_BIT_ORDER_LSB_FIRST  ///< Least significant bit shifted out first.
N} nrf_drv_spi_bit_order_t;
N
N/**
N * @brief SPI master driver instance configuration structure.
N */
Ntypedef struct
N{
N    uint8_t sck_pin;      ///< SCK pin number.
N    uint8_t mosi_pin;     ///< MOSI pin number (optional).
N                          /**< Set to @ref NRF_DRV_SPI_PIN_NOT_USED
N                           *   if this signal is not needed. */
N    uint8_t miso_pin;     ///< MISO pin number (optional).
N                          /**< Set to @ref NRF_DRV_SPI_PIN_NOT_USED
N                           *   if this signal is not needed. */
N    uint8_t ss_pin;       ///< Slave Select pin number (optional).
N                          /**< Set to @ref NRF_DRV_SPI_PIN_NOT_USED
N                           *   if this signal is not needed. The driver
N                           *   supports only active low for this signal.
N                           *   If the signal should be active high,
N                           *   it must be controlled externally. */
N    uint8_t irq_priority; ///< Interrupt priority.
N    uint8_t orc;          ///< Over-run character.
N                          /**< This character is used when all bytes from the TX buffer are sent,
N                               but the transfer continues due to RX. */
N    nrf_drv_spi_frequency_t frequency; ///< SPI frequency.
N    nrf_drv_spi_mode_t      mode;      ///< SPI mode.
N    nrf_drv_spi_bit_order_t bit_order; ///< SPI bit order.
N} nrf_drv_spi_config_t;
N
N/**
N * @brief SPI master instance default configuration.
N */
N#define NRF_DRV_SPI_DEFAULT_CONFIG                           \
N{                                                            \
N    .sck_pin      = NRF_DRV_SPI_PIN_NOT_USED,                \
N    .mosi_pin     = NRF_DRV_SPI_PIN_NOT_USED,                \
N    .miso_pin     = NRF_DRV_SPI_PIN_NOT_USED,                \
N    .ss_pin       = NRF_DRV_SPI_PIN_NOT_USED,                \
N    .irq_priority = SPI_DEFAULT_CONFIG_IRQ_PRIORITY,         \
N    .orc          = 0xFF,                                    \
N    .frequency    = NRF_DRV_SPI_FREQ_4M,                     \
N    .mode         = NRF_DRV_SPI_MODE_0,                      \
N    .bit_order    = NRF_DRV_SPI_BIT_ORDER_MSB_FIRST,         \
N}
X#define NRF_DRV_SPI_DEFAULT_CONFIG                           {                                                                .sck_pin      = NRF_DRV_SPI_PIN_NOT_USED,                    .mosi_pin     = NRF_DRV_SPI_PIN_NOT_USED,                    .miso_pin     = NRF_DRV_SPI_PIN_NOT_USED,                    .ss_pin       = NRF_DRV_SPI_PIN_NOT_USED,                    .irq_priority = SPI_DEFAULT_CONFIG_IRQ_PRIORITY,             .orc          = 0xFF,                                        .frequency    = NRF_DRV_SPI_FREQ_4M,                         .mode         = NRF_DRV_SPI_MODE_0,                          .bit_order    = NRF_DRV_SPI_BIT_ORDER_MSB_FIRST,         }
N
N#define NRF_DRV_SPI_FLAG_TX_POSTINC          (1UL << 0) /**< TX buffer address incremented after transfer. */
N#define NRF_DRV_SPI_FLAG_RX_POSTINC          (1UL << 1) /**< RX buffer address incremented after transfer. */
N#define NRF_DRV_SPI_FLAG_NO_XFER_EVT_HANDLER (1UL << 2) /**< Interrupt after each transfer is suppressed, and the event handler is not called. */
N#define NRF_DRV_SPI_FLAG_HOLD_XFER           (1UL << 3) /**< Set up the transfer but do not start it. */
N#define NRF_DRV_SPI_FLAG_REPEATED_XFER       (1UL << 4) /**< Flag indicating that the transfer will be executed multiple times. */
N
N/**
N * @brief Single transfer descriptor structure.
N */
Ntypedef struct
N{
N    uint8_t const * p_tx_buffer; ///< Pointer to TX buffer.
N    uint8_t         tx_length;   ///< TX buffer length.
N    uint8_t       * p_rx_buffer; ///< Pointer to RX buffer.
N    uint8_t         rx_length;   ///< RX buffer length.
N}nrf_drv_spi_xfer_desc_t;
N
N
N/**
N * @brief Macro for setting up single transfer descriptor.
N *
N * This macro is for internal use only.
N */
N#define NRF_DRV_SPI_SINGLE_XFER(p_tx, tx_len, p_rx, rx_len)  \
N    {                                                        \
N    .p_tx_buffer = (uint8_t const *)(p_tx),                  \
N    .tx_length = (tx_len),                                   \
N    .p_rx_buffer = (p_rx),                                   \
N    .rx_length = (rx_len),                                   \
N    }
X#define NRF_DRV_SPI_SINGLE_XFER(p_tx, tx_len, p_rx, rx_len)      {                                                            .p_tx_buffer = (uint8_t const *)(p_tx),                      .tx_length = (tx_len),                                       .p_rx_buffer = (p_rx),                                       .rx_length = (rx_len),                                       }
N
N/**
N * @brief Macro for setting duplex TX RX transfer.
N */
N#define NRF_DRV_SPI_XFER_TRX(p_tx_buf, tx_length, p_rx_buf, rx_length)                    \
N        NRF_DRV_SPI_SINGLE_XFER(p_tx_buf, tx_length, p_rx_buf, rx_length)
X#define NRF_DRV_SPI_XFER_TRX(p_tx_buf, tx_length, p_rx_buf, rx_length)                            NRF_DRV_SPI_SINGLE_XFER(p_tx_buf, tx_length, p_rx_buf, rx_length)
N
N/**
N * @brief Macro for setting TX transfer.
N */
N#define NRF_DRV_SPI_XFER_TX(p_buf, length) \
N        NRF_DRV_SPI_SINGLE_XFER(p_buf, length, NULL, 0)
X#define NRF_DRV_SPI_XFER_TX(p_buf, length)         NRF_DRV_SPI_SINGLE_XFER(p_buf, length, NULL, 0)
N
N/**
N * @brief Macro for setting RX transfer.
N */
N#define NRF_DRV_SPI_XFER_RX(p_buf, length) \
N        NRF_DRV_SPI_SINGLE_XFER(NULL, 0, p_buf, length)
X#define NRF_DRV_SPI_XFER_RX(p_buf, length)         NRF_DRV_SPI_SINGLE_XFER(NULL, 0, p_buf, length)
N
N/**
N * @brief SPI master driver event types, passed to the handler routine provided
N *        during initialization.
N */
Ntypedef enum
N{
N    NRF_DRV_SPI_EVENT_DONE, ///< Transfer done.
N} nrf_drv_spi_evt_type_t;
N
Ntypedef struct
N{
N    nrf_drv_spi_evt_type_t  type;      ///< Event type.
N    union
N    {
N        nrf_drv_spi_xfer_desc_t done;  ///< Event data for DONE event.
N    } data;
N} nrf_drv_spi_evt_t;
N
N/**
N * @brief SPI master driver event handler type.
N */
Ntypedef void (*nrf_drv_spi_handler_t)(nrf_drv_spi_evt_t const * p_event);
N
N
N/**
N * @brief Function for initializing the SPI master driver instance.
N *
N * This function configures and enables the specified peripheral.
N *
N * @param[in] p_instance Pointer to the driver instance structure.
N * @param[in] p_config   Pointer to the structure with the initial configuration.
N *                       If NULL, the default configuration is used.
N * @param     handler    Event handler provided by the user. If NULL, transfers
N *                       will be performed in blocking mode.
N *
N * @retval NRF_SUCCESS             If initialization was successful.
N * @retval NRF_ERROR_INVALID_STATE If the driver was already initialized.
N * @retval NRF_ERROR_BUSY          If some other peripheral with the same
N *                                 instance ID is already in use. This is
N *                                 possible only if PERIPHERAL_RESOURCE_SHARING_ENABLED
N *                                 is set to a value other than zero.
N */
Nret_code_t nrf_drv_spi_init(nrf_drv_spi_t const * const p_instance,
N                            nrf_drv_spi_config_t const * p_config,
N                            nrf_drv_spi_handler_t handler);
N
N/**
N * @brief Function for uninitializing the SPI master driver instance.
N *
N * @param[in] p_instance Pointer to the driver instance structure.
N */
Nvoid       nrf_drv_spi_uninit(nrf_drv_spi_t const * const p_instance);
N
N/**
N * @brief Function for starting the SPI data transfer.
N *
N * If an event handler was provided in the @ref nrf_drv_spi_init call, this function
N * returns immediately and the handler is called when the transfer is done.
N * Otherwise, the transfer is performed in blocking mode, which means that this function
N * returns when the transfer is finished.
N *
N * @note Peripherals using EasyDMA (for example, SPIM) require the transfer buffers
N *       to be placed in the Data RAM region. If they are not and an SPIM instance is
N *       used, this function will fail with the error code NRF_ERROR_INVALID_ADDR.
N *
N * @param[in] p_instance       Pointer to the driver instance structure.
N * @param[in] p_tx_buffer      Pointer to the transmit buffer. Can be NULL
N *                             if there is nothing to send.
N * @param     tx_buffer_length Length of the transmit buffer.
N * @param[in] p_rx_buffer      Pointer to the receive buffer. Can be NULL
N *                             if there is nothing to receive.
N * @param     rx_buffer_length Length of the receive buffer.
N *
N * @retval NRF_SUCCESS            If the operation was successful.
N * @retval NRF_ERROR_BUSY         If a previously started transfer has not finished
N *                                yet.
N * @retval NRF_ERROR_INVALID_ADDR If the provided buffers are not placed in the Data
N *                                RAM region.
N */
Nret_code_t nrf_drv_spi_transfer(nrf_drv_spi_t const * const p_instance,
N                                uint8_t const * p_tx_buffer,
N                                uint8_t         tx_buffer_length,
N                                uint8_t       * p_rx_buffer,
N                                uint8_t         rx_buffer_length);
N
N
N/**
N * @brief Function for starting the SPI data transfer with additional option flags.
N *
N * Function enables customizing the transfer by using option flags.
N *
N * Additional options are provided using the flags parameter:
N *
N * - @ref NRF_DRV_SPI_FLAG_TX_POSTINC and @ref NRF_DRV_SPI_FLAG_RX_POSTINC<span></span>:
N *   Post-incrementation of buffer addresses. Supported only by SPIM.
N * - @ref NRF_DRV_SPI_FLAG_HOLD_XFER<span></span>: Driver is not starting the transfer. Use this
N *   flag if the transfer is triggered externally by PPI. Supported only by SPIM. Use
N *   @ref nrf_drv_twi_start_task_get to get the address of the start task.
N * - @ref NRF_DRV_SPI_FLAG_NO_XFER_EVT_HANDLER<span></span>: No user event handler after transfer
N *   completion. This also means no interrupt at the end of the transfer. Supported only by SPIM.
N *   If @ref NRF_DRV_SPI_FLAG_NO_XFER_EVT_HANDLER is used, the driver does not set the instance into
N *   busy state, so you must ensure that the next transfers are set up when SPIM is not active.
N *   @ref nrf_drv_spi_end_event_get function can be used to detect end of transfer. Option can be used
N *   together with @ref NRF_DRV_SPI_FLAG_REPEATED_XFER to prepare a sequence of SPI transfers
N *   without interruptions.
N * - @ref NRF_DRV_SPI_FLAG_REPEATED_XFER<span></span>: Prepare for repeated transfers. You can set
N *   up a number of transfers that will be triggered externally (for example by PPI). An example is
N *   a TXRX transfer with the options @ref NRF_DRV_SPI_FLAG_RX_POSTINC,
N *   @ref NRF_DRV_SPI_FLAG_NO_XFER_EVT_HANDLER, and @ref NRF_DRV_SPI_FLAG_REPEATED_XFER. After the
N *   transfer is set up, a set of transfers can be triggered by PPI that will read, for example,
N *   the same register of an external component and put it into a RAM buffer without any interrupts.
N *   @ref nrf_drv_spi_end_event_get can be used to get the address of the END event, which can be
N *   used to count the number of transfers. If @ref NRF_DRV_SPI_FLAG_REPEATED_XFER is used,
N *   the driver does not set the instance into busy state, so you must ensure that the next
N *   transfers are set up when SPIM is not active. Supported only by SPIM.
N * @note Function is intended to be used only in non-blocking mode.
N *
N * @param p_instance  Pointer to the driver instance structure.
N * @param p_xfer_desc Pointer to the transfer descriptor.
N * @param flags       Transfer options (0 for default settings).
N *
N * @retval NRF_SUCCESS             If the procedure was successful.
N * @retval NRF_ERROR_BUSY          If the driver is not ready for a new transfer.
N * @retval NRF_ERROR_NOT_SUPPORTED If the provided parameters are not supported.
N * @retval NRF_ERROR_INVALID_ADDR  If the provided buffers are not placed in the Data
N *                                 RAM region.
N */
Nret_code_t nrf_drv_spi_xfer(nrf_drv_spi_t     const * const p_instance,
N                            nrf_drv_spi_xfer_desc_t const * p_xfer_desc,
N                            uint32_t                        flags);
N
N/**
N * @brief Function for returning the address of a SPIM start task.
N *
N * This function should be used if @ref nrf_drv_spi_xfer was called with the flag @ref NRF_DRV_SPI_FLAG_HOLD_XFER.
N * In that case, the transfer is not started by the driver, but it must be started externally by PPI.
N *
N * @param[in]  p_instance Pointer to the driver instance structure.
N *
N * @return     Start task address.
N */
Nuint32_t nrf_drv_spi_start_task_get(nrf_drv_spi_t const * p_instance);
N
N/**
N * @brief Function for returning the address of a END SPIM event.
N *
N * A END event can be used to detect the end of a transfer if the @ref NRF_DRV_SPI_FLAG_NO_XFER_EVT_HANDLER
N * option is used.
N *
N * @param[in]  p_instance Pointer to the driver instance structure.
N *
N * @return     END event address.
N */
Nuint32_t nrf_drv_spi_end_event_get(nrf_drv_spi_t const * p_instance);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // NRF_DRV_SPI_H__
N
N/** @} */
L 12 "..\..\..\..\..\..\components\drivers_ext\LS013B7DH06\LS013B7DH06.h" 2
N
N#define LS013_VCOM_PIN 22
N#define LS013_VCOM_HZ	 60
N	
N	
N// Commands (inverted MSB/LSB)
N#define LS013_WR 		0x80					// write line command
N#define LS013_CM 		0x20 					// clear memory command
N#define LS013_VCOM 	0x00					// VCOM 
N
N//LCD resolution
N#define LS013_XRES 128 					//pixels per horizontal line
N#define LS013_YRES 128					 	//pixels per vertical line
N#define LS013_BYTES_LINE 48 		//number of bytes in a line 3bits per pixel 
N
N
N	
Ntypedef uint32_t ret_code_t;
Ntypedef enum {
N		WAITING,
N		SEND_LINE,
N		SEND_END
N} display_status;
N	
Nuint8_t* ls013_init(void);
Nret_code_t  ls013_showframe(uint8_t* fb);
Nret_code_t  ls013_flush(void);
Nret_code_t  ls013_clearframe(void);
Nret_code_t  ls013_drawPixel(uint8_t* fb, uint8_t x, uint8_t y, uint8_t color);
N
Nret_code_t  printText(uint8_t* fb, uint8_t x, uint8_t y, char* text, uint8_t length, uint8_t color);
Nret_code_t  printImage(uint8_t* fb, uint8_t x, uint8_t y, uint8_t *image, uint32_t size);
Nret_code_t  fillWindow(uint8_t* fb, uint8_t x, uint8_t y,uint8_t w, uint8_t h, uint8_t color);
N
N
Ndisplay_status ls013_getStatus(void);
N	
N	
N	
N	
N	
N	
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* LS013B7DH06_H */
L 57 "..\..\..\main.c" 2
N#include "nrf_drv_spi.h"
N
N#include "image.h"
L 1 "..\..\..\image.h" 1
N#ifndef IMAGE_H
N#define IMAGE_H
N
N/* arduino #include <avr/pgmspace.h> */
N#include <stdint.h>
N/* image_h Width 96, Height 96 */
N#define WIDTH_image_h 96
N#define HEIGHT_image_h 96
N
Nconst uint8_t  image_h[] = {
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 1 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 2 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 3 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 4 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 5 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 6 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 7 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 8 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 9 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 10 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 11 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 12 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 13 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 14 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 15 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 16 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 17 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 18 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 19 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 20 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 21 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 22 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xCF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, /* scanline 23 */
N0xFF, 0xFF, 0xFF, 0xF1, 0xFF, 0xE3, 0x8F, 0xFF, 0x1F, 0xFE, 0xFF, 0xFF, /* scanline 24 */
N0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xE3, 0x8F, 0xFF, 0x3F, 0xFC, 0xFF, 0xFF, /* scanline 25 */
N0xFF, 0xFF, 0x1F, 0xF8, 0xFF, 0xC3, 0x87, 0xFF, 0x3F, 0xE0, 0xFF, 0xFF, /* scanline 26 */
N0xFF, 0xFF, 0x07, 0xFC, 0xFF, 0xC3, 0x85, 0xFF, 0x7F, 0xC0, 0xFF, 0xFF, /* scanline 27 */
N0xFF, 0xFF, 0x03, 0xFC, 0xFF, 0x03, 0x80, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, /* scanline 28 */
N0xFF, 0xFF, 0x00, 0xFC, 0xFF, 0x03, 0x80, 0xFF, 0x7F, 0x00, 0xFC, 0xFF, /* scanline 29 */
N0xFF, 0x7F, 0x00, 0xFC, 0xFF, 0x03, 0x80, 0xFF, 0x7F, 0x00, 0xF8, 0xFF, /* scanline 30 */
N0xFF, 0x1F, 0x00, 0xFC, 0xFF, 0x03, 0x80, 0xFF, 0x7F, 0x00, 0xE0, 0xFF, /* scanline 31 */
N0xFF, 0x0F, 0x00, 0xFC, 0xFF, 0x03, 0x80, 0xFF, 0x7F, 0x00, 0xC0, 0xFF, /* scanline 32 */
N0xFF, 0x07, 0x00, 0xFC, 0xFF, 0x03, 0x00, 0xFF, 0x7F, 0x00, 0xC0, 0xFF, /* scanline 33 */
N0xFF, 0x03, 0x00, 0xF8, 0xFF, 0x03, 0x80, 0xFF, 0x7F, 0x00, 0x00, 0xFF, /* scanline 34 */
N0xFF, 0x01, 0x00, 0xF8, 0xFF, 0x03, 0x00, 0xFF, 0x3F, 0x00, 0x00, 0xFE, /* scanline 35 */
N0xFF, 0x00, 0x00, 0xF8, 0xFF, 0x01, 0x00, 0xFF, 0x3F, 0x00, 0x00, 0xFC, /* scanline 36 */
N0x7F, 0x00, 0x00, 0xF0, 0xFF, 0x03, 0x80, 0xFF, 0x1F, 0x00, 0x00, 0xFC, /* scanline 37 */
N0x3F, 0x00, 0x00, 0xF0, 0xFF, 0x01, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0xF8, /* scanline 38 */
N0x3F, 0x00, 0x00, 0xE0, 0xFF, 0x01, 0x00, 0xFF, 0x07, 0x00, 0x00, 0xF0, /* scanline 39 */
N0x1F, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0xFE, 0x07, 0x00, 0x00, 0xF0, /* scanline 40 */
N0x0F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0xE0, /* scanline 41 */
N0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, /* scanline 42 */
N0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, /* scanline 43 */
N0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, /* scanline 44 */
N0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, /* scanline 45 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 46 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 47 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 48 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 49 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 50 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 51 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 52 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 53 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 54 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 55 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 56 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, /* scanline 57 */
N0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, /* scanline 58 */
N0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, /* scanline 59 */
N0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, /* scanline 60 */
N0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, /* scanline 61 */
N0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, /* scanline 62 */
N0x0F, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0xE0, /* scanline 63 */
N0x0F, 0x00, 0xF0, 0x03, 0x60, 0x00, 0x00, 0x18, 0x80, 0x1F, 0x00, 0xF0, /* scanline 64 */
N0x1F, 0x00, 0xF8, 0x0F, 0xFC, 0x00, 0x00, 0x7F, 0xE0, 0x3F, 0x00, 0xF0, /* scanline 65 */
N0x3F, 0x00, 0xF8, 0x1F, 0xFC, 0x03, 0x00, 0x7F, 0xE0, 0x3F, 0x00, 0xF8, /* scanline 66 */
N0x3F, 0x00, 0xFC, 0x1F, 0xFE, 0x03, 0x80, 0xFF, 0xF8, 0x7F, 0x00, 0xFC, /* scanline 67 */
N0x7F, 0x00, 0xFC, 0x7F, 0xFE, 0x07, 0xC0, 0xFF, 0xF8, 0x7F, 0x00, 0xFC, /* scanline 68 */
N0xFF, 0x00, 0xFC, 0x7F, 0xFF, 0x0F, 0xE0, 0xFF, 0xFD, 0x7F, 0x00, 0xFE, /* scanline 69 */
N0xFF, 0x01, 0xFC, 0xFF, 0xFF, 0x0F, 0xE0, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, /* scanline 70 */
N0xFF, 0x03, 0xFC, 0xFF, 0xFF, 0x1F, 0xF0, 0xFF, 0xFF, 0x7F, 0x80, 0xFF, /* scanline 71 */
N0xFF, 0x07, 0xFC, 0xFF, 0xFF, 0x1F, 0xF0, 0xFF, 0xFF, 0x7F, 0xC0, 0xFF, /* scanline 72 */
N0xFF, 0x0F, 0xF8, 0xFF, 0xFF, 0x1F, 0xF0, 0xFF, 0xFF, 0x3F, 0xE0, 0xFF, /* scanline 73 */
N0xFF, 0x3F, 0xF8, 0xFF, 0xFF, 0x3F, 0xF8, 0xFF, 0xFF, 0x3F, 0xF8, 0xFF, /* scanline 74 */
N0xFF, 0x7F, 0xF0, 0xFF, 0xFF, 0x3F, 0xF8, 0xFF, 0xFF, 0x3F, 0xFC, 0xFF, /* scanline 75 */
N0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, /* scanline 76 */
N0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, /* scanline 77 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 78 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 79 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 80 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 81 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 82 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 83 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 84 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 85 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 86 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 87 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 88 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 89 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 90 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 91 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 92 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 93 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 94 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 95 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 96 */
N};
N#endif /* IMAGE_H */
L 60 "..\..\..\main.c" 2
N#include "superman.h"
L 1 "..\..\..\superman.h" 1
N#ifndef SUPERMAN_H
N#define SUPERMAN_H
N
N/* arduino #include <avr/pgmspace.h> */
N#include <stdint.h>
N/* superman_h Width 96, Height 96 */
N#define WIDTH_superman_h 96
N#define HEIGHT_superman_h 96
Nconst uint8_t superman_h[] = {
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 1 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 2 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 3 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 4 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 5 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 6 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 7 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 8 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 9 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 10 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 11 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 12 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 13 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 14 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 15 */
N0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, /* scanline 16 */
N0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, /* scanline 17 */
N0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFE, 0xFF, /* scanline 18 */
N0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF, /* scanline 19 */
N0xFF, 0x7F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, /* scanline 20 */
N0xFF, 0x3F, 0x1F, 0x80, 0xFF, 0xFF, 0xFF, 0x7F, 0x80, 0xFF, 0xF3, 0xFF, /* scanline 21 */
N0xFF, 0x9F, 0x0F, 0xE0, 0xFF, 0x00, 0xE0, 0xFF, 0x80, 0xFF, 0xE7, 0xFF, /* scanline 22 */
N0xFF, 0xCF, 0x07, 0xF8, 0x1F, 0x00, 0x00, 0xFF, 0x81, 0xBF, 0xCF, 0xFF, /* scanline 23 */
N0xFF, 0xE7, 0x07, 0xFC, 0x07, 0x00, 0x00, 0xFC, 0x83, 0x3F, 0x9F, 0xFF, /* scanline 24 */
N0xFF, 0xF3, 0x03, 0xFE, 0x01, 0x00, 0x00, 0xF0, 0xC7, 0x3F, 0x3E, 0xFF, /* scanline 25 */
N0xFF, 0xF1, 0x01, 0xFF, 0x00, 0x00, 0x00, 0xE0, 0xE7, 0x3F, 0x7C, 0xFE, /* scanline 26 */
N0xFF, 0x7C, 0xC0, 0x7F, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x3F, 0xF8, 0xFC, /* scanline 27 */
N0x7F, 0x3E, 0xC0, 0x7F, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x3F, 0xF0, 0xF9, /* scanline 28 */
N0x3F, 0x1F, 0xE0, 0x3F, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x3F, 0xE0, 0xF3, /* scanline 29 */
N0x9F, 0x1F, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x3F, 0xE0, 0xE7, /* scanline 30 */
N0x8F, 0x0F, 0xF0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x3F, 0xC0, 0xCF, /* scanline 31 */
N0xC7, 0x07, 0xF8, 0x7F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x3F, 0x80, 0x9F, /* scanline 32 */
N0xE7, 0x07, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x9F, /* scanline 33 */
N0xCF, 0x0F, 0xF8, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xCF, /* scanline 34 */
N0x9F, 0x1F, 0xFC, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE7, /* scanline 35 */
N0x3F, 0x1F, 0xFC, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF3, /* scanline 36 */
N0x7F, 0x3E, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xF0, 0xF9, /* scanline 37 */
N0x7F, 0x7C, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xF8, 0xF9, /* scanline 38 */
N0xFF, 0xF8, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x7C, 0xFC, /* scanline 39 */
N0xFF, 0xF1, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x7E, 0xFE, /* scanline 40 */
N0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x3F, 0xFF, /* scanline 41 */
N0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x81, 0x9F, 0xFF, /* scanline 42 */
N0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 0xCF, 0xFF, /* scanline 43 */
N0xFF, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xE7, 0xFF, /* scanline 44 */
N0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xE3, 0xFF, /* scanline 45 */
N0xFF, 0x3F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0xFF, /* scanline 46 */
N0xFF, 0x7F, 0x7C, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, /* scanline 47 */
N0xFF, 0xFF, 0xFC, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF, /* scanline 48 */
N0xFF, 0xFF, 0xF9, 0x01, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x7F, 0xFE, 0xFF, /* scanline 49 */
N0xFF, 0xFF, 0xF3, 0x03, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0x3F, 0xFF, 0xFF, /* scanline 50 */
N0xFF, 0xFF, 0xE7, 0x03, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x9F, 0xFF, 0xFF, /* scanline 51 */
N0xFF, 0xFF, 0xCF, 0x07, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x8F, 0xFF, 0xFF, /* scanline 52 */
N0xFF, 0xFF, 0x8F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xC7, 0xFF, 0xFF, /* scanline 53 */
N0xFF, 0xFF, 0x1F, 0x1F, 0xFC, 0x01, 0x00, 0x00, 0xF8, 0xE7, 0xFF, 0xFF, /* scanline 54 */
N0xFF, 0xFF, 0x3F, 0x3F, 0xFE, 0x07, 0x00, 0x00, 0xF8, 0xF3, 0xFF, 0xFF, /* scanline 55 */
N0xFF, 0xFF, 0x7F, 0x7E, 0xFF, 0x1F, 0x00, 0x00, 0xFC, 0xF9, 0xFF, 0xFF, /* scanline 56 */
N0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, /* scanline 57 */
N0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0x7F, 0x00, 0xF0, 0x7F, 0xFE, 0xFF, 0xFF, /* scanline 58 */
N0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xFD, 0xFF, 0x3F, 0xFE, 0xFF, 0xFF, /* scanline 59 */
N0xFF, 0xFF, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, /* scanline 60 */
N0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0x8F, 0xFF, 0xFF, 0xFF, /* scanline 61 */
N0xFF, 0xFF, 0xFF, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0xFF, 0xFF, /* scanline 62 */
N0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF, 0xFF, 0xEF, 0xE7, 0xFF, 0xFF, 0xFF, /* scanline 63 */
N0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0x00, 0x00, 0xF0, 0xF3, 0xFF, 0xFF, 0xFF, /* scanline 64 */
N0xFF, 0xFF, 0xFF, 0x7F, 0x7E, 0x00, 0x00, 0xF8, 0xF9, 0xFF, 0xFF, 0xFF, /* scanline 65 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0xFC, 0xF8, 0xFF, 0xFF, 0xFF, /* scanline 66 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x01, 0x00, 0x7C, 0xFC, 0xFF, 0xFF, 0xFF, /* scanline 67 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0x03, 0x00, 0x3E, 0xFE, 0xFF, 0xFF, 0xFF, /* scanline 68 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0x03, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 69 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x07, 0x80, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 70 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0x0F, 0xC0, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 71 */
N0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0x1F, 0xE0, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 72 */
N0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xF0, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 73 */
N0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7E, 0xF8, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 74 */
N0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 75 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x7F, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 76 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x7F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 77 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 78 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 79 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 80 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 81 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 82 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 83 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 84 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 85 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 86 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 87 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 88 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 89 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 90 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 91 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 92 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 93 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 94 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 95 */
N0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* scanline 96 */
N};
N#endif /* SUPERMAN_H */
L 61 "..\..\..\main.c" 2
N
N#include "gfx.h"
L 1 "..\..\..\..\..\..\external\ugfx\gfx.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    gfx.h
N * @brief   GFX system header file.
N *
N * @addtogroup GFX
N *
N * @brief	Main module to glue all the others together
N *
N * @{
N */
N
N#ifndef _GFX_H
N#define _GFX_H
N
N/**
N * These two definitions below are required before anything else so that we can
N * turn module definitions off and on.
N */
N
N/**
N * @brief   Generic 'false' boolean constant.
N */
N#if !defined(FALSE) || defined(__DOXYGEN__)
X#if !0L || 0L
N	#define FALSE       0
N#endif
N
N/**
N * @brief   Generic 'true' boolean constant.
N */
N#if !defined(TRUE) || defined(__DOXYGEN__)
X#if !0L || 0L
N	#define TRUE        -1
N#endif
N
N/* gfxconf.h is the user's project configuration for the GFX system. */
N#include "gfxconf.h"
L 1 "..\..\..\..\none\gfxconf.h" 1
N/**
N * This file has a different license to the rest of the uGFX system.
N * You can copy, modify and distribute this file as you see fit.
N * You do not need to publish your source modifications to this file.
N * The only thing you are not permitted to do is to relicense it
N * under a different license.
N */
N
N/**
N * Copy this file into your project directory and rename it as gfxconf.h
N * Edit your copy to turn on the uGFX features you want to use.
N * The values below are the defaults.
N *
N * Only remove the comments from lines where you want to change the
N * default value. This allows definitions to be included from
N * driver makefiles when required and provides the best future
N * compatibility for your project.
N *
N * Please use spaces instead of tabs in this file.
N */
N
N#ifndef _GFXCONF_H
N#define _GFXCONF_H
N
N
N///////////////////////////////////////////////////////////////////////////
N// GOS - One of these must be defined, preferably in your Makefile       //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_OS_CHIBIOS                           FALSE
N//#define GFX_USE_OS_FREERTOS                          FALSE
N//    #define GFX_FREERTOS_USE_TRACE                   FALSE
N//#define GFX_USE_OS_WIN32                             FALSE
N//#define GFX_USE_OS_LINUX                             FALSE
N//#define GFX_USE_OS_OSX                               FALSE
N//#define GFX_USE_OS_ECOS                              FALSE
N//#define GFX_USE_OS_RAWRTOS                           FALSE
N//#define GFX_USE_OS_ARDUINO                           FALSE
N//#define GFX_USE_OS_KEIL                              FALSE
N//#define GFX_USE_OS_CMSIS                             FALSE
N  #define GFX_USE_OS_RAW32                             TRUE
N//#define GFX_USE_OS_NIOS                              FALSE
N//#define GFX_USE_OS_QT                                FALSE
N//    #define INTERRUPTS_OFF()                         optional_code
N//    #define INTERRUPTS_ON()                          optional_code
N
N// Options that (should where relevant) apply to all operating systems
N//    #define GFX_NO_INLINE                            FALSE
N//    #define GFX_COMPILER                             GFX_COMPILER_UNKNOWN
N//    #define GFX_CPU                                  GFX_CPU_UNKNOWN
N//    #define GFX_CPU_NO_ALIGNMENT_FAULTS              FALSE
N//    #define GFX_CPU_ENDIAN                           GFX_CPU_ENDIAN_UNKNOWN
N      #define GFX_OS_HEAP_SIZE                         0
N//    #define GFX_OS_NO_INIT                           FALSE
N//    #define GFX_OS_INIT_NO_WARNING                   FALSE
N//    #define GFX_OS_PRE_INIT_FUNCTION                 myHardwareInitRoutine
N//    #define GFX_OS_EXTRA_INIT_FUNCTION               myOSInitRoutine
N//    #define GFX_OS_EXTRA_DEINIT_FUNCTION             myOSDeInitRoutine
N//    #define GFX_EMULATE_MALLOC                       FALSE
N
N
N///////////////////////////////////////////////////////////////////////////
N// GDISP                                                                 //
N///////////////////////////////////////////////////////////////////////////
N#define GFX_USE_GDISP                                  TRUE
N
N//#define GDISP_NEED_AUTOFLUSH                         FALSE
N//#define GDISP_NEED_TIMERFLUSH                        FALSE
N//#define GDISP_NEED_VALIDATION                        TRUE
N//#define GDISP_NEED_CLIP                              TRUE
N//#define GDISP_NEED_CIRCLE                            FALSE
N//#define GDISP_NEED_ELLIPSE                           FALSE
N//#define GDISP_NEED_ARC                               FALSE
N//#define GDISP_NEED_ARCSECTORS                        FALSE
N//#define GDISP_NEED_CONVEX_POLYGON                    FALSE
N//#define GDISP_NEED_SCROLL                            FALSE
N//#define GDISP_NEED_PIXELREAD                         FALSE
N//#define GDISP_NEED_CONTROL                           FALSE
N//#define GDISP_NEED_QUERY                             FALSE
N//#define GDISP_NEED_MULTITHREAD                       FALSE
N//#define GDISP_NEED_STREAMING                         FALSE
N//#define GDISP_NEED_TEXT                              FALSE
N//    #define GDISP_NEED_TEXT_WORDWRAP                 FALSE
N//    #define GDISP_NEED_ANTIALIAS                     FALSE
N//    #define GDISP_NEED_UTF8                          FALSE
N//    #define GDISP_NEED_TEXT_KERNING                  FALSE
N//    #define GDISP_INCLUDE_FONT_UI1                   FALSE
N//    #define GDISP_INCLUDE_FONT_UI2                   FALSE		// The smallest preferred font.
N//    #define GDISP_INCLUDE_FONT_LARGENUMBERS          FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS10          FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS12          FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS16          FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS20          FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS24          FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS32          FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANSBOLD12      FALSE
N//    #define GDISP_INCLUDE_FONT_FIXED_10X20           FALSE
N//    #define GDISP_INCLUDE_FONT_FIXED_7X14            FALSE
N//    #define GDISP_INCLUDE_FONT_FIXED_5X8             FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS12_AA       FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS16_AA       FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS20_AA       FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS24_AA       FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANS32_AA       FALSE
N//    #define GDISP_INCLUDE_FONT_DEJAVUSANSBOLD12_AA   FALSE
N//    #define GDISP_INCLUDE_USER_FONTS                 FALSE
N
N//#define GDISP_NEED_IMAGE                             FALSE
N//    #define GDISP_NEED_IMAGE_NATIVE                  FALSE
N//    #define GDISP_NEED_IMAGE_GIF                     FALSE
N//    #define GDISP_NEED_IMAGE_BMP                     FALSE
N//        #define GDISP_NEED_IMAGE_BMP_1               TRUE
N//        #define GDISP_NEED_IMAGE_BMP_4               TRUE
N//        #define GDISP_NEED_IMAGE_BMP_4_RLE           TRUE
N//        #define GDISP_NEED_IMAGE_BMP_8               TRUE
N//        #define GDISP_NEED_IMAGE_BMP_8_RLE           TRUE
N//        #define GDISP_NEED_IMAGE_BMP_16              TRUE
N//        #define GDISP_NEED_IMAGE_BMP_24              TRUE
N//        #define GDISP_NEED_IMAGE_BMP_32              TRUE
N//    #define GDISP_NEED_IMAGE_JPG                     FALSE
N//    #define GDISP_NEED_IMAGE_PNG                     FALSE
N//        #define GDISP_NEED_IMAGE_PNG_INTERLACED      FALSE
N//        #define GDISP_NEED_IMAGE_PNG_TRANSPARENCY    TRUE
N//        #define GDISP_NEED_IMAGE_PNG_BACKGROUND      TRUE
N//        #define GDISP_NEED_IMAGE_PNG_ALPHACLIFF      32
N//        #define GDISP_NEED_IMAGE_PNG_PALETTE_124     TRUE
N//        #define GDISP_NEED_IMAGE_PNG_PALETTE_8       TRUE
N//        #define GDISP_NEED_IMAGE_PNG_GRAYSCALE_124   TRUE
N//        #define GDISP_NEED_IMAGE_PNG_GRAYSCALE_8     TRUE
N//        #define GDISP_NEED_IMAGE_PNG_GRAYSCALE_16    TRUE
N//        #define GDISP_NEED_IMAGE_PNG_GRAYALPHA_8     TRUE
N//        #define GDISP_NEED_IMAGE_PNG_GRAYALPHA_16    TRUE
N//        #define GDISP_NEED_IMAGE_PNG_RGB_8           TRUE
N//        #define GDISP_NEED_IMAGE_PNG_RGB_16          TRUE
N//        #define GDISP_NEED_IMAGE_PNG_RGBALPHA_8      TRUE
N//        #define GDISP_NEED_IMAGE_PNG_RGBALPHA_16     TRUE
N//    #define GDISP_NEED_IMAGE_ACCOUNTING              FALSE
N
N//#define GDISP_NEED_PIXMAP                            FALSE
N//    #define GDISP_NEED_PIXMAP_IMAGE                  FALSE
N
N//#define GDISP_DEFAULT_ORIENTATION                    GDISP_ROTATE_LANDSCAPE    // If not defined the native hardware orientation is used.
N//#define GDISP_LINEBUF_SIZE                           128
N//#define GDISP_STARTUP_COLOR                          Black
N#define GDISP_NEED_STARTUP_LOGO                        TRUE
N
N#define GDISP_TOTAL_DISPLAYS                        	 1
N
N/*#define GDISP_DRIVER_LIST                              GDISP_DRIVER_LS013														
N    #ifdef GDISP_DRIVER_LIST
N        // For code and speed optimization define as TRUE or FALSE if all controllers have the same capability
N        #define GDISP_HARDWARE_STREAM_WRITE          FALSE
N        #define GDISP_HARDWARE_STREAM_READ           FALSE
N        #define GDISP_HARDWARE_STREAM_POS            FALSE
N        #define GDISP_HARDWARE_DRAWPIXEL             FALSE
N        #define GDISP_HARDWARE_CLEARS                FALSE
N        #define GDISP_HARDWARE_FILLS                 FALSE
N        #define GDISP_HARDWARE_BITFILLS              FALSE
N        #define GDISP_HARDWARE_SCROLL                FALSE
N        #define GDISP_HARDWARE_PIXELREAD             FALSE
N        #define GDISP_HARDWARE_CONTROL               FALSE
N        #define GDISP_HARDWARE_QUERY                 FALSE
N        #define GDISP_HARDWARE_CLIP                  FALSE
N
N				#define GDISP_PIXELFORMAT                    GDISP_PIXELFORMAT_RGB111
N    #endif
N*/
N//#define GDISP_USE_GFXNET                             FALSE
N//    #define GDISP_GFXNET_PORT                        13001
N//    #define GDISP_GFXNET_CUSTOM_LWIP_STARTUP         FALSE
N//    #define GDISP_DONT_WAIT_FOR_NET_DISPLAY          FALSE
N//    #define GDISP_GFXNET_UNSAFE_SOCKETS              FALSE
N
N
N///////////////////////////////////////////////////////////////////////////
N// GWIN                                                                  //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_GWIN                                 FALSE
N
N//#define GWIN_NEED_WINDOWMANAGER                      FALSE
N//    #define GWIN_REDRAW_IMMEDIATE                    FALSE
N//    #define GWIN_REDRAW_SINGLEOP                     FALSE
N//    #define GWIN_NEED_FLASHING                       FALSE
N//        #define GWIN_FLASHING_PERIOD                 250
N
N//#define GWIN_NEED_CONSOLE                            FALSE
N//    #define GWIN_CONSOLE_USE_HISTORY                 FALSE
N//        #define GWIN_CONSOLE_HISTORY_AVERAGING       FALSE
N//        #define GWIN_CONSOLE_HISTORY_ATCREATE        FALSE
N//    #define GWIN_CONSOLE_ESCSEQ                      FALSE
N//    #define GWIN_CONSOLE_USE_BASESTREAM              FALSE
N//    #define GWIN_CONSOLE_USE_FLOAT                   FALSE
N//#define GWIN_NEED_GRAPH                              FALSE
N//#define GWIN_NEED_GL3D                               FALSE
N
N//#define GWIN_NEED_WIDGET                             FALSE
N//#define GWIN_FOCUS_HIGHLIGHT_WIDTH                   1
N//    #define GWIN_NEED_LABEL                          FALSE
N//        #define GWIN_LABEL_ATTRIBUTE                 FALSE
N//    #define GWIN_NEED_BUTTON                         FALSE
N//        #define GWIN_BUTTON_LAZY_RELEASE             FALSE
N//    #define GWIN_NEED_SLIDER                         FALSE
N//        #define GWIN_SLIDER_NOSNAP                   FALSE
N//        #define GWIN_SLIDER_DEAD_BAND                5
N//        #define GWIN_SLIDER_TOGGLE_INC               20
N//    #define GWIN_NEED_CHECKBOX                       FALSE
N//    #define GWIN_NEED_IMAGE                          FALSE
N//        #define GWIN_NEED_IMAGE_ANIMATION            FALSE
N//    #define GWIN_NEED_RADIO                          FALSE
N//    #define GWIN_NEED_LIST                           FALSE
N//        #define GWIN_NEED_LIST_IMAGES                FALSE
N//    #define GWIN_NEED_PROGRESSBAR                    FALSE
N//        #define GWIN_PROGRESSBAR_AUTO                FALSE
N//    #define GWIN_NEED_KEYBOARD                       FALSE
N//        #define GWIN_KEYBOARD_DEFAULT_LAYOUT         VirtualKeyboard_English1
N//        #define GWIN_NEED_KEYBOARD_ENGLISH1          TRUE
N//    #define GWIN_NEED_TEXTEDIT                       FALSE
N//    #define GWIN_FLAT_STYLING                        FALSE
N//    #define GWIN_WIDGET_TAGS                         FALSE
N
N//#define GWIN_NEED_CONTAINERS                         FALSE
N//    #define GWIN_NEED_CONTAINER                      FALSE
N//    #define GWIN_NEED_FRAME                          FALSE
N//    #define GWIN_NEED_TABSET                         FALSE
N//        #define GWIN_TABSET_TABHEIGHT                18
N
N
N///////////////////////////////////////////////////////////////////////////
N// GTRANS                                                                //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_GTRANS                               FALSE
N
N
N///////////////////////////////////////////////////////////////////////////
N// GEVENT                                                                //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_GEVENT                               FALSE
N
N//#define GEVENT_ASSERT_NO_RESOURCE                    FALSE
N//#define GEVENT_MAXIMUM_SIZE                          32
N//#define GEVENT_MAX_SOURCE_LISTENERS                  32
N
N
N///////////////////////////////////////////////////////////////////////////
N// GTIMER                                                                //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_GTIMER                               FALSE
N
N//#define GTIMER_THREAD_PRIORITY                       HIGH_PRIORITY
N//#define GTIMER_THREAD_WORKAREA_SIZE                  2048
N
N
N///////////////////////////////////////////////////////////////////////////
N// GQUEUE                                                                //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_GQUEUE                               FALSE
N
N//#define GQUEUE_NEED_ASYNC                            FALSE
N//#define GQUEUE_NEED_GSYNC                            FALSE
N//#define GQUEUE_NEED_FSYNC                            FALSE
N//#define GQUEUE_NEED_BUFFERS                          FALSE
N
N///////////////////////////////////////////////////////////////////////////
N// GINPUT                                                                //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_GINPUT                               FALSE
N
N//#define GINPUT_NEED_MOUSE                            FALSE
N//    #define GINPUT_TOUCH_STARTRAW                    FALSE
N//    #define GINPUT_TOUCH_NOTOUCH                     FALSE
N//    #define GINPUT_TOUCH_NOCALIBRATE                 FALSE
N//    #define GINPUT_TOUCH_NOCALIBRATE_GUI             FALSE
N//    #define GINPUT_MOUSE_POLL_PERIOD                 25
N//    #define GINPUT_MOUSE_CLICK_TIME                  300
N//    #define GINPUT_TOUCH_CXTCLICK_TIME               700
N//    #define GINPUT_TOUCH_USER_CALIBRATION_LOAD       FALSE
N//    #define GINPUT_TOUCH_USER_CALIBRATION_SAVE       FALSE
N//    #define GMOUSE_DRIVER_LIST                       GMOUSEVMT_Win32, GMOUSEVMT_Win32
N//#define GINPUT_NEED_KEYBOARD                         FALSE
N//    #define GINPUT_KEYBOARD_POLL_PERIOD              200
N//    #define GKEYBOARD_DRIVER_LIST                    GKEYBOARDVMT_Win32, GKEYBOARDVMT_Win32
N//    #define GKEYBOARD_LAYOUT_OFF                     FALSE
N//        #define GKEYBOARD_LAYOUT_SCANCODE2_US        FALSE
N//#define GINPUT_NEED_TOGGLE                           FALSE
N//#define GINPUT_NEED_DIAL                             FALSE
N
N
N///////////////////////////////////////////////////////////////////////////
N// GFILE                                                                 //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_GFILE                                FALSE
N
N//#define GFILE_NEED_PRINTG                            FALSE
N//#define GFILE_NEED_SCANG                             FALSE
N//#define GFILE_NEED_STRINGS                           FALSE
N//#define GFILE_NEED_FILELISTS                         FALSE
N//#define GFILE_NEED_STDIO                             FALSE
N//#define GFILE_NEED_NOAUTOMOUNT                       FALSE
N//#define GFILE_NEED_NOAUTOSYNC                        FALSE
N
N//#define GFILE_NEED_MEMFS                             FALSE
N//#define GFILE_NEED_ROMFS                             FALSE
N//#define GFILE_NEED_RAMFS                             FALSE
N//#define GFILE_NEED_FATFS                             FALSE
N//#define GFILE_NEED_NATIVEFS                          FALSE
N//#define GFILE_NEED_CHBIOSFS                          FALSE
N
N//#define GFILE_ALLOW_FLOATS                           FALSE
N//#define GFILE_ALLOW_DEVICESPECIFIC                   FALSE
N//#define GFILE_MAX_GFILES                             3
N
N///////////////////////////////////////////////////////////////////////////
N// GADC                                                                  //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_GADC                                 FALSE
N//    #define GADC_MAX_LOWSPEED_DEVICES                4
N
N///////////////////////////////////////////////////////////////////////////
N// GAUDIO                                                                //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_GAUDIO                               FALSE
N//    #define GAUDIO_NEED_PLAY                         FALSE
N//    #define GAUDIO_NEED_RECORD                       FALSE
N
N///////////////////////////////////////////////////////////////////////////
N// GMISC                                                                 //
N///////////////////////////////////////////////////////////////////////////
N//#define GFX_USE_GMISC                                FALSE
N
N//#define GMISC_NEED_ARRAYOPS                          FALSE
N//#define GMISC_NEED_FASTTRIG                          FALSE
N//#define GMISC_NEED_FIXEDTRIG                         FALSE
N//#define GMISC_NEED_INVSQRT                           FALSE
N//    #define GMISC_INVSQRT_MIXED_ENDIAN               FALSE
N//    #define GMISC_INVSQRT_REAL_SLOW                  FALSE
N//#define GMISC_NEED_MATRIXFLOAT2D                     FALSE
N//#define GMISC_NEED_MATRIXFIXED2D                     FALSE
N
N#endif /* _GFXCONF_H */
L 43 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N
N/* Include Compiler and CPU support */
N#include "src/gfx_compilers.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gfx_compilers.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    gfx_compilers.h
N * @brief   GFX compiler support header file.
N *
N * @addtogroup GFX
N *
N * @brief	Main module to glue all the others together
N *
N * @{
N */
N
N#ifndef _GFX_COMPILERS_H
N#define _GFX_COMPILERS_H
N
N/**
N * @name    GFX compilation options
N * @{
N */
N 	/**
N	 * @brief	Should various inline ugfx functions be non-inline.
N	 * @details	Defaults to FALSE
N	 * @note	Generally there is no need to set this to TRUE as it will have huge performance impacts
N	 *			in the driver level.
N	 */
N	#ifndef GFX_NO_INLINE
N		#define GFX_NO_INLINE			FALSE
N	#endif
N
N	// Set the no inline value
N	#if GFX_NO_INLINE
X	#if 0
S		#define GFXINLINE
N	#endif
N
N	/**
N	 * @brief	Enable compiler specific code
N	 * @details	Auto detected by default but it can be overridden in gfxconf.h
N	 * @note	This is setting enables optimisations and code options that are compiler specific.
N	 * @note	If the compiler can't be auto-detected it is set to GFX_COMPILER_UNKNOWN
N	 * @{
N	 */
N	#ifndef GFX_COMPILER
N		#define GFX_COMPILER			GFX_COMPILER_UNKNOWN
N	#endif
N	#define GFX_COMPILER_UNKNOWN		0		//**< Unknown compiler
N	#define GFX_COMPILER_ACC			1		//**< ACC Compiler
N	#define GFX_COMPILER_ALTIUM			2		//**< Altium MicroBlaze C
N	#define GFX_COMPILER_ALTIUMHW		3		//**< Altium C-to-Hardware
N	#define GFX_COMPILER_AMSTERDAM		4		//**< Amsterdam Compiler Kit
N	#define GFX_COMPILER_ARMCC			5		//**< ARM Compiler
N	#define GFX_COMPILER_AZTEC			6		//**< Aztec C
N	#define GFX_COMPILER_BORLAND		7		//**< Borland C++
N	#define GFX_COMPILER_CC65			8		//**< CC65
N	#define GFX_COMPILER_CLANG			9		//**< CLang (LLVM) compiler
N	#define GFX_COMPILER_COMEAU			10		//**< Comeau C++
N	#define GFX_COMPILER_COMPAQ			11		//**< Compaq C
N	#define GFX_COMPILER_COMPCERT		12		//**< Compcert Compiler
N	#define GFX_COMPILER_CONVEX			13		//**< Convex C
N	#define GFX_COMPILER_CRAY			14		//**< Cray C/C++
N	#define GFX_COMPILER_CYGWIN			15		//**< Cygwin (x86) unix emulator compiler for windows
N	#define GFX_COMPILER_DAIB			16		//**< Diab C/C++
N	#define GFX_COMPILER_DEC			17		//**< The older DEC C Compiler
N	#define GFX_COMPILER_DICE			18		//**< DICE C Compiler
N	#define GFX_COMPILER_DIGNUS			19		//**< Dignus Systems C++ Compiler
N	#define GFX_COMPILER_DJGPP			20		//**< DJGPP
N	#define GFX_COMPILER_DMARS			21		//**< Digital Mars
N	#define GFX_COMPILER_EDG			22		//**< EDG C++
N	#define GFX_COMPILER_EKOPATH		23		//**< EKOPath Compiler
N	#define GFX_COMPILER_FUJITSU		24		//**< Fujitsu C++ Compiler
N	#define GFX_COMPILER_GCC			25		//**< Standard GCC/G++
N	#define GFX_COMPILER_GREENHILL		26		//**< Green Hill C/C++
N	#define GFX_COMPILER_HIGHC			27		//**< Metaware High C/C++
N	#define GFX_COMPILER_HP				28		//**< HP C/aC++
N	#define GFX_COMPILER_IAR			29		//**< IAR C/C++
N	#define GFX_COMPILER_IBMXL			30		//**< IBM XL C/C++ Compiler
N	#define GFX_COMPILER_IMAGECRAFT		31		//**< ImageCraft C Compiler
N	#define GFX_COMPILER_INTEL			32		//**< Intel ICC/ICPC Compiler
N	#define GFX_COMPILER_KAI			33		//**< Kai C++
N	#define GFX_COMPILER_KEIL			34		//**< Keil (use this when working with uVision IDE)
N	#define GFX_COMPILER_LCC			35		//**< LCC
N	#define GFX_COMPILER_METROWORKS		36		//**< Metroworks
N	#define GFX_COMPILER_MICROTEC		37		//**< Microtec C/C++
N	#define GFX_COMPILER_MICROWAY		38		//**< Microway NDP C
N	#define GFX_COMPILER_MINGW32		39		//**< MingW32 (x86) compiler for windows
N	#define GFX_COMPILER_MINGW64		40		//**< MingW64 (x64) compiler for windows
N	#define GFX_COMPILER_MIPSPRO		41		//**< MIPS Pro
N	#define GFX_COMPILER_MIRACLE		42		//**< Miracle C
N	#define GFX_COMPILER_MPW			43		//**< MPW C++
N	#define GFX_COMPILER_NORCROFT		44		//**< Norcroft ARM
N	#define GFX_COMPILER_NWCC			45		//**< NWCC
N	#define GFX_COMPILER_OPEN64			46		//**< Open64
N	#define GFX_COMPILER_OSS			47		//**< Oracle Solaris Studio
N	#define GFX_COMPILER_PACIFIC		48		//**< Pacific C
N	#define GFX_COMPILER_PALM			49		//**< Palm C/C++
N	#define GFX_COMPILER_PELLES			50		//**< Pelles C
N	#define GFX_COMPILER_PGCC			51		//**< Portland PGCC/PGCPP
N	#define GFX_COMPILER_RENESAS		52		//**< Renesas C/C++
N	#define GFX_COMPILER_SASC			53		//**< SAS/C
N	#define GFX_COMPILER_SCO			54		//**< SCO OpenServer
N	#define GFX_COMPILER_SDCC			55		//**< Small Device C Compiler
N	#define GFX_COMPILER_SN				56		//**< SN Compiler
N	#define GFX_COMPILER_STRATUS		57		//**< Stratus VOS C
N	#define GFX_COMPILER_SYMANTEC		58		//**< Symantec C++
N	#define GFX_COMPILER_TENDRA			59		//**< TenDRA C/C++
N	#define GFX_COMPILER_THINK			60		//**< Think C
N	#define GFX_COMPILER_TI				61		//**< Texas Instruments C/C++
N	#define GFX_COMPILER_TINYC			62		//**< Tiny C
N	#define GFX_COMPILER_TURBOC			63		//**< Borland Turbo C
N	#define GFX_COMPILER_ULTIMATE		64		//**< Ultimate C/C++
N	#define GFX_COMPILER_USL			65		//**< USL C
N	#define GFX_COMPILER_VBCC			66		//**< VBCC
N	#define GFX_COMPILER_VS				67		//**< Microsoft Visual Studio
N	#define GFX_COMPILER_WATCOM			68		//**< Watcom
N	#define GFX_COMPILER_ZTC			69		//**< Zortech C++
N	/** @} */
N
N	/************************************ Start Compiler Auto-Detection *************************
N	 *
N	 * Do not alter the order of these unless you know what you are doing as some compilers try
N	 *	to emulate other compilers. GCC in particular is commonly emulated and is also used as
N	 *	a code base for other compiler variants.
N	 */
N	#if GFX_COMPILER == GFX_COMPILER_UNKNOWN
X	#if 0 == 0
N		#undef GFX_COMPILER
N		#if defined(__MINGW32__)
X		#if 0L
S			#define GFX_COMPILER	GFX_COMPILER_MINGW32
S		#elif defined(__MINGW64__)
X		#elif 0L
S			#define GFX_COMPILER	GFX_COMPILER_MINGW64
S		#elif defined(__CYGWIN__)
X		#elif 0L
S			#define GFX_COMPILER	GFX_COMPILER_CYGWIN
N		#elif defined(__KEIL__) || defined(__CA__) || defined(__C51__) || defined(__CX51__) || defined(__C166__) || defined(__C251__) \
N				|| (defined(__CC_ARM) && defined(__EDG__))
X		#elif 0L || 0L || 0L || 0L || 0L || 0L 				|| (1L && 1L)
N			#define GFX_COMPILER	GFX_COMPILER_KEIL
N		#elif defined(__clang__) || defined(__llvm__)
S			#define GFX_COMPILER	GFX_COMPILER_CLANG
S		#elif defined(__INTEL_COMPILER) || defined(__ICC) || defined(__ECC) || defined(__TCL)
S			#define GFX_COMPILER	GFX_COMPILER_INTEL
S		#elif defined(__GNUC__) || defined(__GNUG__)
S			#define GFX_COMPILER	GFX_COMPILER_GCC
S		#elif defined(__CC_ARM)
S			#define GFX_COMPILER	GFX_COMPILER_ARMCC
S		#elif defined(__HP_cc) || defined(__HP_aCC)
S			#define GFX_COMPILER	GFX_COMPILER_HP
S		#elif defined(__IBMC__) || defined(__IBMCPP__) || defined(__xlc__) || defined(__xlC__)
S			#define GFX_COMPILER	GFX_COMPILER_IBMXL
S		#elif defined(_MSC_VER)
S			#define GFX_COMPILER	GFX_COMPILER_VS
S		#elif defined(__PGI)
S			#define GFX_COMPILER	GFX_COMPILER_PGCC
S		#elif defined(__SUNPRO_C) || defined(__SUNPRO_CC)
S			#define GFX_COMPILER	GFX_COMPILER_OSS
S		#elif defined(__TURBOC__)
S			#define GFX_COMPILER	GFX_COMPILER_TURBOC
S		#elif defined(__BORLANDC__)
S			#define GFX_COMPILER	GFX_COMPILER_BORLAND
S		#elif defined(__COMO__)
S			#define GFX_COMPILER	GFX_COMPILER_COMEAU
S		#elif defined(__DECC) || defined(__VAXC) || defined(VAXC) || defined(__DECCXX)
S			#define GFX_COMPILER	GFX_COMPILER_COMPAQ
S		#elif defined(__osf__) && defined(__LANGUAGE_C__)
S			#define GFX_COMPILER	GFX_COMPILER_DEC
S		#elif defined(_CRAYC)
S			#define GFX_COMPILER	GFX_COMPILER_CRAY
S		#elif defined(__DCC__)
S			#define GFX_COMPILER	GFX_COMPILER_DAIB
S		#elif defined(__DMC__)
S			#define GFX_COMPILER	GFX_COMPILER_DMARS
S		#elif defined(__KCC)
S			#define GFX_COMPILER	GFX_COMPILER_KAI
S		#elif defined(__LCC__)
S			#define GFX_COMPILER	GFX_COMPILER_LCC
S		#elif defined(__HIGHC__)
S			#define GFX_COMPILER	GFX_COMPILER_HIGHC
S		#elif defined(__MWERKS__) || defined(__CWCC__)
S			#define GFX_COMPILER	GFX_COMPILER_METROWORKS
S		#elif defined(__sgi)
S			#define GFX_COMPILER	GFX_COMPILER_MIPSPRO
S		#elif defined(__MRC__)
S			#define GFX_COMPILER	GFX_COMPILER_MPW
S		#elif defined(__CC_NORCROFT)
S			#define GFX_COMPILER	GFX_COMPILER_NORCROFT
S		#elif defined(__SASC__)
S			#define GFX_COMPILER	GFX_COMPILER_SASC
S		#elif defined( _SCO_DS )
S			#define GFX_COMPILER	GFX_COMPILER_SCO
S		#elif defined(__TINYC__)
S			#define GFX_COMPILER	GFX_COMPILER_TINYC
S		#elif defined( __USLC__ )
S			#define GFX_COMPILER	GFX_COMPILER_USL
S		#elif defined(__WATCOMC__)
S			#define GFX_COMPILER	GFX_COMPILER_WATCOM
S		#elif defined(__AZTEC_C__) || defined(AZTEC_C)
S			#define GFX_COMPILER	GFX_COMPILER_AZTEC
S		#elif defined(__CC65__)
S			#define GFX_COMPILER	GFX_COMPILER_CC65
S		#elif defined(__convexc__)
S			#define GFX_COMPILER	GFX_COMPILER_CONVEX
S		#elif defined(__COMPCERT__)
S			#define GFX_COMPILER	GFX_COMPILER_COMPCERT
S		#elif defined(_DICE)
S			#define GFX_COMPILER	GFX_COMPILER_DICE
S		#elif defined(__SYSC__)
S			#define GFX_COMPILER	GFX_COMPILER_DIGNUS
S		#elif defined(__DJGPP__) || defined(__GO32__)
S			#define GFX_COMPILER	GFX_COMPILER_DJGPP
S		#elif defined(__EDG__)
S			#define GFX_COMPILER	GFX_COMPILER_EDG
S		#elif defined(__PATHCC__)
S			#define GFX_COMPILER	GFX_COMPILER_EKOPATH
S		#elif defined(__FCC_VERSION)
S			#define GFX_COMPILER	GFX_COMPILER_FUJITSU
S		#elif defined(__ghs__)
S			#define GFX_COMPILER	GFX_COMPILER_GREENHILL
S		#elif defined(__IAR_SYSTEMS_ICC__)
S			#define GFX_COMPILER	GFX_COMPILER_IAR
S		#elif defined(_MRI)
S			#define GFX_COMPILER	GFX_COMPILER_MICROTEC
S		#elif defined(__NDPC__) || defined(__NDPX__)
S			#define GFX_COMPILER	GFX_COMPILER_MICROWAY
S		#elif defined(MIRACLE)
S			#define GFX_COMPILER	GFX_COMPILER_MIRACLE
S		#elif defined(__NWCC__)
S			#define GFX_COMPILER	GFX_COMPILER_NWCC
S		#elif defined(__OPEN64__)
S			#define GFX_COMPILER	GFX_COMPILER_OPEN64
S		#elif defined(__PACIFIC__)
S			#define GFX_COMPILER	GFX_COMPILER_PACIFIC
S		#elif defined(_PACC_VER)
S			#define GFX_COMPILER	GFX_COMPILER_PALM
S		#elif defined(__POCC__)
S			#define GFX_COMPILER	GFX_COMPILER_PELLES
S		#elif defined(__RENESAS__) || defined(__HITACHI__)
S			#define GFX_COMPILER	GFX_COMPILER_RENESAS
S		#elif defined(SDCC)
S			#define GFX_COMPILER	GFX_COMPILER_SDCC
S		#elif defined(__SNC__)
S			#define GFX_COMPILER	GFX_COMPILER_SN
S		#elif defined(__VOSC__)
S			#define GFX_COMPILER	GFX_COMPILER_STRATUS
S		#elif defined(__TenDRA__)
S			#define GFX_COMPILER	GFX_COMPILER_TENDRA
S		#elif defined(__TI_COMPILER_VERSION__)
S			#define GFX_COMPILER	GFX_COMPILER_TI
S		#elif defined(THINKC3) || defined(THINKC4)
S			#define GFX_COMPILER	GFX_COMPILER_THINK
S		#elif defined(_UCC)
S			#define GFX_COMPILER	GFX_COMPILER_ULTIMATE
S		#elif defined(__VBCC__)
S			#define GFX_COMPILER	GFX_COMPILER_VBCC
S		#elif defined(__ZTC__)
S			#define GFX_COMPILER	GFX_COMPILER_ZTC
S		#elif defined(__SC__)
S			#define GFX_COMPILER	GFX_COMPILER_SYMANTEC
S		#elif defined(_ACC_)
S			#define GFX_COMPILER	GFX_COMPILER_ACC
S		#elif defined(__CMB__)
S			#define GFX_COMPILER	GFX_COMPILER_ALTIUM
S		#elif defined(__CHC__)
S			#define GFX_COMPILER	GFX_COMPILER_ALTIUMHW
S		#elif defined(__ACK__)
S			#define GFX_COMPILER	GFX_COMPILER_AMSTERDAM
S		#elif defined(__IMAGECRAFT__)
S			#define GFX_COMPILER	GFX_COMPILER_IMAGECRAFT
S
S		#else
S			#define GFX_COMPILER	GFX_COMPILER_UNKNOWN
N		#endif
N	#endif
N	/************************************ End Compiler Auto-Detection *************************/
N
N	/************************************ Start Compiler Settings *****************************
N	 *
N	 *  Please keep this list in alphabetical order to keep it easier to maintain
N	 */
N	#undef GFX_COMPILER_NAME
N	#undef GFX_COMPILER_TESTED
N	#undef GFX_COMPILER_VERSION_MAJOR
N	#undef GFX_COMPILER_VERSION_MINOR
N	#undef GFX_COMPILER_VERSION_PATCH
N	#undef GFX_COMPILER_VERSION_BUILD
N	#if GFX_COMPILER ==  GFX_COMPILER_ACC
X	#if 34 ==  1
S		#define GFX_COMPILER_NAME					"ACC"
S	#elif GFX_COMPILER ==  GFX_COMPILER_ALTIUM
X	#elif 34 ==  2
S		#define GFX_COMPILER_NAME					"Altium MicroBlaze C"
S		#ifdef __BUILD__
S			#define GFX_COMPILER_VERSION_MAJOR		((__BUILD__)/1000000)
S			#define GFX_COMPILER_VERSION_MINOR		(((__BUILD__)/1000)%1000)
S			#define GFX_COMPILER_VERSION_PATCH		((__BUILD__)%1000)
S		#else
S			#define GFX_COMPILER_VERSION_MAJOR		((__VERSION__)/1000)
S			#define GFX_COMPILER_VERSION_MINOR		((__VERSION__)%1000)
S			#define GFX_COMPILER_VERSION_PATCH		(__REVISION__)
S		#endif
S	#elif GFX_COMPILER ==  GFX_COMPILER_ALTIUMHW
X	#elif 34 ==  3
S		#define GFX_COMPILER_NAME					"Altium C-to-Hardware"
S		#ifdef __BUILD__
S			#define GFX_COMPILER_VERSION_MAJOR		((__BUILD__)/1000000)
S			#define GFX_COMPILER_VERSION_MINOR		(((__BUILD__)/1000)%1000)
S			#define GFX_COMPILER_VERSION_PATCH		((__BUILD__)%1000)
S		#else
S			#define GFX_COMPILER_VERSION_MAJOR		((__VERSION__)/1000)
S			#define GFX_COMPILER_VERSION_MINOR		((__VERSION__)%1000)
S			#define GFX_COMPILER_VERSION_PATCH		(__REVISION__)
S		#endif
S	#elif GFX_COMPILER ==  GFX_COMPILER_AMSTERDAM
X	#elif 34 ==  4
S		#define GFX_COMPILER_NAME					"Amsterdam Compiler Kit"
S	#elif GFX_COMPILER == GFX_COMPILER_ARMCC
X	#elif 34 == 5
S		#define GFX_COMPILER_NAME					"ARMCC"
S		#define GFX_COMPILER_VERSION_MAJOR			((__ARMCC_VERSION)/100000)
S		#define GFX_COMPILER_VERSION_MINOR			(((__ARMCC_VERSION)/10000)%10)
S		#define GFX_COMPILER_VERSION_PATCH			(((__ARMCC_VERSION)/1000)%10)
S		#define GFX_COMPILER_VERSION_BUILD			((__ARMCC_VERSION)%1000)
S		#define __LITTLE_IF_NOT_BIG__				// Oops - Defines __BIG_ENDIAN but not __LITTLE_ENDIAN
S	#elif GFX_COMPILER == GFX_COMPILER_AZTEC
X	#elif 34 == 6
S		#define GFX_COMPILER_NAME					"Aztec"
S		#define GFX_COMPILER_VERSION_MAJOR			((__VERSION)/100)
S		#define GFX_COMPILER_VERSION_MINOR			((__VERSION)%100)
S	#elif GFX_COMPILER == GFX_COMPILER_BORLAND
X	#elif 34 == 7
S		#define GFX_COMPILER_NAME					"Borland C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((__BORLANDC__)/0x100)
S		#define GFX_COMPILER_VERSION_MINOR			(((((__BORLANDC__)%0x100)/0x10)*10) + ((__BORLANDC__)%0x10))
S	#elif GFX_COMPILER == GFX_COMPILER_CC65
X	#elif 34 == 8
S		#define GFX_COMPILER_NAME					"CC65"
S		#define GFX_COMPILER_VERSION_MAJOR			((__CC65__)/0x100)
S		#define GFX_COMPILER_VERSION_MINOR			(((__CC65__)/0x10)%0x10)
S		#define GFX_COMPILER_VERSION_PATCH			((__CC65__)%0x10)
S	#elif GFX_COMPILER == GFX_COMPILER_CLANG
X	#elif 34 == 9
S		#define GFX_COMPILER_NAME					"CLang (LLVM)"
S		#define GFX_COMPILER_TESTED					TRUE
S		#define GFX_COMPILER_VERSION_MAJOR			(__clang_major__)
S		#define GFX_COMPILER_VERSION_MINOR			(__clang_minor__)
S		#define GFX_COMPILER_VERSION_PATCH			(__clang_patchlevel__)
S		#define DEPRECATED(msg)						__attribute__((deprecated(msg)));
S	#elif GFX_COMPILER == GFX_COMPILER_COMEAU
X	#elif 34 == 10
S		#define GFX_COMPILER_NAME					"Comeau C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((__COMO_VERSION__)/100)
S		#define GFX_COMPILER_VERSION_MINOR			((__COMO_VERSION__)%100)
S	#elif GFX_COMPILER == GFX_COMPILER_COMPAQ
X	#elif 34 == 11
S		#define GFX_COMPILER_NAME					"Compaq C"
S		#define GFX_COMPILER_VERSION_MAJOR			((__DECC_VER)/10000000)
S		#define GFX_COMPILER_VERSION_MINOR			(((__DECC_VER)/100000)%100)
S		#define GFX_COMPILER_VERSION_PATCH			((__DECC_VER)%10000)
S	#elif GFX_COMPILER == GFX_COMPILER_COMPCERT
X	#elif 34 == 12
S		#define GFX_COMPILER_NAME					"Compcert"
S	#elif GFX_COMPILER == GFX_COMPILER_CONVEX
X	#elif 34 == 13
S		#define GFX_COMPILER_NAME					"Convex C"
S	#elif GFX_COMPILER == GFX_COMPILER_CRAY
X	#elif 34 == 14
S		#define GFX_COMPILER_NAME					"Cray C/C++"
S		#define GFX_COMPILER_VERSION_MAJOR			(_RELEASE)
S		#define GFX_COMPILER_VERSION_MINOR			(_RELEASE_MINOR)
S	#elif GFX_COMPILER == GFX_COMPILER_CYGWIN
X	#elif 34 == 15
S		#define GFX_COMPILER_NAME					"Cygwin"
S		#define GFX_COMPILER_TESTED					TRUE
S		#define GFX_COMPILER_VERSION_MAJOR			(__GNUC__)
S		#define GFX_COMPILER_VERSION_MINOR			(__GNUC_MINOR__)
S		#ifdef __GNUC_PATCHLEVEL__
S			#define GFX_COMPILER_VERSION_PATCH		(__GNUC_PATCHLEVEL__)
S		#endif
S		#define DEPRECATED(msg)						__attribute__((deprecated(msg)))
S	#elif GFX_COMPILER == GFX_COMPILER_DAIB
X	#elif 34 == 16
S		#define GFX_COMPILER_NAME					"Diab C/C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((__VERSION_NUMBER__)/1000)
S		#define GFX_COMPILER_VERSION_MINOR			(((__VERSION_NUMBER__)/100)%10)
S		#define GFX_COMPILER_VERSION_PATCH			((__VERSION_NUMBER__)%100)
S	#elif GFX_COMPILER == GFX_COMPILER_DEC
X	#elif 34 == 17
S		#define GFX_COMPILER_NAME					"DEC"
S	#elif GFX_COMPILER == GFX_COMPILER_DICE
X	#elif 34 == 18
S		#define GFX_COMPILER_NAME					"DICE C"
S	#elif GFX_COMPILER == GFX_COMPILER_DIGNUS
X	#elif 34 == 19
S		#define GFX_COMPILER_NAME					"Dignus Systems C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((__SYSC_VER__)/10000)
S		#define GFX_COMPILER_VERSION_MINOR			(((__SYSC_VER__)/100)%100)
S		#define GFX_COMPILER_VERSION_PATCH			((__SYSC_VER__)%100)
S	#elif GFX_COMPILER == GFX_COMPILER_DJGPP
X	#elif 34 == 20
S		#define GFX_COMPILER_NAME					"DJGPP"
S		#ifdef __DJGPP__
S			#define GFX_COMPILER_VERSION_MAJOR		(__DJGPP__)
S			#define GFX_COMPILER_VERSION_MINOR		(__DJGPP_MINOR__)
S		#else
S			#define GFX_COMPILER_VERSION_MAJOR		(1)
S		#endif
S	#elif GFX_COMPILER == GFX_COMPILER_DMARS
X	#elif 34 == 21
S		#define GFX_COMPILER_NAME					"Digital Mars"
S		#define GFX_COMPILER_VERSION_MAJOR			((__DMC__)/0x100)
S		#define GFX_COMPILER_VERSION_MINOR			(((__DMC__)/0x10)%0x10)
S		#define GFX_COMPILER_VERSION_PATCH			((__DMC__)%0x10)
S	#elif GFX_COMPILER == GFX_COMPILER_EDG
X	#elif 34 == 22
S		#define GFX_COMPILER_NAME					"EDG C++"
S		#define GFX_COMPILER_TESTED					TRUE
S		#define GFX_COMPILER_VERSION_MAJOR			((__EDG_VERSION__)/100)
S		#define GFX_COMPILER_VERSION_MINOR			((__EDG_VERSION__)%100)
S		#pragma diag_remark = Pe301
S		#pragma diag_remark = Pe083
S		#pragma diag_remark = Pe767
S		#pragma diag_remark = Pe188
S		#pragma diag_remark = Pe186
S		#pragma diag_remark = Pe068
S		#pragma diag_remark = Pa050
S	#elif GFX_COMPILER == GFX_COMPILER_EKOPATH
X	#elif 34 == 23
S		#define GFX_COMPILER_NAME					"EKOPath"
S		#define GFX_COMPILER_VERSION_MAJOR			(__PATHCC__)
S		#define GFX_COMPILER_VERSION_MINOR			(__PATHCC_MINOR__)
S		#define GFX_COMPILER_VERSION_PATCH			(__PATHCC_PATCHLEVEL__)
S	#elif GFX_COMPILER == GFX_COMPILER_FUJITSU
X	#elif 34 == 24
S		#define GFX_COMPILER_NAME					"Fujitsu C++"
S	#elif GFX_COMPILER == GFX_COMPILER_GCC
X	#elif 34 == 25
S		#define GFX_COMPILER_NAME					"GCC"
S		#define GFX_COMPILER_TESTED					TRUE
S		#define GFX_COMPILER_VERSION_MAJOR			(__GNUC__)
S		#define GFX_COMPILER_VERSION_MINOR			(__GNUC_MINOR__)
S		#ifdef __GNUC_PATCHLEVEL__
S			#define GFX_COMPILER_VERSION_PATCH		(__GNUC_PATCHLEVEL__)
S		#endif
S		#define DEPRECATED(msg)						__attribute__((deprecated(msg)))
S	#elif GFX_COMPILER == GFX_COMPILER_GREENHILL
X	#elif 34 == 26
S		#define GFX_COMPILER_NAME					"Green Hill C/C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((__GHS_VERSION_NUMBER__)/100)
S		#define GFX_COMPILER_VERSION_MINOR			(((__GHS_VERSION_NUMBER__)/10)%10)
S		#define GFX_COMPILER_VERSION_PATCH			((__GHS_VERSION_NUMBER__)%10)
S	#elif GFX_COMPILER == GFX_COMPILER_HIGHC
X	#elif 34 == 27
S		#define GFX_COMPILER_NAME					"Metaware High C/C++"
S	#elif GFX_COMPILER == GFX_COMPILER_HP
X	#elif 34 == 28
S		#define GFX_COMPILER_NAME					"HP C/aC++"
S		#ifdef __HP_aCC
S			#if __HP_aCC == 1
S				#define GFX_COMPILER_VERSION_MAJOR	(1)
S				#define GFX_COMPILER_VERSION_MINOR	(15)
S			#else
S				#define GFX_COMPILER_VERSION_MAJOR	((__HP_aCC)/10000)
S				#define GFX_COMPILER_VERSION_MINOR	(((__HP_aCC)/100)%100)
S				#define GFX_COMPILER_VERSION_PATCH	((__HP_aCC)%100)
S			#endif
S		#endif
S	#elif GFX_COMPILER == GFX_COMPILER_IAR
X	#elif 34 == 29
S		#define GFX_COMPILER_NAME					"IAR C++"
S		#define GFX_COMPILER_TESTED					TRUE
S		#define GFX_COMPILER_VERSION_MAJOR			((__VER__)/100)
S		#define GFX_COMPILER_VERSION_MINOR			((__VER__)%100)
S		#pragma diag_remark = Pe301
S		#pragma diag_remark = Pe083
S		#pragma diag_remark = Pe767
S		#pragma diag_remark = Pe188
S		#pragma diag_remark = Pe186
S		#pragma diag_remark = Pe068
S		#pragma diag_remark = Pa050
S	#elif GFX_COMPILER == GFX_COMPILER_IBMXL
X	#elif 34 == 30
S		#define GFX_COMPILER_NAME					"IBM XL C/C++"
S		#ifdef __xlC__
S			#define GFX_COMPILER_VERSION_MAJOR		((__xlC__)/0x100)
S			#define GFX_COMPILER_VERSION_MINOR		((__xlC__)%0x100)
S			#define GFX_COMPILER_VERSION_PATCH		((__xlC_ver__)/0x100)
S			#define GFX_COMPILER_VERSION_BUILD		((__xlC_ver__)%0x100)
S		#elif defined(__COMPILER_VER__)
S			#define GFX_COMPILER_VERSION_MAJOR		(((__COMPILER_VER__)/0x1000000)%0x10)
S			#define GFX_COMPILER_VERSION_MINOR		(((__COMPILER_VER__)/0x10000)%0x100)
S			#define GFX_COMPILER_VERSION_PATCH		((__COMPILER_VER__)/0x10000)
S		#elif defined(__IBMC__)
S			#define GFX_COMPILER_VERSION_MAJOR		((__IBMC__)/100)
S			#define GFX_COMPILER_VERSION_MINOR		(((__IBMC__)/10)%10)
S			#define GFX_COMPILER_VERSION_PATCH		((__IBMC__)%10)
S		#elif defined(__IBMCPP__)
S			#define GFX_COMPILER_VERSION_MAJOR		((__IBMCPP__)/100)
S			#define GFX_COMPILER_VERSION_MINOR		(((__IBMCPP__)/10)%10)
S			#define GFX_COMPILER_VERSION_PATCH		((__IBMCPP__)%10)
S		#endif
S	#elif GFX_COMPILER == GFX_COMPILER_IMAGECRAFT
X	#elif 34 == 31
S		#define GFX_COMPILER_NAME					"Imagecraft C"
S	#elif GFX_COMPILER == GFX_COMPILER_INTEL
X	#elif 34 == 32
S		#define GFX_COMPILER_NAME					"Intel ICC/ICPC"
S		#ifdef __INTEL_COMPILER
S			#define GFX_COMPILER_VERSION_MAJOR		((__INTEL_COMPILER)/100)
S			#define GFX_COMPILER_VERSION_MINOR		(((__INTEL_COMPILER)/10)%10)
S			#define GFX_COMPILER_VERSION_PATCH		((__INTEL_COMPILER)%10)
S			#ifdef __INTEL_COMPILER_BUILD_DATE
S				#define GFX_COMPILER_VERSION_BUILD	(__INTEL_COMPILER_BUILD_DATE)
S			#endif
S		#endif
S	#elif GFX_COMPILER == GFX_COMPILER_KAI
X	#elif 34 == 33
S		#define GFX_COMPILER_NAME					"Kai C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((__KCC_VERSION)/0x1000)
S		#define GFX_COMPILER_VERSION_MINOR			(((__KCC_VERSION)/0x100)%0x10)
S		#define GFX_COMPILER_VERSION_PATCH			((__KCC_VERSION)%0x100)
N	#elif GFX_COMPILER == GFX_COMPILER_KEIL
X	#elif 34 == 34
N		#define GFX_COMPILER_NAME					"Keil"
N		#define GFX_COMPILER_TESTED					TRUE
N		#if defined(__ARMCC_VERSION)
X		#if 1L
N			#define GFX_COMPILER_VERSION_MAJOR		((__ARMCC_VERSION)/1000000)
N			#define GFX_COMPILER_VERSION_MINOR		(((__ARMCC_VERSION)/10000)%100)
N			#define GFX_COMPILER_VERSION_PATCH		((__ARMCC_VERSION)%10000)
N			#ifdef __EDG_VERSION__
N				#define GFX_COMPILER_VERSION_BUILD	(__EDG_VERSION__)
N			#endif
N		#elif defined(__CA__)
S			#define GFX_COMPILER_VERSION_MAJOR		((__CA__)/100)
S			#define GFX_COMPILER_VERSION_MINOR		((__CA__)%100)
S		#elif defined(__C166__)
S			#define GFX_COMPILER_VERSION_MAJOR		((__C166__)/100)
S			#define GFX_COMPILER_VERSION_MINOR		((__C166__)%100)
S		#elif defined(__C51__)
S			#define GFX_COMPILER_VERSION_MAJOR		((__C51__)/100)
S			#define GFX_COMPILER_VERSION_MINOR		((__C51__)%100)
S		#elif defined(__C251__)
S			#define GFX_COMPILER_VERSION_MAJOR		((__C251__)/100)
S			#define GFX_COMPILER_VERSION_MINOR		((__C251__)%100)
N		#endif
N		#define DEPRECATED(msg)						__attribute__((deprecated(msg)))
N		#pragma anon_unions							// Allow anonymous unions
N		#pragma diag_remark 1293					// Turn off warning: assignment in condition
N		#pragma diag_remark 83						// Turn off warning: type qualifier specified more than once
N		#pragma diag_remark 767						// Turn off warning: conversion from pointer to smaller integer
N		#pragma diag_remark 188						// Turn off warning: enumerated type mixed with another type
N		#ifndef GFXINLINE							// Get the Keil definition for inline
N			#define GFXINLINE	__inline
N		#endif
N		#define __LITTLE_IF_NOT_BIG__				// Oops - Defines __BIG_ENDIAN but not __LITTLE_ENDIAN
N	#elif GFX_COMPILER == GFX_COMPILER_LCC
S		#define GFX_COMPILER_NAME					"LCC"
S	#elif GFX_COMPILER == GFX_COMPILER_METROWORKS
S		#define GFX_COMPILER_NAME					"Metroworks CodeWarrior"
S		#define GFX_COMPILER_VERSION_MAJOR			((__MWERKS__)/0x1000)
S		#define GFX_COMPILER_VERSION_MINOR			(((__MWERKS__)/0x100)%0x10)
S		#define GFX_COMPILER_VERSION_PATCH			((__MWERKS__)%100)
S	#elif GFX_COMPILER == GFX_COMPILER_MICROTEC
S		#define GFX_COMPILER_NAME					"Microtec C/C++"
S	#elif GFX_COMPILER == GFX_COMPILER_MICROWAY
S		#define GFX_COMPILER_NAME					"Microway NDP C"
S	#elif GFX_COMPILER == GFX_COMPILER_MINGW32
S		#define GFX_COMPILER_NAME					"MingW32"
S		#define GFX_COMPILER_TESTED					TRUE
S		#define GFX_COMPILER_VERSION_MAJOR			(__GNUC__)
S		#define GFX_COMPILER_VERSION_MINOR			(__GNUC_MINOR__)
S		#ifdef __GNUC_PATCHLEVEL__
S			#define GFX_COMPILER_VERSION_PATCH		(__GNUC_PATCHLEVEL__)
S		#endif
S		#define DEPRECATED(msg)						__attribute__((deprecated(msg)))
S	#elif GFX_COMPILER == GFX_COMPILER_MINGW64
S		#define GFX_COMPILER_NAME					"MingW64"
S		#define GFX_COMPILER_VERSION_MAJOR			(__GNUC__)
S		#define GFX_COMPILER_VERSION_MINOR			(__GNUC_MINOR__)
S		#ifdef __GNUC_PATCHLEVEL__
S			#define GFX_COMPILER_VERSION_PATCH		(__GNUC_PATCHLEVEL__)
S		#endif
S		#define DEPRECATED(msg)						__attribute__((deprecated(msg)))
S	#elif GFX_COMPILER == GFX_COMPILER_MIPSPRO
S		#define GFX_COMPILER_NAME					"MIPS Pro"
S		#ifdef _SGI_COMPILER_VERSION
S			#define GFX_COMPILER_VERSION_MAJOR		((_SGI_COMPILER_VERSION)/100)
S			#define GFX_COMPILER_VERSION_MINOR		(((_SGI_COMPILER_VERSION)/10)%10)
S			#define GFX_COMPILER_VERSION_PATCH		((_SGI_COMPILER_VERSION)%10)
S		#else
S			#define GFX_COMPILER_VERSION_MAJOR		((_COMPILER_VERSION)/100)
S			#define GFX_COMPILER_VERSION_MINOR		(((_COMPILER_VERSION)/10)%10)
S			#define GFX_COMPILER_VERSION_PATCH		((_COMPILER_VERSION)%10)
S		#endif
S	#elif GFX_COMPILER == GFX_COMPILER_MIRACLE
S		#define GFX_COMPILER_NAME					"Miracle C"
S	#elif GFX_COMPILER == GFX_COMPILER_MPW
S		#define GFX_COMPILER_NAME					"MPW C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((__MRC__)/0x100)
S		#define GFX_COMPILER_VERSION_MINOR			((__MRC__)%0x100)
S	#elif GFX_COMPILER == GFX_COMPILER_NORCROFT
S		#define GFX_COMPILER_NAME					"Norcroft C"
S	#elif GFX_COMPILER == GFX_COMPILER_NWCC
S		#define GFX_COMPILER_NAME					"NWCC"
S	#elif GFX_COMPILER == GFX_COMPILER_OPEN64
S		#define GFX_COMPILER_NAME					"Open64"
S		#define GFX_COMPILER_VERSION_MAJOR			(__OPENCC__)
S		#define GFX_COMPILER_VERSION_MINOR			(__OPENCC_MINOR__)
S	#elif GFX_COMPILER == GFX_COMPILER_OSS
S		#define GFX_COMPILER_NAME					"Oracle Solaris Studio"
S		#ifdef __SUNPRO_C >= 0x1000
S			#define GFX_COMPILER_VERSION_MAJOR		((__SUNPRO_C)/0x1000)
S			#define GFX_COMPILER_VERSION_MINOR		(((((__SUNPRO_C)/0x100)%0x10)*10) + (((__SUNPRO_C)/0x10)%10))
S			#define GFX_COMPILER_VERSION_PATCH		((__SUNPRO_C)%0x10)
S		#else
S			#define GFX_COMPILER_VERSION_MAJOR		((__SUNPRO_C)/0x100)
S			#define GFX_COMPILER_VERSION_MINOR		(((__SUNPRO_C)/0x10)%0x10)
S			#define GFX_COMPILER_VERSION_PATCH		((__SUNPRO_C)%0x10)
S		#endif
S	#elif GFX_COMPILER == GFX_COMPILER_PACIFIC
S		#define GFX_COMPILER_NAME					"Pacific C"
S	#elif GFX_COMPILER == GFX_COMPILER_PALM
S		#define GFX_COMPILER_NAME					"Palm C/C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((_PACC_VER)/0x10000000)
S		#define GFX_COMPILER_VERSION_MINOR			(((_PACC_VER)/0x100000)%0x100)
S		#define GFX_COMPILER_VERSION_PATCH			(((_PACC_VER)/0x1000)%0x100)
S		#define GFX_COMPILER_VERSION_BUILD			((_PACC_VER)%0x1000)
S	#elif GFX_COMPILER == GFX_COMPILER_PELLES
S		#define GFX_COMPILER_NAME					"Pelles C"
S		#define GFX_COMPILER_VERSION_MAJOR			((__POCC__)/100)
S		#define GFX_COMPILER_VERSION_MINOR			((__POCC__)%100)
S	#elif GFX_COMPILER == GFX_COMPILER_PGCC
S		#define GFX_COMPILER_NAME					"Portland PGCC/PGCPP"
S		#define GFX_COMPILER_VERSION_MAJOR			(__PGIC__)
S		#define GFX_COMPILER_VERSION_MINOR			(__PGIC_MINOR__)
S		#define GFX_COMPILER_VERSION_PATCH			(__PGIC_PATCHLEVEL__)
S	#elif GFX_COMPILER == GFX_COMPILER_RENESAS
S		#define GFX_COMPILER_NAME					"Renesas C/C++"
S		#ifdef __HITACHI_VERSION__
S			#define GFX_COMPILER_VERSION_MAJOR		((__HITACHI_VERSION__)/0x100)
S			#define GFX_COMPILER_VERSION_MINOR		((__HITACHI_VERSION__)%0x100)
S		#elif __RENESAS_VERSION__ < 0x10000
S			#define GFX_COMPILER_VERSION_MAJOR		((__RENESAS_VERSION__)/0x100)
S			#define GFX_COMPILER_VERSION_MINOR		((__RENESAS_VERSION__)%0x100)
S		#else
S			#define GFX_COMPILER_VERSION_MAJOR		((__RENESAS_VERSION__)/0x1000000)
S			#define GFX_COMPILER_VERSION_MINOR		(((__RENESAS_VERSION__)/0x10000)%0x100)
S			#define GFX_COMPILER_VERSION_PATCH		(((__RENESAS_VERSION__)/0x100)%0x100)
S			#define GFX_COMPILER_VERSION_BUILD		((__RENESAS_VERSION__)%0x100)
S		#endif
S	#elif GFX_COMPILER == GFX_COMPILER_SASC
S		#define GFX_COMPILER_NAME					"SAS/C"
S		#ifdef __SASC__
S			#define GFX_COMPILER_VERSION_MAJOR		((__SASC__)/100)
S			#define GFX_COMPILER_VERSION_MINOR		((__SASC__)%100)
S		#else
S			#define GFX_COMPILER_VERSION_MAJOR		(__VERSION__)
S			#define GFX_COMPILER_VERSION_MINOR		(__REVISION__)
S		#endif
S	#elif GFX_COMPILER == GFX_COMPILER_SCO
S		#define GFX_COMPILER_NAME					"SCO OpenServer"
S	#elif GFX_COMPILER == GFX_COMPILER_SDCC
S		#define GFX_COMPILER_NAME					"Small Device C"
S		#define GFX_COMPILER_VERSION_MAJOR			((SDCC)/100)
S		#define GFX_COMPILER_VERSION_MINOR			(((SDCC)/10)%10)
S		#define GFX_COMPILER_VERSION_PATCH			((SDCC)%10)
S	#elif GFX_COMPILER == GFX_COMPILER_SN
S		#define GFX_COMPILER_NAME					"SN"
S	#elif GFX_COMPILER == GFX_COMPILER_STRATUS
S		#define GFX_COMPILER_NAME					"Stratus VOS C"
S		#define GFX_COMPILER_VERSION_MAJOR			(__VOSC__)
S	#elif GFX_COMPILER == GFX_COMPILER_SYMANTEC
S		#define GFX_COMPILER_NAME					"Symantec C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((__SC__)/0x100)
S		#define GFX_COMPILER_VERSION_MINOR			((__SC__)%0x100)
S	#elif GFX_COMPILER == GFX_COMPILER_TENDRA
S		#define GFX_COMPILER_NAME					"TenDRA C/C++"
S	#elif GFX_COMPILER == GFX_COMPILER_THINK
S		#define GFX_COMPILER_NAME					"Think C"
S		#ifdef THINKC4
S			#define GFX_COMPILER_VERSION_MAJOR		(4)
S		#else
S			#define GFX_COMPILER_VERSION_MAJOR		(3)
S		#endif
S	#elif GFX_COMPILER == GFX_COMPILER_TI
S		#define GFX_COMPILER_NAME					"Texas Instruments C/C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((SDCC)/1000000)
S		#define GFX_COMPILER_VERSION_MINOR			(((SDCC)/1000)%1000)
S		#define GFX_COMPILER_VERSION_PATCH			((SDCC)%1000)
S	#elif GFX_COMPILER == GFX_COMPILER_TINYC
S		#define GFX_COMPILER_NAME					"Tiny C"
S		#define GFX_COMPILER_TESTED					TRUE
S	#elif GFX_COMPILER == GFX_COMPILER_TURBOC
S		#define GFX_COMPILER_NAME					"Borland Turbo C/C++"
S		#if __TURBOC__ < 0x295 || __TURBOC__ >= 0x400
S			#define GFX_COMPILER_VERSION_MAJOR		((__TURBOC__)/0x100)
S			#define GFX_COMPILER_VERSION_MINOR		((__TURBOC__)%0x100)
S		#elif __TURBOC__ == 0x295
S			#define GFX_COMPILER_VERSION_MAJOR		(1)
S			#define GFX_COMPILER_VERSION_MINOR		(0)
S		#elif __TURBOC__ == 0x296
S			#define GFX_COMPILER_VERSION_MAJOR		(1)
S			#define GFX_COMPILER_VERSION_MINOR		(1)
S		#elif __TURBOC__ == 0x297
S			#define GFX_COMPILER_VERSION_MAJOR		(2)
S			#define GFX_COMPILER_VERSION_MINOR		(0)
S		#endif
S	#elif GFX_COMPILER == GFX_COMPILER_ULTIMATE
S		#define GFX_COMPILER_NAME					"Ultimate C/C++"
S		#define GFX_COMPILER_VERSION_MAJOR			(_MAJOR_REV)
S		#define GFX_COMPILER_VERSION_MINOR			(_MINOR_REV)
S	#elif GFX_COMPILER == GFX_COMPILER_USL
S		#define GFX_COMPILER_NAME					"USL C"
S		#define GFX_COMPILER_VERSION_MAJOR			((__SCO_VERSION__)/100000000)
S		#define GFX_COMPILER_VERSION_MINOR			(((__SCO_VERSION__)/1000000)%100)
S		#define GFX_COMPILER_VERSION_BUILD			((__SCO_VERSION__)%1000000)
S	#elif GFX_COMPILER == GFX_COMPILER_VBCC
S		#define GFX_COMPILER_NAME					"VBCC"
S	#elif GFX_COMPILER == GFX_COMPILER_VS
S		#define GFX_COMPILER_NAME					"Microsoft Visual Studio"
S		#ifdef _MSC_FULL_VER
S			#if _MSC_FULL_VER < 100000000
S				#define GFX_COMPILER_VERSION_MAJOR	((_MSC_FULL_VER)/1000000)
S				#define GFX_COMPILER_VERSION_MINOR	(((_MSC_FULL_VER)/10000)%100)
S				#define GFX_COMPILER_VERSION_PATCH	(((_MSC_FULL_VER)/10000)%10000)
S			#else
S				#define GFX_COMPILER_VERSION_MAJOR	((_MSC_FULL_VER)/10000000)
S				#define GFX_COMPILER_VERSION_MINOR	(((_MSC_FULL_VER)/100000)%100)
S				#define GFX_COMPILER_VERSION_PATCH	(((_MSC_FULL_VER)/100000)%10000)
S			#endif
S		#else
S			#define GFX_COMPILER_VERSION_MAJOR		((_MSC_VER)/100)
S			#define GFX_COMPILER_VERSION_MINOR		((_MSC_VER)%100)
S		#endif
S		#ifdef _MSC_BUILD
S			#define GFX_COMPILER_VERSION_BUILD		(_MSC_BUILD)
S		#endif
S		#define DEPRECATED(msg)						__declspec(deprecated(msg))
S	#elif GFX_COMPILER == GFX_COMPILER_WATCOM
S		#define GFX_COMPILER_NAME					"Watcom C"
S		#define GFX_COMPILER_VERSION_MAJOR			((__WATCOMC__)/100)
S		#define GFX_COMPILER_VERSION_MINOR			((__WATCOMC__)%100)
S	#elif GFX_COMPILER == GFX_COMPILER_ZTC
S		#define GFX_COMPILER_NAME					"Zortech C++"
S		#define GFX_COMPILER_VERSION_MAJOR			((__ZTC__)/0x100)
S		#define GFX_COMPILER_VERSION_MINOR			(((__ZTC__)/0x10)%0x10)
S		#define GFX_COMPILER_VERSION_PATCH			((__ZTC__)%0x10)
N	#endif
N	#ifndef GFX_COMPILER_TESTED
S		#define GFX_COMPILER_TESTED		FALSE
N	#endif
N	/************************************ End Compiler Settings *************************/
N
N	/**
N	 * @brief	The name of the compiler set or auto-detected
N	 * @details	Read-Only
N	 * @note	If you successfully compile ugfx with an unknown compiler
N	 * 			please report back to us via the ugfx forum so that we can add
N	 * 			it to our list of compilers to detect.
N	 */
N	#ifndef GFX_COMPILER_NAME
S		#define GFX_COMPILER_NAME		"Unknown"
S		#warning "You are using an unknown compiler. Please report this on the ugfx forum"
N	#endif
N
N	/**
N	 * @brief	This compiler is tested with ugfx
N	 * @details	Read-Only
N	 * @note	If you successfully compile ugfx with an un-tested compiler
N	 * 			please report back to us via the ugfx forum any compile errors
N	 * 			or warnings so that we can add it to our list of tested compilers.
N	 * @note	Although the compiler being used may be tested, it may have been
N	 * 			tested with a different compiler version. Please report any problems
N	 * 			on the ugfx forum.
N	 */
N	#if !GFX_COMPILER_TESTED
X	#if ! -1
S		#warning "You are using an un-tested compiler. Please report any compile errors or warnings on the ugfx forum"
N	#endif
N
N	/**
N	 * @brief	The major version number of the compiler
N	 * @details	Read-Only. It will be set to 0 if it can't be automatically detected.
N	 * @note	If you know how to detect a version number for a compiler and we haven't,
N	 * 			please report this on the ugfx forum.
N	 */
N	#ifndef GFX_COMPILER_VERSION_MAJOR
S		#define GFX_COMPILER_VERSION_MAJOR	0
N	#endif
N	/**
N	 * @brief	The minor version number of the compiler
N	 * @details	Read-Only. It will be set to 0 if it can't be automatically detected.
N	 * @note	If you know how to detect a version number for a compiler and we haven't,
N	 * 			please report this on the ugfx forum.
N	 */
N	#ifndef GFX_COMPILER_VERSION_MINOR
S		#define GFX_COMPILER_VERSION_MINOR	0
N	#endif
N	/**
N	 * @brief	The patch version number of the compiler
N	 * @details	Read-Only. It will be set to 0 if it can't be automatically detected.
N	 * @note	If you know how to detect a version number for a compiler and we haven't,
N	 * 			please report this on the ugfx forum.
N	 */
N	#ifndef GFX_COMPILER_VERSION_PATCH
S		#define GFX_COMPILER_VERSION_PATCH	0
N	#endif
N	/**
N	 * @brief	The build number of the compiler
N	 * @details	Read-Only. It will be set to 0 if it can't be automatically detected.
N	 * @note	If you know how to detect a version number for a compiler and we haven't,
N	 * 			please report this on the ugfx forum.
N	 */
N	#ifndef GFX_COMPILER_VERSION_BUILD
S		#define GFX_COMPILER_VERSION_BUILD	0
N	#endif
N
N	/**
N	 * @brief	Enable CPU specific code
N	 * @details	Auto detected by default but it can be overridden in gfxconf.h
N	 * @note	This is setting enables optimisations and code options that are CPU specific.
N	 * @note	If the CPU can't be auto-detected it is set to GFX_CPU_UNKNOWN
N	 * @note	Auto-detection is particularly weak currently particularly for ARM and other
N	 * 			non-Intel platforms. This doesn't normally matter very much as everything is
N	 * 			handled with more conservative code. Where you might want to add a manual CPU
N	 * 			define is for operating systems such as RAW32 that use the generic ugfx thread code
N	 * 			rather than operating system defined threading routines. For these platforms specifying
N	 * 			the CPU can make a decent performance improvement.
N	 * @{
N	 */
N	#ifndef GFX_CPU
N		#define GFX_CPU					GFX_CPU_UNKNOWN
N	#endif
N	#define GFX_CPU_UNKNOWN				0		//**< Unknown cpu
N	#define GFX_CPU_CORTEX_M0			0x01	//**< Cortex M0
N	#define GFX_CPU_CORTEX_M1			0x02	//**< Cortex M1
N	#define GFX_CPU_CORTEX_M2			0x03	//**< Cortex M2
N	#define GFX_CPU_CORTEX_M3			0x04	//**< Cortex M3
N	#define GFX_CPU_CORTEX_M4			0x05	//**< Cortex M4
N	#define GFX_CPU_CORTEX_M4_FP		0x06	//**< Cortex M4 with hardware floating point
N	#define GFX_CPU_CORTEX_M7			0x07	//**< Cortex M7
N	#define GFX_CPU_CORTEX_M7_FP		0x08	//**< Cortex M7 with hardware floating point
N	#define GFX_CPU_X86					0x10	//**< Intel x86
N	#define GFX_CPU_X64					0x11	//**< Intel x64
N	#define GFX_CPU_IA64				0x12	//**< Intel Itanium
N	#define GFX_CPU_POWERPC32			0x20	//**< PowerPC
N	#define GFX_CPU_POWERPC64			0x21	//**< PowerPC
N	#define GFX_CPU_SPARC				0x22	//**< Sparc
N	/** @} */
N
N	/************************************ Start CPU Auto-Detection *****************************/
N	#if GFX_CPU == GFX_CPU_UNKNOWN
X	#if 0 == 0
N		#undef GFX_CPU
N		#if defined(__ia64) || defined(__itanium__) || defined(_M_IA64)
X		#if 0L || 0L || 0L
S			#define GFX_CPU		GFX_CPU_IA64
S		#elif defined(__powerpc__) || defined(__ppc__) || defined(__PPC__)
X		#elif 0L || 0L || 0L
S			#if defined(__powerpc64__) || defined(__ppc64__) || defined(__PPC64__) || defined(__64BIT__) || defined(_LP64) || defined(__LP64__)
S				#define GFX_CPU		GFX_CPU_POWERPC64
S			#else
S				#define GFX_CPU		GFX_CPU_POWERPC32
S			#endif
S		#elif defined(__sparc)
X		#elif 0L
S			#define GFX_CPU		GFX_CPU_SPARC
S		#elif defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) || defined(_WIN64)
X		#elif 0L || 0L || 0L || 0L
S			#define GFX_CPU		GFX_CPU_X64
S		#elif defined(__i386) || defined(_M_IX86) || defined(_WIN32)
X		#elif 0L || 0L || 0L
S			#define GFX_CPU		GFX_CPU_X86
N		#else
N			#define GFX_CPU		GFX_CPU_UNKNOWN
N		#endif
N	#endif
N	/************************************ End CPU Auto-Detection *****************************/
N
N	/************************************ Start CPU Settings *****************************/
N	#if GFX_CPU == GFX_CPU_X86
X	#if 0 == 0x10
S		#undef GFX_CPU_NO_ALIGNMENT_FAULTS
S		#define GFX_CPU_NO_ALIGNMENT_FAULTS		TRUE
S		#undef GFX_CPU_ENDIAN
S		#define GFX_CPU_ENDIAN					GFX_CPU_ENDIAN_LITTLE
S	#elif GFX_CPU == GFX_CPU_X64
X	#elif 0 == 0x11
S		#undef GFX_CPU_ENDIAN
S		#define GFX_CPU_ENDIAN					GFX_CPU_ENDIAN_LITTLE
N	#endif
N	/************************************ End CPU Settings *****************************/
N
N	/**
N	 * @brief   Does this CPU automatically handle alignment faults
N	 * @details	Defaults to FALSE
N	 * @note	Setting this to TRUE can decrease code size and increase speed but
N	 * 			it should not be turned on with a CPU that can generate
N	 * 			alignment segfaults.
N	 * @note	If you are unsure leave this as FALSE as that generates
N	 * 			the more conservative code.
N	 * @note	For some CPU's this can be auto-detected.
N	 */
N	#ifndef GFX_CPU_NO_ALIGNMENT_FAULTS
N		#define GFX_CPU_NO_ALIGNMENT_FAULTS		FALSE
N	#endif
N
N	/**
N	 * @brief	The endianness of the CPU
N	 * @details	Auto detected by default but it can be overridden in gfxconf.h
N	 * @note	This is setting enables optimisations that are cpu endian specific.
N	 * @note	If the endianness can't be auto-detected it is set to GFX_CPU_ENDIAN_UNKNOWN
N	 * 			and safe (but potentially slow) code is generated
N	 * @{
N	 */
N	#ifndef GFX_CPU_ENDIAN
N		#define GFX_CPU_ENDIAN			GFX_CPU_ENDIAN_UNKNOWN
N	#endif
N	#define GFX_CPU_ENDIAN_UNKNOWN		0				//**< Unknown endianness
N	#define GFX_CPU_ENDIAN_LITTLE		0x03020100		//**< Little endian
N	#define GFX_CPU_ENDIAN_BIG			0x00010203		//**< Big endian
N	#define GFX_CPU_ENDIAN_WBDWL		0x02030001		//**< Words are big endian, DWords are little endian eg. Honeywell 316
N	#define GFX_CPU_ENDIAN_WLDWB		0x01000302		//**< Words are little endian, DWords are big endian eg PDP-11
N	/** @} */
N
N	/************************************ Start Endianness Auto-Detection *****************************/
N	#if GFX_CPU_ENDIAN == GFX_CPU_ENDIAN_UNKNOWN
X	#if 0 == 0
N		#undef GFX_CPU_ENDIAN
N		#if (defined(__BYTE_ORDER__)&&defined(__ORDER_BIG_ENDIAN__)&&(__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)) 			\
N				|| (defined(__BYTE_ORDER)&&defined(__BIG_ENDIAN)&&(__BYTE_ORDER == __BIG_ENDIAN))						\
N				|| defined(__BIG_ENDIAN__) || defined(__BIG_ENDIAN) || defined(_BIG_ENDIAN) 							\
N				|| defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) 										\
N				|| defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(__ARMEB__)
X		#if (0L&&0L&&(__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)) 							|| (0L&&0L&&(__BYTE_ORDER == __BIG_ENDIAN))										|| 0L || 0L || 0L 											|| 0L || 0L || 0L 														|| 0L || 0L || 0L
S			#define GFX_CPU_ENDIAN			GFX_CPU_ENDIAN_BIG
N		#elif (defined(__BYTE_ORDER__)&&defined(__ORDER_LITTLE_ENDIAN__)&&(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))	\
N				|| (defined(__BYTE_ORDER)&&defined(_LITTLE_ENDIAN)&&(__BYTE_ORDER == _LITTLE_ENDIAN))					\
N				|| defined(__LITTLE_ENDIAN__) || defined(__LITTLE_ENDIAN) || defined(_LITTLE_ENDIAN)					\
N				|| defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL)											\
N				|| defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(__ARMEL__)									\
N				|| defined(__LITTLE_IF_NOT_BIG__)
X		#elif (0L&&0L&&(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))					|| (0L&&0L&&(__BYTE_ORDER == _LITTLE_ENDIAN))									|| 0L || 0L || 0L									|| 0L || 0L || 0L															|| 0L || 0L || 0L													|| 1L
N			#define GFX_CPU_ENDIAN			GFX_CPU_ENDIAN_LITTLE
N		#else
S			#define GFX_CPU_ENDIAN			GFX_CPU_ENDIAN_UNKNOWN
N		#endif
N	#endif
N	/************************************ End Endianness Auto-Detection *****************************/
N
N	/**
N	 * @brief   Mark a function as deprecated.
N	 */
N	#ifndef DEPRECATED
S		#define DEPRECATED(msg)
N	#endif
N
N	/**
N	 * @brief   Mark a function as inline.
N	 */
N	#ifndef GFXINLINE
S		#define GFXINLINE	inline
N	#endif
N
N/** @} */
N
N#endif /* _GFX_COMPILERS_H */
N/** @} */
N
L 46 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N
N/**
N * @name    GFX sub-systems that can be turned on
N * @{
N */
N	/**
N	 * @brief   GFX Driver API
N	 * @details	Defaults to TRUE
N	 * @note	Not much useful can be done without a driver
N	 */
N	#ifndef GFX_USE_GDRIVER
N		#define GFX_USE_GDRIVER	TRUE
N	#endif
N	/**
N	 * @brief   GFX Graphics Display Basic API
N	 * @details	Defaults to FALSE
N	 * @note	Also add the specific hardware driver to your makefile.
N	 * 			Eg.  include $(GFXLIB)/drivers/gdisp/Nokia6610/driver.mk
N	 */
N	#ifndef GFX_USE_GDISP
S		#define GFX_USE_GDISP	FALSE
N	#endif
N	/**
N	 * @brief   GFX Graphics Windowing API
N	 * @details	Defaults to FALSE
N	 * @details	Extends the GDISP API to add the concept of graphic windows.
N	 * @note	Also supports high-level "window" objects such as console windows,
N	 * 			buttons, graphing etc
N	 */
N	#ifndef GFX_USE_GWIN
N		#define GFX_USE_GWIN	FALSE
N	#endif
N	/**
N	 * @brief   GFX Event API
N	 * @details	Defaults to FALSE
N	 * @details	Defines the concept of a "Source" that can send "Events" to "Listeners".
N	 */
N	#ifndef GFX_USE_GEVENT
N		#define GFX_USE_GEVENT	FALSE
N	#endif
N	/**
N	 * @brief   GFX Timer API
N	 * @details	Defaults to FALSE
N	 * @details	Provides thread context timers - both one-shot and periodic.
N	 */
N	#ifndef GFX_USE_GTIMER
N		#define GFX_USE_GTIMER	FALSE
N	#endif
N	/**
N	 * @brief   GFX Queue API
N	 * @details	Defaults to FALSE
N	 * @details	Provides queue management.
N	 */
N	#ifndef GFX_USE_GQUEUE
N		#define GFX_USE_GQUEUE	FALSE
N	#endif
N	/**
N	 * @brief   GFX Input Device API
N	 * @details	Defaults to FALSE
N	 * @note	Also add the specific hardware drivers to your makefile.
N	 * 			Eg.
N	 * 				include $(GFXLIB)/drivers/ginput/toggle/Pal/driver.mk
N	 * 			and...
N	 * 				include $(GFXLIB)/drivers/ginput/touch/MCU/driver.mk
N	 */
N	#ifndef GFX_USE_GINPUT
N		#define GFX_USE_GINPUT	FALSE
N	#endif
N	/**
N	 * @brief   GFX Generic Periodic ADC API
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_GADC
N		#define GFX_USE_GADC	FALSE
N	#endif
N	/**
N	 * @brief   GFX Audio API
N	 * @details	Defaults to FALSE
N	 * @note	Also add the specific hardware drivers to your makefile.
N	 * 			Eg.
N	 * 				include $(GFXLIB)/drivers/gaudio/GADC/driver.mk
N	 */
N	#ifndef GFX_USE_GAUDIO
N		#define GFX_USE_GAUDIO	FALSE
N	#endif
N	/**
N	 * @brief   GFX Miscellaneous Routines API
N	 * @details	Defaults to FALSE
N	 * @note	Turning this on without turning on any GMISC_NEED_xxx macros will result
N	 * 			in no extra code being compiled in. GMISC is made up from the sum of its
N	 * 			parts.
N	 */
N	#ifndef GFX_USE_GMISC
N		#define GFX_USE_GMISC	FALSE
N	#endif
N	/**
N	 * @brief   GFX File API
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_GFILE
N		#define GFX_USE_GFILE	FALSE
N	#endif
N	/**
N	 * @brief   GFX Translation Support API
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_GTRANS
N		#define GFX_USE_GTRANS	FALSE
N	#endif
N/** @} */
N
N/**
N * Get all the options for each sub-system.
N *
N */
N#include "src/gos/gos_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gos/gos_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gos/gos_options.h
N * @brief   GOS - Operating System options header file.
N *
N * @addtogroup GOS
N * @{
N */
N
N#ifndef _GOS_OPTIONS_H
N#define _GOS_OPTIONS_H
N
N/**
N * @name    The operating system to use. One (and only one) of these must be defined.
N * @{
N */
N	/**
N	 * @brief   Use ChibiOS
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_CHIBIOS
N		#define GFX_USE_OS_CHIBIOS		FALSE
N	#endif
N	/**
N	 * @brief   Use FreeRTOS
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_FREERTOS
N		#define GFX_USE_OS_FREERTOS		FALSE
N	#endif
N	/**
N	 * @brief   Use Win32
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_WIN32
N		#define GFX_USE_OS_WIN32		FALSE
N	#endif
N	/**
N	 * @brief   Use a linux based system running X11
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_LINUX
N		#define GFX_USE_OS_LINUX		FALSE
N	#endif
N	/**
N	 * @brief   Use a Mac OS-X based system
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_OSX
N		#define GFX_USE_OS_OSX			FALSE
N	#endif
N	/**
N	 * @brief   Use a Raw 32-bit CPU based system (Bare Metal)
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_RAW32
S		#define GFX_USE_OS_RAW32		FALSE
N	#endif
N	/**
N	 * @brief   Use a eCos
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_ECOS
N		#define GFX_USE_OS_ECOS			FALSE
N	#endif
N	/**
N	 * @brief   Use RAWRTOS
N	 * @details Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_RAWRTOS
N		#define GFX_USE_OS_RAWRTOS		FALSE
N	#endif
N	/**
N	 * @brief   Use Arduino
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_ARDUINO
N		#define GFX_USE_OS_ARDUINO		FALSE
N	#endif
N	/**
N	 * @brief	Use CMSIS RTOS compatible OS
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_CMSIS
N		#define GFX_USE_OS_CMSIS		FALSE
N	#endif
N	/**
N	 * @brief   Use Keil CMSIS
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_KEIL
N		#define GFX_USE_OS_KEIL			FALSE
N	#endif
N	/**
N	 * @brief   Use NIOS-II
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_NIOS
N		#define GFX_USE_OS_NIOS			FALSE
N	#endif
N	/**
N	 * @brief   Use Qt
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFX_USE_OS_QT
N		#define GFX_USE_OS_QT			FALSE
N	#endif
N/**
N * @}
N *
N * @name    GOS Optional Parameters
N * @{
N */
N 	/**
N 	 * @name	GFX_OS_PRE_INIT_FUNCTION
N 	 * @brief	A macro that defines a function that uGFX calls as part of gfxInit() in order to initialize hardware
N 	 * @details	Defaults to undefined
N 	 * @note	If defined the specified function is called before any other initialization.
N 	 * 			It is typically used to initialize hardware or the C runtime.
N 	 * @note	Eg. In your source:
N 	 * 					void myHardwareInitRoutine(void);
N 	 * 				In gfxconf.h:
N 	 * 					#define GFX_OS_PRE_INIT_FUNCTION myHardwareInitRoutine
N 	 */
N    //#define GFX_OS_PRE_INIT_FUNCTION                 myHardwareInitRoutine
N 	/**
N 	 * @name	GFX_OS_EXTRA_INIT_FUNCTION
N 	 * @brief	A macro that defines a function that uGFX calls as part of gfxInit() just after initializing
N 	 * 			the operating system.
N 	 * @details	Defaults to undefined
N 	 * @note	If defined the specified function is called just after the operating system is initialized by
N 	 * 			gfxInit(). Note that if gfxInit() is set up to not initialize an operating system it is called after
N 	 * 			the GFX_OS_PRE_INIT_FUNCTION function (if any).
N 	 * @note	Eg. In your source:
N 	 * 					void myOSInitRoutine(void);
N 	 * 				In gfxconf.h:
N 	 * 					#define GFX_OS_EXTRA_INIT_FUNCTION myOSInitRoutine
N 	 */
N    //#define GFX_OS_EXTRA_INIT_FUNCTION               myOSInitRoutine
N	/**
N 	 * @name	GFX_OS_EXTRA_DEINIT_FUNCTION
N 	 * @brief	A macro that defines a function that uGFX calls as part of gfxDeInit() just before de-initializing
N 	 * 			the operating system.
N 	 * @details	Defaults to undefined
N 	 * @note	If defined the specified function is called just before the operating system is de-initialized by
N 	 * 			gfxDeInit().
N 	 * @note	Eg. In your source:
N 	 * 					void myOSDeInitRoutine(void);
N 	 * 				In gfxconf.h:
N 	 * 					#define GFX_OS_EXTRA_DEINIT_FUNCTION myOSDeInitRoutine
N 	 */
N    //#define GFX_OS_EXTRA_DEINIT_FUNCTION             myOSDeInitRoutine
N 	/**
N 	 * @brief	Should uGFX avoid initializing the operating system
N 	 * @details	Defaults to FALSE
N 	 * @note	This is not relevant to all operating systems eg Win32 never initializes the
N 	 * 			operating system as uGFX runs as an application outside the boot process.
N 	 * @note	Operating system initialization is not necessarily implemented for all
N 	 * 			operating systems yet even when it is relevant. These operating systems
N 	 * 			will display a compile warning reminding you to initialize the operating
N 	 * 			system in your application code. Note that on these operating systems the
N 	 * 			demo applications will not work without modification.
N 	 */
N 	#ifndef GFX_OS_NO_INIT
N 		#define GFX_OS_NO_INIT			FALSE
N 	#endif
N 	/**
N 	 * @brief	Turn off warnings about initializing the operating system
N 	 * @details	Defaults to FALSE
N 	 * @note	This is only relevant where GOS cannot initialize the operating
N 	 * 			system automatically or the operating system initialization has been
N 	 * 			explicitly turned off.
N 	 */
N	#ifndef GFX_OS_INIT_NO_WARNING
N		#define GFX_OS_INIT_NO_WARNING	FALSE
N	#endif
N 	/**
N 	 * @brief	Should uGFX stuff be added to the FreeRTOS+Tracer
N 	 * @details	Defaults to FALSE
N 	 */
N 	#ifndef GFX_FREERTOS_USE_TRACE
N 		#define GFX_FREERTOS_USE_TRACE	FALSE
N 	#endif
N 	/**
N 	 * @brief	How much RAM should uGFX use for the heap when using its own internal heap allocator
N 	 * @details	Defaults to 0.
N 	 * @note	Only used when the internal ugfx heap allocator is used
N 	 * 				(GFX_USE_OS_RAW32, GFX_USE_OS_ARDUINO, GFX_US_OS_KEIL, GFX_USE_OS_CMSIS)
N 	 * @note	If 0 then the standard C runtime malloc(), free() and realloc()
N 	 * 			are used.
N 	 * @note	If it is non-zero then this is the number of bytes of RAM
N 	 * 			to use for the heap (gfxAlloc() and gfxFree()). No C
N 	 * 			runtime routines will be used and a new routine @p gfxAddHeapBlock()
N 	 * 			is added allowing the user to add extra memory blocks to the heap.
N 	 */
N	#ifndef GFX_OS_HEAP_SIZE
S		#define GFX_OS_HEAP_SIZE		0
N	#endif
N 	/**
N 	 * @brief	Enable wrappers for malloc() and free()
N 	 * @details	Defaults to FALSE
N 	 * @note	If enabled, malloc() and free() will be implemented as wrappers that call gfxAlloc() and
N 	 *			gfxFree() in order to provide portability to libraries using these function.
N 	 * @note	Enabling this can solve 'unresolved _sbrk' issues
N 	 * @note	It is strongly recommended to always use gfxAlloc() and gfxFree() directy to ensure
N 	 *			portability of uGFX applications across all platforms.
N 	 */
N	#ifndef GFX_EMULATE_MALLOC
N		#define GFX_EMULATE_MALLOC	FALSE
N	#endif
N/** @} */
N
N#endif /* _GOS_OPTIONS_H */
N/** @} */
L 162 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gdriver/gdriver_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gdriver/gdriver_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gdriver/gdriver_options.h
N * @brief   GDRIVER - Driver options header file.
N *
N * @addtogroup GDRIVER
N * @{
N */
N
N#ifndef _GDRIVER_OPTIONS_H
N#define _GDRIVER_OPTIONS_H
N
N/**
N * @name    GDRIVER Functionality to be included
N * @{
N */
N/**
N * @}
N *
N * @name    GDRIVER Optional Parameters
N * @{
N */
N/** @} */
N
N#endif /* _GDRIVER_OPTIONS_H */
N/** @} */
L 163 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gfile/gfile_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gfile/gfile_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gfile/gfile_options.h
N * @brief   GFILE - File IO options header file.
N *
N * @addtogroup GFILE
N * @{
N */
N
N#ifndef _GFILE_OPTIONS_H
N#define _GFILE_OPTIONS_H
N
N/**
N * @name    GFILE Functionality to be included
N * @{
N */
N	/**
N	 * @brief	Should the filesystem not be mounted automatically
N	 * @details	The filesystem is normally mounted automatically if the
N	 *			user does not do it manually. This option turns that off
N	 *			so the user must manually mount the file-system first.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFILE_NEED_NOAUTOMOUNT
N		#define GFILE_NEED_NOAUTOMOUNT	FALSE
N	#endif
N	/**
N	 * @brief	Should the filesystem be synced automatically
N	 * @details	The filesystem will automatically be synced after an open() or
N	 *			write() call unless this feature is disabled.
N	 * @details	If this feature is disabled, the user should sync the filesystem
N	 *			himself using @p gfileSync()
N	 * @details	Not all filesystems implement the syncing feature. This feature will
N	 *			have no effect in such a case.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFILE_NEED_NOAUTOSYNC
N		#define GFILE_NEED_NOAUTOSYNC	FALSE
N	#endif
N	/**
N	 * @brief   Include printg, fprintg etc functions
N	 * @details	Defaults to FALSE
N	 * @pre		To get the string sprintg functions you also need to define @p GFILE_NEED_STRINGS
N	 */
N	#ifndef GFILE_NEED_PRINTG
N		#define GFILE_NEED_PRINTG		FALSE
N	#endif
N	/**
N	 * @brief   Include scang, fscang etc functions
N	 * @details	Defaults to FALSE
N	 * @pre		To get the string sscang functions you also need to define @p GFILE_NEED_STRINGS
N	 */
N	#ifndef GFILE_NEED_SCANG
N		#define GFILE_NEED_SCANG		FALSE
N	#endif
N	/**
N	 * @brief   Include the string based file functions
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GFILE_NEED_STRINGS
N		#define GFILE_NEED_STRINGS		FALSE
N	#endif
N	/**
N	 * @brief   Map many stdio functions to their GFILE equivalent
N	 * @details	Defaults to FALSE
N	 * @note	This replaces the functions in stdio.h with equivalents
N	 * 			- Do not include stdio.h as it has different conflicting definitions.
N	 */
N	#ifndef GFILE_NEED_STDIO
N		#define GFILE_NEED_STDIO		FALSE
N	#endif
N	/**
N	 * @brief   Include the ROM file system
N	 * @details	Defaults to FALSE
N	 * @note	If GFILE_ALLOW_DEVICESPECIFIC is on then you can ensure that you are
N	 * 			opening a file on the ROM file system by prefixing
N	 * 			its name with "S|" (the letter 'S', followed by a vertical bar).
N	 * @note	This requires a file called romfs_files.h to be in the
N	 * 			users project include path. This file should include all the files
N	 * 			converted to .h files using the file2c utility (using flags "-dbcs").
N	 */
N	#ifndef GFILE_NEED_ROMFS
N		#define GFILE_NEED_ROMFS		FALSE
N	#endif
N	/**
N	 * @brief   Include the RAM file system
N	 * @details	Defaults to FALSE
N	 * @note	If GFILE_ALLOW_DEVICESPECIFIC is on then you can ensure that you are
N	 * 			opening a file on the RAM file system by prefixing
N	 * 			its name with "R|" (the letter 'R', followed by a vertical bar).
N	 * @note	You must also define GFILE_RAMFS_SIZE with the size of the file system
N	 * 			to be allocated in RAM.
N	 */
N	#ifndef GFILE_NEED_RAMFS
N		#define GFILE_NEED_RAMFS		FALSE
N	#endif
N	/**
N	 * @brief   Include the FAT file system driver based on the FATFS library
N	 * @details	Defaults to FALSE
N	 * @note	If GFILE_ALLOW_DEVICESPECIFIC is on then you can ensure that you are
N	 * 			opening a file on the FAT file system by prefixing
N	 * 			its name with "F|" (the letter 'F', followed by a vertical bar).
N	 * @note	FATFS and PETITFS offer the same FAT file system support. They just use
N	 * 			different constraints. PETITFS is smaller but has less features. Only
N	 * 			one can be used at a time. The block interfaces are also different.
N	 */
N	#ifndef GFILE_NEED_FATFS
N		#define GFILE_NEED_FATFS		FALSE
N	#endif
N	/**
N	 * @brief   Include the FAT file system driver based on the PETITFS library
N	 * @details	Defaults to FALSE
N	 * @note	If GFILE_ALLOW_DEVICESPECIFIC is on then you can ensure that you are
N	 * 			opening a file on the FAT file system by prefixing
N	 * 			its name with "F|" (the letter 'F', followed by a vertical bar).
N	 * @note	FATFS and PETITFS offer the same FAT file system support. They just use
N	 * 			different constraints. PETITFS is smaller but has less features. Only
N	 * 			one can be used at a time. The block interfaces are also different.
N	 * @note	Due to the restrictions on the PETITFS library on writing, we do not implement
N	 * 			writing.
N	 * @note	PETITFS can only have one file open at a time.
N	 */
N	#ifndef GFILE_NEED_PETITFS
N		#define GFILE_NEED_PETITFS		FALSE
N	#endif
N	/**
N	 * @brief   Include the operating system's native file system
N	 * @details	Defaults to FALSE
N	 * @note	If GFILE_ALLOW_DEVICESPECIFIC is on then you can ensure that you are
N	 * 			opening a file on the native file system by prefixing
N	 * 			its name with "N|" (the letter 'N', followed by a vertical bar).
N	 * @note	If defined then the gfileStdOut and gfileStdErr handles
N	 * 			use the operating system equivalent stdio and stderr.
N	 * 			If it is not defined the gfileStdOut and gfileStdErr io is discarded.
N	 */
N	#ifndef GFILE_NEED_NATIVEFS
N		#define GFILE_NEED_NATIVEFS		FALSE
N	#endif
N	/**
N	 * @brief   Include ChibiOS BaseFileStream support
N	 * @details	Defaults to FALSE
N	 * @pre		This is only relevant on the ChibiOS operating system.
N	 * @note	Use the @p gfileOpenBaseFileStream() call to open a GFILE based on a
N	 * 			BaseFileStream. The BaseFileStream must already be open.
N	 * @note	A GFile of this type cannot be opened by filename. The BaseFileStream
N	 * 			must be pre-opened using the operating system.
N	 */
N	#ifndef GFILE_NEED_CHIBIOSFS
N		#define GFILE_NEED_CHIBIOSFS	FALSE
N	#endif
N	/**
N	 * @brief   Include raw memory pointer support
N	 * @details	Defaults to FALSE
N	 * @note	Use the @p gfileOpenMemory() call to open a GFILE based on a
N	 * 			memory pointer. The GFILE opened appears to be of unlimited size.
N	 * @note	A GFile of this type cannot be opened by filename.
N	 */
N	#ifndef GFILE_NEED_MEMFS
N		#define GFILE_NEED_MEMFS		FALSE
N	#endif
N	/**
N	 * @brief   Include support for file list functions
N	 * @details	Defaults to FALSE
N	 * @note	Adds support for @p gfileOpenFileList(), @p gfileReadFileList() and @p gfileCloseFileList().
N	 */
N	#ifndef GFILE_NEED_FILELISTS
N		#define GFILE_NEED_FILELISTS	FALSE
N	#endif
N/**
N * @}
N *
N * @name    GFILE Optional Parameters
N * @{
N */
N	/**
N	 * @brief  Add floating point support to printg/scang etc.
N	 */
N	#ifndef GFILE_ALLOW_FLOATS
N		#define GFILE_ALLOW_FLOATS	FALSE
N	#endif
N	/**
N	 * @brief   Can the device be specified as part of the file name.
N	 * @note	If this is on then a device letter and a vertical bar can be
N	 * 			prefixed on a file name to specify that it must be on a
N	 * 			specific device.
N	 */
N	#ifndef GFILE_ALLOW_DEVICESPECIFIC
N		#define GFILE_ALLOW_DEVICESPECIFIC		FALSE
N	#endif
N	/**
N	 * @brief   The maximum number of open files
N	 * @note	This count excludes gfileStdIn, gfileStdOut and gfileStdErr
N	 * 			(if open by default).
N	 */
N	#ifndef GFILE_MAX_GFILES
N		#define GFILE_MAX_GFILES		3
N	#endif
N	/**
N	 * @brief   TUse an external FATFS library instead of the uGFX inbuilt one
N	 * @note	This is applicable when GFILE_NEED_FATFS is specified. It allows
N	 *			the programmer to use their own FATFS implementation provided the
N	 *			api matches the fatfs-0.10b API.
N	 * @note	The users ffconf.h file still needs to be reachable when compiling uGFX.
N	 * @note	If ffconf.h contains _FS_REENTRANT as true then the user provided simpleton
N	 *			routines must be compatible with uGFX threading.
N	 * @note	If ffconf.h contains _USE_LFN == 3 then the user provided simpleton routines must
N	 *			be compatible with uGFX memory management.
N	 */
N	#ifndef GFILE_FATFS_EXTERNAL_LIB
N		#define GFILE_FATFS_EXTERNAL_LIB		FALSE
N	#endif
N	/**
N	 * @brief   TUse an external PETITFS library instead of the uGFX inbuilt one
N	 * @note	This is applicable when GFILE_NEED_PETITFS is specified. It allows
N	 *			the programmer to use their own FATFS implementation provided the
N	 *			api matches the petitfs-0.03 API.
N	 * @note	The users pffconf.h file still needs to be reachable when compiling uGFX.
N	 */
N	#ifndef GFILE_PETITFS_EXTERNAL_LIB
N		#define GFILE_PETITFS_EXTERNAL_LIB	FALSE
N	#endif
N	
N/** @} */
N
N#endif /* _GFILE_OPTIONS_H */
N/** @} */
L 164 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gmisc/gmisc_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gmisc/gmisc_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gmisc/gmisc_options.h
N * @brief   GMISC - Miscellaneous Routines options header file.
N *
N * @addtogroup GMISC
N * @{
N */
N
N#ifndef _GMISC_OPTIONS_H
N#define _GMISC_OPTIONS_H
N
N/**
N * @name    GMISC Functionality to be included
N * @{
N */
N	/**
N	 * @brief   Include array operation functions
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GMISC_NEED_ARRAYOPS
N		#define GMISC_NEED_ARRAYOPS			FALSE
N	#endif
N	/**
N	 * @brief   Include fast floating point trig functions (fsin, fcos)
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GMISC_NEED_FASTTRIG
N		#define GMISC_NEED_FASTTRIG			FALSE
N	#endif
N	/**
N	 * @brief   Include fast fixed point trig functions (ffsin, ffcos)
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GMISC_NEED_FIXEDTRIG
N		#define GMISC_NEED_FIXEDTRIG		FALSE
N	#endif
N	/**
N	 * @brief   Include fast inverse square root (x^-1/2)
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GMISC_NEED_INVSQRT
N		#define GMISC_NEED_INVSQRT		FALSE
N	#endif
N/**
N * @}
N *
N * @name    GMISC Optional Parameters
N * @{
N */
N	/**
N	 * @brief	Modifies the @p invsqrt() function to assume a different integer to floating point endianness.
N	 * @note	Normally the floating point format and the integer format have
N	 * 			the same endianness. Unfortunately there are some strange
N	 * 			processors that don't eg. some very early ARM devices.
N	 * 			For those where the endianness doesn't match you can fix it by
N	 * 			defining GMISC_INVSQRT_MIXED_ENDIAN.
N	 * @note	This still assumes the processor is using an ieee floating point format.
N	 *
N	 * If you have a software floating point that uses a non-standard
N	 * floating point format (or very strange hardware) then define
N	 * GMISC_INVSQRT_REAL_SLOW and it will do it the hard way.
N	 */
N	#ifndef GMISC_INVSQRT_MIXED_ENDIAN
N		#define GMISC_INVSQRT_MIXED_ENDIAN	FALSE
N	#endif
N	/**
N	 * @brief	Modifies the @p invsqrt() function to do things the long slow way.
N	 * @note	This causes the @p invsqrt() function to work regardless of the
N	 * 			processor floating point format.
N	 * @note	This makes the @p invsqrt() function very slow.
N	 */
N	#ifndef GMISC_INVSQRT_REAL_SLOW
N		#define GMISC_INVSQRT_REAL_SLOW		FALSE
N	#endif
N/** @} */
N
N#endif /* _GMISC_OPTIONS_H */
N/** @} */
L 165 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gtrans/gtrans_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gtrans/gtrans_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gtrans/gtrans_options.h
N *
N * @addtogroup GTRANS
N * @{
N */
N
N#ifndef _GTRANS_OPTIONS_H
N#define _GTRANS_OPTIONS_H
N
N
N
N#endif /* _GTRANS_OPTIONS_H */
N/** @} */
L 166 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gqueue/gqueue_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gqueue/gqueue_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gqueue/gqueue_options.h
N * @brief   GQUEUE - Queue options header file.
N *
N * @addtogroup GQUEUE
N * @{
N */
N
N#ifndef _GQUEUE_OPTIONS_H
N#define _GQUEUE_OPTIONS_H
N
N/**
N * @name    GQUEUE Functions to include.
N * @{
N */
N	/**
N	 * @brief   Enable Asynchronous Queues
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GQUEUE_NEED_ASYNC
N		#define GQUEUE_NEED_ASYNC		FALSE
N	#endif
N	/**
N	 * @brief   Enable Get-Synchronous Queues
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GQUEUE_NEED_GSYNC
N		#define GQUEUE_NEED_GSYNC		FALSE
N	#endif
N	/**
N	 * @brief   Enable Fully Synchronous Queues
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GQUEUE_NEED_FSYNC
N		#define GQUEUE_NEED_FSYNC		FALSE
N	#endif
N	/**
N	 * @brief	Enable Queue-able Data Buffers
N	 */
N	#ifndef GQUEUE_NEED_BUFFERS
N		#define GQUEUE_NEED_BUFFERS		FALSE
N	#endif
N/**
N * @}
N *
N * @name    GQUEUE Optional Sizing Parameters
N * @{
N */
N/** @} */
N
N#endif /* _GQUEUE_OPTIONS_H */
N/** @} */
L 167 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gevent/gevent_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gevent/gevent_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gevent/gevent_options.h
N * @brief   GEVENT sub-system options header file.
N *
N * @addtogroup GEVENT
N * @{
N */
N
N#ifndef _GEVENT_OPTIONS_H
N#define _GEVENT_OPTIONS_H
N
N/**
N * @name    GEVENT Functionality to be included
N * @{
N */
N	/**
N	 * @brief   Should routines assert() if they run out of resources.
N	 * @details	Defaults to FALSE.
N	 * @details	If FALSE the application must be prepared to handle these
N	 *			failures.
N	 */
N	#ifndef GEVENT_ASSERT_NO_RESOURCE
N		#define GEVENT_ASSERT_NO_RESOURCE		FALSE
N	#endif
N/**
N * @}
N *
N * @name    GEVENT Optional Sizing Parameters
N * @{
N */
N	/**
N	 * @brief   Defines the maximum size of an event status variable.
N	 * @details	Defaults to 32 bytes
N	 */
N	#ifndef GEVENT_MAXIMUM_SIZE
N		#define GEVENT_MAXIMUM_SIZE				32
N	#endif
N	/**
N	 * @brief   Defines the maximum Source/Listener pairs in the system.
N	 * @details	Defaults to 32
N	 */
N	#ifndef GEVENT_MAX_SOURCE_LISTENERS
N		#define GEVENT_MAX_SOURCE_LISTENERS		32
N	#endif
N/** @} */
N
N#endif /* _GEVENT_OPTIONS_H */
N/** @} */
L 168 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gtimer/gtimer_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gtimer/gtimer_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gtimer/gtimer_options.h
N * @brief   GTIMER sub-system options header file.
N *
N * @addtogroup GTIMER
N * @{
N */
N
N#ifndef _GTIMER_OPTIONS_H
N#define _GTIMER_OPTIONS_H
N
N/**
N * @name    GTIMER Functionality to be included
N * @{
N */
N/**
N * @}
N *
N * @name    GTIMER Optional Sizing Parameters
N * @{
N */
N	/**
N	 * @brief	Defines the GTIMER thread priority
N	 * @details	Defaults to HIGH_PRIORITY
N	 */
N	#ifndef GTIMER_THREAD_PRIORITY
N		#define GTIMER_THREAD_PRIORITY			HIGH_PRIORITY
N	#endif
N	/**
N	 * @brief   Defines the size of the timer threads work area (stack+structures).
N	 * @details	Defaults to 2048 bytes
N	 */
N	#ifndef GTIMER_THREAD_WORKAREA_SIZE
N		#define GTIMER_THREAD_WORKAREA_SIZE		2048
N	#endif
N/** @} */
N
N#endif /* _GTIMER_OPTIONS_H */
N/** @} */
L 169 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gdisp/gdisp_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gdisp/gdisp_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gdisp/gdisp_options.h
N * @brief   GDISP sub-system options header file.
N *
N * @addtogroup GDISP
N * @{
N */
N
N#ifndef _GDISP_OPTIONS_H
N#define _GDISP_OPTIONS_H
N
N/**
N * @name    GDISP Functionality to be included
N * @{
N */
N	/**
N	 * @brief   Should drawing operations be automatically flushed.
N	 * @details	Defaults to FALSE
N	 * @note	If set to FALSE and the controller requires flushing
N	 * 			then the application must manually call @p gdispGFlush().
N	 * 			Setting this to TRUE causes GDISP to automatically flush
N	 * 			after each drawing operation. Note this may be slow but enables
N	 * 			an application to avoid having to manually call the flush routine.
N	 * @note	If TRUE and GDISP_NEED_TIMERFLUSH is also TRUE, this takes precedence.
N	 * @note	Most controllers don't need flushing which is why this is set to
N	 * 			FALSE by default.
N	 */
N	#ifndef GDISP_NEED_AUTOFLUSH
N		#define GDISP_NEED_AUTOFLUSH			FALSE
N	#endif
N	/**
N	 * @brief   Should drawing operations be automatically flushed on a timer.
N	 * @details	Defaults to FALSE, Can be set to FALSE or a timer period in milliseconds.
N	 * @note	The period should not be set too short or it will consume all your CPU. A
N	 * 			value between 250 and 500 milliseconds would probably be suitable.
N	 * @note	If TRUE and GDISP_NEED_AUTOFLUSH is also TRUE, this is ineffective.
N	 * @note	Most controllers don't need flushing which is why this is set to
N	 * 			FALSE by default.
N	 */
N	#ifndef GDISP_NEED_TIMERFLUSH
N		#define GDISP_NEED_TIMERFLUSH			FALSE
N	#endif
N	/**
N	 * @brief   Should all operations be clipped to the screen and colors validated.
N	 * @details	Defaults to TRUE.
N	 * @note    If this is FALSE, any operations that extend beyond the
N	 *          edge of the screen will have undefined results. Any
N	 *			out-of-range colors will produce undefined results.
N	 * @note	This should always be left as the default (TRUE) unless you
N	 * 			are a maniac for speed and you have thoroughly tested your code
N	 * 			and it never overwrites the edges of the screen.
N	 * @note	Setting GDISP_NEED_CLIP to TRUE internally uses the same mechanism
N	 * 			as this validation. There is no advantage in setting this FALSE if
N	 * 			GDISP_NEED_CLIP is TRUE.
N	 */
N	#ifndef GDISP_NEED_VALIDATION
N		#define GDISP_NEED_VALIDATION			TRUE
N	#endif
N	/**
N	 * @brief   Are clipping functions needed.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_CLIP
N		#define GDISP_NEED_CLIP					TRUE
N	#endif
N	/**
N	 * @brief   Streaming functions are needed
N	 * @details	Defaults to FALSE.
N	 */
N	#ifndef GDISP_NEED_STREAMING
N		#define GDISP_NEED_STREAMING			FALSE
N	#endif
N	/**
N	 * @brief   Are text functions needed.
N	 * @details	Defaults to FALSE
N	 * @note	You must also define at least one font.
N	 */
N	#ifndef GDISP_NEED_TEXT
N		#define GDISP_NEED_TEXT					FALSE
N	#endif
N	/**
N	 * @brief   Are circle functions needed.
N	 * @details	Defaults to FALSE
N	 * @note	Uses integer algorithms only. It does not use any trig or floating point.
N	 */
N	#ifndef GDISP_NEED_CIRCLE
N		#define GDISP_NEED_CIRCLE				FALSE
N	#endif
N	/**
N	 * @brief   Are ellipse functions needed.
N	 * @details	Defaults to FALSE
N	 * @note	Uses integer algorithms only. It does not use any trig or floating point.
N	 */
N	#ifndef GDISP_NEED_ELLIPSE
N		#define GDISP_NEED_ELLIPSE				FALSE
N	#endif
N	/**
N	 * @brief   Are arc sector functions needed.
N	 * @details	Defaults to FALSE
N	 * @note	Uses integer algorithms only. It does not use any trig or floating point.
N	 */
N	#ifndef GDISP_NEED_ARCSECTORS
N		#define GDISP_NEED_ARCSECTORS			FALSE
N	#endif
N	/**
N	 * @brief   Are arc functions needed.
N	 * @details	Defaults to FALSE
N	 * @note	This can be compiled using fully integer mathematics by
N	 * 			defining GFX_USE_GMISC and GMISC_NEED_FIXEDTRIG as TRUE.
N	 * @note	This can be compiled to use floating point but no trig functions
N	 * 			by defining GFX_USE_GMISC and GMISC_NEED_FASTTRIG as TRUE.
N	 * @note	If neither of the above are defined it requires the maths library
N	 * 			to be included in the link to provide floating point and trig support.
N	 * 			ie  include -lm in your compiler flags.
N	 */
N	#ifndef GDISP_NEED_ARC
N		#define GDISP_NEED_ARC					FALSE
N	#endif
N	/**
N	 * @brief   Are convex polygon functions needed.
N	 * @details	Defaults to FALSE
N	 * @note	Convex polygons are those that have no internal angles. That is;
N	 * 			you can draw a line from any point on the polygon to any other point
N	 * 			on the polygon without it going outside the polygon.
N	 */
N	#ifndef GDISP_NEED_CONVEX_POLYGON
N		#define GDISP_NEED_CONVEX_POLYGON		FALSE
N	#endif
N	/**
N	 * @brief   Are scrolling functions needed.
N	 * @details	Defaults to FALSE
N	 * @note	This function must be supported by the low level GDISP driver
N	 * 			you have included in your project. If it isn't, defining this
N	 * 			option will cause a compile error.
N	 */
N	#ifndef GDISP_NEED_SCROLL
N		#define GDISP_NEED_SCROLL				FALSE
N	#endif
N	/**
N	 * @brief   Is the capability to read pixels back needed.
N	 * @details	Defaults to FALSE
N	 * @note	This function must be supported by the low level GDISP driver
N	 * 			you have included in your project. If it isn't, defining this
N	 * 			option will cause a compile error.
N	 */
N	#ifndef GDISP_NEED_PIXELREAD
N		#define GDISP_NEED_PIXELREAD			FALSE
N	#endif
N	/**
N	 * @brief   Control some aspect of the hardware operation.
N	 * @details	Defaults to FALSE
N	 * @note	This allows control of hardware specific features such as
N	 * 			screen rotation, backlight levels, contrast etc
N	 */
N	#ifndef GDISP_NEED_CONTROL
N		#define GDISP_NEED_CONTROL				FALSE
N	#endif
N	/**
N	 * @brief   Query some aspect of the hardware operation.
N	 * @details	Defaults to FALSE
N	 * @note	This allows query of hardware specific features
N	 */
N	#ifndef GDISP_NEED_QUERY
N		#define GDISP_NEED_QUERY				FALSE
N	#endif
N	/**
N	 * @brief   Is the image interface required.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_IMAGE
N		#define GDISP_NEED_IMAGE				FALSE
N	#endif
N	/**
N	 * @brief   Is the image interface required.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_PIXMAP
N		#define GDISP_NEED_PIXMAP				FALSE
N	#endif
N/**
N * @}
N *
N * @name    GDISP Multi-Threading Options
N * @{
N */
N	/**
N	 * @brief   Do the drawing functions need to be thread-safe.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_MULTITHREAD
N		#define GDISP_NEED_MULTITHREAD			FALSE
N	#endif
N/**
N * @}
N *
N * @name    GDISP Optional Parameters
N * @{
N */
N	/**
N	 * @brief	Should the startup logo be displayed
N	 *
N	 * @details Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_STARTUP_LOGO
S		#define GDISP_NEED_STARTUP_LOGO 		TRUE
N	#endif
N	/**
N	 * @brief	Define the initial background color for all displays in the system.
N	 */
N	#ifndef GDISP_STARTUP_COLOR
N		#define GDISP_STARTUP_COLOR				Black
N	#endif
N	/**
N	 * @brief	Define the default orientation for all displays in the system.
N	 * @note	GDISP_NEED_CONTROL must also be set (and the hardware must support it)
N	 * @note	If not specified then displays default to the native hardware orientation
N	 */
N	// #define GDISP_DEFAULT_ORIENTATION		GDISP_ROTATE_LANDSCAPE
N	/**
N	 * @brief   The size of pixel buffer (in pixels) used for optimization.
N	 * @details	Set to zero to guarantee disabling of the buffer.
N	 * @note	Depending on the driver and what operations the application
N	 * 			needs, this buffer may never be allocated.
N	 * @note	Setting the size to zero may cause some operations to not
N	 * 			compile eg. Scrolling if there is no hardware scroll support.
N	 * @note	Increasing the size will speedup certain operations
N	 * 			at the expense of RAM.
N	 * @note	Currently only used to support scrolling on hardware without
N	 * 			scrolling support, and to increase the speed of streaming
N	 * 			operations on non-streaming hardware where there is a
N	 * 			hardware supported bit-blit.
N	 */
N	#ifndef GDISP_LINEBUF_SIZE
N		#define GDISP_LINEBUF_SIZE				128
N	#endif
N/**
N * @}
N *
N * @name    GDISP Multiple Display Support
N * @{
N */
N	/**
N	 * @brief   The total number of displays using the default driver.
N	 * @note	If you want to use multiple displays either set GDISP_TOTAL_DISPLAYS or GDISP_DRIVER_LIST
N	 *          but not both.
N	 */
N	#ifndef GDISP_TOTAL_DISPLAYS
S		#define GDISP_TOTAL_DISPLAYS		1
N	#endif
N	#if defined(__DOXYGEN__)
X	#if 0L
S		/**
S		 * @brief   The list of display drivers.
S		 * @note	Replace this example with your own definition in your gfxconf.h file. See the gdisp_lld.c
S		 *          in each driver (near the top) to get the name of the VMT for a driver.
S		 * @note    The same driver can occur more than once in the list to create an extra instance of that driver.
S		 * @note    If defining this you must also define GDISP_PIXELFORMAT for your application to use.
S         *          Choose a value that is most common accross all your drivers for efficiency.
S         * @note    If using this you may optionally define the GDISP_HARDWARE_xxx values as either TRUE or FALSE.
S         *          Doing this causes GDISP to assume that all (TRUE) or none (FALSE) of the listed drivers have that
S         *          capability. This can help improve drawing speed and efficiency.
S		 */
S		#define GDISP_DRIVER_LIST		  GDISPVMT_Win32, GDISPVMT_SSD1963
N	#endif
N/**
N * @}
N *
N * @name    GDISP Image Options
N * @pre		GDISP_NEED_IMAGE must be TRUE
N * @{
N */
N	/**
N	 * @brief   Is native image decoding required.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_IMAGE_NATIVE
N		#define GDISP_NEED_IMAGE_NATIVE			FALSE
N	#endif
N	/**
N	 * @brief   Is GIF image decoding required.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_IMAGE_GIF
N		#define GDISP_NEED_IMAGE_GIF			FALSE
N	#endif
N	/**
N	 * @brief   Is BMP image decoding required.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_IMAGE_BMP
N		#define GDISP_NEED_IMAGE_BMP			FALSE
N	#endif
N	/**
N	 * @brief   Is JPG image decoding required.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_IMAGE_JPG
N		#define GDISP_NEED_IMAGE_JPG			FALSE
N	#endif
N	/**
N	 * @brief   Is PNG image decoding required.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG
N		#define GDISP_NEED_IMAGE_PNG			FALSE
N	#endif
N	/**
N	 * @brief   Is memory accounting required during image decoding.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_IMAGE_ACCOUNTING
N		#define GDISP_NEED_IMAGE_ACCOUNTING		FALSE
N	#endif
N/**
N * @}
N *
N * @name    GDISP BMP Image Options
N * @pre		GDISP_NEED_IMAGE and GDISP_NEED_IMAGE_BMP must be TRUE
N * @{
N */
N	/**
N	 * @brief   Is BMP 1 bit per pixel (monochrome/2 color) image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_BMP_1
N		#define GDISP_NEED_IMAGE_BMP_1		TRUE
N	#endif
N	/**
N	 * @brief   Is BMP 4 bits per pixel (16 color) image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_BMP_4
N		#define GDISP_NEED_IMAGE_BMP_4		TRUE
N	#endif
N	/**
N	 * @brief   Is BMP 4 bits per pixel (16 color) with RLE compression image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_BMP_4_RLE
N		#define GDISP_NEED_IMAGE_BMP_4_RLE	TRUE
N	#endif
N	/**
N	 * @brief   Is BMP 8 bits per pixel (256 color) image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_BMP_8
N		#define GDISP_NEED_IMAGE_BMP_8		TRUE
N	#endif
N	/**
N	 * @brief   Is BMP 8 bits per pixel (256 color) with RLE compression image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_BMP_8_RLE
N		#define GDISP_NEED_IMAGE_BMP_8_RLE	TRUE
N	#endif
N	/**
N	 * @brief   Is BMP 16 bits per pixel (65536 color) image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_BMP_16
N		#define GDISP_NEED_IMAGE_BMP_16		TRUE
N	#endif
N	/**
N	 * @brief   Is BMP 24 bits per pixel (true-color) image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_BMP_24
N		#define GDISP_NEED_IMAGE_BMP_24		TRUE
N	#endif
N	/**
N	 * @brief   Is BMP 32 bits per pixel (true-color) image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_BMP_32
N		#define GDISP_NEED_IMAGE_BMP_32		TRUE
N	#endif
N/**
N * @}
N *
N * @name    GDISP PNG Image Options
N * @pre		GDISP_NEED_IMAGE and GDISP_NEED_IMAGE_PNG must be TRUE
N * @{
N */
N	/**
N	 * @brief   Is PNG Interlaced image decoding required.
N	 * @details	Defaults to FALSE
N	 * @note	Currently not supported due to the complex decoding and display requirements
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_INTERLACED
N		#define GDISP_NEED_IMAGE_PNG_INTERLACED			FALSE
N	#endif
N	/**
N	 * @brief   Is PNG image transparency processed.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_TRANSPARENCY
N		#define GDISP_NEED_IMAGE_PNG_TRANSPARENCY		TRUE
N	#endif
N	/**
N	 * @brief   Is PNG background data processed.
N	 * @details	Defaults to TRUE
N	 * @note	If the background is specified in the image file and this define is TRUE,
N	 * 			that background color is used for transparency and alpha blending.
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_BACKGROUND
N		#define GDISP_NEED_IMAGE_PNG_BACKGROUND			TRUE
N	#endif
N	/**
N	 * @brief   What is the cliff between non-blended alpha pixels being displayed or not.
N	 * @details	Range of 0 to 255
N	 * @note	If GDISP_NEED_IMAGE_PNG_BACKGROUND is TRUE and the PNG file contains a
N	 * 			background color then the pixel will be blended with the background color
N	 * 			according to the alpha.
N	 * 			If not then no blending occurs. The pixel will either be set or not.
N	 * 			Any alpha value greater or equal to this number will be displayed.
N	 * 			Anything less than this number is not displayed.
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_ALPHACLIFF
N		#define GDISP_NEED_IMAGE_PNG_ALPHACLIFF			32
N	#endif
N	/**
N	 * @brief   Is 1, 2 and 4 bit PNG palettized image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_PALETTE_124
N		#define GDISP_NEED_IMAGE_PNG_PALETTE_124		TRUE
N	#endif
N	/**
N	 * @brief   Is 8 bit PNG palettized image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_PALETTE_8
N		#define GDISP_NEED_IMAGE_PNG_PALETTE_8			TRUE
N	#endif
N	/**
N	 * @brief   Is 1,2 and 4 bit PNG grayscale image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_GRAYSCALE_124
N		#define GDISP_NEED_IMAGE_PNG_GRAYSCALE_124		TRUE
N	#endif
N	/**
N	 * @brief   Is 8 bit PNG grayscale image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_GRAYSCALE_8
N		#define GDISP_NEED_IMAGE_PNG_GRAYSCALE_8		TRUE
N	#endif
N	/**
N	 * @brief   Is 16 bit PNG grayscale image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_GRAYSCALE_16
N		#define GDISP_NEED_IMAGE_PNG_GRAYSCALE_16		TRUE
N	#endif
N	/**
N	 * @brief   Is 8 bit PNG grayscale with 8 bit alpha image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_GRAYALPHA_8
N		#define GDISP_NEED_IMAGE_PNG_GRAYALPHA_8		TRUE
N	#endif
N	/**
N	 * @brief   Is 16 bit PNG grayscale with 16 bit alpha image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_GRAYALPHA_16
N		#define GDISP_NEED_IMAGE_PNG_GRAYALPHA_16		TRUE
N	#endif
N	/**
N	 * @brief   Is 8/8/8 bit PNG RGB image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_RGB_8
N		#define GDISP_NEED_IMAGE_PNG_RGB_8				TRUE
N	#endif
N	/**
N	 * @brief   Is 16/16/16 bit PNG RGB image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_RGB_16
N		#define GDISP_NEED_IMAGE_PNG_RGB_16				TRUE
N	#endif
N	/**
N	 * @brief   Is 8/8/8 bit PNG RGB with 8 bit alpha image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_RGBALPHA_8
N		#define GDISP_NEED_IMAGE_PNG_RGBALPHA_8			TRUE
N	#endif
N	/**
N	 * @brief   Is 16/16/16 bit PNG RGB with 16 bit alpha image decoding required.
N	 * @details	Defaults to TRUE
N	 */
N	#ifndef GDISP_NEED_IMAGE_PNG_RGBALPHA_16
N		#define GDISP_NEED_IMAGE_PNG_RGBALPHA_16		TRUE
N	#endif
N/**
N * @}
N *
N * @name	GDISP Text Rendering Options
N * @{
N */
N	/**
N	 * @brief	Enable advanced word-wrapping.
N	 * @details	Only has an effect with @p gdispGDrawStringBox() and @p gdispGFillStringBox()
N	 * @details Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_TEXT_WORDWRAP
N		#define GDISP_NEED_TEXT_WORDWRAP		FALSE
N	#endif
N	/**
N	 * @brief	Enable UTF-8 support for text rendering.
N	 * @details Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_UTF8
N		#define GDISP_NEED_UTF8					FALSE
N	#endif
N	/**
N	 * @brief	Enable kerning for font rendering (improves character placement).
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_TEXT_KERNING
N		#define GDISP_NEED_TEXT_KERNING			FALSE
N	#endif
N	/**
N	 * @brief	Enable antialiased font support
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GDISP_NEED_ANTIALIAS
N		#define GDISP_NEED_ANTIALIAS			FALSE
N	#endif
N/**
N * @}
N *
N * @name	GDISP Pixmap Options
N * @{
N */
N	#ifndef GDISP_NEED_PIXMAP_IMAGE
N		#define GDISP_NEED_PIXMAP_IMAGE			FALSE
N	#endif
N/**
N * @}
N *
N * @name    GDISP Optional Low Level Driver Defines
N * @{
N */
N	/**
N	 * @brief   Set the screen height and width.
N	 * @note	Ignored by some low level GDISP drivers, optional for others.
N	 * @note	Where these values are allowed, a default is always provided be the low level driver.
N	 * @note	The list of GDISP low level drivers that allow these to be set are...
N	 *				WIN32, SSD1289, SSD1963, TestStub
N	 */
N	/* #define GDISP_SCREEN_WIDTH		nnnn */
N	/* #define GDISP_SCREEN_HEIGHT		nnnn */
N	/**
N	 * @brief   Define which bus interface to use.
N	 * @details	Only required by the SSD1963 driver.
N	 * @note	This will be replaced eventually by board definition files
N	 */
N	// #define GDISP_USE_FSMC
N	// #define GDISP_USE_GPIO
N/** @} */
N
N#endif /* _GDISP_OPTIONS_H */
N/** @} */
N
L 170 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gwin/gwin_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gwin/gwin_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gwin/gwin_options.h
N * @brief   GWIN sub-system options header file.
N *
N * @addtogroup GWIN
N * @brief	The GWIN module uses all the other modules (GDISP, GINPUT, GTIMER...) to
N *			form a complete GUI toolkit.
N * 
N * @{
N */
N
N#ifndef _GWIN_OPTIONS_H
N#define _GWIN_OPTIONS_H
N
N/**
N * @name    GWIN Functionality to be included
N * @{
N */
N	/**
N	 * @brief   Should window manager support be included
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_WINDOWMANAGER
N		#define GWIN_NEED_WINDOWMANAGER	FALSE
N	#endif
N	/**
N	 * @brief	Should the widget hierarchy be included. This provides parent-child features.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_CONTAINERS
N		#define GWIN_NEED_CONTAINERS	FALSE
N	#endif
N	/**
N	 * @brief   Should widget functions be included. Needed for any widget (eg Buttons, Sliders etc)
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_WIDGET
N		#define GWIN_NEED_WIDGET	FALSE
N	#endif
N	/**
N	 * @brief   The width of the rectangle that highlights a widget that is focused
N	 * @details	Defaults to 1
N	 */
N	#ifndef GWIN_FOCUS_HIGHLIGHT_WIDTH
N		#define GWIN_FOCUS_HIGHLIGHT_WIDTH 1
N	#endif
N	/**
N	 * @brief	Should the simple container be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_CONTAINER
N		#define GWIN_NEED_CONTAINER		FALSE
N	#endif
N	/**
N	 * @brief	Should the frame widget be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_FRAME
N		#define GWIN_NEED_FRAME		FALSE
N	#endif
N	/**
N	 * @brief   Should console functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_CONSOLE
N		#define GWIN_NEED_CONSOLE	FALSE
N	#endif
N	/**
N	 * @brief   Should graph functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_GRAPH
N		#define GWIN_NEED_GRAPH		FALSE
N	#endif
N	/**
N	 * @brief   Should gl3d functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_GL3D
N		#define GWIN_NEED_GL3D		FALSE
N	#endif
N	/**
N	 * @brief   Should button functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_BUTTON
N		#define GWIN_NEED_BUTTON	FALSE
N	#endif
N	/**
N	 * @brief   Should progressbar functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_PROGRESSBAR
N		#define GWIN_NEED_PROGRESSBAR	FALSE
N	#endif
N	/**
N	 * @brief   Should slider functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_SLIDER
N		#define GWIN_NEED_SLIDER	FALSE
N	#endif
N	/**
N	 * @brief   Should checkbox functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_CHECKBOX
N		#define GWIN_NEED_CHECKBOX	FALSE
N	#endif
N	/**
N	 * @brief   Should image functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_IMAGE
N		#define GWIN_NEED_IMAGE		FALSE
N	#endif
N	/**
N	 * @brief   Should label functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_LABEL
N		#define GWIN_NEED_LABEL		FALSE
N	#endif
N	/**
N	 * @brief   Should radio button functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_RADIO
N		#define GWIN_NEED_RADIO		FALSE
N	#endif
N	/**
N	 * @brief   Should list widget functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_LIST
N		#define GWIN_NEED_LIST		FALSE
N	#endif
N	/**
N	 * @brief   Should tabset functions be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_TABSET
N		#define GWIN_NEED_TABSET	FALSE
N	#endif
N	/**
N	 * @brief   Should the virtual keyboard be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_KEYBOARD
N		#define GWIN_NEED_KEYBOARD	FALSE
N	#endif
N	/**
N	 * @brief   Should the textedit widget be included.
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_TEXTEDIT
N		#define GWIN_NEED_TEXTEDIT	FALSE
N	#endif
N/**
N * @}
N *
N * @name    GWIN Optional Parameters
N * @{
N */
N	/**
N	 * @brief   Add a tag to each widget
N	 * @details	Defaults to FALSE
N	 * @note	Adds a tag member to each widget. Any events created include this tag.
N	 * 			The enables switch based application logic to detect the event source.
N	 */
N	#ifndef GWIN_WIDGET_TAGS
N		#define GWIN_WIDGET_TAGS		FALSE
N	#endif
N	/**
N	 * @brief   Use flat styling for controls rather than a 3D look
N	 * @details	Defaults to FALSE
N	 * @note	This may appear better on color-restricted displays
N	 * @note	Flat styling is less graphics and cpu intensive (marginally) than the default 3D look.
N	 */
N	#ifndef GWIN_FLAT_STYLING
N		#define GWIN_FLAT_STYLING		FALSE
N	#endif
N	/**
N	 * @brief	Don't use a timer for redrawing windows
N	 * @details	Defaults to FALSE
N	 * @note	Normally windows and widgets are redrawn on a timer. Setting this
N	 * 			option causes them to be redrawn immediately. Note that this can
N	 * 			cause extended blocking times on events and saves little code.
N	 * @note	If GWIN_NEED_WINDOWMANAGER is FALSE then this setting is ignored
N	 * 			as redrawing always occurs immediately.
N	 */
N	#ifndef GWIN_REDRAW_IMMEDIATE
N		#define GWIN_REDRAW_IMMEDIATE	FALSE
N	#endif
N	/**
N	 * @brief	Redraw all windows in a single operation
N	 * @details	Defaults to FALSE
N	 * @note	Windows are normally redraw one per gtimer cycle.
N	 * 			Setting this option causes all windows to be redrawn in
N	 * 			a single gtimer cycle. Note that this can
N	 * 			cause extended blocking times on the timer thread but may
N	 * 			speed up redraw slightly.
N	 * @note	This is only relevant if GWIN_REDRAW_IMMEDIATE is FALSE.
N	 * 			Everything always gets redrawn in a single operation if
N	 * 			GWIN_REDRAW_IMMEDIATE is TRUE.
N	 */
N	#ifndef GWIN_REDRAW_SINGLEOP
N		#define GWIN_REDRAW_SINGLEOP	FALSE
N	#endif
N	/**
N	 * @brief   Buttons should not insist the mouse is over the button on mouse release
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_BUTTON_LAZY_RELEASE
N		#define GWIN_BUTTON_LAZY_RELEASE		FALSE
N	#endif
N	/**
N	 * @brief	Should the content of the console be saved for redrawing.
N	 * @details	Defaults to FALSE
N	 * @details	If this feature is enabled, the contents of the console will be saved
N	 * 			as it is written. If a redraw is required it will be redrawn from the
N	 * 			history. Scrolling will also use the history buffer if it is turned on.
N	 * @note	Using this option allocates the amount of memory to store the
N	 * 			history based on the minimum character width in the current font
N	 * 			at the time the history is turned on. Using a fixed width font is a good
N	 * 			idea to minimize memory usage.
N	 * @note	If you change the size of the window or you change the font being displayed
N	 * 			you should turn off the history and then turn it back on in order to get
N	 * 			a new buffer of the correct size for the window/font combination. Strange
N	 * 			redrawing and scrolling effects can occur if the buffer is too small to
N	 * 			save a complete screen of data. Note the system tries to optimize storage
N	 * 			so this may only be evident in very limited situations eg with a console
N	 * 			with many characters in it.
N	 * @note	@p gwinConsoleSetBuffer() can be used to turn the history buffer off and on.
N	 */
N	#ifndef GWIN_CONSOLE_USE_HISTORY
N		#define GWIN_CONSOLE_USE_HISTORY		FALSE
N	#endif
N	/**
N	 * @brief	Use font width averaging for the history buffer allocation.
N	 * @details	Defaults to FALSE
N	 * @details	If this feature is enabled, the width one third of the way between
N	 * 			the font's character width minimum and maximum will be used instead
N	 * 			of the font's minimum width.
N	 * @note	This option reduces the memory allocation for a variable width font's
N	 * 			history buffer. Note that strange
N	 * 			redrawing and scrolling effects can occur if the buffer is too small to
N	 * 			save a complete screen of data. The system tries to optimize storage
N	 * 			so this may only be evident in very limited situations eg with a console
N	 * 			with many characters in it.
N	 */
N	#ifndef GWIN_CONSOLE_HISTORY_AVERAGING
N		#define GWIN_CONSOLE_HISTORY_AVERAGING	FALSE
N	#endif
N	/**
N	 * @brief	Should the history be turned on for all console windows when they are first created.
N	 * @details	Defaults to FALSE
N	 * @note	@p gwinConsoleSetBuffer() can be used to turn the history buffer off and on at
N	 * 			any time.
N	 */
N	#ifndef GWIN_CONSOLE_HISTORY_ATCREATE
N		#define GWIN_CONSOLE_HISTORY_ATCREATE	FALSE
N	#endif
N	/**
N	 * @brief   Console Windows need floating point support in @p gwinPrintf
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_CONSOLE_USE_FLOAT
N		#define GWIN_CONSOLE_USE_FLOAT			FALSE
N	#endif
N	/**
N	 * @brief   Console windows support escape sequences to control display
N	 * @details	Defaults to FALSE
N	 *
N	 * @note
N	 * 		Currently supported:
N	 * 			ESC color		Change subsequent text color
N	 * 							color:	"0" = black, "1" = red, "2" = green, "3" = yellow, "4" = blue,
N	 * 									"5" = magenta, "6" = cyan, "7" = white
N	 * 			ESC C			Revert subsequent text color to the window default
N	 * 			ESC u			Turn on underline
N	 * 			ESC U			Turn off underline
N	 * 			ESC b			Turn on bold
N	 * 			ESC B			Turn off bold
N	 * 			ESC J			Clear the window
N	 */
N	#ifndef GWIN_CONSOLE_ESCSEQ
N		#define GWIN_CONSOLE_ESCSEQ				FALSE
N	#endif
N	/**
N	 * @brief   Console Windows need BaseStreamSequential support (ChibiOS only)
N	 * @details	Defaults to FALSE
N	 * @note	To use the ChibiOS basestream functions such as chprintf()
N	 * 			for printing in a console window you need to set this option to
N	 * 			TRUE in your gfxconf.h and include in your application source file...
N	 * 			\#include "chprintf.h"
N	 * 			In your makefile, as part of your list of C source files, include
N	 * 			${CHIBIOS}/os/various/chprintf.c
N	 */
N	#ifndef GWIN_CONSOLE_USE_BASESTREAM
N		#define GWIN_CONSOLE_USE_BASESTREAM		FALSE
N	#endif
N	/**
N	 * @brief   Image windows can optionally support animated images
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_IMAGE_ANIMATION
N		#define GWIN_NEED_IMAGE_ANIMATION		FALSE
N	#endif
N	/**
N	 * @brief	Enable the API to use attributes in the label widget
N	 * @details	Defaults to FALSE
N	 * @note	Using this feature is discouraged. The proper (and faster as well
N	 *			as more efficient) way is to use two separate labels.
N	 */
N	#ifndef GWIN_LABEL_ATTRIBUTE
N	 	#define GWIN_LABEL_ATTRIBUTE			FALSE
N	#endif
N	/**
N	 * @brief	Enable the API to use images in items in the list widget
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_NEED_LIST_IMAGES
N	 	#define GWIN_NEED_LIST_IMAGES			FALSE
N	#endif
N	/**
N	 * @brief	Enable the API to automatically increment the progressbar over time
N	 * @details	Defaults to FALSE
N	 */
N	#ifndef GWIN_PROGRESSBAR_AUTO
N	 	#define GWIN_PROGRESSBAR_AUTO			FALSE
N	#endif
N	/**
N	 * @brief	Should the slider avoid snapping to a fixed position when the mouse is released
N	 * @details	Defaults to FALSE
N	 * @note	If FALSE the slider will snap to the closest set-able position when the
N	 * 			mouse is released. If TRUE it will maintain the position the
N	 * 			mouse was released at, except when at the minimum and maximum slider values.
N	 */
N	#ifndef GWIN_SLIDER_NOSNAP
N	 	#define GWIN_SLIDER_NOSNAP				FALSE
N	#endif
N	/**
N	 * @brief	The number of pixels of dead-band at each end of the slider
N	 * @details	Defaults to 5
N	 * @note	A dead-band is required because fingers can often cannot
N	 * 			accurately control the slider peg at the edges of the slider
N	 */
N	#ifndef GWIN_SLIDER_DEAD_BAND
N		#define GWIN_SLIDER_DEAD_BAND			5
N	#endif
N	/**
N	 * @brief	How many toggles it takes to go from minimum to maximum value on a slider
N	 * @details	Defaults to 20
N	 * @note	When the slider is being operated by a toggle device this setting describes
N	 * 			how many toggles are required to go from end to end.
N	 */
N	#ifndef GWIN_SLIDER_TOGGLE_INC
N		#define GWIN_SLIDER_TOGGLE_INC			20
N	#endif
N	/**
N	 * @brief	The height in pixels of a row of tabs in a tabset
N	 * @details	Defaults to 18
N	 */
N	#ifndef GWIN_TABSET_TABHEIGHT
N		#define GWIN_TABSET_TABHEIGHT			18
N	#endif
N	/**
N	 * @brief	Should flashing of widgets be supported
N	 * @details	Defaults to FALSE
N	 * @pre		Requires GWIN_NEED_WINDOWMANAGER to be TRUE
N	 */
N	#ifndef GWIN_NEED_FLASHING
N		#define GWIN_NEED_FLASHING				FALSE
N	#endif
N	/**
N	 * @brief	What is the period for the flashing timer
N	 * @details	Defaults to 250 milliseconds
N	 */
N	#ifndef GWIN_FLASHING_PERIOD
N		#define GWIN_FLASHING_PERIOD			250
N	#endif
N	/**
N	 * @brief	The default keyboard layout for the virtual gwin keyboard
N	 * @details	Defaults to VirtualKeyboardLayout_English1
N	 */
N	#ifndef GWIN_KEYBOARD_DEFAULT_LAYOUT
N		#define GWIN_KEYBOARD_DEFAULT_LAYOUT	VirtualKeyboard_English1
N	#endif
N/**
N * @}
N *
N * @name    GWIN Virtual Keyboard Layouts
N * @brief	One or more of these may be defined. They will only be created if GWIN_NEED_KEYBOARD is TRUE.
N * @{
N */
N	/**
N	 * @brief	The default keyboard layout for the virtual gwin keyboard
N	 * @details	Defaults to VirtualKeyboardLayout_English1
N	 */
N	#ifndef GWIN_NEED_KEYBOARD_ENGLISH1
N		#define GWIN_NEED_KEYBOARD_ENGLISH1		TRUE
N	#endif
N/** @} */
N
N#endif /* _GWIN_OPTIONS_H */
N/** @} */
L 171 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/ginput/ginput_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/ginput/ginput_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/ginput/ginput_options.h
N * @brief   GINPUT sub-system options header file.
N *
N * @addtogroup GINPUT
N * @{
N */
N
N#ifndef _GINPUT_OPTIONS_H
N#define _GINPUT_OPTIONS_H
N
N/**
N * @name    GINPUT Functionality to be included
N * @{
N */
N	/**
N	 * @brief   Should mouse/touch functions be included.
N	 * @details	Defaults to FALSE
N	 * @note	Also add a mouse/touch hardware driver to your makefile.
N	 * 			Eg.
N	 * 				include $(GFXLIB)/drivers/ginput/touch/MCU/driver.mk
N	 */
N	#ifndef GINPUT_NEED_MOUSE
N		#define GINPUT_NEED_MOUSE		FALSE
N	#endif
N	/**
N	 * @brief   Should keyboard functions be included.
N	 * @details	Defaults to FALSE
N	 * @note	Also add a keyboard hardware driver to your makefile.
N	 * 			Eg.
N	 * 				include $(GFXLIB)/drivers/ginput/keyboard/XXXX/driver.mk
N	 */
N	#ifndef GINPUT_NEED_KEYBOARD
N		#define GINPUT_NEED_KEYBOARD	FALSE
N	#endif
N	/**
N	 * @brief   Should hardware toggle/switch/button functions be included.
N	 * @details	Defaults to FALSE
N	 * @note	Also add a toggle hardware driver to your makefile.
N	 * 			Eg.
N	 * 				include $(GFXLIB)/drivers/ginput/toggle/Pal/driver.mk
N	 */
N	#ifndef GINPUT_NEED_TOGGLE
N		#define GINPUT_NEED_TOGGLE		FALSE
N	#endif
N	/**
N	 * @brief   Should analog dial functions be included.
N	 * @details	Defaults to FALSE
N	 * @note	Also add a dial hardware driver to your makefile.
N	 * 			Eg.
N	 * 				include $(GFXLIB)/drivers/ginput/dial/analog/driver.mk
N	 */
N	#ifndef GINPUT_NEED_DIAL
N		#define GINPUT_NEED_DIAL		FALSE
N	#endif
N/**
N * @}
N *
N * @name    GINPUT Optional Sizing Parameters
N * @{
N */
N/**
N * @}
N *
N * @name    GINPUT Optional Low Level Driver Defines
N * @{
N */
N	/**
N	 * @brief   Start touch devices without loading or running calibration.
N	 * @details	Defaults to FALSE
N	 * @note	This is used if you want to manually control the initial calibration
N	 * 			process. In practice this is only useful for a touch driver test program.
N	 */
N	#ifndef GINPUT_TOUCH_STARTRAW
N		#define GINPUT_TOUCH_STARTRAW					FALSE
N	#endif
N 	/**
N	 * @brief   Turn off the touch calibration GUI.
N	 * @details	Defaults to FALSE
N	 * @note	Turning off the calibration GUI just turns off the manual calibration
N	 * 			process. Readings may still be calibrated if calibration data
N	 * 			can be loaded.
N	 * @note	Calibration requires a lot of code. If your device doesn't require it
N	 * 			using this option can save a lot of space.
N	 */
N	#ifndef GINPUT_TOUCH_NOCALIBRATE_GUI
N		#define GINPUT_TOUCH_NOCALIBRATE_GUI			FALSE
N	#endif
N	/**
N	 * @brief   Turn off all touch calibration support.
N	 * @details	Defaults to FALSE
N	 * @note	With this set to TRUE touch readings will not be calibrated.
N	 * @note	This automatically turns off the calibration GUI too!
N	 * @note	Calibration requires a lot of code. If your device doesn't require it
N	 * 			using this option can save a lot of space.
N	 */
N	#ifndef GINPUT_TOUCH_NOCALIBRATE
N		#define GINPUT_TOUCH_NOCALIBRATE				FALSE
N	#endif
N	/**
N	 * @brief   Turn off all touch support.
N	 * @details	Defaults to FALSE
N	 * @note	This automatically turns off all calibration and the calibration GUI too!
N	 * @note	Touch device handling requires a lot of code. If your device doesn't require it
N	 * 			using this option can save a lot of space.
N	 */
N	#ifndef GINPUT_TOUCH_NOTOUCH
N		#define GINPUT_TOUCH_NOTOUCH					FALSE
N	#endif
N	/**
N	 * @brief   Milliseconds between mouse polls.
N	 * @details	Defaults to 25 milliseconds
N	 * @note	How often mice should be polled. More often leads to smoother mouse movement
N	 * 			but increases CPU usage.
N	 */
N	#ifndef GINPUT_MOUSE_POLL_PERIOD
N		#define GINPUT_MOUSE_POLL_PERIOD				25
N	#endif
N
N	/**
N	 * @brief   Maximum length of CLICK in milliseconds
N	 * @details	Defaults to 300 milliseconds
N	 * @note	Mouse down to Mouse up times greater than this are not clicks.
N	 */
N	#ifndef GINPUT_MOUSE_CLICK_TIME
N		#define GINPUT_MOUSE_CLICK_TIME					300
N	#endif
N	/**
N	 * @brief   Milliseconds to generate a CXTCLICK on a touch device.
N	 * @details	Defaults to 500 milliseconds
N	 * @note	If you hold the touch down for longer than this a CXTCLICK is generated
N	 * 			but only on a touch device.
N	 */
N	#ifndef GINPUT_TOUCH_CXTCLICK_TIME
N		#define GINPUT_TOUCH_CXTCLICK_TIME				500
N	#endif
N   /**
N     * @brief   There is a user supplied routine to load mouse calibration data
N	 * @details	Defaults to FALSE
N     * @note    If TRUE the user must supply the @p LoadMouseCalibration() routine.
N     */
N	#ifndef GINPUT_TOUCH_USER_CALIBRATION_LOAD
N		#define GINPUT_TOUCH_USER_CALIBRATION_LOAD		FALSE
N	#endif
N   /**
N     * @brief   There is a user supplied routine to save mouse calibration data
N	 * @details	Defaults to FALSE
N     * @note    If TRUE the user must supply the @p SaveMouseCalibration() routine.
N     */
N	#ifndef GINPUT_TOUCH_USER_CALIBRATION_SAVE
N		#define GINPUT_TOUCH_USER_CALIBRATION_SAVE		FALSE
N	#endif
N	#if defined(__DOXYGEN__)
X	#if 0L
S	   /**
S		 * @brief   Define multiple static mice
S		 * @details	When not defined the system automatically detects a single linked mouse driver
S		 * @note	The references to GMOUSEVMT_Win32 in the definition would be replaced
S		 * 			by the names of the VMT for each of the static mice you want to
S		 * 			include.
S		 * @note	Dynamic mice associated automatically with a display eg Win32, X or GFXnet
S		 * 			do not need to be specified in this list as the associated display driver will register
S		 * 			them automatically as the display is created.
S		 */
S		#define GMOUSE_DRIVER_LIST						GMOUSEVMT_Win32, GMOUSEVMT_Win32
N	#endif
N	/**
N	 * @brief   Milliseconds between keyboard polls.
N	 * @details	Defaults to 200 milliseconds
N	 * @note	How often keyboards should be polled.
N	 */
N	#ifndef GINPUT_KEYBOARD_POLL_PERIOD
N		#define GINPUT_KEYBOARD_POLL_PERIOD				200
N	#endif
N	#if defined(__DOXYGEN__)
X	#if 0L
S	   /**
S		 * @brief   Define multiple static keyboards
S		 * @details	When not defined the system automatically detects a single linked keyboard driver
S		 * @note	The references to GKEYBOARDVMT_Win32 in the definition would be replaced
S		 * 			by the names of the VMT for each of the static keyboards you want to
S		 * 			include.
S		 * @note	Dynamic keyboards associated automatically with a display eg Win32, X or GFXnet
S		 * 			do not need to be specified in this list as the display driver will register
S		 * 			them automatically as the display is created.
S		 */
S		#define GKEYBOARD_DRIVER_LIST					GMOUSEVMT_Win32, GMOUSEVMT_Win32
N	#endif
N   /**
N     * @brief   Turn off the layout engine.
N	 * @details	When defined the layout engine is removed from the code and characters
N	 * 			are passed directly from the keyboard driver to the application.
N	 * @note	Turning off the layout engine just saves code if it is not needed.
N     */
N	#ifndef GKEYBOARD_LAYOUT_OFF
N		#define GKEYBOARD_LAYOUT_OFF					FALSE
N	#endif
N	/**
N	 * @brief   Various Keyboard Layouts that can be included.
N	 * @details	A keyboard layout controls conversion of scancodes to characters
N	 * 			and enables one keyboard to have multiple language mappings.
N	 * @note	Defining a layout does not make it active. The keyboard driver
N	 * 			must have it active as the default or the application must
N	 * 			use @p ginputSetKeyboardLayout() to set the active layout.
N	 * @note	Multiple layouts can be included but only one will be active
N	 * 			at a time (per keyboard).
N	 * @{
N	 */
N	#ifndef GKEYBOARD_LAYOUT_SCANCODE2_US
N		#define GKEYBOARD_LAYOUT_SCANCODE2_US			FALSE				// US Keyboard using the ScanCode 2 set.
N	#endif
N	/** @} */
N/** @} */
N
N#endif /* _GINPUT_OPTIONS_H */
N/** @} */
L 172 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gadc/gadc_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gadc/gadc_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gadc/gadc_options.h
N * @brief   GADC - Periodic ADC subsystem options header file.
N *
N * @addtogroup GADC
N * @{
N */
N
N#ifndef _GADC_OPTIONS_H
N#define _GADC_OPTIONS_H
N
N/**
N * @name    GADC Functionality to be included
N * @{
N */
N/**
N * @}
N *
N * @name    GADC Optional Sizing Parameters
N * @{
N */
N	/**
N	 * @brief   The maximum GADC sample rate
N	 * @details	Defaults to 44000
N	 * @note	This value must be less than half the maximum sample rate allowed by the CPU.
N	 * 			This is to ensure there is time between high speed samples to perform low
N	 * 			speed device sampling.
N	 */
N	#ifndef GADC_MAX_HIGH_SPEED_SAMPLERATE
N		#define GADC_MAX_HIGH_SPEED_SAMPLERATE	44000
N	#endif
N/** @} */
N
N#endif /* _GADC_OPTIONS_H */
N/** @} */
L 173 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gaudio/gaudio_options.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gaudio/gaudio_options.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gaudio/gaudio_options.h
N * @brief   GAUDIO - Audio subsystem options header file.
N *
N * @addtogroup GAUDIO
N * @{
N */
N
N#ifndef _GAUDIO_OPTIONS_H
N#define _GAUDIO_OPTIONS_H
N
N/**
N * @name    GAUDIO Functionality to be included
N * @{
N */
N	/**
N	 * @brief	Audio Play capability is needed
N	 */
N	#ifndef GAUDIO_NEED_PLAY
N		#define GAUDIO_NEED_PLAY			FALSE
N	#endif
N	/**
N	 * @brief	Audio Recording capability is needed
N	 */
N	#ifndef GAUDIO_NEED_RECORD
N		#define GAUDIO_NEED_RECORD			FALSE
N	#endif
N/**
N * @}
N *
N * @name    GAUDIO Optional Sizing Parameters
N * @{
N */
N/** @} */
N
N#endif /* _GAUDIO_OPTIONS_H */
N/** @} */
L 174 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N
N/**
N * Interdependency safety checks on the sub-systems.
N * These must be in dependency order.
N *
N */
N#ifndef GFX_DISPLAY_RULE_WARNINGS
N	#define GFX_DISPLAY_RULE_WARNINGS	FALSE
N#endif
N#include "src/gwin/gwin_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gwin/gwin_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gwin/gwin_rules.h
N * @brief   GWIN safety rules header file.
N *
N * @addtogroup GWIN
N * @{
N */
N
N#ifndef _GWIN_RULES_H
N#define _GWIN_RULES_H
N
N#if GFX_USE_GWIN
X#if 0
S	// Sub-system rules
S	#if !GFX_USE_GDISP
S		#error "GWIN: GFX_USE_GDISP must be TRUE when using GWIN"
S	#endif
S	#if !GDISP_NEED_CLIP
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GWIN: Drawing can occur outside the defined windows as GDISP_NEED_CLIP is FALSE"
S		#endif
S	#endif
S
S	// Objects require their super-class
S	#if GWIN_NEED_TABSET || GWIN_NEED_FRAME || GWIN_NEED_CONTAINER
S		#if !GWIN_NEED_CONTAINERS
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GWIN: GWIN_NEED_CONTAINERS is required when a container is enabled. It has been turned on for you."
S			#endif
S			#undef GWIN_NEED_CONTAINERS
S			#define GWIN_NEED_CONTAINERS	TRUE
S		#endif
S	#endif
S	#if GWIN_NEED_BUTTON || GWIN_NEED_SLIDER || GWIN_NEED_CHECKBOX || GWIN_NEED_LABEL || GWIN_NEED_RADIO || GWIN_NEED_LIST || \
S		GWIN_NEED_IMAGE || GWIN_NEED_CHECKBOX || GWIN_NEED_PROGRESSBAR || GWIN_NEED_KEYBOARD || GWIN_NEED_TEXTEDIT
X	#if GWIN_NEED_BUTTON || GWIN_NEED_SLIDER || GWIN_NEED_CHECKBOX || GWIN_NEED_LABEL || GWIN_NEED_RADIO || GWIN_NEED_LIST || 		GWIN_NEED_IMAGE || GWIN_NEED_CHECKBOX || GWIN_NEED_PROGRESSBAR || GWIN_NEED_KEYBOARD || GWIN_NEED_TEXTEDIT
S		#if !GWIN_NEED_WIDGET
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GWIN: GWIN_NEED_WIDGET is required when a widget is used. It has been turned on for you."
S			#endif
S			#undef GWIN_NEED_WIDGET
S			#define GWIN_NEED_WIDGET	TRUE
S		#endif
S	#endif
S
S	// Rules for the super-classes
S	#if GWIN_NEED_CONTAINERS
S		#if !GWIN_NEED_WIDGET
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GWIN: GWIN_NEED_WIDGET is required when GWIN_NEED_CONTAINERS is enabled. It has been turned on for you."
S			#endif
S			#undef GWIN_NEED_WIDGET
S			#define GWIN_NEED_WIDGET	TRUE
S		#endif
S	#endif
S	#if GWIN_NEED_WIDGET
S		#if !GDISP_NEED_TEXT
S			#error "GWIN: GDISP_NEED_TEXT is required if GWIN_NEED_WIDGET is TRUE."
S		#endif
S		#if !GFX_USE_GINPUT
S			// This test also ensures that GFX_USE_GEVENT is set
S			#error "GWIN: GFX_USE_GINPUT (and one or more input sources) is required if GWIN_NEED_WIDGET is TRUE"
S		#endif
S		#if !GWIN_NEED_WINDOWMANAGER
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GWIN: GWIN_NEED_WINDOWMANAGER is required if GWIN_NEED_WIDGET is TRUE. It has been turned on for you."
S			#endif
S			#undef GWIN_NEED_WINDOWMANAGER
S			#define GWIN_NEED_WINDOWMANAGER	TRUE
S		#endif
S		#if !GDISP_NEED_MULTITHREAD
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GWIN: GDISP_NEED_MULTITHREAD is required if GWIN_NEED_WIDGET is TRUE. It has been turned on for you"
S			#endif
S			#undef GDISP_NEED_MULTITHREAD
S			#define GDISP_NEED_MULTITHREAD	TRUE
S		#endif
S	#endif
S	#if GWIN_NEED_WINDOWMANAGER
S		#if !GFX_USE_GQUEUE || !GQUEUE_NEED_ASYNC
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GWIN: GFX_USE_GQUEUE and GQUEUE_NEED_ASYNC is required if GWIN_NEED_WINDOWMANAGER is TRUE. It has been turned on for you."
S			#endif
S			#undef GFX_USE_GQUEUE
S			#undef GQUEUE_NEED_ASYNC
S			#define GFX_USE_GQUEUE		TRUE
S			#define GQUEUE_NEED_ASYNC	TRUE
S		#endif
S		#if !GFX_USE_GTIMER
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GWIN: GFX_USE_GTIMER is required if GWIN_NEED_WINDOWMANAGER is TRUE. It has been turned on for you."
S			#endif
S			#undef GFX_USE_GTIMER
S			#define GFX_USE_GTIMER		TRUE
S		#endif
S	#endif
S
S	// Rules for individual objects
S	#if GWIN_NEED_LIST
S		#if !GDISP_NEED_TEXT
S			#error "GWIN: GDISP_NEED_TEXT is required when GWIN_NEED_LIST is TRUE."
S		#endif
S	#endif
S	#if GWIN_NEED_RADIO
S		#if !GDISP_NEED_CIRCLE
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GWIN: GDISP_NEED_CIRCLE should be set to TRUE for much nicer radio button widgets."
S			#endif
S		#endif
S	#endif
S	#if GWIN_NEED_IMAGE
S		#if !GDISP_NEED_IMAGE
S			#error "GWIN: GDISP_NEED_IMAGE is required when GWIN_NEED_IMAGE is TRUE."
S		#endif
S	#endif
S	#if GWIN_NEED_CONSOLE
S		#if !GDISP_NEED_TEXT
S			#error "GWIN: GDISP_NEED_TEXT is required if GWIN_NEED_CONSOLE is TRUE."
S		#endif
S	#endif
S	#if GWIN_NEED_TEXTEDIT
S		#if !GDISP_NEED_TEXT
S			#error "GWIN: GDISP_NEED_TEXT is required if GWIN_NEED_TEXTEDIT is TRUE."
S		#endif
S		#if !(GINPUT_NEED_KEYBOARD || GWIN_NEED_KEYBOARD)
S			#error "GWIN: GINPUT_NEED_KEYBOARD or GWIN_NEED_KEYBOARD is required if GWIN_NEED_TEXTEDIT is TRUE."
S		#endif
S	#endif
N#endif
N
N#endif /* _GWIN_RULES_H */
N/** @} */
L 184 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/ginput/ginput_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/ginput/ginput_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/ginput/ginput_rules.h
N * @brief   GINPUT safety rules header file.
N *
N * @addtogroup GINPUT
N * @{
N */
N
N#ifndef _GINPUT_RULES_H
N#define _GINPUT_RULES_H
N
N#if GFX_USE_GINPUT
X#if 0
S	#if !GFX_USE_GEVENT
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GINPUT: GFX_USE_GEVENT is required if GFX_USE_GINPUT is TRUE. It has been turned on for you."
S		#endif
S		#undef GFX_USE_GEVENT
S		#define	GFX_USE_GEVENT		TRUE
S	#endif
S	#if !GFX_USE_GTIMER
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GINPUT: GFX_USE_GTIMER is required if GFX_USE_GINPUT is TRUE. It has been turned on for you."
S		#endif
S		#undef GFX_USE_GTIMER
S		#define	GFX_USE_GTIMER		TRUE
S	#endif
S	#if GINPUT_NEED_MOUSE
S		#if GINPUT_TOUCH_NOTOUCH
S			// No warning needed for this
S			#undef GINPUT_TOUCH_NOCALIBRATE
S			#define GINPUT_TOUCH_NOCALIBRATE	TRUE
S		#endif
S		#if GINPUT_TOUCH_NOCALIBRATE
S			// No warning needed for this
S			#undef GINPUT_TOUCH_NOCALIBRATE_GUI
S			#define GINPUT_TOUCH_NOCALIBRATE_GUI	TRUE
S		#endif
S		#if !GINPUT_TOUCH_NOTOUCH && GINPUT_MOUSE_CLICK_TIME > GINPUT_TOUCH_CXTCLICK_TIME
S			#error "GINPUT MOUSE: The GINPUT_MOUSE_CLICK_TIME must be <= GINPUT_TOUCH_CXTCLICK_TIME"
S		#endif
S	#endif
N#endif
N
N#endif /* _GINPUT_RULES_H */
N/** @} */
L 185 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gdisp/gdisp_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gdisp/gdisp_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gdisp/gdisp_rules.h
N * @brief   GDISP safety rules header file.
N *
N * @addtogroup GDISP
N * @{
N */
N
N#ifndef _GDISP_RULES_H
N#define _GDISP_RULES_H
N
N#if GFX_USE_GDISP
X#if -1
N	#if !GFX_USE_GDRIVER
X	#if ! -1
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GDISP: GFX_USE_GDRIVER is required. GFX_USE_GDRIVER has turned on for you."
S		#endif
S		#undef GFX_USE_GDRIVER
S		#define GFX_USE_GDRIVER				TRUE
N	#endif
N	#if defined(GDISP_DRIVER_LIST)
X	#if 0L
S        #if GDISP_TOTAL_DISPLAYS != 1
S            #error "GDISP Multiple Drivers: You can't specify both GDISP_TOTAL_DISPLAYS and GDISP_DRIVER_LIST"
S        #endif
S		#ifndef GDISP_PIXELFORMAT
S			#error "GDISP Multiple Drivers: You must specify a value for GDISP_PIXELFORMAT when using GDISP_DRIVER_LIST"
S		#endif
N	#endif
N	#if GDISP_NEED_AUTOFLUSH && GDISP_NEED_TIMERFLUSH
X	#if 0 && 0
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GDISP: Both GDISP_NEED_AUTOFLUSH and GDISP_NEED_TIMERFLUSH has been set. GDISP_NEED_TIMERFLUSH has been disabled for you."
S		#endif
S		#undef GDISP_NEED_TIMERFLUSH
S		#define GDISP_NEED_TIMERFLUSH		FALSE
N	#endif
N	#if GDISP_NEED_TIMERFLUSH
X	#if 0
S		#if GDISP_NEED_TIMERFLUSH < 50 || GDISP_NEED_TIMERFLUSH > 1200
S			#error "GDISP: GDISP_NEED_TIMERFLUSH has been set to an invalid value (FALSE, 50-1200)."
S		#endif
S		#if !GFX_USE_GTIMER
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GDISP: GDISP_NEED_TIMERFLUSH has been set but GFX_USE_GTIMER has not been set. It has been turned on for you."
S			#endif
S			#undef GFX_USE_GTIMER
S			#define GFX_USE_GTIMER				TRUE
S			#undef GDISP_NEED_MULTITHREAD
S			#define GDISP_NEED_MULTITHREAD		TRUE
S		#endif
N	#endif
N	#if GDISP_NEED_ANTIALIAS && !GDISP_NEED_PIXELREAD
X	#if 0 && !0
S		#if GDISP_HARDWARE_PIXELREAD
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GDISP: GDISP_NEED_ANTIALIAS has been set but GDISP_NEED_PIXELREAD has not. It has been turned on for you."
S			#endif
S			#undef GDISP_NEED_PIXELREAD
S			#define GDISP_NEED_PIXELREAD	TRUE
S		#else
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GDISP: GDISP_NEED_ANTIALIAS has been set but your hardware does not support reading back pixels. Anti-aliasing will only occur for filled characters."
S			#endif
S		#endif
N	#endif
N	#if (defined(GDISP_INCLUDE_FONT_SMALL) && GDISP_INCLUDE_FONT_SMALL) || (defined(GDISP_INCLUDE_FONT_LARGER) && GDISP_INCLUDE_FONT_LARGER)
X	#if (0L && GDISP_INCLUDE_FONT_SMALL) || (0L && GDISP_INCLUDE_FONT_LARGER)
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GDISP: An old font (Small or Larger) has been defined. A single default font of UI2 has been added instead."
S			#warning "GDISP: Please see <$(GFXLIB)/include/gdisp/fonts/fonts.h> for a list of available font names."
S		#endif
S		#undef GDISP_INCLUDE_FONT_UI2
S		#define GDISP_INCLUDE_FONT_UI2		TRUE
N	#endif
N	#if GDISP_NEED_IMAGE
X	#if 0
S		#if !GFX_USE_GFILE
S			#if GFX_DISPLAY_RULE_WARNINGS
S				#warning "GDISP: GFX_USE_GFILE is required when GDISP_NEED_IMAGE is TRUE. It has been turned on for you."
S			#endif
S			#undef GFX_USE_GFILE
S			#define GFX_USE_GFILE	TRUE
S		#endif
N	#endif
N#endif
N
N#endif /* _GDISP_RULES_H */
N/** @} */
L 186 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gaudio/gaudio_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gaudio/gaudio_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gaudio/gaudio_rules.h
N * @brief   GAUDIO safety rules header file.
N *
N * @addtogroup GAUDIO
N * @{
N */
N
N#ifndef _GAUDIO_RULES_H
N#define _GAUDIO_RULES_H
N
N#if GFX_USE_GAUDIO
X#if 0
S	#if !GAUDIO_NEED_PLAY && !GAUDIO_NEED_RECORD
S		#error "GAUDIO: GAUDIO_NEED_PLAY and/or GAUDIO_NEED_RECORD is required if GFX_USE_GAUDIO is TRUE"
S	#endif
S	#if !GFX_USE_GQUEUE
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GAUDIO: GFX_USE_GQUEUE is required if GFX_USE_GAUDIO is TRUE. It has been turned on for you."
S		#endif
S		#undef GFX_USE_GQUEUE
S		#define	GFX_USE_GQUEUE		TRUE
S	#endif
S	#if GAUDIO_NEED_PLAY && !GQUEUE_NEED_ASYNC
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GAUDIO: GQUEUE_NEED_ASYNC is required if GAUDIO_NEED_PLAY is TRUE. It has been turned on for you."
S		#endif
S		#undef GQUEUE_NEED_ASYNC
S		#define	GQUEUE_NEED_ASYNC		TRUE
S	#endif
S	#if !GQUEUE_NEED_GSYNC || !GQUEUE_NEED_BUFFERS
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GAUDIO: GQUEUE_NEED_BUFFERS and GQUEUE_NEED_GSYNC are required if GFX_USE_GAUDIO is TRUE. They have been turned on for you."
S		#endif
S		#undef GQUEUE_NEED_BUFFERS
S		#define	GQUEUE_NEED_BUFFERS		TRUE
S		#undef GQUEUE_NEED_GSYNC
S		#define	GQUEUE_NEED_GSYNC		TRUE
S	#endif
S	#if GFX_USE_GEVENT && !GFX_USE_GTIMER
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GAUDIO: GFX_USE_GTIMER is required if GFX_USE_GAUDIO and GFX_USE_GEVENT are TRUE. It has been turned on for you."
S		#endif
S		#undef GFX_USE_GTIMER
S		#define	GFX_USE_GTIMER		TRUE
S	#endif
N#endif
N
N#endif /* _GAUDIO_RULES_H */
N/** @} */
L 187 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gadc/gadc_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gadc/gadc_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gadc/gadc_rules.h
N * @brief   GADC safety rules header file.
N *
N * @addtogroup GADC
N * @{
N */
N
N#ifndef _GADC_RULES_H
N#define _GADC_RULES_H
N
N#if GFX_USE_GADC
X#if 0
S	#if !GFX_USE_GTIMER
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GADC: GFX_USE_GTIMER is required if GFX_USE_GADC is TRUE. It has been turned on for you."
S		#endif
S		#undef GFX_USE_GTIMER
S		#define	GFX_USE_GTIMER		TRUE
S	#endif
S	#if !GFX_USE_GQUEUE || !GQUEUE_NEED_GSYNC || !GQUEUE_NEED_BUFFERS
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GADC: GFX_USE_GQUEUE, GQUEUE_NEED_BUFFERS and GQUEUE_NEED_GSYNC are required if GFX_USE_GADC is TRUE. They have been turned on for you."
S		#endif
S		#undef GFX_USE_GQUEUE
S		#define	GFX_USE_GQUEUE		TRUE
S		#undef GQUEUE_NEED_BUFFERS
S		#define	GQUEUE_NEED_BUFFERS		TRUE
S		#undef GQUEUE_NEED_GSYNC
S		#define	GQUEUE_NEED_GSYNC		TRUE
S	#endif
N#endif
N
N#endif /* _GADC_RULES_H */
N/** @} */
L 188 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gevent/gevent_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gevent/gevent_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gevent/gevent_rules.h
N * @brief   GEVENT safety rules header file.
N *
N * @addtogroup GEVENT
N * @{
N */
N
N#ifndef _GEVENT_RULES_H
N#define _GEVENT_RULES_H
N
N#if GFX_USE_GEVENT
X#if 0
N#endif
N
N#endif /* _GEVENT_RULES_H */
N/** @} */
L 189 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gtimer/gtimer_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gtimer/gtimer_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gtimer/gtimer_rules.h
N * @brief   GTIMER safety rules header file.
N *
N * @addtogroup GTIMER
N * @{
N */
N
N#ifndef _GTIMER_RULES_H
N#define _GTIMER_RULES_H
N
N#if GFX_USE_GTIMER
X#if 0
S	#if GFX_USE_GDISP && !GDISP_NEED_MULTITHREAD
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GTIMER: GDISP_NEED_MULTITHREAD has not been specified."
S			#warning "GTIMER: Make sure you are not performing any GDISP/GWIN drawing operations in the timer callback!"
S		#endif
S	#endif
N#endif
N
N#endif /* _GTIMER_RULES_H */
N/** @} */
L 190 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gqueue/gqueue_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gqueue/gqueue_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gqueue/gqueue_rules.h
N * @brief   GQUEUE safety rules header file.
N *
N * @addtogroup GQUEUE
N * @{
N */
N
N#ifndef _GQUEUE_RULES_H
N#define _GQUEUE_RULES_H
N
N#if GFX_USE_GQUEUE
X#if 0
S	#if GQUEUE_NEED_BUFFERS && !GQUEUE_NEED_GSYNC
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GQUEUE: GQUEUE_NEED_GSYNC is required if GQUEUE_NEED_BUFFERS is TRUE. It has been turned on for you."
S		#endif
S		#undef GQUEUE_NEED_GSYNC
S		#define	GQUEUE_NEED_GSYNC		TRUE
S	#endif
N#endif
N
N#endif /* _GQUEUE_RULES_H */
N/** @} */
L 191 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gmisc/gmisc_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gmisc/gmisc_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gmisc/gmisc_rules.h
N * @brief   GMISC safety rules header file.
N *
N * @addtogroup GMISC
N * @{
N */
N
N#ifndef _GMISC_RULES_H
N#define _GMISC_RULES_H
N
N#if GFX_USE_GMISC
X#if 0
N#endif
N
N#endif /* _GMISC_RULES_H */
N/** @} */
L 192 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gtrans/gtrans_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gtrans/gtrans_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gtrans/gtrans_rules.h
N *
N * @addtogroup GTRANS
N * @{
N */
N
N#ifndef _GTRANS_RULES_H
N#define _GTRANS_RULES_H
N
N#if GFX_USE_GTRANS
X#if 0
N#endif
N
N#endif /* _GTRANS_RULES_H */
N/** @} */
L 193 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gfile/gfile_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gfile/gfile_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gfile/gfile_rules.h
N * @brief   GFILE safety rules header file.
N *
N * @addtogroup GFILE
N * @{
N */
N
N#ifndef _GFILE_RULES_H
N#define _GFILE_RULES_H
N
N#if GFX_USE_GFILE
X#if 0
S	#if GFILE_NEED_PETITFS && GFILE_NEED_FATFS
S		#error "GFILE: Both GFILE_NEED_PETITFS and GFILE_NEED_FATFS cannot both be turned on at the same time."
S	#endif
N#endif
N
N#endif /* _GFILE_RULES_H */
N/** @} */
L 194 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gdriver/gdriver_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gdriver/gdriver_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gdriver/gdriver_rules.h
N * @brief   GDRIVER safety rules header file.
N *
N * @addtogroup GFILE
N * @{
N */
N
N#ifndef _GDRIVER_RULES_H
N#define _GDRIVER_RULES_H
N
N#if GFX_USE_GDRIVER
X#if -1
N#endif
N
N#endif /* _GDRIVER_RULES_H */
N/** @} */
L 195 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gos/gos_rules.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gos/gos_rules.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gos/gos_rules.h
N * @brief   GOS safety rules header file.
N *
N * @addtogroup GOS
N * @{
N */
N
N#ifndef _GOS_RULES_H
N#define _GOS_RULES_H
N
N#if !GFX_USE_OS_CHIBIOS && !GFX_USE_OS_WIN32 && !GFX_USE_OS_LINUX && !GFX_USE_OS_OSX && !GFX_USE_OS_RAW32 && !GFX_USE_OS_FREERTOS && !GFX_USE_OS_ECOS && !GFX_USE_OS_RAWRTOS && !GFX_USE_OS_ARDUINO && !GFX_USE_OS_CMSIS && !GFX_USE_OS_KEIL && !GFX_USE_OS_NIOS && !GFX_USE_OS_QT
X#if !0 && !0 && !0 && !0 && ! -1 && !0 && !0 && !0 && !0 && !0 && !0 && !0 && !0
S	#error "GOS: No operating system has been defined."
N#endif
N
N#if GFX_USE_OS_CHIBIOS + GFX_USE_OS_WIN32 + GFX_USE_OS_LINUX + GFX_USE_OS_OSX + GFX_USE_OS_RAW32 + GFX_USE_OS_FREERTOS + GFX_USE_OS_ECOS + GFX_USE_OS_RAWRTOS + GFX_USE_OS_ARDUINO + GFX_USE_OS_CMSIS + GFX_USE_OS_KEIL + GFX_USE_OS_NIOS + GFX_USE_OS_QT != 1 * TRUE
X#if 0 + 0 + 0 + 0 + -1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 != 1 * -1
S	#error "GOS: More than one operation system has been defined as TRUE."
N#endif
N
N#if GFX_FREERTOS_USE_TRACE && !GFX_USE_OS_FREERTOS
X#if 0 && !0
S 	#error "GOS: GFX_FREERTOS_USE_TRACE is only available for the FreeRTOS port."
N#endif
N
N#if GFX_EMULATE_MALLOC
X#if 0
S	#if GFX_USE_OS_WIN32 || GFX_USE_OS_LINUX || GFX_USE_OS_OSX || GFX_USE_OS_ECOS || \
S			(GFX_OS_HEAP_SIZE == 0 && (GFX_USE_OS_RAW32 || GFX_USE_OS_ARDUINO || GFX_USE_OS_CMSIS || GFX_USE_OS_KEIL))
X	#if GFX_USE_OS_WIN32 || GFX_USE_OS_LINUX || GFX_USE_OS_OSX || GFX_USE_OS_ECOS || 			(GFX_OS_HEAP_SIZE == 0 && (GFX_USE_OS_RAW32 || GFX_USE_OS_ARDUINO || GFX_USE_OS_CMSIS || GFX_USE_OS_KEIL))
S		#if GFX_DISPLAY_RULE_WARNINGS
S			#warning "GOS: Cannot emulate malloc as gfxAlloc() internally uses malloc on this platform"
S		#endif
S		#undef GFX_EMULATE_MALLOC
S		#define GFX_EMULATE_MALLOC	FALSE
S	#endif
N#endif
N
N#endif /* _GOS_RULES_H */
N/** @} */
L 196 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N
N/**
N *  Include the sub-system header files
N */
N#include "src/gos/gos.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gos/gos.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gos/gos.h
N * @brief   GOS - Operating System Support header file
N *
N * @addtogroup GOS
N *
N * @brief	Module to build a uniform abstraction layer between uGFX and the underlying system
N *
N * @note	Some of the routines specified below may be implemented simply as
N * 			a macro to the real operating system call.
N * @{
N */
N
N#ifndef _GOS_H
N#define _GOS_H
N
N#if defined(__DOXYGEN__)
X#if 0L
S	/*===========================================================================*/
S	/* Type definitions                                                          */
S	/*===========================================================================*/
S
S	/**
S	 * @name	Various integer sizes
S	 * @note	Your platform may use slightly different definitions to these
S	 * @{
S	 */
S	typedef unsigned char	bool_t;
S	typedef char			int8_t;
S	typedef unsigned char	uint8_t;
S	typedef short			int16_t;
S	typedef unsigned short	uint16_t;
S	typedef long			int32_t;
S	typedef unsigned long	uint32_t;
S	/** @} */
S
S	/**
S	 * @name	Various platform (and operating system) dependent types
S	 * @note	Your platform may use slightly different definitions to these
S	 * @{
S	 */
S	typedef unsigned long	size_t;
S	typedef unsigned long	delaytime_t;
S	typedef unsigned long	systemticks_t;
S	typedef short			semcount_t;
S	typedef int				threadreturn_t;
S	typedef int				threadpriority_t;
S	/** @} */
S
S	/**
S	 * @brief	Declare a thread function
S	 *
S	 * @param[in] fnName	The name of the function
S	 * @param[in] param 	A custom parameter that is passed to the function
S	 */
S	#define DECLARE_THREAD_FUNCTION(fnName, param)	threadreturn_t fnName(void *param)
S
S	/**
S	 * @brief	Declare a thread stack
S	 *
S	 * @param[in] name 		The name of the stack
S	 * @param[in] sz 		The size of the stack
S	 */
S	#define DECLARE_THREAD_STACK(name, sz)			uint8_t name[sz];
S
S	/*
S	 * @brief	Return from a thread
S	 *
S	 * @details	Some underlying operating systems allow to return a value from a thread while others don't.
S	 *			For systems that don't allow to return a value from a thread function this call is simply ignored.
S	 *
S	 * @param[in] reval		The value which should be returned
S	 */
S	#define THREAD_RETURN(retval)					return retval
S
S	/**
S	 * @name	Various platform (and operating system) constants
S	 * @note	Your platform may use slightly different definitions to these
S	 * @{
S	 */
S	#define FALSE						0
S	#define TRUE						1
S	#define TIME_IMMEDIATE				0
S	#define TIME_INFINITE				((delaytime_t)-1)
S	#define MAX_SEMAPHORE_COUNT			((semcount_t)(((unsigned long)((semcount_t)(-1))) >> 1))
S	#define LOW_PRIORITY				0
S	#define NORMAL_PRIORITY				1
S	#define HIGH_PRIORITY				2
S	/** @} */
S
S	/**
S	 * @brief	A semaphore
S	 * @note	Your operating system will have a proper definition for this structure
S	 */
S	typedef struct {} gfxSem;
S
S	/**
S	 * @brief	A mutex
S	 * @note	Your operating system will have a proper definition for this structure
S	 */
S	typedef struct {} gfxMutex;
S
S	/**
S	 * @brief	A thread handle
S	 * @note	Your operating system will have a proper definition for this.
S	 */
S	typedef void * gfxThreadHandle;
S
S	/*===========================================================================*/
S	/* Function declarations.                                                    */
S	/*===========================================================================*/
S
S	#ifdef __cplusplus
S	extern "C" {
S	#endif
S
S	/**
S	 * @brief	Halt the GFX application due to an error.
S	 *
S	 * @param[in] msg	An optional debug message to show (Can be NULL)
S	 *
S	 * @api
S	 */
S	void gfxHalt(const char *msg);
S
S	/**
S	 * @brief	Exit the GFX application.
S	 *
S	 * @api
S	 */
S	void gfxExit(void);
S
S	/**
S	 * @brief	Allocate memory
S	 * @return	A pointer to the memory allocated or NULL if there is no more memory available
S	 *
S	 * @param[in] sz	The size in bytes of the area to allocate
S	 *
S	 * @api
S	 */
S	void *gfxAlloc(size_t sz);
S
S	/**
S	 * @brief	Re-allocate memory
S	 * @return	A pointer to the new memory area or NULL if there is no more memory available
S	 *
S	 * @param[in] ptr		The old memory area to be increased/decreased in size
S	 * @param[in] oldsz		The size in bytes of the old memory area
S	 * @param[in] newsz		The size in bytes of the new memory area
S	 *
S	 * @note		Some operating systems don't use the oldsz parameter as they implicitly know the size of
S	 * 				old memory area. The parameter must always be supplied however for API compatibility.
S	 * @note		gfxRealloc() can make the area smaller or larger but may have to return a different pointer.
S	 * 				If this occurs the new area contains a copy of the data from the old area. The old memory
S	 * 				pointer should not be used after this routine as the original area may have been freed.
S	 * @note		If there is insufficient memory to create the new memory region, NULL is returned and the
S	 * 				old memory area is left unchanged.
S	 *
S	 * @api
S	 */
S	void *gfxRealloc(void *ptr, size_t oldsz, size_t newsz);
S
S	/**
S	 * @brief	Free memory
S	 *
S	 * @param[in] ptr	The memory to free
S	 *
S	 * @api
S	 */
S	void gfxFree(void *ptr);
S
S	/**
S	 * @brief	Use gfxAlloc and gfxFree to implement malloc() and free()
S	 *
S	 * @note	Sometimes your application will include functions that
S	 * 			want to internally use malloc() and free(). As the default
S	 * 			implementations of these in your C library are almost
S	 * 			invariably incorrect for an embedded platform, this option
S	 * 			allows you to emulate those calls with gfxAlloc() and gfxFree().
S	 *			An example is the C library routine rand() which on many
S	 *			implementations internally uses malloc().
S	 *
S	 * @api
S	 */
S	#ifndef GFX_EMULATE_MALLOC
S		#define GFX_EMULATE_MALLOC			FALSE
S	#endif
S
S	/**
S	 * @brief	Yield the current thread
S	 * @details	Give up the rest of the current time slice for this thread in order to give other threads
S	 * 			a chance to run.
S	 *
S	 * @api
S	 */
S	void gfxYield(void);
S
S	/**
S	 * @brief	Put the current thread to sleep for the specified period in milliseconds
S	 *
S	 * @param[in] ms	The number milliseconds to sleep
S	 *
S	 * @note		Specifying TIME_IMMEDIATE will yield the current thread but return
S	 * 				on the next time slice.
S	 * @note		Specifying TIME_INFINITE will sleep forever.
S	 *
S	 * @api
S	 */
S	void gfxSleepMilliseconds(delaytime_t ms);
S
S	/**
S	 * @brief	Put the current thread to sleep for the specified period in microseconds
S	 *
S	 * @param[in] us	The number microseconds to sleep
S	 *
S	 * @note		Specifying TIME_IMMEDIATE will return immediately (no sleeping)
S	 * @note		Specifying TIME_INFINITE will sleep forever.
S	 *
S	 * @api
S	 */
S	void gfxSleepMicroseconds(delaytime_t us);
S
S	/**
S	 * @brief	Get the current operating system tick time
S	 * @return	The current tick time
S	 *
S	 * @note	A "tick" is an arbitrary period of time that the operating
S	 * 			system uses to mark time.
S	 * @note	The absolute value of this call is relatively meaningless. Its usefulness
S	 * 			is in calculating periods between two calls to this function.
S	 * @note	As the value from this function can wrap it is important that any periods are calculated
S	 * 			as t2 - t1 and then compared to the desired period rather than comparing
S	 * 			t1 + period to t2
S	 *
S	 * @api
S	 */
S	systemticks_t gfxSystemTicks(void);
S
S	/**
S	 * @brief	Convert a given number of millseconds to a number of operating system ticks
S	 * @return	The period in system ticks.
S	 *
S	 * @note	A "tick" is an arbitrary period of time that the operating
S	 * 			system uses to mark time.
S	 *
S	 * @param[in] ms	The number of millseconds
S	 *
S	 * @api
S	 */
S	systemticks_t gfxMillisecondsToTicks(delaytime_t ms);
S
S	/**
S	 * @brief	Lock the operating system to protect a sequence of code
S	 *
S	 * @note	Calling this will lock out all other threads from executing even at interrupt level
S	 * 			within the GFX system. On hardware this may be implemented as a disabling of interrupts,
S	 * 			however in an operating system which hides real interrupt level code it may simply use a
S	 * 			mutex lock.
S	 * @note	The thread MUST NOT block whilst the system is locked. It must execute in this state for
S	 * 			as short a period as possible as this can seriously affect interrupt latency on some
S	 * 			platforms.
S	 * @note	While locked only interrupt level (iclass) GFX routines may be called.
S	 *
S	 * @api
S	 */
S	void gfxSystemLock(void);
S
S	/**
S	 * @brief	Unlock the operating system previous locked by gfxSystemLock()
S	 *
S	 * @api
S	 */
S	void gfxSystemUnlock(void);
S
S	/**
S	 * @brief	Initialise a mutex to protect a region of code from other threads.
S	 *
S	 * @param[in]	pmutex	A pointer to the mutex
S	 *
S	 * @note	Whilst a counting semaphore with a limit of 1 can be used for similiar purposes
S	 * 			on many operating systems using a seperate mutex structure is more efficient.
S	 *
S	 * @api
S	 */
S	void gfxMutexInit(gfxMutex *pmutex);
S
S	/**
S	 * @brief	Destroy a Mutex.
S	 *
S	 * @param[in]	pmutex	A pointer to the mutex
S	 *
S	 * @api
S	 */
S	void gfxMutexDestroy(gfxMutex *pmutex);
S
S	/**
S	 * @brief	Enter the critical code region protected by the mutex.
S	 * @details	Blocks until there is no other thread in the critical region.
S	 *
S	 * @param[in]	pmutex	A pointer to the mutex
S	 *
S	 * @api
S	 */
S	void gfxMutexEnter(gfxMutex *pmutex);
S
S	/**
S	 * @brief	Exit the critical code region protected by the mutex.
S	 * @details	May cause another thread waiting on the mutex to now be placed into the run queue.
S	 *
S	 * @param[in]	pmutex	A pointer to the mutex
S	 *
S	 * @api
S	 */
S	void gfxMutexExit(gfxMutex *pmutex);
S
S	/**
S	 * @brief	Initialise a Counted Semaphore
S	 *
S	 * @param[in] psem		A pointer to the semaphore
S	 * @param[in] val		The initial value of the semaphore
S	 * @param[in] limit		The maxmimum value of the semaphore
S	 *
S	 * @note	Operations defined for counted semaphores:
S	 * 				Signal: The semaphore counter is increased and if the result is non-positive then a waiting thread
S	 * 						 is queued for execution. Note that once the thread reaches "limit", further signals are
S	 * 						 ignored.
S	 * 				Wait: The semaphore counter is decreased and if the result becomes negative the thread is queued
S	 * 						in the semaphore and suspended.
S	 *
S	 * @api
S	 */
S	void gfxSemInit(gfxSem *psem, semcount_t val, semcount_t limit);
S
S	/**
S	 * @brief	Destroy a Counted Semaphore
S	 *
S	 * @param[in] psem		A pointer to the semaphore
S	 *
S	 * @note	Any threads waiting on the semaphore will be released
S	 *
S	 * @api
S	 */
S	void gfxSemDestroy(gfxSem *psem);
S
S	/**
S	 * @brief	Wait on a semaphore
S	 * @details	The semaphore counter is decreased and if the result becomes negative the thread waits for it to become
S	 * 				non-negative again
S	 * @return	FALSE if the wait timeout occurred otherwise TRUE
S	 *
S	 * @param[in] psem		A pointer to the semaphore
S	 * @param[in] ms		The maximum time to wait for the semaphore
S	 *
S	 * @api
S	 */
S	bool_t gfxSemWait(gfxSem *psem, delaytime_t ms);
S
S	/**
S	 * @brief	Test if a wait on a semaphore can be satisfied immediately
S	 * @details	Equivalent to @p gfxSemWait(psem, TIME_IMMEDIATE) except it can be called at interrupt level
S	 * @return	FALSE if the wait would occur occurred otherwise TRUE
S	 *
S	 * @param[in] psem		A pointer to the semaphore
S	 *
S	 * @iclass
S	 * @api
S	 */
S	bool_t gfxSemWaitI(gfxSem *psem);
S
S	/**
S	 * @brief	Signal a semaphore
S	 * @details	The semaphore counter is increased and if the result is non-positive then a waiting thread
S	 * 						 is queued for execution. Note that once the thread reaches "limit", further signals are
S	 * 						 ignored.
S	 *
S	 * @param[in] psem		A pointer to the semaphore
S	 *
S	 * @api
S	 */
S	void gfxSemSignal(gfxSem *psem);
S
S	/**
S	 * @brief	Signal a semaphore
S	 * @details	The semaphore counter is increased and if the result is non-positive then a waiting thread
S	 * 						 is queued for execution. Note that once the thread reaches "limit", further signals are
S	 * 						 ignored.
S	 *
S	 * @param[in] psem		A pointer to the semaphore
S	 *
S	 * @iclass
S	 * @api
S	 */
S	void gfxSemSignalI(gfxSem *psem);
S
S	/**
S	 * @brief	Get the current semaphore count
S	 * @return	The current semaphore count
S	 *
S	 * @param[in] psem		A pointer to the semaphore
S	 *
S	 * @api
S	 */
S	semcount_t gfxSemCounter(gfxSem *psem);
S
S	/**
S	 * @brief	Get the current semaphore count
S	 * @return	The current semaphore count
S	 *
S	 * @param[in] psem		A pointer to the semaphore
S	 *
S	 * @iclass
S	 * @api
S	 */
S	semcount_t gfxSemCounterI(gfxSem *psem);
S
S	/**
S	 * @brief	Start a new thread.
S	 * @return	Returns a thread handle if the thread was started, NULL on an error
S	 *
S	 * @param[in]	stackarea	A pointer to the area for the new threads stack or NULL to dynamically allocate it
S	 * @param[in]	stacksz		The size of the thread stack. 0 means the default operating system size although this
S	 * 							is only valid when stackarea is dynamically allocated.
S	 * @param[in]	prio		The priority of the new thread
S	 * @param[in]	fn			The function the new thread will run
S	 * @param[in]	param		A parameter to pass the thread function.
S	 *
S	 * @api
S	 */
S	gfxThreadHandle gfxThreadCreate(void *stackarea, size_t stacksz, threadpriority_t prio, DECLARE_THREAD_FUNCTION((*fn),p), void *param);
S
S	/**
S	 * @brief	Wait for a thread to finish.
S	 * @return	Returns the thread exit code.
S	 *
S	 * @param[in]	thread		The Thread Handle
S	 *
S	 * @note		This will also close the thread handle as it is no longer useful
S	 * 				once the thread has ended.
S	 * @api
S	 */
S	threadreturn_t gfxThreadWait(gfxThreadHandle thread);
S
S	/**
S	 * @brief	Get the current thread handle.
S	 * @return	A thread handle
S	 *
S	 * @api
S	 */
S	gfxThreadHandle gfxThreadMe(void);
S
S	/**
S	 * @brief	Close the thread handle.
S	 *
S	 * @param[in]	thread		The Thread Handle
S	 *
S	 * @note	This does not affect the thread, it just closes our handle to the thread.
S	 *
S	 * @api
S	 */
S	void gfxThreadClose(gfxThreadHandle thread);
S
S	#ifdef __cplusplus
S	}
S	#endif
S
S/**
S * All the above was just for the doxygen documentation. All the implementation of the above
S * (without any of the documentation overheads) is in the files below.
S */
S#elif GFX_USE_OS_RAWRTOS
X#elif 0
S 	#include "gos_rawrtos.h"
S#elif GFX_USE_OS_CHIBIOS
X#elif 0
S	#include "gos_chibios.h"
S#elif GFX_USE_OS_FREERTOS
X#elif 0
S	#include "gos_freertos.h"
S#elif GFX_USE_OS_WIN32
X#elif 0
S	#include "gos_win32.h"
S#elif GFX_USE_OS_LINUX
X#elif 0
S	#include "gos_linux.h"
S#elif GFX_USE_OS_OSX
X#elif 0
S	#include "gos_osx.h"
N#elif GFX_USE_OS_RAW32
X#elif -1
N	#include "gos_raw32.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gos/gos_raw32.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * The raw32 GOS implementation supports any 32 bit processor with or without an
N * 	underlying operating system. It uses cooperative multi-tasking. Be careful
N * 	when writing device drivers not to disturb the assumptions this creates by performing
N * 	call-backs to uGFX code unless you define the INTERRUPTS_OFF() and INTERRUPTS_ON() macros.
N * 	It still requires some C runtime library support...
N * 		enough startup to initialise the stack, interrupts, static data etc and call main().
N * 		setjmp() and longjmp()			- for threading
N * 		memcpy()						- for heap and threading
N * 		malloc(), realloc and free()	- if GOS_RAW_HEAP_SIZE == 0
N *
N * 	You must also define the following routines in your own code so that timing functions will work...
N * 		systemticks_t gfxSystemTicks(void);
N *		systemticks_t gfxMillisecondsToTicks(delaytime_t ms);
N */
N#ifndef _GOS_RAW32_H
N#define _GOS_RAW32_H
N
N#if GFX_USE_OS_RAW32
X#if -1
N
N/*===========================================================================*/
N/* Type definitions                                                          */
N/*===========================================================================*/
N
Ntypedef unsigned char	bool_t;
N
N#if __STDC_VERSION__ >= 199901L
X#if 199901L >= 199901L
N	#include <stdint.h>
N#elif defined(__GNUC__) || defined(__GNUG__)
S	typedef __INT8_TYPE__	int8_t;
S	typedef __UINT8_TYPE__	uint8_t;
S	typedef __INT16_TYPE__	int16_t;
S	typedef __UINT16_TYPE__	uint16_t;
S	typedef __INT32_TYPE__	int32_t;
S	typedef __UINT32_TYPE__	uint32_t;
S#else
S	typedef signed char		int8_t;
S	typedef unsigned char	uint8_t;
S	typedef signed short	int16_t;
S	typedef unsigned short	uint16_t;
S	typedef signed int		int32_t;
S	typedef unsigned int	uint32_t;
N#endif
N
N#if defined(__STDC__)
X#if 1L
N	#include <stddef.h>
N#else
S	typedef uint32_t		size_t;
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N	void gfxHalt(const char *msg);
N	void gfxExit(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N/*===========================================================================*/
N/* Use the generic thread handling and heap handling                         */
N/*===========================================================================*/
N
N#define GOS_NEED_X_THREADS	TRUE
N#define GOS_NEED_X_HEAP		TRUE
N
N#include "gos_x_threads.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gos/gos_x_threads.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * This threading implementation supports most 32 bit processors with or without an
N * 	underlying operating system. It uses cooperative multi-tasking. Be careful
N * 	when writing device drivers not to disturb the assumptions this creates by performing
N * 	call-backs from interrupt handlers to uGFX code unless you define the INTERRUPTS_OFF()
N * 	and INTERRUPTS_ON() macros.
N * 	It still requires some C runtime library support for the setjmp implementation...
N * 		setjmp() and longjmp()			- for threading
N * 		memcpy()						- for heap and threading
N *
N * 	You must also define the following routines in your own code so that timing functions will work...
N * 		systemticks_t gfxSystemTicks(void);
N *		systemticks_t gfxMillisecondsToTicks(delaytime_t ms);
N */
N#ifndef _GOS_X_THREADS_H
N#define _GOS_X_THREADS_H
N
N#if GOS_NEED_X_THREADS
X#if -1
N
Ntypedef uint32_t		delaytime_t;
Ntypedef uint32_t		systemticks_t;
Ntypedef short			semcount_t;
Ntypedef int				threadreturn_t;
Ntypedef int				threadpriority_t;
N
N#define DECLARE_THREAD_FUNCTION(fnName, param)	threadreturn_t fnName(void *param)
N#define DECLARE_THREAD_STACK(name, sz)			uint8_t name[sz];
N#define THREAD_RETURN(retval)					return retval
N
N#define TIME_IMMEDIATE				0
N#define TIME_INFINITE				((delaytime_t)-1)
N#define MAX_SEMAPHORE_COUNT			0x7FFF
N#define LOW_PRIORITY				0
N#define NORMAL_PRIORITY				1
N#define HIGH_PRIORITY				2
N
Ntypedef struct {
N	semcount_t		cnt;
N	semcount_t		limit;
N} gfxSem;
N
Ntypedef uint32_t		gfxMutex;
Ntypedef void *			gfxThreadHandle;
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N	// Required timing functions - supplied by the user or the operating system
N	systemticks_t gfxSystemTicks(void);
N	systemticks_t gfxMillisecondsToTicks(delaytime_t ms);
N
N	// Sleep Functions
N	void gfxSleepMilliseconds(delaytime_t ms);
N	void gfxSleepMicroseconds(delaytime_t ms);
N	void gfxYield(void);
N
N	// System Locking
N	void gfxSystemLock(void);
N	void gfxSystemUnlock(void);
N
N	// Mutexes
N	void gfxMutexInit(gfxMutex *pmutex);
N	#define gfxMutexDestroy(pmutex)
N	void gfxMutexEnter(gfxMutex *pmutex);
N	void gfxMutexExit(gfxMutex *pmutex);
N
N	// Semaphores
N	void gfxSemInit(gfxSem *psem, semcount_t val, semcount_t limit);
N	#define gfxSemDestroy(psem)
N	bool_t gfxSemWait(gfxSem *psem, delaytime_t ms);
N	bool_t gfxSemWaitI(gfxSem *psem);
N	void gfxSemSignal(gfxSem *psem);
N	void gfxSemSignalI(gfxSem *psem);
N
N	// Deprecated Semaphore functions (they still work here)
N	#define gfxSemCounter(psem)			((psem)->cnt)
N	#define gfxSemCounterI(psem)		((psem)->cnt)
N
N	// Threads
N	gfxThreadHandle gfxThreadCreate(void *stackarea, size_t stacksz, threadpriority_t prio, DECLARE_THREAD_FUNCTION((*fn),p), void *param);
X	gfxThreadHandle gfxThreadCreate(void *stackarea, size_t stacksz, threadpriority_t prio, threadreturn_t (*fn)(void *p), void *param);
N	#define gfxThreadClose(thread)
N	threadreturn_t gfxThreadWait(gfxThreadHandle thread);
N	gfxThreadHandle gfxThreadMe(void);
N
N	/** The following is not part of the public ugfx API has some operating systems
N	 * 	simply do not provide this capability.
N	 * 	For RAW32 we need it anyway so we might as well declare it here.
N	 */
N	void gfxThreadExit(threadreturn_t ret);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* GOS_NEED_X_THREADS */
N#endif /* _GOS_X_THREADS_H */
L 77 "..\..\..\..\..\..\external\ugfx\src/gos/gos_raw32.h" 2
N#include "gos_x_heap.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gos/gos_x_heap.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N#ifndef _GOS_X_HEAP_H
N#define _GOS_X_HEAP_H
N
N#if GOS_NEED_X_HEAP || defined(__DOXYGEN__)
X#if -1 || 0L
N
N/*===========================================================================*/
N/* Type definitions                                                          */
N/*===========================================================================*/
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N	#if GFX_OS_HEAP_SIZE != 0 || defined(__DOXYGEN__)
X	#if 0 != 0 || 0L
S		/**
S		 * @brief	Take a chunk of memory and add it to the available heap
S		 * @note	Memory added must obviously not already be on the heap.
S		 * @note	It is allowable to add multiple non-contiguous blocks of memory
S		 * 			to the heap. If however it is contiguous with a previously added block
S		 * 			it will get merged with the existing block in order to allow
S		 * 			allocations that span the boundary.
S		 * @pre		GFX_OS_HEAP_SIZE != 0 and an operating system that uses the
S		 * 			internal ugfx heap allocator rather than its own allocator.
S		 */
S		void gfxAddHeapBlock(void *ptr, size_t sz);
N	#endif
N
N	void *gfxAlloc(size_t sz);
N	void *gfxRealloc(void *ptr, size_t oldsz, size_t newsz);
N	void gfxFree(void *ptr);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* GOS_NEED_X_HEAP */
N#endif /* _GOS_X_HEAP_H */
L 78 "..\..\..\..\..\..\external\ugfx\src/gos/gos_raw32.h" 2
N
N#endif /* GFX_USE_OS_RAW32 */
N#endif /* _GOS_RAW32_H */
L 490 "..\..\..\..\..\..\external\ugfx\src/gos/gos.h" 2
N#elif GFX_USE_OS_ECOS
S	#include "gos_ecos.h"
S#elif GFX_USE_OS_ARDUINO
S	#include "gos_arduino.h"
S#elif GFX_USE_OS_CMSIS
S 	#include "gos_cmsis.h"
S#elif GFX_USE_OS_KEIL
S    #include "gos_keil.h"
S#elif GFX_USE_OS_NIOS
S    #include "gos_nios.h"
S#elif GFX_USE_OS_QT
S    #include "gos_qt.h"
S#else
S	#error "Your operating system is not supported yet"
N#endif
N
N#endif /* _GOS_H */
N/** @} */
L 201 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N//#include "src/gdriver/gdriver.h"			// This module is only included by source that needs it.
N#include "src/gfile/gfile.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gfile/gfile.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gfile/gfile.h
N * @brief   GFILE - File IO Routines header file.
N *
N * @addtogroup GFILE
N *
N * @brief	Module which contains operating system independent file I/O.
N *
N * @{
N */
N
N#ifndef _GFILE_H
N#define _GFILE_H
N
N#include "../../gfx.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gfile/../../gfx.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    gfx.h
N * @brief   GFX system header file.
N *
N * @addtogroup GFX
N *
N * @brief	Main module to glue all the others together
N *
N * @{
N */
N
N#ifndef _GFX_H
S#define _GFX_H
S
S/**
S * These two definitions below are required before anything else so that we can
S * turn module definitions off and on.
S */
S
S/**
S * @brief   Generic 'false' boolean constant.
S */
S#if !defined(FALSE) || defined(__DOXYGEN__)
S	#define FALSE       0
S#endif
S
S/**
S * @brief   Generic 'true' boolean constant.
S */
S#if !defined(TRUE) || defined(__DOXYGEN__)
S	#define TRUE        -1
S#endif
S
S/* gfxconf.h is the user's project configuration for the GFX system. */
S#include "gfxconf.h"
S
S/* Include Compiler and CPU support */
S#include "src/gfx_compilers.h"
S
S/**
S * @name    GFX sub-systems that can be turned on
S * @{
S */
S	/**
S	 * @brief   GFX Driver API
S	 * @details	Defaults to TRUE
S	 * @note	Not much useful can be done without a driver
S	 */
S	#ifndef GFX_USE_GDRIVER
S		#define GFX_USE_GDRIVER	TRUE
S	#endif
S	/**
S	 * @brief   GFX Graphics Display Basic API
S	 * @details	Defaults to FALSE
S	 * @note	Also add the specific hardware driver to your makefile.
S	 * 			Eg.  include $(GFXLIB)/drivers/gdisp/Nokia6610/driver.mk
S	 */
S	#ifndef GFX_USE_GDISP
S		#define GFX_USE_GDISP	FALSE
S	#endif
S	/**
S	 * @brief   GFX Graphics Windowing API
S	 * @details	Defaults to FALSE
S	 * @details	Extends the GDISP API to add the concept of graphic windows.
S	 * @note	Also supports high-level "window" objects such as console windows,
S	 * 			buttons, graphing etc
S	 */
S	#ifndef GFX_USE_GWIN
S		#define GFX_USE_GWIN	FALSE
S	#endif
S	/**
S	 * @brief   GFX Event API
S	 * @details	Defaults to FALSE
S	 * @details	Defines the concept of a "Source" that can send "Events" to "Listeners".
S	 */
S	#ifndef GFX_USE_GEVENT
S		#define GFX_USE_GEVENT	FALSE
S	#endif
S	/**
S	 * @brief   GFX Timer API
S	 * @details	Defaults to FALSE
S	 * @details	Provides thread context timers - both one-shot and periodic.
S	 */
S	#ifndef GFX_USE_GTIMER
S		#define GFX_USE_GTIMER	FALSE
S	#endif
S	/**
S	 * @brief   GFX Queue API
S	 * @details	Defaults to FALSE
S	 * @details	Provides queue management.
S	 */
S	#ifndef GFX_USE_GQUEUE
S		#define GFX_USE_GQUEUE	FALSE
S	#endif
S	/**
S	 * @brief   GFX Input Device API
S	 * @details	Defaults to FALSE
S	 * @note	Also add the specific hardware drivers to your makefile.
S	 * 			Eg.
S	 * 				include $(GFXLIB)/drivers/ginput/toggle/Pal/driver.mk
S	 * 			and...
S	 * 				include $(GFXLIB)/drivers/ginput/touch/MCU/driver.mk
S	 */
S	#ifndef GFX_USE_GINPUT
S		#define GFX_USE_GINPUT	FALSE
S	#endif
S	/**
S	 * @brief   GFX Generic Periodic ADC API
S	 * @details	Defaults to FALSE
S	 */
S	#ifndef GFX_USE_GADC
S		#define GFX_USE_GADC	FALSE
S	#endif
S	/**
S	 * @brief   GFX Audio API
S	 * @details	Defaults to FALSE
S	 * @note	Also add the specific hardware drivers to your makefile.
S	 * 			Eg.
S	 * 				include $(GFXLIB)/drivers/gaudio/GADC/driver.mk
S	 */
S	#ifndef GFX_USE_GAUDIO
S		#define GFX_USE_GAUDIO	FALSE
S	#endif
S	/**
S	 * @brief   GFX Miscellaneous Routines API
S	 * @details	Defaults to FALSE
S	 * @note	Turning this on without turning on any GMISC_NEED_xxx macros will result
S	 * 			in no extra code being compiled in. GMISC is made up from the sum of its
S	 * 			parts.
S	 */
S	#ifndef GFX_USE_GMISC
S		#define GFX_USE_GMISC	FALSE
S	#endif
S	/**
S	 * @brief   GFX File API
S	 * @details	Defaults to FALSE
S	 */
S	#ifndef GFX_USE_GFILE
S		#define GFX_USE_GFILE	FALSE
S	#endif
S	/**
S	 * @brief   GFX Translation Support API
S	 * @details	Defaults to FALSE
S	 */
S	#ifndef GFX_USE_GTRANS
S		#define GFX_USE_GTRANS	FALSE
S	#endif
S/** @} */
S
S/**
S * Get all the options for each sub-system.
S *
S */
S#include "src/gos/gos_options.h"
S#include "src/gdriver/gdriver_options.h"
S#include "src/gfile/gfile_options.h"
S#include "src/gmisc/gmisc_options.h"
S#include "src/gtrans/gtrans_options.h"
S#include "src/gqueue/gqueue_options.h"
S#include "src/gevent/gevent_options.h"
S#include "src/gtimer/gtimer_options.h"
S#include "src/gdisp/gdisp_options.h"
S#include "src/gwin/gwin_options.h"
S#include "src/ginput/ginput_options.h"
S#include "src/gadc/gadc_options.h"
S#include "src/gaudio/gaudio_options.h"
S
S/**
S * Interdependency safety checks on the sub-systems.
S * These must be in dependency order.
S *
S */
S#ifndef GFX_DISPLAY_RULE_WARNINGS
S	#define GFX_DISPLAY_RULE_WARNINGS	FALSE
S#endif
S#include "src/gwin/gwin_rules.h"
S#include "src/ginput/ginput_rules.h"
S#include "src/gdisp/gdisp_rules.h"
S#include "src/gaudio/gaudio_rules.h"
S#include "src/gadc/gadc_rules.h"
S#include "src/gevent/gevent_rules.h"
S#include "src/gtimer/gtimer_rules.h"
S#include "src/gqueue/gqueue_rules.h"
S#include "src/gmisc/gmisc_rules.h"
S#include "src/gtrans/gtrans_rules.h"
S#include "src/gfile/gfile_rules.h"
S#include "src/gdriver/gdriver_rules.h"
S#include "src/gos/gos_rules.h"
S
S/**
S *  Include the sub-system header files
S */
S#include "src/gos/gos.h"
S//#include "src/gdriver/gdriver.h"			// This module is only included by source that needs it.
S#include "src/gfile/gfile.h"
S#include "src/gmisc/gmisc.h"
S#include "src/gtrans/gtrans.h"
S#include "src/gqueue/gqueue.h"
S#include "src/gevent/gevent.h"
S#include "src/gtimer/gtimer.h"
S#include "src/gdisp/gdisp.h"
S#include "src/gwin/gwin.h"
S#include "src/ginput/ginput.h"
S#include "src/gadc/gadc.h"
S#include "src/gaudio/gaudio.h"
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S	/**
S	 * @brief	The one call to start it all
S	 *
S	 * @note	This will initialise each sub-system that has been turned on.
S	 * 			For example, if GFX_USE_GDISP is defined then display will be initialised
S	 * 			and cleared to black.
S	 * @note	If you define GFX_OS_NO_INIT as TRUE in your gfxconf.h file then ugfx doesn't try to
S	 * 			initialise the operating system for you when you call @p gfxInit().
S	 * @note	If you define GFX_OS_EXTRA_INIT_FUNCTION in your gfxconf.h file the macro is the
S	 * 			name of a void function with no parameters that is called immediately after
S	 * 			operating system initialisation (whether or not GFX_OS_NO_INIT is set).
S	 * @note	If you define GFX_OS_EXTRA_DEINIT_FUNCTION in your gfxconf.h file the macro is the
S	 * 			name of a void function with no parameters that is called immediately before
S	 * 			operating system de-initialisation (as ugfx is exiting).
S	 *
S	 * @api
S	 */
S	void gfxInit(void);
S
S	/**
S	 * @brief	The one call to end it all
S	 *
S	 * @note	This will de-initialise each sub-system that has been turned on.
S	 *
S	 * @api
S	 */
S	void gfxDeinit(void);
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* _GFX_H */
N/** @} */
N
L 23 "..\..\..\..\..\..\external\ugfx\src/gfile/gfile.h" 2
N
N#if GFX_USE_GFILE || defined(__DOXYGEN__)
X#if 0 || 0L
S
S/*===========================================================================*/
S/* Type definitions                                                          */
S/*===========================================================================*/
S
S/**
S * @brief	A file pointer
S */
S
Stypedef struct GFILE GFILE;
Stypedef struct gfileList gfileList;
S
Sextern GFILE *gfileStdIn;
Sextern GFILE *gfileStdErr;
Sextern GFILE *gfileStdOut;
S
S/*===========================================================================*/
S/* External declarations.                                                    */
S/*===========================================================================*/
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S	/**
S	 * @brief					Check if file exists
S	 * 
S	 * @param[in] fname			The file name
S	 * 
S	 * @return					TRUE if file exists, FALSE otherwise
S	 * 
S	 * @api
S	 */
S	bool_t		gfileExists(const char *fname);
S
S	/**
S	 * @brief					Delete file
S	 * 
S	 * @param[in] fname			The file name
S	 * 
S	 * @return					TRUE on success, FALSE otherwise
S	 * 
S	 * @api
S	 */
S	bool_t		gfileDelete(const char *fname);
S
S	/**
S	 * @brief					Get the size of a file
S	 * @note					Please use @p gfileGetSize() if the file is opened
S	 * 
S	 * @param[in] fname			The file name
S	 * 
S	 * @return					File size on success, -1 on error
S	 * 
S	 * @api
S	 */
S	long int	gfileGetFilesize(const char *fname);
S
S	/**
S	 * @brief					Rename file
S	 *
S	 * @param[in] oldname		The current file name
S	 * @param[in] newname		The new name of the file
S	 *
S	 * @return					TRUE on success, FALSE otherwise
S	 *
S	 * @api
S	 */
S	bool_t		gfileRename(const char *oldname, const char *newname);
S
S	/**
S	 * @brief					Open file
S	 * @details					A file must be opened before it can be accessed
S	 * @details					The resulting GFILE will be used for all functions that access the file.
S	 *
S	 * @param[in] fname			The file name
S	 * @param[in] mode			The mode.
S	 *
S	 * @return					Valid GFILE on success, 0 otherwise
S	 *
S	 * @note					The modes follow the c library fopen() standard.
S	 * 							The valid modes are:
S	 * 							<ul><li>r   - Open for read, the file must exist</li>
S	 * 								<li>w   - Open for write, the file is truncated if it exists</li>
S	 * 								<li>wx  - Open for write, the file must not exist</li>
S	 * 								<li>a   - Open for append, the file is truncated if it exists</li>
S	 * 								<li>ax  - Open for append, the file must not exists</li>
S	 * 							</ul>
S	 * 							The following flags can also be added to the above modes:<br/>
S	 * 							<ul><li>+   - Open for both read and write</li>
S	 * 								<li>b   - Open as a binary file rather than a text file</li>
S	 * 							</ul>
S	 * @note					Not all file-systems support all modes. For example, write
S	 * 							is not available with the ROM file-system. Similarly few platforms
S	 * 							distinguish between binary and text files.
S	 * @note					Even though binary vs. text is relevant only for a small number of platforms
S	 * 							the "b" flag should always be specified for binary files such as images.
S	 * 							This ensures portability to other platforms. The extra flag will be ignored
S	 * 							on platforms where it is not relevant.
S	 *
S	 * @api
S	 */	
S	GFILE *		gfileOpen(const char *fname, const char *mode);
S
S	/**
S	 * @brief					Close file
S	 * @details					Closes a file after is has been opened using @p gfileOpen()
S	 *
S	 * @param[in] f				The file
S	 *
S	 * @api
S	 */
S	void		gfileClose(GFILE *f);
S
S	/**
S	 * @brief					Read from file
S	 * @details					Reads a given amount of bytes from the file
S	 * @details					The read/write cursor will not be reset when calling this function
S	 *
S	 * @param[in] f				The file
S	 * @param[out] buf			The buffer in which to save the content that has been read from the file
S	 * @param[in] len			Amount of bytes to read
S	 *
S	 * @return					Amount of bytes read
S	 *
S	 * @api
S	 */
S	size_t		gfileRead(GFILE *f, void *buf, size_t len);
S
S	/**
S	 * @brief					Write to file
S	 * @details					Write a given amount of bytes to the file
S	 * @details					The read/write cursor will not be reset when calling this function
S	 *
S	 * @param[in] f				The file
S	 * @param[in] buf			The buffer which contains the content that will be written to the file
S	 * @param[in] len			Amount of bytes to write
S	 *
S	 * @return					Amount of bytes written
S	 *
S	 * @api
S	 */
S	size_t		gfileWrite(GFILE *f, const void *buf, size_t len);
S
S	/**
S	 * @brief					Get the current position of the read/write cursor
S	 *
S	 * @param[in] f				The file
S	 *
S	 * @return					The current position in the file
S	 *
S	 * @api
S	 */
S	long int	gfileGetPos(GFILE *f);
S
S	/**
S	 * @brief					Set the position of the read/write cursor
S	 *
S	 * @param[in] f				The file
S	 * @param[in] pos			The position to which the cursor will be set
S	 *
S	 * @return					TRUE on success, FALSE otherwise
S	 *
S	 * @api
S	 */
S	bool_t		gfileSetPos(GFILE *f, long int pos);
S
S	/**
S	 * @brief					Get the size of file
S	 * @note					Please use @p gfileGetFilesize() if the file is not opened
S	 *
S	 * @param[in] f				The file
S	 *
S	 * @return					The size of the file
S	 *
S	 * @api
S	 */
S	long int	gfileGetSize(GFILE *f);
S
S	/**
S	 * @brief					Check for EOF
S	 * @details					Checks if the cursor is at the end of the file
S	 *
S	 * @param[in] f				The file
S	 *
S	 * @return					TRUE if EOF, FALSE otherwise
S	 *
S	 * @api
S	 */
S	bool_t		gfileEOF(GFILE *f);
S
S	/**
S	 * @brief					Mount a logical drive (aka partition)
S	 *
S	 * @details					Not supported by every file system
S	 * @details					Currently just one drive at one is supported.
S	 *
S	 * @param[in] fs			The file system (F for FatFS)
S	 * @param[in] drive			The logical drive prefix
S	 *
S	 * @return					TRUE on success, FALSE otherwise
S	 *
S	 * @api
S	 */
S	bool_t gfileMount(char fs, const char *drive);
S
S	/**
S	 * @brief					Unmount a logical drive (aka partition)
S	 *
S	 * @details					Does have no effect if @p gfileMount() as been called before hand
S	 *
S	 * @param[in] fs			The file system (F for FatFS)
S	 * @param[in] drive			The logical drive prefix
S	 *
S	 * @return					TRUE on success, FALSE otherwise
S	 *
S	 * @api
S	 */
S	bool_t gfileUnmount(char fs, const char *drive);
S
S	/**
S	 * @brief					Syncs the file object (flushes the buffer)
S	 *
S	 * @details					Not supported by every file system
S	 *
S	 * @param[in] f				The file
S	 *
S	 * @return					TRUE on success, FALSE otherwise
S	 *
S	 * @api
S	 */
S	bool_t gfileSync(GFILE *f);
S
S	#if GFILE_NEED_FILELISTS || defined(__DOXYGEN__)
S		/**
S		 * @brief				Open a file list
S		 *
S		 * @param[in] fs		The file system (F for FatFS)
S		 * @param[in] path		Path information to pass to the file system
S		 * @param[in] dirs		Pass TRUE to get directories only, FALSE to get files only
S		 *
S		 * @return				A pointer to a file list on success, NULL otherwise
S		 *
S		 * @note				The path parameter is handled in a file-system specific way. It could be
S		 * 						treated as a directory name, it may be treated as a file pattern, or it
S		 * 						may be ignored. Passing NULL will always return the full list of files
S		 * 						in at least the top level directory.
S		 * @note				For file systems that do not support directories, passing TRUE for dirs
S		 * 						will return an error.
S		 * @note				You must call @p gfileCloseFileList() when you have finished with the
S		 * 						file list in order to free resources.
S		 *
S		 * @api
S		 */
S		gfileList *gfileOpenFileList(char fs, const char *path, bool_t dirs);
S
S		/**
S		 * @brief				Get the next file in a file list.
S		 *
S		 * @param[in] pfl		Pointer to a file list returned by @p gfileOpenFileList()
S		 *
S		 * @return				A pointer to a file (or directory) name. Returns NULL if there are no more.
S		 *
S		 * @note				The file name may contain the full directory path or may not depending
S		 * 						on how the file system treats directories.
S		 * @note				The returned buffer may be destroyed by the next call to any of
S		 * 						@p gfileOpenFileList(), @p gfileReadFileList() or @p gfileCloseFileList().
S		 * 						Do not use this pointer after one of those calls.
S		 *
S		 * @api
S		 */
S		const char *gfileReadFileList(gfileList *pfl);
S
S		/**
S		 * @brief				Close a file list.
S		 *
S		 * @param[in] pfl		Pointer to a file list returned by @p gfileOpenFileList()
S		 *
S		 * @api
S		 */
S		void gfileCloseFileList(gfileList *pfl);
S	#endif
S
S	#if (GFILE_NEED_CHIBIOSFS && GFX_USE_OS_CHIBIOS) || defined(__DOXYGEN__)
S		/**
S		 * @brief					Open file from a ChibiOS FileStream
S		 *
S		 * @param[in] FileStreamPtr	The BaseFileStream (ChibiOS V2) or FileStream (ChibiOS V3) to open as a GFILE
S		 * @param[in] mode			The mode.
S		 *
S		 * @return					Valid GFILE on success, 0 otherwise
S		 *
S		 * @note					The modes are the same modes as in @p gfileOpen(). The
S		 * 							open mode is NOT compared against the FileStream capabilities.
S		 * @note					Supported operations are: read, write, getpos, setpos, eof and getsize
S		 *
S		 * @api
S		 */
S		GFILE *		gfileOpenChibiOSFileStream(void *FileStreamPtr, const char *mode);
S		#define gfileOpenBaseFileStream(f,m)	gfileOpenChibiOSFileStream(f,m)
S	#endif
S
S	#if GFILE_NEED_MEMFS || defined(__DOXYGEN__)
S		/**
S		 * @brief					Open file from a memory pointer
S		 *
S		 * @param[in] memptr		The pointer to the memory
S		 * @param[in] mode			The mode.
S		 *
S		 * @return					Valid GFILE on success, 0 otherwise
S		 *
S		 * @note					The modes are the same modes as in @p gfileOpen(). Note there is
S		 * 							no concept of file-size. Be careful not to overwrite other memory or
S		 * 							to read from inaccessible sections of memory.
S		 * @note					Supported operations are: read, write, getpos, setpos
S		 *
S		 * @api
S		 */
S		GFILE *		gfileOpenMemory(void *memptr, const char *mode);
S	#endif
S
S	#if GFILE_NEED_STRINGS || defined(__DOXYGEN__)
S		/**
S		 * @brief					Open file from a null terminated C string
S		 *
S		 * @param[in] str			The pointer to the string or string buffer
S		 * @param[in] mode			The mode
S		 *
S		 * @return					Valid GFILE on success, 0 otherwise
S		 *
S		 * @note					The modes are the same modes as in @p gfileOpen(). Note there is
S		 * 							no concept of file-size. Be careful not to overwrite other memory or
S		 * 							to read from inaccessible sections of memory.
S		 * @note					Reading will return EOF when the NULL character is reached.
S		 * @note					Writing will always place a NULL in the next character effectively terminating the
S		 * 							string at the character just written.
S		 * @note					Supported operations are: read, write, append, getpos, setpos
S		 * @note					Be careful with setpos and getpos. They do not check for the end of the string.
S		 * @note					Reading and Writing will read/write a maximum of one character at a time.
S		 *
S		 * @api
S		 */
S		GFILE *		gfileOpenString(char *str, const char *mode);
S	#endif
S
S	#if GFILE_NEED_PRINTG || defined(__DOXYGEN__)
S		#include <stdarg.h>
S
S		int vfnprintg(GFILE *f, int maxlen, const char *fmt, va_list arg);
S		int fnprintg(GFILE *f, int maxlen, const char *fmt, ...);
S		#define vfprintg(f,m,a)			vfnprintg(f,0,m,a)
S		#define fprintg(f,m,...)		fnprintg(f,0,m,__VA_ARGS__)
S		#define vprintg(m,a)			vfnprintg(gfileStdOut,0,m,a)
S		#define printg(m,...)			fnprintg(gfileStdOut,0,m,__VA_ARGS__)
S
S		#if GFILE_NEED_STRINGS
S			int vsnprintg(char *buf, int maxlen, const char *fmt, va_list arg);
S			int snprintg(char *buf, int maxlen, const char *fmt, ...);
S			#define vsprintg(s,m,a)		vsnprintg(s,0,m,a)
S			#define sprintg(s,m,...)	snprintg(s,0,m,__VA_ARGS__)
S		#endif
S	#endif
S
S	#if GFILE_NEED_SCANG || defined(__DOXYGEN__)
S		#include <stdarg.h>
S
S		int vfscang(GFILE *f, const char *fmt, va_list arg);
S		int fscang(GFILE *f, const char *fmt, ...);
S		#define vscang(f,a)			vfscang(gfileStdIn,f,a)
S		#define scang(f,...)		fscang(gfileStdIn,f,__VA_ARGS__)
S
S		#if GFILE_NEED_STRINGS
S			int vsscang(const char *buf, const char *fmt, va_list arg);
S			int sscang(const char *buf, const char *fmt, ...);
S		#endif
S	#endif
S
S	#if GFILE_NEED_STDIO && !defined(GFILE_NEED_STDIO_MUST_BE_OFF)
S		// Needed routines and definitions
S		size_t gstdioRead(void * ptr, size_t size, size_t count, GFILE *f);
S		size_t gstdioWrite(const void * ptr, size_t size, size_t count, GFILE *f);
S		int gstdioGetpos(GFILE *f, long int *pos);
S		int gstdioSeek(GFILE *f, size_t offset, int origin);
S		#define SEEK_SET	0
S		#define SEEK_CUR	1
S		#define SEEK_END	2
S
S		// Stdio emulation
S		#define stdin					gfileStdIn
S		#define stdout					gfileStdOut
S		#define stderr					gfileStdErr
S		#define FOPEN_MAX				GFILE_MAX_GFILES
S		#define TMP_MAX					GFILE_MAX_GFILES
S		#define FILENAME_MAX			256						// Use a relatively small number for an embedded platform
S		#define L_tmpnam				FILENAME_MAX
S		#define P_tmpdir				"/tmp/"
S		#define FILE					GFILE
S		#define fopen(n,m)				gfileOpen(n,m)
S		#define fclose(f)				gfileClose(f)
S		#define fread(p,sz,cnt,f)		gstdioRead(p,sz,cnt,f)
S		#define fwrite(p,sz,cnt,f)		gstdioWrite(p,sz,cnt,f)
S		#define fseek(f,ofs,org)		gstdioSeek(f,ofs,org)
S		#define remove(n)				(!gfileDelete(n))
S		#define rename(o,n)				(!gfileRename(o,n))
S		#define fflush(f)				(0)
S		#define ftell(f)				gfileGetPos(f)
S		#define fpos_t					long int
S		#define fgetpos(f,pos)			gstdioGetpos(f,pos)
S		#define fsetpos(f, pos)			(!gfileSetPos(f, *pos))
S		#define rewind(f)				gfileSetPos(f, 0);
S		#define feof(f)					gfileEOF(f)
S		#define vfprintf(f,m,a)			vfnprintg(f,0,m,a)
S		#define fprintf(f,m,...)		fnprintg(f,0,m,__VA_ARGS__)
S		#define vprintf(m,a)			vfnprintg(gfileStdOut,0,m,a)
S		#define printf(m,...)			fnprintg(gfileStdOut,0,m,__VA_ARGS__)
S		#define vsnprintf(s,n,m,a)		vsnprintg(s,n,m,a)
S		#define snprintf(s,n,m,...)		snprintg(s,n,m,__VA_ARGS__)
S		#define vsprintf(s,m,a)			vsnprintg(s,0,m,a)
S		#define sprintf(s,m,...)		snprintg(s,0,m,__VA_ARGS__)
S
S		//TODO
S		//void clearerr ( FILE * stream );
S		//int ferror ( FILE * stream );
S		//FILE * tmpfile ( void );		// Auto-deleting
S		//char * tmpnam ( char * str );
S		//char * mktemp (char *template);
S		//FILE * freopen ( const char * filename, const char * mode, FILE * stream );
S		//setbuf
S		//setvbuf
S		//fflush
S		//fgetc
S		//fgets
S		//fputc
S		//fputs
S		//getc
S		//getchar
S		//puts
S		//ungetc
S		//void perror (const char * str);
S	#endif
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* GFX_USE_GFILE */
N
N#endif /* _GFILE_H */
N/** @} */
N
L 203 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gmisc/gmisc.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gmisc/gmisc.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gmisc/gmisc.h
N * @brief   GMISC - Miscellaneous Routines header file.
N *
N * @addtogroup GMISC
N *
N * @brief	Module which contains different features such as array conversions
N *
N * @{
N */
N
N#ifndef _GMISC_H
N#define _GMISC_H
N
N#include "../../gfx.h"
N
N/*===========================================================================*/
N/* Type definitions                                                          */
N/*===========================================================================*/
N
N// Forward definition
Ntypedef struct point point;
N
N/**
N * @brief	Sample data formats
N * @note	These are defined regardless of whether you use the GMISC module
N * 			or not as they are used in lots of places.
N */
Ntypedef enum ArrayDataFormat_e {
N	ARRAY_DATA_UNKNOWN = 0,
N	ARRAY_DATA_4BITUNSIGNED = 4,	ARRAY_DATA_4BITSIGNED = 5,
N	ARRAY_DATA_8BITUNSIGNED = 8,	ARRAY_DATA_8BITSIGNED = 9,
N	ARRAY_DATA_10BITUNSIGNED = 10,	ARRAY_DATA_10BITSIGNED = 11,
N	ARRAY_DATA_12BITUNSIGNED = 12,	ARRAY_DATA_12BITSIGNED = 13,
N	ARRAY_DATA_14BITUNSIGNED = 14,	ARRAY_DATA_14BITSIGNED = 15,
N	ARRAY_DATA_16BITUNSIGNED = 16,	ARRAY_DATA_16BITSIGNED = 17,
N	} ArrayDataFormat;
N
N/**
N * @brief	Is the sample data format a "signed" data format?
N */
N#define gfxSampleFormatIsSigned(fmt)	((fmt) & 1)
N
N/**
N * @brief	How many bits are in the sample data format
N */
N#define gfxSampleFormatBits(fmt)	((fmt) & ~1)
N
N/**
N * @brief   The type for a fixed point type.
N * @details	The top 16 bits are the integer component, the bottom 16 bits are the real component.
N */
Ntypedef int32_t	fixed;
N
N/**
N * @brief   Macros to convert to and from a fixed point.
N * @{
N */
N#define FIXED(x)			((fixed)(x)<<16)						/* @< integer to fixed */
N#define NONFIXED(x)			((x)>>16)								/* @< fixed to integer */
N#define FIXED0_5			32768									/* @< 0.5 as a fixed (used for rounding) */
N#define FP2FIXED(x)			((fixed)((x)*65536.0))					/* @< floating point to fixed */
N#define FIXED2FP(x)			((double)(x)/65536.0)					/* @< fixed to floating point */
N#define FIXEDMUL(a,b)		((fixed)((((long long)(a))*(b))>>16))	/* @< fixed,fixed multiplication */
N#define FIXEDMULINT(a,b)	((a)*(b))								/* @< integer,fixed multiplication */
N/** @} */
N
N/**
N * @brief   The famous number pi
N */
N#ifndef GFX_PI
N	#define GFX_PI	3.1415926535897932384626433832795028841971693993751
N#endif
N
N/**
N * @brief   pi as a fixed point
N */
N#define FIXED_PI	FP2FIXED(GFX_PI)
N
N/*===========================================================================*/
N/* External declarations.                                                    */
N/*===========================================================================*/
N
N#if GFX_USE_GMISC || defined(__DOXYGEN__)
X#if 0 || 0L
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S#if GMISC_NEED_ARRAYOPS || defined(__DOXYGEN__)
S	/**
S	 * @brief				Convert from one array format to another array format.
S	 * @pre					Requires GFX_USE_GMISC and GMISC_NEED_ARRAYOPS
S	 *
S	 * @param[in] srcfmt		The format of the source array
S	 * @param[in] src			The source array
S	 * @param[in] dstfmt		The format of the destination array
S	 * @param[in] dst			The dstination array
S	 * @param[in] cnt			The number of array elements to convert
S	 *
S	 * @note				Assumes the destination buffer is large enough for the resultant data.
S	 * @note				This routine is optimised to perform as fast as possible.
S	 * @note				No type checking is performed on the source format. It is assumed to
S	 * 						have only valid values eg. ARRAY_DATA_4BITSIGNED will have values
S	 * 							0000 -> 0111 for positive numbers and 1111 -> 1000 for negative numbers
S	 * 							Bits 5 -> 8 in the storage byte are treated in an undefined manner.
S	 * @note				If srcfmt or dstfmt is an unknown format, this routine does nothing
S	 * 						with no warning that something is wrong
S	 *
S	 * @api
S	 */
S	void gmiscArrayConvert(ArrayDataFormat srcfmt, void *src, ArrayDataFormat dstfmt, void *dst, size_t cnt);
S
S	#if 0
S		void gmiscArrayTranslate(ArrayDataFormat fmt, void *src, void *dst, size_t cnt, int trans);
S
S		void gmiscArrayMultiply(ArrayDataFormat fmt, void *src, void *dst, size_t cnt, int mult);
S
S		void gmiscArrayDivide(ArrayDataFormat fmt, void *src, void *dst, size_t cnt, int mdiv);
S
S		void gmiscArrayMultDiv(ArrayDataFormat fmt, void *src, void *dst, size_t cnt, int mult, int div);
S
S		void gmiscArrayAdd(ArrayDataFormat fmt, void *src1, void *src2, void *dst, size_t cnt);
S
S		void gmiscArrayAddNoOverflow(ArrayDataFormat fmt, void *src1, void *src2, void *dst, size_t cnt);
S	#endif
S#endif
S
S#if GMISC_NEED_FASTTRIG || defined(__DOXYGEN__)
S		extern const double sintabledouble[];
S
S		/**
S		 * @brief	Fast Table Based Trig functions
S		 * @return	A double in the range -1.0 .. 0.0 .. 1.0
S		 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_FASTTRIG
S		 *
S		 * @param[in] degrees	The angle in degrees (not radians)
S		 *
S		 * @note	These functions use degrees rather than radians to describe the angle.
S		 *
S		 * @api
S		 * @{
S		 */
S		double fsin(int degrees);
S		double fcos(int degrees);
S		/** @}
S		 *
S		 * @brief	Fast Table Based Trig functions
S		 * @return	A double in the range -1.0 .. 0.0 .. 1.0
S		 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_FASTTRIG
S		 *
S		 * @param[in] degrees	The angle in degrees 0 .. 359
S		 *
S		 * @note	These functions use degrees rather than radians to describe the angle.
S		 * @note	These functions are super fast but require the parameter to be in range.
S		 * 			Use the lowercase functions if the parameter may not be in range or if a
S		 * 			required trig function is not supported in this form.
S		 *
S		 * @api
S		 * @{
S		 */
S		#define FSIN(degrees) 	sintabledouble[degrees];
S		/** @} */
S#endif
S
S#if GMISC_NEED_FIXEDTRIG || defined(__DOXYGEN__)
S		extern const fixed sintablefixed[];
S
S		/**
S		 * @brief	Fast Table Based Trig functions
S		 * @return	A fixed point in the range -1.0 .. 0.0 .. 1.0
S		 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_FIXEDTRIG
S		 *
S		 * @param[in] degrees	The angle in degrees (not radians)
S		 *
S		 * @note	These functions use degrees rather than radians to describe the angle.
S		 *
S		 * @api
S		 * @{
S		 */
S		fixed ffsin(int degrees);
S		fixed ffcos(int degrees);
S		/** @}
S		 *
S		 * @brief	Fast Table Based Trig functions
S		 * @return	A fixed point in the range -1.0 .. 0.0 .. 1.0
S		 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_FIXEDTRIG
S		 *
S		 * @param[in] degrees	The angle in degrees 0 .. 359
S		 *
S		 * @note	These functions use degrees rather than radians to describe the angle.
S		 * @note	These functions are super fast but require the parameter to be in range.
S		 * 			Use the lowercase functions if the parameter may not be in range or if a
S		 * 			required trig function is not supported in this form.
S		 *
S		 * @api
S		 * @{
S		 */
S		#define FFSIN(degrees) 	sintablefixed[degrees];
S		/** @} */
S#endif
S
S#if GMISC_NEED_INVSQRT || defined(__DOXYGEN__)
S		/**
S		 * @brief	Fast inverse square root function (x^-1/2)
S		 * @return	The approximate inverse square root
S		 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_INVSQRT
S		 *
S		 * @param[in] n	The number to find the inverse square root of
S		 *
S		 * @note	This function generates an approximate result. Higher accuracy (at the expense
S		 * 			of speed) can be obtained by modifying the source code (the necessary line
S		 * 			is already there - just commented out).
S		 * @note	This function relies on the internal machine format of a float and a long.
S		 * 			If your machine architecture is very unusual this function may not work.
S		 *
S		 * @api
S		 */
S		float invsqrt(float n);
S#endif
S
S#if GMISC_NEED_MATRIXFLOAT2D || defined(__DOXYGEN__)
S
S	/**
S	 * @brief	A matrix for doing 2D graphics using floats
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFLOAT2D
S	 */
S	typedef struct MatrixFloat2D {
S		float	a00, a01, a02;
S		float	a10, a11, a12;
S		float	a20, a21, a22;
S	} MatrixFloat2D;
S
S	/**
S	 * @brief	Apply the matrix to a set of points
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFLOAT2D
S	 *
S	 * @param[in] dst	The destination array of points
S	 * @param[in] src	The source array of points
S	 * @param[in] m		The matrix to apply
S	 * @param[in] cnt	How many points are in the array
S	 *
S	 * @note	In-place matrix application is allowed ie. dst = src
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFloat2DApplyToPoints(point *dst, const point *src, const MatrixFloat2D *m, int cnt);
S
S	/**
S	 * @brief	Set the 2D matrix to the identity matrix
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFLOAT2D
S	 *
S	 * @param[in] m		The matrix to set to identity
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFloat2DSetIdentity(MatrixFloat2D *m);
S
S	/**
S	 * @brief	Multiple two 2D matrixes together
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFLOAT2D
S	 *
S	 * @param[in] dst	The destination matrix
S	 * @param[in] src1	The first source matrix
S	 * @param[in] src2	The second source matrix
S	 *
S	 * @note	In-place matrix application is NOT allowed ie. dst != src1, dst != src2
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFloat2DMultiply(MatrixFloat2D *dst, const MatrixFloat2D *src1, const MatrixFloat2D *src2);
S
S	/**
S	 * @brief	Add an x,y translation to a matrix
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFLOAT2D
S	 *
S	 * @param[in] dst		The destination matrix
S	 * @param[in] src		The source matrix. Can be NULL
S	 * @param[in] tx, ty	The x and y translation to apply
S	 *
S	 * @note	In-place matrix operation is NOT allowed ie. dst != src
S	 * @note	If no source matrix is provided, it is equivalent to applying the operation
S	 * 			to an identity matrix. It also is a much simpler operation requiring no multiplication.
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFloat2DApplyTranslation(MatrixFloat2D *dst, const MatrixFloat2D *src, float tx, float ty);
S
S	/**
S	 * @brief	Add x,y scaling to a matrix
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFLOAT2D
S	 *
S	 * @param[in] dst		The destination matrix
S	 * @param[in] src		The source matrix. Can be NULL
S	 * @param[in] sx, sy	The scaling to apply in the x and y direction. Negative numbers give reflection.
S	 *
S	 * @note	In-place matrix operation is NOT allowed ie. dst != src
S	 * @note	If no source matrix is provided, it is equivalent to applying the operation
S	 * 			to an identity matrix. It also is a much simpler operation requiring no multiplication.
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFloat2DApplyScale(MatrixFloat2D *dst, const MatrixFloat2D *src, float sx, float sy);
S
S	/**
S	 * @brief	Add x,y shear to a matrix
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFLOAT2D
S	 *
S	 * @param[in] dst		The destination matrix
S	 * @param[in] src		The source matrix. Can be NULL
S	 * @param[in] sx, sy	The shear to apply in the x and y direction.
S	 *
S	 * @note	In-place matrix operation is NOT allowed ie. dst != src
S	 * @note	If no source matrix is provided, it is equivalent to applying the operation
S	 * 			to an identity matrix. It also is a much simpler operation requiring no multiplication.
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFloat2DApplyShear(MatrixFloat2D *dst, const MatrixFloat2D *src, float sx, float sy);
S
S	/**
S	 * @brief	Add rotation to a matrix
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFLOAT2D
S	 *
S	 * @param[in] dst		The destination matrix
S	 * @param[in] src		The source matrix. Can be NULL
S	 * @param[in] angle		The angle to apply in degrees (not radians).
S	 *
S	 * @note	In-place matrix operation is NOT allowed ie. dst != src
S	 * @note	If no source matrix is provided, it is equivalent to applying the operation
S	 * 			to an identity matrix. It also is a much simpler operation.
S	 * @note	If GMISC_NEED_FASTTRIG is defined then the fast table sin and cos lookup's will be used
S	 * 			rather than the C library versions.
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFloat2DApplyRotation(MatrixFloat2D *dst, const MatrixFloat2D *src, int angle);
S#endif
S
S#if GMISC_NEED_MATRIXFIXED2D || defined(__DOXYGEN__)
S
S	/**
S	 * @brief	A matrix for doing 2D graphics using fixed point maths
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFIXED2D
S	 */
S	typedef struct MatrixFixed2D {
S		fixed	a00, a01, a02;
S		fixed	a10, a11, a12;
S		fixed	a20, a21, a22;
S	} MatrixFixed2D;
S
S	/**
S	 * @brief	Apply the matrix to a set of points
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFIXED2D
S	 *
S	 * @param[in] dst	The destination array of points
S	 * @param[in] src	The source array of points
S	 * @param[in] m		The matrix to apply
S	 * @param[in] cnt	How many points are in the array
S	 *
S	 * @note	In-place matrix application is allowed ie. dst = src
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFixed2DApplyToPoints(point *dst, const point *src, const MatrixFixed2D *m, int cnt);
S
S	/**
S	 * @brief	Set the 2D matrix to the identity matrix
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFIXED2D
S	 *
S	 * @param[in] m		The matrix to set to identity
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFixed2DSetIdentity(MatrixFixed2D *m);
S
S	/**
S	 * @brief	Multiple two 2D matrixes together
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFIXED2D
S	 *
S	 * @param[in] dst	The destination matrix
S	 * @param[in] src1	The first source matrix
S	 * @param[in] src2	The second source matrix
S	 *
S	 * @note	In-place matrix application is NOT allowed ie. dst != src1, dst != src2
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFixed2DMultiply(MatrixFixed2D *dst, const MatrixFixed2D *src1, const MatrixFixed2D *src2);
S
S	/**
S	 * @brief	Add an x,y translation to a matrix
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFIXED2D
S	 *
S	 * @param[in] dst		The destination matrix
S	 * @param[in] src		The source matrix. Can be NULL
S	 * @param[in] tx, ty	The x and y translation to apply
S	 *
S	 * @note	In-place matrix operation is NOT allowed ie. dst != src
S	 * @note	If no source matrix is provided, it is equivalent to applying the operation
S	 * 			to an identity matrix. It also is a much simpler operation requiring no multiplication.
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFixed2DApplyTranslation(MatrixFixed2D *dst, const MatrixFixed2D *src, fixed tx, fixed ty);
S
S	/**
S	 * @brief	Add x,y scaling to a matrix
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFIXED2D
S	 *
S	 * @param[in] dst		The destination matrix
S	 * @param[in] src		The source matrix. Can be NULL
S	 * @param[in] sx, sy	The scaling to apply in the x and y direction. Negative numbers give reflection.
S	 *
S	 * @note	In-place matrix operation is NOT allowed ie. dst != src
S	 * @note	If no source matrix is provided, it is equivalent to applying the operation
S	 * 			to an identity matrix. It also is a much simpler operation requiring no multiplication.
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFixed2DApplyScale(MatrixFixed2D *dst, const MatrixFixed2D *src, fixed sx, fixed sy);
S
S	/**
S	 * @brief	Add x,y shear to a matrix
S	 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFIXED2D
S	 *
S	 * @param[in] dst		The destination matrix
S	 * @param[in] src		The source matrix. Can be NULL
S	 * @param[in] sx, sy	The shear to apply in the x and y direction.
S	 *
S	 * @note	In-place matrix operation is NOT allowed ie. dst != src
S	 * @note	If no source matrix is provided, it is equivalent to applying the operation
S	 * 			to an identity matrix. It also is a much simpler operation requiring no multiplication.
S	 *
S	 * @api
S	 */
S	void gmiscMatrixFixed2DApplyShear(MatrixFixed2D *dst, const MatrixFixed2D *src, fixed sx, fixed sy);
S
S	#if GMISC_NEED_FIXEDTRIG || defined(__DOXYGEN__)
S		/**
S		 * @brief	Add rotation to a matrix
S		 * @pre		Requires GFX_USE_GMISC and GMISC_NEED_MATRIXFIXED2D and GMISC_NEED_FIXEDTRIG
S		 *
S		 * @param[in] dst		The destination matrix
S		 * @param[in] src		The source matrix. Can be NULL
S		 * @param[in] angle		The angle to apply in degrees (not radians).
S		 *
S		 * @note	In-place matrix operation is NOT allowed ie. dst != src
S		 * @note	If no source matrix is provided, it is equivalent to applying the operation
S		 * 			to an identity matrix. It also is a much simpler operation requiring no multiplication.
S		 *
S		 * @api
S		 */
S		void gmiscMatrixFixed2DApplyRotation(MatrixFixed2D *dst, const MatrixFixed2D *src, int angle);
S	#endif
S#endif
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* GFX_USE_MISC */
N
N#endif /* _GMISC_H */
N/** @} */
N
L 204 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gtrans/gtrans.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gtrans/gtrans.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gtrans/gtrans.h
N *
N * @addtogroup GTRANS
N *
N * @brief	Module that allows changing the language of an application dynamically during run-time.
N *
N * @{
N */
N
N#ifndef _TRANS_H
N#define _TRANS_H
N
N#include "../../gfx.h"
N
N#if GFX_USE_GTRANS || defined(__DOXYGEN__)
X#if 0 || 0L
S
S/**
S * @struct transTable
S * @brief A table containing translated strings.
S */
Stypedef struct transTable {
S	unsigned numEntries;    /**< The number of strings that this table contains */
S	const char** strings;	/**< The translated strings */
S} transTable;
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/**
S * @brief A wrapper macro to make writing and reading translatable applications easier.
S */
S#define gt(str) gtransString(str)
S
S/**
S * @brief Get the string of the current language specified by the string of the base language.
S *
S * @details This function will return the string of the current language that corresponds to
S *			the specified string in the base language.
S * @details This function uses strcmp() internally to compare strings.
S *
S * @param[in] string The string to translate.
S *
S * @return The corresponding string of the current language or the string passed as a parameter if it doesn't exist.
S */
Sconst char* gtransString(const char* string);
S
S/**
S * @brief Get the string at the specified index position of the current language.
S *
S * @details Getting translation strings is a lot faster using the index as an accessor rather
S *          than the string in the base language.
S *
S * @param[in] index The index of the string in the current language translation table.
S *
S * @return The string at the given index of the current language or 0 if it doesn't exist.
S */
Sconst char* gtransIndex(unsigned index);
S
S/**
S * @brief Set the base language.
S *
S * @details A translatable application needs to have a base language. All translations will
S *          be relative to this base language.
S *
S * @param[in] translation The translation table
S */
Svoid gtransSetBaseLanguage(const transTable* const translation);
S
S/**
S * @brief Set the current language.
S *
S * @details All translations will refer to the current language set by calling this function.
S *
S * @param[in] translation The translation table
S */
Svoid gtransSetLanguage(const transTable* const translation);
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* GFX_USE_GTRANS */
N
N#endif /* _TRANS_H */
N/** @} */
L 205 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gqueue/gqueue.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gqueue/gqueue.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gqueue/gqueue.h
N * @brief   GQUEUE header file.
N *
N * @addtogroup GQUEUE
N *
N * @brief	Module which provides queue management (only internally used)
N *
N * @details	There are 3 types of queues:
N * 			<ul><li><b>Asynchronous Queues (ASync) </b> - Queue operations never block</li>
N * 				<li><b>Get Synchronous Queues (GSync) </b> - Queue Get operations block until something is placed in the Queue</li>
N * 				<li><b>Put Synchronous Queues (PSync)</b> - Queue Put operations block until the element is removed from the Queue</li>
N * 				<li><b>Fully Synchronous Queues (FSync)</b> - Queue GET and Put operations block</li>
N * 			</ul>
N * 			We need 4 types of queues even though fully synchronous queues support all operations including asynchronous
N * 			operations because fully synchronous queues have the highest storage requirements. The other queue types are
N * 			optimizations. Efficiency IS important to use (particularly RAM efficiency).
N * 			In practice we only implement ASync, GSync and FSync queues as PSync queues are of dubious value.
N * 			<br>
N * 			We also define GDataBuffer which is a data buffer that supports being queued.
N * @{
N */
N
N#ifndef _GQUEUE_H
N#define _GQUEUE_H
N
N#if GFX_USE_GQUEUE || defined(__DOXYGEN__)
X#if 0 || 0L
S
S/**
S * @brief	A queue item
S * @{
S */
Stypedef struct gfxQueueASyncItem {
S	struct gfxQueueASyncItem	*next;
S} gfxQueueASyncItem, gfxQueueGSyncItem;
S
Stypedef struct gfxQueueFSyncItem {
S	struct gfxQueueFSyncItem	*next;
S	gfxSem						sem;
S} gfxQueueFSyncItem;
S/** @} */
S
S/**
S * @brief	A queue
S * @{
S */
Stypedef struct gfxQueueASync {
S	gfxQueueASyncItem	*head;
S	gfxQueueASyncItem	*tail;
S} gfxQueueASync;
S
Stypedef struct gfxQueueGSync {
S	gfxQueueGSyncItem	*head;
S	gfxQueueGSyncItem	*tail;
S	gfxSem				sem;
S} gfxQueueGSync;
S
Stypedef struct gfxQueueFSync {
S	gfxQueueFSyncItem	*head;
S	gfxQueueFSyncItem	*tail;
S	gfxSem				sem;
S} gfxQueueFSync;
S/** @} */
S
S/**
S * @brief	A Data Buffer Queue
S * @note	This structure is followed immediately by the data itself.
S * 			When allocating the buffers for the data put this structure
S * 			at the beginning of the buffer.
S */
Stypedef struct GDataBuffer {
S	gfxQueueGSyncItem	next;		// @< Used for queueing the buffers
S	size_t				size;		// @< The size of the buffer area following this structure (in bytes)
S	size_t				len;		// @< The length of the data in the buffer area (in bytes)
S} GDataBuffer;
S
S/*===========================================================================*/
S/* Function declarations.                                                    */
S/*===========================================================================*/
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/**
S * @name	Initialisation functions
S * @brief	Initialise a queue.
S *
S * @param[in]	pqueue	A pointer to the queue
S *
S * @note	Whilst queues are normally FIFO, a GFX queue also supports push and pop operations.
S * 			A pop operation is the same as normal get from the queue but a push places the item
S * 			at the head of the queue instead of the tail (as a put would).
S *
S * @api
S * @{
S */
Svoid gfxQueueASyncInit(gfxQueueASync *pqueue);
Svoid gfxQueueGSyncInit(gfxQueueGSync *pqueue);
Svoid gfxQueueFSyncInit(gfxQueueFSync *pqueue);
S/** @} */
S
S/**
S * @name	Deinitialisation functions
S * @brief	De-Initialise a queue.
S *
S * @param[in]	pqueue	A pointer to the queue
S *
S * @api
S * @{
S */
S#define gfxQueueASyncDeinit(pqueue)
Svoid gfxQueueGSyncDeinit(gfxQueueGSync *pqueue);
Svoid gfxQueueFSyncDeinit(gfxQueueFSync *pqueue);
S/** @} */
S
S/**
S * @name	Get() Functions
S * @brief	Get an item from the head of the queue (and remove it from the queue).
S * @return	NULL if the timeout expires before an item is available
S *
S * @param[in]	pqueue	A pointer to the queue
S * @param[in]	ms		The maxmimum time to wait for an item. For ASync queues this parameter is
S * 						not specified as TIME_IMMEDIATE is assumed.
S *
S * @note		The routines ending in "I" are interrupt/system/iclass level routines.
S *
S * @api
S * @{
S */
SgfxQueueASyncItem *gfxQueueASyncGet(gfxQueueASync *pqueue);
SgfxQueueASyncItem *gfxQueueASyncGetI(gfxQueueASync *pqueue);
SgfxQueueGSyncItem *gfxQueueGSyncGet(gfxQueueGSync *pqueue, delaytime_t ms);
SgfxQueueGSyncItem *gfxQueueGSyncGetI(gfxQueueGSync *pqueue);
SgfxQueueFSyncItem *gfxQueueFSyncGet(gfxQueueFSync *pqueue, delaytime_t ms);
S/** @} */
S
S/**
S * @name	Put() Functions
S * @brief	Put an item on the end of the queue.
S * @return	none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE
S *
S * @param[in]	pqueue	A pointer to the queue
S * @param[in]	pitem	A pointer to the queue item
S * @param[in]	ms		The maxmimum time to wait for an item to be removed from the queue (only for FSync queues)
S *
S * @note		FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the
S * 				item is removed from the queue. Note that even if the timeout occurs - the item
S * 				remains in the queue.
S * @note		The routines ending in "I" are interrupt/system/iclass level routines.
S *
S * @api
S * @{
S */
Svoid gfxQueueASyncPut(gfxQueueASync *pqueue, gfxQueueASyncItem *pitem);
Svoid gfxQueueASyncPutI(gfxQueueASync *pqueue, gfxQueueASyncItem *pitem);
Svoid gfxQueueGSyncPut(gfxQueueGSync *pqueue, gfxQueueGSyncItem *pitem);
Svoid gfxQueueGSyncPutI(gfxQueueGSync *pqueue, gfxQueueGSyncItem *pitem);
Sbool_t gfxQueueFSyncPut(gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem, delaytime_t ms);
S/** @} */
S
S/**
S * @name	Pop() Functions
S * @brief	Pop an item from the head of the queue (and remove it from the queue).
S * @details	This is exactly the same as the Get operation above.
S *
S * @api
S * @{
S */
S#define gfxQueueASyncPop(pqueue)			gfxQueueASyncGet(pqueue)
S#define gfxQueueASyncPopI(pqueue)			gfxQueueASyncGetI(pqueue)
S#define gfxQueueGSyncPop(pqueue, ms)		gfxQueueGSyncGet(pqueue, ms)
S#define gfxQueueFSyncPop(pqueue, ms)		gfxQueueFSyncGet(pqueue, ms)
S/** @} */
S
S/**
S * @name	Push() Functions
S * @brief	Push an item into the start of the queue.
S * @return	none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE
S *
S * @param[in]	pqueue	A pointer to the queue
S * @param[in]	pitem	A pointer to the queue item
S * @param[in]	ms		The maxmimum time to wait for an item to be popped (only for FSync queues)
S *
S * @note		FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the
S * 				item is removed from the queue. Note that even if the timeout occurs - the item
S * 				remains in the queue.
S * @note		The routines ending in "I" are interrupt/system/iclass level routines.
S *
S * @api
S * @{
S */
Svoid gfxQueueASyncPush(gfxQueueASync *pqueue, gfxQueueASyncItem *pitem);
Svoid gfxQueueASyncPushI(gfxQueueASync *pqueue, gfxQueueASyncItem *pitem);
Svoid gfxQueueGSyncPush(gfxQueueGSync *pqueue, gfxQueueGSyncItem *pitem);
Svoid gfxQueueGSyncPushI(gfxQueueGSync *pqueue, gfxQueueGSyncItem *pitem);
Sbool_t gfxQueueFSyncPush(gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem, delaytime_t ms);
S/** @} */
S
S/**
S * @name	Insert() Functions
S * @brief	Insert an item on the queue after the specified item.
S * @return	none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE
S *
S * @param[in]	pqueue	A pointer to the queue
S * @param[in]	pitem	A pointer to the queue item
S * @param[in]	pafter	A pointer to the queue item this new item must be inserted after. If NULL or
S * 							pafter can't be found in the queue, it puts the new item at the end of the queue.
S * @param[in]	ms		The maxmimum time to wait for an item to be removed from the queue (only for FSync queues)
S *
S * @note		FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the
S * 				item is removed from the queue. Note that even if the timeout occurs - the item
S * 				remains in the queue.
S * @note		The routines ending in "I" are interrupt/system/iclass level routines.
S *
S * @api
S * @{
S */
Svoid gfxQueueASyncInsert(gfxQueueASync *pqueue, gfxQueueASyncItem *pitem, gfxQueueASyncItem *pafter);
Svoid gfxQueueASyncInsertI(gfxQueueASync *pqueue, gfxQueueASyncItem *pitem, gfxQueueASyncItem *pafter);
Svoid gfxQueueGSyncInsert(gfxQueueGSync *pqueue, gfxQueueGSyncItem *pitem, gfxQueueASyncItem *pafter);
Svoid gfxQueueGSyncInsertI(gfxQueueGSync *pqueue, gfxQueueGSyncItem *pitem, gfxQueueASyncItem *pafter);
Sbool_t gfxQueueFSyncInsert(gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem, gfxQueueASyncItem *pafter, delaytime_t ms);
S/** @} */
S
S/**
S * @name	Remove() Functions
S * @brief	Remove an item from the queue.
S * @note	Removes the specified item from the queue where-ever it is in the queue
S *
S * @param[in]	pqueue	A pointer to the queue
S * @param[in]	pitem	A pointer to the queue item
S *
S * @note	If the item isn't in the queue the routine just returns.
S * @note	If a process is waiting on the Put/Push operation for the item, that process
S * 			will be signaled.
S * @note	The routines ending in "I" are interrupt/system/iclass level routines.
S *
S * @api
S * @{
S */
Svoid gfxQueueASyncRemove(gfxQueueASync *pqueue, gfxQueueASyncItem *pitem);
Svoid gfxQueueASyncRemoveI(gfxQueueASync *pqueue, gfxQueueASyncItem *pitem);
Svoid gfxQueueGSyncRemove(gfxQueueGSync *pqueue, gfxQueueGSyncItem *pitem);
Svoid gfxQueueGSyncRemoveI(gfxQueueGSync *pqueue, gfxQueueGSyncItem *pitem);
Svoid gfxQueueFSyncRemove(gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem);
S/** @} */
S
S/**
S * @name	isEmpty() Functions
S * @brief	Is the queue empty?
S * @return	TRUE if the queue is empty
S *
S * @param[in]	pqueue	A pointer to the queue
S *
S * @note	The routines ending in "I" are interrupt/system/iclass level routines.
S *
S * @api
S * @{
S */
S#define gfxQueueASyncIsEmpty(pqueue)		((pqueue)->head == 0)
S#define gfxQueueASyncIsEmptyI(pqueue)		((pqueue)->head == 0)
S#define gfxQueueGSyncIsEmpty(pqueue)		((pqueue)->head == 0)
S#define gfxQueueGSyncIsEmptyI(pqueue)		((pqueue)->head == 0)
S#define gfxQueueFSyncIsEmpty(pqueue)		((pqueue)->head == 0)
S#define gfxQueueFSyncIsEmptyI(pqueue)		((pqueue)->head == 0)
S/** @} */
S
S/**
S * @name	IsInQueue() Functions
S * @brief	Is an item in the queue?
S * @return	TRUE if the item is in the queue?
S *
S * @param[in]	pqueue	A pointer to the queue
S * @param[in]	pitem	A pointer to the queue item
S *
S * @note	This operation may be expensive.
S * @note	The routines ending in "I" are interrupt/system/iclass level routines.
S *
S * @api
S * @{
S */
Sbool_t gfxQueueASyncIsIn(gfxQueueASync *pqueue, const gfxQueueASyncItem *pitem);
Sbool_t gfxQueueASyncIsInI(gfxQueueASync *pqueue, const gfxQueueASyncItem *pitem);
Sbool_t gfxQueueGSyncIsIn(gfxQueueGSync *pqueue, const gfxQueueGSyncItem *pitem);
Sbool_t gfxQueueGSyncIsInI(gfxQueueGSync *pqueue, const gfxQueueGSyncItem *pitem);
Sbool_t gfxQueueFSyncIsIn(gfxQueueFSync *pqueue, const gfxQueueFSyncItem *pitem);
Sbool_t gfxQueueFSyncIsInI(gfxQueueFSync *pqueue, const gfxQueueFSyncItem *pitem);
S/** @} */
S
S/**
S * @name	Peek() Functions
S * @brief	Get the first item from the head of the queue but do not remove it from the queue.
S * @return	NULL if no item is available.
S *
S * @param[in]	pqueue	A pointer to the queue
S *
S * @note	This call does not block.
S * @note	This can be used as the first call to iterate all the elements in the queue.
S * @note	As that item is still on the queue, it should be treated as read-only. It could
S * 			also be removed from the queue at any time by another thread (thereby altering the
S * 			queue item).
S * @note	The routines ending in "I" are interrupt/system/iclass level routines.
S *
S * @api
S * @{
S */
S#define gfxQueueASyncPeek(pqueue)	((const gfxQueueASyncItem *)((pqueue)->head))
S#define gfxQueueASyncPeekI(pqueue)	((const gfxQueueASyncItem *)((pqueue)->head))
S#define gfxQueueGSyncPeek(pqueue)	((const gfxQueueGSyncItem *)((pqueue)->head))
S#define gfxQueueGSyncPeekI(pqueue)	((const gfxQueueGSyncItem *)((pqueue)->head))
S#define gfxQueueFSyncPeek(pqueue)	((const gfxQueueFSyncItem *)((pqueue)->head))
S#define gfxQueueFSyncPeekI(pqueue)	((const gfxQueueFSyncItem *)((pqueue)->head))
S/** @} */
S
S/**
S * @name	Next() Functions
S * @brief	Get the next item in the queue (but do not remove it from the queue).
S * @return	NULL if no item is available.
S *
S * @param[in]	pitem	The previous item in the queue
S *
S * @note	This call does not block.
S * @note	This can be used as subsequent calls to iterate all the elements in the queue.
S * @note	As that item is still on the queue, it should be treated as read-only. It could
S * 			also be removed from the queue at any time by another thread (thereby altering the
S * 			queue item).
S * @note	The routines ending in "I" are interrupt/system/iclass level routines.
S *
S * @api
S * @{
S */
S#define gfxQueueASyncNext(pitem)	((const gfxQueueASyncItem *)((pitem)->next))
S#define gfxQueueASyncNextI(pitem)	((const gfxQueueASyncItem *)((pitem)->next))
S#define gfxQueueGSyncNext(pitem)	((const gfxQueueGSyncItem *)((pitem)->next))
S#define gfxQueueGSyncNextI(pitem)	((const gfxQueueGSyncItem *)((pitem)->next))
S#define gfxQueueFSyncNext(pitem)	((const gfxQueueFSyncItem *)((pitem)->next))
S#define gfxQueueFSyncNextI(pitem)	((const gfxQueueFSyncItem *)((pitem)->next))
S/** @} */
S
S/**
S * @name		BufferAlloc() Functions
S * @brief		Allocate some buffers and put them on the free list
S * @return		TRUE is it succeeded. FALSE on allocation failure.
S *
S * @param[in] num	The number of buffers to allocate
S * @param[in] size	The size (in bytes) of each buffer
S *
S * @api
S * @{
S */
Sbool_t gfxBufferAlloc(unsigned num, size_t size);
S/** @} */
S
S/**
S * @name		BufferIsAvailable() Functions
S * @brief		Is there one or more buffers currently available on the free list
S * @return		TRUE if there are buffers in the free list
S *
S * @api
S * @{
S */
Sbool_t gfxBufferIsAvailable(void);
S/** @} */
S
S/**
S * @name		BufferGet() Functions
S * @brief		Get a buffer from the free list
S * @return		A GDataBuffer pointer or NULL if the timeout is exceeded
S *
S * @param[in] ms	The maximum amount of time in milliseconds to wait for a buffer if one is not available.
S *
S * @api
S * @{
S */
SGDataBuffer *gfxBufferGet(delaytime_t ms);
SGDataBuffer *gfxBufferGetI(void);
S/** @} */
S
S/**
S * @name		BufferRelease() Functions
S * @brief		Release a buffer back to the free list
S *
S * @param[in] pd		The buffer to put (back) on the free-list.
S *
S * @note		This call should be used to return any buffers that were taken from
S * 				the free-list once they have been finished with. It can also be used
S * 				to put new buffers onto the free-list. Just make sure the "size" field
S * 				of the GDataBuffer structure has been filled in first.
S *
S * @api
S * @{
S */
Svoid gfxBufferRelease(GDataBuffer *pd);
Svoid gfxBufferReleaseI(GDataBuffer *pd);
S/** @} */
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* GFX_USE_GQUEUE */
N#endif /* _GQUEUE_H */
N/** @} */
L 206 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gevent/gevent.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gevent/gevent.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gevent/gevent.h
N *
N * @addtogroup GEVENT
N *
N * @brief		Module to build a complete many-to-many event system
N * 
N * @details		GEVENT provides a simple to use but yet powerful event
N *				system.
N *
N * @pre			GFX_USE_GEVENT must be set to TRUE in your gfxconf.h
N *
N * @{
N */
N#ifndef _GEVENT_H
N#define _GEVENT_H
N
N#include "../../gfx.h"
N
N#if GFX_USE_GEVENT || defined(__DOXYGEN__)
X#if 0 || 0L
S
S/*===========================================================================*/
S/* Type definitions                                                          */
S/*===========================================================================*/
S
Stypedef uint16_t						GEventType;
S		#define GEVENT_NULL				0x0000				// Null Event - Do nothing
S		#define GEVENT_EXIT				0x0001				// The listener is being forced to exit (someone is destroying the listener)
S		
S		/* Other event types are allocated in ranges in their respective include files */
S		#define GEVENT_GINPUT_FIRST		0x0100				// GINPUT events range from 0x0100 to 0x01FF
S		#define GEVENT_GWIN_FIRST		0x0200				// GWIN events range from 0x0200 to 0x02FF
S		#define GEVENT_GADC_FIRST		0x0300				// GADC events range from 0x0300 to 0x033F
S		#define GEVENT_GAUDIO_FIRST		0x0340				// GAUDIO events range from 0x0340 to 0x037F
S		#define GEVENT_USER_FIRST		0x8000				// Any application defined events start at 0x8000
S
S// This object can be typecast to any GEventXxxxx type to allow any sub-system (or the application) to create events.
S//	The prerequisite is that the new status structure type starts with a field named 'type' of type 'GEventType'.
S//	The total status structure also must not exceed GEVENT_MAXIMUM_SIZE bytes.
S//	For example, this is used by GWIN button events, GINPUT data streams etc.
Stypedef union GEvent_u {
S	GEventType			type;								// The type of this event
S	char				pad[GEVENT_MAXIMUM_SIZE];			// This is here to allow static initialisation of GEventObject's in the application.
S} GEvent;
S
S// A special callback function
Stypedef void (*GEventCallbackFn)(void *param, GEvent *pe);
S
S// The Listener Object
Stypedef struct GListener {
S	gfxSem				waitqueue;			// Private: Semaphore for the listener to wait on.
S	uint16_t			flags;				// Private: Flags for operation
S	GEventCallbackFn	callback;			// Private: Call back Function
S	void				*param;				// Private: Parameter for the callback function.
S	GEvent				event;				// Public:  The event object into which the event information is stored.
S	} GListener;
S
S// The Source Object
Stypedef struct GSource_t			GSource, *GSourceHandle;	
S
S// This structure is passed to a source to describe a contender listener for sending the current event.
Stypedef struct GSourceListener_t {
S	GListener		*pListener;			// The listener
S	GSource			*pSource;			// The source
S	uint32_t		listenflags;		// The flags the listener passed when the source was assigned to it.
S	uint32_t		srcflags;			// For the source's exclusive use. Initialised as 0 for a new listener source assignment.
S	} GSourceListener;
S
S/*===========================================================================*/
S/* External declarations.                                                    */
S/*===========================================================================*/
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/* How to listen for events (act as a Listener)...
S	1. Get handles for all the event sources you are interested in.
S	2. Initialise a listener
S	3. Attach sources to your listener.
S		- Sources can be attached or detached from a listener at any time.
S		- A source can be attached to more than one listener.
S	4. Loop on getting listener events
S	5. When finished detach all sources from the listener
S	
S	How to create events (act as a Source)...
S	1. Provide a funtion to the application that returns a GSourceHandle (which can be a pointer to whatever the source wants)
S	2. Whenever a possible event occurs call geventGetSourceListener to get a pointer to a GSourceListener.
S			This will return NULL when there are no more listeners.
S			For each listener	- check the flags to see if an event should be sent.
S								- use geventGetEvent() to get the event buffer supplied by the listener
S									and then call geventSendEvent to send the event.
S								- Note: geventGetEvent() may return FALSE to indicate the listener is currently not listening and
S									therefore no event should be sent. This situation enables the source to (optionally) flag
S									to the listener on its next wait that there have been missed events.
S								- Note: The GSourceListener pointer (and the GEvent buffer) are only valid between
S									the geventGetSourceListener call and either the geventSendEvent call or the next
S									geventGetSourceListener call.
S								- Note: All listeners must be processed for this event before anything else is processed.
S*/
S
S/*---------- Listener Functions --------------------------------------------*/
S
S/**
S * @brief	Create a Listener
S * @details	If insufficient resources are available it will either assert or return NULL
S *			depending on the value of GEVENT_ASSERT_NO_RESOURCE.
S *
S * @param[in] pl	A listener
S */
Svoid geventListenerInit(GListener *pl);
S
S/**
S * @brief 	Attach a source to a listener
S * @details	Flags are interpreted by the source when generating events for each listener.
S *			If this source is already assigned to the listener it will update the flags.
S *			If insufficient resources are available it will either assert or return FALSE
S *			depending on the value of GEVENT_ASSERT_NO_RESOURCE.
S *
S * @param[in] pl	The listener
S * @param[in] gsh	The source which has to be attached to the listener
S * @param[in] flags	The flags
S *
S * @return TRUE if succeeded, FALSE otherwise
S */
Sbool_t geventAttachSource(GListener *pl, GSourceHandle gsh, uint32_t flags);
S
S/**
S * @brief	Detach a source from a listener
S * @details	If gsh is NULL detach all sources from this listener and if there is still
S *			a thread waiting for events on this listener, it is sent the exit event.
S *
S * @param[in] pl	The listener
S * @param[in] gsh	The source
S */
Svoid geventDetachSource(GListener *pl, GSourceHandle gsh);
S
S/**
S * @brief	Wait for an event on a listener from an assigned source.
S * @details	The type of the event should be checked (pevent->type) and then pevent should
S *			be typecast to the actual event type if it needs to be processed.
S * 			timeout specifies the time to wait in system ticks.
S *			TIME_INFINITE means no timeout - wait forever for an event.
S *			TIME_IMMEDIATE means return immediately
S * @note	The returned GEvent is released when this routine is called again
S * 			or when optionally @p geventEventComplete() is called. Calling @p geventEventComplete()
S * 			allows the GEvent object to be reused earlier which can reduce missed events. The GEvent
S * 			object MUST NOT be used after this function is called (and is blocked waiting for the next
S * 			event) or after geventEventComplete() is called.
S *
S * @param[in] pl		The listener
S * @param[in] timeout	The timeout
S *
S * @return	NULL on timeout
S */
SGEvent *geventEventWait(GListener *pl, delaytime_t timeout);
S
S/**
S * @brief	Release the GEvent buffer associated with a listener.
S * @details	The GEvent returned by @p geventEventWait() is released.
S * @note	The GEvent pointer returned by @p geventEventWait() is released when @p geventEventWait()
S * 			is called again or when this function is called. The GEvent
S * 			object MUST NOT be used after this function is called.
S *
S * @param[in] pl		The listener
S */
Svoid geventEventComplete(GListener *pl);
S
S/* @brief	Register a callback for an event on a listener from an assigned source.
S * @details	The type of the event should be checked (pevent->type) and then pevent should be typecast to the
S *			actual event type if it needs to be processed.
S *
S * @params[in] pl		The Listener
S * @params[in] fn		The function to call back
S * @params[in] param	A parameter to pass the callback function
S *
S * @note	The GEvent buffer is valid only during the time of the callback. The callback MUST NOT save
S * 			a pointer to the buffer for use outside the callback.
S * @note	An existing callback function is de-registered by passing a NULL for 'fn'. Any existing
S * 			callback function is replaced. Any thread currently waiting using geventEventWait will be sent the exit event.
S * @note	Callbacks occur in a thread context but stack space must be kept to a minumum and
S * 			the callback must process quickly as all other events are performed on a single thread.
S * @note	In the callback function you should never call ANY event functions using your own GListener handle
S * 			as it WILL create a deadlock and lock the system up.
S * @note	Applications should not use this call - geventEventWait() is the preferred mechanism for an
S * 			application. This call is provided for GUI objects that may not have their own thread.
S */
Svoid geventRegisterCallback(GListener *pl, GEventCallbackFn fn, void *param);
S
S/*---------- Source Functions --------------------------------------------*/
S
S/**
S * @brief	Called by a source with a possible event to get a listener record.
S * @details	@p lastlr should be NULL on the first call and thereafter the result of the previous call.
S *
S * @param[in] gsh		The source handler
S * @param[in] lastlr	The source listener
S *
S * @return	NULL when there are no more listeners for this source
S */
SGSourceListener *geventGetSourceListener(GSourceHandle gsh, GSourceListener *lastlr);
S
S/**
S * @brief	Get the event buffer from the GSourceListener.
S * @details	A NULL return allows the source to record (perhaps in glr->scrflags) that the listener
S *			has missed events. This can then be notified as part of the next event for the listener.
S *			The buffer can only be accessed untill the next call to geventGetSourceListener
S *			or geventSendEvent
S *
S * @param[in] psl	The source listener
S *
S * @return	NULL if the listener is not currently listening.
S */
SGEvent *geventGetEventBuffer(GSourceListener *psl);
S
S/** 
S * @brief	Called by a source to indicate the listener's event buffer has been filled.
S * @details	After calling this function the source must not reference in fields in the GSourceListener or the event buffer.
S *
S * @param[in] psl	The source listener
S */
Svoid geventSendEvent(GSourceListener *psl);
S
S/**
S * @brief	Detach any listener that has this source attached
S *
S * @param[in] gsh	The source handle
S */
Svoid geventDetachSourceListeners(GSourceHandle gsh);
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* GFX_USE_GEVENT */
N
N#endif /* _GEVENT_H */
N/** @} */
N
L 207 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gtimer/gtimer.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gtimer/gtimer.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gtimer/gtimer.h
N *
N * @addtogroup GTIMER
N *
N * @brief	Module which provides software based timers for user-space applications
N *
N * @details	The reason why ChibiOS/GFX has it's own timer abstraction is because
N *			virtual timers provided by ChibiOS/RT are interrupt context only.
N *			While great for what they are designed for, they make coding of the input
N *			drivers much more complex.
N *			For non-performance critical drivers like these input drivers,  it would also
N *			hog an in-ordinate amount of critical (interrupt locked) system time.
N *			This contrary to the goals of a real-time operating system. So a user-land
N *			(thread based) timer mechanism is also required.
N *
N * @pre		GFX_USE_GTIMER must be set to TRUE in your gfxconf.h
N *
N * @{
N */
N
N#ifndef _GTIMER_H
N#define _GTIMER_H
N
N#include "../../gfx.h"
N
N#if GFX_USE_GTIMER || defined(__DOXYGEN__)
X#if 0 || 0L
S
S/*===========================================================================*/
S/* Type definitions                                                          */
S/*===========================================================================*/
S
S/* Data part of a static GTimer initialiser */
S#define _GTIMER_DATA() {0,0,0,0,0,0,0}
S
S/* Static GTimer initialiser */
S#define GTIMER_DECL(name) GTimer name = _GTIMER_DATA()
S
S/* A callback function (executed in a thread context) */
Stypedef void (*GTimerFunction)(void *param);
S
S/**
S * @brief	 A GTimer structure
S */
Stypedef struct GTimer_t {
S	GTimerFunction		fn;
S	void				*param;
S	systemticks_t		when;
S	systemticks_t		period;
S	uint16_t			flags;
S	struct GTimer_t		*next;
S	struct GTimer_t		*prev;
S} GTimer;
S
S/*===========================================================================*/
S/* External declarations.                                                    */
S/*===========================================================================*/
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/**
S * @brief   Initialise a timer
S *
S * @param[in] pt 	Pointer to a GTimer structure
S *
S * @api
S */
Svoid gtimerInit(GTimer* pt);
S
S/**
S * @brief	Deinitialise a timer
S *
S * @param[in] pt	Pointer to a GTimer structure
S *
S * @api
S */
Svoid gtimerDeinit(GTimer* pt);
S
S/**
S * @brief   Set a timer going or alter its properties if it is already going.
S *
S * @param[in] pt	Pointer to a GTimer structure
S * @param[in] fn		The callback function
S * @param[in] param		The parameter to pass to the callback function
S * @param[in] periodic	Is the timer a periodic timer? FALSE is a once-only timer.
S * @param[in] millisec	The timer period. The following special values are allowed:
S *							TIME_IMMEDIATE	causes the callback function to be called asap.
S *											A periodic timer with this value will fire once only.
S *							TIME_INFINITE	never timeout (unless triggered by gtimerJab or gtimerJabI)
S *
S * @note				If the timer is already active its properties are updated with the new parameters.
S *						The current period will be immediately canceled (without the callback function being
S *						called) and the timer will be restart with the new timer properties.
S * @note				The callback function should be careful not to over-run the thread stack.
S *						Define a new value for the macro GTIME_THREAD_STACK_SIZE if you want to
S *						change the default size.
S * @note				The callback function should return as quickly as possible as all
S *						timer callbacks are performed by a single thread. If a callback function
S *						takes too long it could affect the timer response for other timers.
S * @note				A timer callback function is not a replacement for a dedicated thread if the
S *						function wants to perform computationally expensive stuff.
S * @note				As the callback function is called on GTIMER's thread, the function must make sure it uses
S *						appropriate synchronisation controls such as semaphores or mutexes around any data
S *						structures it shares with other threads such as the main application thread.
S *
S * @api
S */
Svoid gtimerStart(GTimer *pt, GTimerFunction fn, void *param, bool_t periodic, delaytime_t millisec);
S
S/**
S * @brief   Stop a timer (periodic or otherwise)
S *
S * @param[in] pt		Pointer to a GTimer structure
S *
S * @note				If the timer is not active this does nothing.
S *
S * @api
S */
Svoid gtimerStop(GTimer *pt);
S
S/**
S * @brief   Test if a timer is currently active
S *
S * @param[in] pt		Pointer to a GTimer structure
S *
S * @return	TRUE if active, FALSE otherwise
S *
S * @api
S */
Sbool_t gtimerIsActive(GTimer *pt);
S
S/**
S * @brief   			Jab a timer causing the current period to immediate expire
S * @details				The callback function will be called as soon as possible.
S *
S * @pre					Use from a normal thread context.
S *
S * @param[in] pt		Pointer to a GTimer structure
S *
S * @note				If the timer is not active this does nothing.
S * @note				Repeated Jabs before the callback function actually happens are ignored.
S *
S * @api
S */
Svoid gtimerJab(GTimer *pt);
S
S/**
S * @brief   			Jab a timer causing the current period to immediate expire
S * @details				The callback function will be called as soon as possible.
S *
S * @pre					Use from an interrupt routine context.
S *
S * @param[in] pt		Pointer to a GTimer structure
S *
S * @note				If the timer is not active this does nothing.
S * @note				Repeated Jabs before the callback function actually happens are ignored.
S *
S * @iclass
S * @api
S */
Svoid gtimerJabI(GTimer *pt);
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* GFX_USE_GTIMER */
N
N#endif /* _GTIMER_H */
N/** @} */
N
L 208 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gdisp/gdisp.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gdisp/gdisp.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gdisp/gdisp.h
N * @brief   GDISP Graphic Driver subsystem header file.
N *
N * @addtogroup GDISP
N *
N * @brief		Module to interface graphic / pixel oriented displays
N *
N * @details		The GDISP module provides high level abstraction to interface pixel oriented graphic displays.
N *
N * @pre			GFX_USE_GDISP must be set to TRUE in gfxconf.h
N *
N * @note		Each drawing routine supports a gdispXXXX and a gdispGXXXX function. The difference is that the
N * 				gdispXXXX function does not require a display to be specified. Note there is a slight anomaly
N * 				in the naming with gdispGBlitArea() vs gdispBlitAreaEx() and gdispBlitArea(), the latter of
N * 				which is now deprecated.
N * @{
N */
N
N#ifndef _GDISP_H
N#define _GDISP_H
N
N#include "../../gfx.h"
N
N/* This type definition is defined here as it gets used in other gfx sub-systems even
N * if GFX_USE_GDISP is FALSE.
N */
N
N/**
N * @brief   The type for a coordinate or length on the screen.
N */
Ntypedef int16_t	coord_t;
N
N#if GFX_USE_GDISP || defined(__DOXYGEN__)
X#if -1 || 0L
N
N/*===========================================================================*/
N/* Type definitions                                                          */
N/*===========================================================================*/
N
N/**
N * @struct point
N * @brief   Type for a 2D point on the screen.
N */
Ntypedef struct point {
N	coord_t x;		/**< The x coordinate of the point. */
N	coord_t y;		/**< The y coordinate of the point. */
N} point, point_t;
N
N/**
N * @enum justify
N * @brief   Type for the text justification.
N */
Ntypedef enum justify {
N	justifyLeft = 0,		/**< Justify Left */
N	justifyCenter = 1,		/**< Justify Center */
N	justifyRight = 2		/**< Justify Right */
N} justify_t;
N
N/**
N * @enum fontmetric
N * @brief   Type for the font metric.
N */
Ntypedef enum fontmetric {
N	fontHeight,				/**< The height of the font */
N	fontDescendersHeight,	/**< The descenders height */
N	fontLineSpacing,		/**< The line spacing */
N	fontCharPadding,		/**< The char padding */
N	fontMinWidth,			/**< The minimum width */
N	fontMaxWidth,			/**< The maximum width */
N	fontBaselineX,			/**< The base line in x direction */
N	fontBaselineY			/**< The base line in y direction */
N} fontmetric_t;
N
N/**
N * @brief   The type of a font.
N */
Ntypedef const struct mf_font_s* font_t;
N
N/**
N * @enum 	orientation
N * @brief   Type for the screen orientation.
N * @note	GDISP_ROTATE_LANDSCAPE and GDISP_ROTATE_PORTRAIT are internally converted to the
N * 			most appropriate other orientation.
N */
Ntypedef enum orientation {
N	GDISP_ROTATE_0 = 0,				/**< Don't rotate. This is the displays native orientation. */
N	GDISP_ROTATE_90 = 90,			/**< Rotate by 90 degrees absolute to the native rotation. */
N	GDISP_ROTATE_180 = 180,			/**< Rotate by 180 degrees absolute to the native rotation. */
N	GDISP_ROTATE_270 = 270,			/**< Rotate by 270 degrees absolute to the native rotation. */
N	GDISP_ROTATE_PORTRAIT = 1000,	/**< Put the display into portrait mode. */
N	GDISP_ROTATE_LANDSCAPE = 1001	/**< Put the display into landscape mode. */
N} orientation_t;
N
N/**
N * @enum 	powermode
N * @brief   Type for the available power modes for the screen.
N */
Ntypedef enum powermode {
N	powerOff,						/**< Turn the display off. */
N	powerSleep,						/**< Put the display into sleep mode. */
N	powerDeepSleep,					/**< Put the display into deep-sleep mode. */
N	powerOn							/**< Turn the display on. */
N} powermode_t;
N
N/*
N * Our black box display structure.
N */
Ntypedef struct GDisplay		GDisplay;
N
N/**
N * @brief   The default screen to use for the gdispXXXX calls.
N * @note	This is set by default to the first display in the system. You can change
N * 			it by calling @p gdispSetDisplay().
N */
Nextern GDisplay	*GDISP;
N
N/*===========================================================================*/
N/* Constants.                                                                */
N/*===========================================================================*/
N
N/**
N * @brief   Driver Control Constants
N * @details	Unsupported control codes are ignored.
N * @note	The value parameter should always be typecast to (void *).
N * @note	There are some predefined and some specific to the low level driver.
N * @note	GDISP_CONTROL_POWER			- Takes a gdisp_powermode_t
N * 			GDISP_CONTROL_ORIENTATION	- Takes a gdisp_orientation_t
N * 			GDISP_CONTROL_BACKLIGHT -	 Takes an int from 0 to 100. For a driver
N * 											that only supports off/on anything other
N * 											than zero is on.
N * 			GDISP_CONTROL_CONTRAST		- Takes an int from 0 to 100.
N * 			GDISP_CONTROL_LLD			- Low level driver control constants start at
N * 											this value.
N */
N#define GDISP_CONTROL_POWER			0
N#define GDISP_CONTROL_ORIENTATION	1
N#define GDISP_CONTROL_BACKLIGHT		2
N#define GDISP_CONTROL_CONTRAST		3
N#define GDISP_CONTROL_LLD			1000
N
N/*===========================================================================*/
N/* Defines relating to the display hardware									 */
N/*===========================================================================*/
N
N#if !defined(GDISP_DRIVER_LIST)
X#if !0L
N	// Pull in the default hardware configuration for a single controller.
N	// If we have multiple controllers the settings must be set in the
N	// users gfxconf.h file.
N	// Use the compiler include path to find it
N	#include "gdisp_lld_config.h"
L 1 "..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer\gdisp_lld_config.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N#ifndef _GDISP_LLD_CONFIG_H
N#define _GDISP_LLD_CONFIG_H
N
N#if GFX_USE_GDISP
X#if -1
N
N/*===========================================================================*/
N/* Driver hardware support.                                                  */
N/*===========================================================================*/
N
N#define GDISP_HARDWARE_DRAWPIXEL		TRUE
N#define GDISP_HARDWARE_PIXELREAD		TRUE
N#define GDISP_HARDWARE_CONTROL			TRUE
N
N// Any other support comes from the board file
N#include "board_framebuffer.h"
L 1 "..\..\..\..\none\board_framebuffer.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N#include "LS013B7DH06.h"
N
N// Uncomment this if your frame buffer device requires flushing
N#define GDISP_HARDWARE_FLUSH		TRUE
N#define GDISP_LLD_PIXELFORMAT		GDISP_PIXELFORMAT_RGB111
N#define GDISP_DRIVER_3BIT_MSB		TRUE
N
N
N
N#ifdef GDISP_DRIVER_VMT
S
Sstatic void board_init(GDisplay *g, fbInfo *fbi) {
S		// TODO: Initialize your frame buffer device here
S
S		// TODO: Set the details of the frame buffer
S		g->g.Width = 128;
S		g->g.Height = 128;
S		g->g.Backlight = 100;
S		g->g.Contrast = 100;
S		fbi->linelen = 48;				// bytes per row
S		fbi->pixels = ls013_init();												// pointer to the memory frame buffer
S		
S		ls013_clearframe();
S		
S	}
S
S	#if GDISP_HARDWARE_FLUSH
S		static void board_flush(GDisplay *g) {
S			// TODO: Can be an empty function if your hardware doesn't support this
S			ls013_flush();
S		}
S	#endif
S
S	#if GDISP_NEED_CONTROL
S		static void board_backlight(GDisplay *g, uint8_t percent) {
S			// TODO: Can be an empty function if your hardware doesn't support this
S			(void) g;
S			(void) percent;
S		}
S
S		static void board_contrast(GDisplay *g, uint8_t percent) {
S			// TODO: Can be an empty function if your hardware doesn't support this
S			(void) g;
S			(void) percent;
S		}
S
S		static void board_power(GDisplay *g, powermode_t pwr) {
S			// TODO: Can be an empty function if your hardware doesn't support this
S			(void) g;
S			(void) pwr;
S		}
S	#endif
S
N#endif /* GDISP_LLD_BOARD_IMPLEMENTATION */
L 23 "..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer\gdisp_lld_config.h" 2
N
N#ifndef GDISP_LLD_PIXELFORMAT
S	#error "GDISP FrameBuffer: You must specify a GDISP_LLD_PIXELFORMAT in your board_framebuffer.h or your makefile"
N#endif
N
N// This driver currently only supports unpacked formats with more than 8 bits per pixel
N//	that is, we only support GRAY_SCALE with 8 bits per pixel or any unpacked TRUE_COLOR format.
N// Note: At the time this file is included we have not calculated all our color
N//			definitions so we need to do this by hand.
N#if (GDISP_LLD_PIXELFORMAT & 0x4000) && (GDISP_LLD_PIXELFORMAT & 0xFF) != 8
X#if (GDISP_PIXELFORMAT_RGB111 & 0x4000) && (GDISP_PIXELFORMAT_RGB111 & 0xFF) != 8
S	#error "GDISP FrameBuffer: This driver does not support the specified GDISP_LLD_PIXELFORMAT"
N#endif
N
N#endif	/* GFX_USE_GDISP */
N
N#endif	/* _GDISP_LLD_CONFIG_H */
L 158 "..\..\..\..\..\..\external\ugfx\src/gdisp/gdisp.h" 2
N
N	// Unless the user has specified a specific pixel format, use
N	// the native format for the controller.
N	#if !defined(GDISP_PIXELFORMAT) && defined(GDISP_LLD_PIXELFORMAT)
X	#if !0L && 1L
N		#define GDISP_PIXELFORMAT 			GDISP_LLD_PIXELFORMAT
N	#endif
N#endif
N
N/**
N * @name    GDISP pixel format choices
N * @{
N */
N	/**
N	 * @brief   The pixel format.
N	 * @details	It generally defaults to the hardware pixel format.
N	 * @note	This doesn't need to match the hardware pixel format.
N	 * 			It is definitely more efficient when it does.
N	 * @note	When GDISP_DRIVER_LIST is defined, this must
N	 * 			be explicitly defined and you should ensure the best match
N	 * 			with your hardware across all devices.
N	 */
N	#ifndef GDISP_PIXELFORMAT
S		#define GDISP_PIXELFORMAT 			GDISP_PIXELFORMAT_ERROR
N	#endif
N	/**
N	 * @brief   Do pixels require packing for a blit
N	 * @note	Is only valid for a pixel format that doesn't fill it's datatype. eg formats:
N	 *				GDISP_PIXELFORMAT_RGB888
N	 *				GDISP_PIXELFORMAT_RGB444
N	 *				GDISP_PIXELFORMAT_RGB666
N	 *				GDISP_PIXELFORMAT_CUSTOM
N	 * @note	Very few cases should actually require packed pixels as the low
N	 *				level driver can also pack on the fly as it is sending it
N	 *				to the graphics device.
N	 * @note	Packed pixels are not really supported at this point.
N	 */
N	#ifndef GDISP_PACKED_PIXELS
N		#define GDISP_PACKED_PIXELS			FALSE
N	#endif
N
N	/**
N	 * @brief   Do lines of pixels require packing for a blit
N	 * @note	Ignored if GDISP_PACKED_PIXELS is FALSE
N	 */
N	#ifndef GDISP_PACKED_LINES
N		#define GDISP_PACKED_LINES			FALSE
N	#endif
N/** @} */
N
N/*===========================================================================*/
N/* Defines related to the pixel format										 */
N/*===========================================================================*/
N
N/* Load our color definitions and pixel formats */
N#include "gdisp_colors.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gdisp/gdisp_colors.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gdisp/gdisp_colors.h
N *
N * @defgroup Colors Colors
N * @ingroup GDISP
N *
N * @brief   Sub-Module for color handling.
N *
N * @{
N */
N
N#ifndef _GDISP_COLORS_H
N#define _GDISP_COLORS_H
N
N#include "../../gfx.h"
N
N#if GFX_USE_GDISP || defined(__DOXYGEN__)
X#if -1 || 0L
N
Ntypedef uint16_t	colorformat;
N
N/**
N * @name	Color system masks
N *
N * @details For pixel formats we do some assignment of codes to enable
N * 			format auto-calculation. (Undocumented).
N * 			0x2RGB			TRUECOLOR	RGB format, R = red bits, G = green bits, B = blue bits
N * 			0x3RGB			TRUECOLOR	BGR format, R = red bits, G = green bits, B = blue bits
N * 			0x40XX			GRAYSCALE	XX = bits
N * 			0x60XX			PALLETTE	XX = bits
N * 			0x8XXX			CUSTOM format.
N * @{
N */
N#define GDISP_COLORSYSTEM_MASK			0xF000
N#define GDISP_COLORSYSTEM_RGB			0x2000
N#define GDISP_COLORSYSTEM_BGR			0x3000
N/** @} */
N
N/**
N * @name   Color Type Constants
N * @{
N */
N#define GDISP_COLORSYSTEM_TRUECOLOR		0x2000
N#define GDISP_COLORSYSTEM_GRAYSCALE		0x4000
N#define GDISP_COLORSYSTEM_PALETTE		0x6000
N/** @} */
N
N/**
N * @name   Pixel Format Constants
N * @{
N */
N#define GDISP_PIXELFORMAT_MONO		(GDISP_COLORSYSTEM_GRAYSCALE|0x0001)
N#define GDISP_PIXELFORMAT_GRAY4		(GDISP_COLORSYSTEM_GRAYSCALE|0x0002)
N#define GDISP_PIXELFORMAT_GRAY16	(GDISP_COLORSYSTEM_GRAYSCALE|0x0004)
N#define GDISP_PIXELFORMAT_GRAY256	(GDISP_COLORSYSTEM_GRAYSCALE|0x0008)
N#define GDISP_PIXELFORMAT_RGB111	(GDISP_COLORSYSTEM_RGB|0x0111)
N#define GDISP_PIXELFORMAT_RGB565	(GDISP_COLORSYSTEM_RGB|0x0565)
N#define GDISP_PIXELFORMAT_BGR565	(GDISP_COLORSYSTEM_BGR|0x0565)
N#define GDISP_PIXELFORMAT_RGB555	(GDISP_COLORSYSTEM_RGB|0x0555)
N#define GDISP_PIXELFORMAT_BGR555	(GDISP_COLORSYSTEM_BGR|0x0555)
N#define GDISP_PIXELFORMAT_RGB888	(GDISP_COLORSYSTEM_RGB|0x0888)
N#define GDISP_PIXELFORMAT_BGR888	(GDISP_COLORSYSTEM_BGR|0x0888)
N#define GDISP_PIXELFORMAT_RGB444	(GDISP_COLORSYSTEM_RGB|0x0444)
N#define GDISP_PIXELFORMAT_BGR444	(GDISP_COLORSYSTEM_BGR|0x0444)
N#define GDISP_PIXELFORMAT_RGB332	(GDISP_COLORSYSTEM_RGB|0x0332)
N#define GDISP_PIXELFORMAT_BGR332	(GDISP_COLORSYSTEM_BGR|0x0233)
N#define GDISP_PIXELFORMAT_RGB233	(GDISP_COLORSYSTEM_RGB|0x0233)
N#define GDISP_PIXELFORMAT_BGR233	(GDISP_COLORSYSTEM_BGR|0x0332)
N#define GDISP_PIXELFORMAT_RGB666	(GDISP_COLORSYSTEM_RGB|0x0666)
N#define GDISP_PIXELFORMAT_BGR666	(GDISP_COLORSYSTEM_BGR|0x0666)
N#define GDISP_PIXELFORMAT_ERROR		0x0000
N/** @} */
N
N/**
N * @name   Some basic colors
N * @{
N */
N#define White			HTML2COLOR(0xFFFFFF)
N#define Black			HTML2COLOR(0x000000)
N#define Gray			HTML2COLOR(0x808080)
N#define Grey			Gray
N#define Blue			HTML2COLOR(0x0000FF)
N#define Red				HTML2COLOR(0xFF0000)
N#define Fuchsia			HTML2COLOR(0xFF00FF)
N#define Magenta			Fuchsia
N#define Green			HTML2COLOR(0x008000)
N#define Yellow			HTML2COLOR(0xFFFF00)
N#define Aqua			HTML2COLOR(0x00FFFF)
N#define Cyan			Aqua
N#define Lime			HTML2COLOR(0x00FF00)
N#define Maroon			HTML2COLOR(0x800000)
N#define Navy			HTML2COLOR(0x000080)
N#define Olive			HTML2COLOR(0x808000)
N#define Purple			HTML2COLOR(0x800080)
N#define Silver			HTML2COLOR(0xC0C0C0)
N#define Teal			HTML2COLOR(0x008080)
N#define Orange			HTML2COLOR(0xFFA500)
N#define Pink			HTML2COLOR(0xFFC0CB)
N#define SkyBlue			HTML2COLOR(0x87CEEB)
N/** @} */
N
N#if defined(__DOXYGEN__)
X#if 0L
S	/**
S	 * @brief	The color system (grayscale, palette or truecolor)
S	 */
S	#define COLOR_SYSTEM			GDISP_COLORSYSTEM_TRUECOLOR
S
S	/**
S	 * @brief	The number of bits in a color value
S	 */
S	#define COLOR_BITS			16
S
S	/**
S	 * @name	Color bits
S	 * @brief	The number of bits for each of red, green and blue
S	 * @{
S	 */
S	#define COLOR_BITS_R		5
S	#define COLOR_BITS_G		6
S	#define COLOR_BITS_B		5
S	/** @} */
S
S	/**
S	 * @name	Color bit shifts
S	 * @brief	The number of bits to shift each of red, green and blue to put it in the correct place in the color
S	 * @{
S	 */
S	#define COLOR_SHIFT_R		11
S	#define COLOR_SHIFT_G		5
S	#define COLOR_SHIFT_B		0
S	/** @} */
S
S	/**
S	 * @brief	Does the color need masking to remove invalid bits
S	 */
S	#define COLOR_NEEDS_MASK	FALSE
S
S	/**
S	 * @brief	If the color needs masking to remove invalid bits, this is the mask
S	 */
S	#define COLOR_MASK			0xFFFF
S
S	/**
S	 * @brief   The color type
S	 */
S	#define COLOR_TYPE			uint16_t
S
S	/**
S	 * @brief	The number of bits in the color type (not necessarily the same as COLOR_BITS).
S	 */
S	#define COLOR_TYPE_BITS		16
S
S	/**
S	 * @brief   Convert a luminance (0 to 255) into a color value.
S	 * @note	The word "Luma" is used instead of grey or gray due to the spelling ambiguities of the word grey
S	 * @note	This is not a weighted luminance conversion in the color tv style.
S	 * @note	@p LUMA2COLOR() uses a linear conversion (0.33R + 0.33G + 0.33B). Note this is different to color
S	 * 			tv luminance (0.26126R + 0.7152G + 0.0722B),  digital tv luminance of (0.299R + 0.587G + 0.114B), or
S	 * 			@p LUMA_OF() which uses (0.25R + 0.5G + 0.25B).
S	 */
S	#define LUMA2COLOR(l)		((color_t)((((l) & 0xF8)<<8) | (((l) & 0xFC)<<3) | (((l) & 0xF8)>>3)))
S
S	/**
S	 * @brief   Convert red, green, blue (each 0 to 255) into a color value.
S	 */
S	#define RGB2COLOR(r,g,b)	((color_t)((((r) & 0xF8)<<8) | (((g) & 0xFC)<<3) | (((b) & 0xF8)>>3)))
S
S	/**
S	 * @brief   Convert a 6 digit HTML code (hex) into a color value.
S	 */
S	#define HTML2COLOR(h)		((color_t)((((h) & 0xF80000)>>8) | (((h) & 0x00FC00)>>5) | (((h) & 0x0000F8)>>3)))
S
S	/**
S	 * @name	Extraction macros (quick)
S	 *
S	 * @brief   Extract the luma/red/green/blue component (0 to 255) of a color value.
S	 * @note	This uses quick and dirty bit shifting. If you want more exact colors
S	 * 			use @p EXACT_RED_OF() etc which uses multiplies and divides. For constant
S	 * 			colors using @p EXACT_RED_OF() is no more expensive because the compiler
S	 * 			evaluates the arithmetic.
S	 * @note	@p LUMA_OF() returns a roughly weighted luminance (0.25R + 0.5G + 0.25B). Note this is
S	 * 			different to @p LUMA2COLOR() which uses a linear conversion (0.33R + 0.33G + 0.33B) and
S	 * 			color tv luminance of (0.26126R + 0.7152G + 0.0722B) and digital tv luminance of (0.299R + 0.587G + 0.114B).
S	 * @note	A 5 bit color component maximum value (0x1F) converts to 0xF8 (slightly off-color)
S	 * @{
S	 */
S	#define LUMA_OF(c)			((RED_OF(c)+((uint16_t)GREEN_OF(c)<<1)+BLUE_OF(c))>>2)
S	#define RED_OF(c)			(((c) & 0xF800)>>8)
S	#define GREEN_OF(c)			(((c)&0x007E)>>3)
S	#define BLUE_OF(c)			(((c)&0x001F)<<3)
S	/** @} */
S
S	/**
S	 * @name	Extraction macros (precise)
S	 *
S	 * @brief   Extract the exact luma/red/green/blue component (0 to 255) of a color value.
S	 * @note	This uses multiplies and divides rather than bit shifting.
S	 * 			This gives exact equivalent colors at the expense of more cpu intensive
S	 * 			operations. Note for constants this is no more expensive than @p REF_OF()
S	 * 			because the compiler evaluates the arithmetic.
S	 * @note	@p EXACT_LUMA_OF() returns a roughly weighted luminance (0.25R + 0.5G + 0.25B). Note this is
S	 * 			different to @p LUMA2COLOR() which uses a linear conversion (0.33R + 0.33G + 0.33B) and
S	 * 			color tv luminance of (0.26126R + 0.7152G + 0.0722B) and digital tv luminance of (0.299R + 0.587G + 0.114B).
S	 * @note	A 5 bit color component maximum value (0x1F) converts to 0xFF (the true equivalent color)
S	 * @{
S	 */
S	#define EXACT_LUMA_OF(c)	((EXACT_RED_OF(c)+((uint16_t)EXACT_GREEN_OF(c)<<1)+EXACT_BLUE_OF(c))>>2)
S	#define EXACT_RED_OF(c)		(((((c)>>11)&0x1F)*255)/31)
S	#define EXACT_GREEN_OF(c)	(((((c)>>5)&0x3F)*255)/63)
S	#define EXACT_BLUE_OF(c)	(((((c)>>0)&0x1F)*255)/31)
S	/** @} */
N#endif
N
N/*
N * We use this big mess of macros to calculate all the components
N * to prevent user errors in the color definitions. It greatly simplifies
N * the above definitions and ensures a consistent implementation.
N */
N
N//-------------------------
N//	True-Color color system
N//-------------------------
N#if GDISP_PIXELFORMAT & GDISP_COLORSYSTEM_TRUECOLOR
X#if (0x2000|0x0111) & 0x2000
N	#define COLOR_SYSTEM			GDISP_COLORSYSTEM_TRUECOLOR
N
N	// Calculate the number of bits
N	#define COLOR_BITS_R			((GDISP_PIXELFORMAT>>8) & 0x0F)
N	#define COLOR_BITS_G			((GDISP_PIXELFORMAT>>4) & 0x0F)
N	#define COLOR_BITS_B			((GDISP_PIXELFORMAT>>0) & 0x0F)
N	#define COLOR_BITS				(COLOR_BITS_R + COLOR_BITS_G + COLOR_BITS_B)
N
N	// From the number of bits determine COLOR_TYPE, COLOR_TYPE_BITS and masking
N	#if COLOR_BITS <= 8
X	#if ((((0x2000|0x0111)>>8) & 0x0F) + (((0x2000|0x0111)>>4) & 0x0F) + (((0x2000|0x0111)>>0) & 0x0F)) <= 8
N		#define COLOR_TYPE			uint8_t
N		#define COLOR_TYPE_BITS	8 
N	#elif COLOR_BITS <= 16
S		#define COLOR_TYPE			uint16_t
S		#define COLOR_TYPE_BITS		16
S	#elif COLOR_BITS <= 32
S		#define COLOR_TYPE			uint32_t
S		#define COLOR_TYPE_BITS		32
S	#else
S		#error "GDISP: Cannot define color types with more than 32 bits"
N	#endif
N	#if COLOR_TYPE_BITS == COLOR_BITS
X	#if 8 == ((((0x2000|0x0111)>>8) & 0x0F) + (((0x2000|0x0111)>>4) & 0x0F) + (((0x2000|0x0111)>>0) & 0x0F))
S		#define COLOR_NEEDS_MASK	FALSE
N	#else
N		#define COLOR_NEEDS_MASK	TRUE
N	#endif
N	#define COLOR_MASK()			((1 << COLOR_BITS)-1)
N
N	// Calculate the component bit shifts
N	#if (GDISP_PIXELFORMAT & GDISP_COLORSYSTEM_MASK) == GDISP_COLORSYSTEM_RGB
X	#if ((0x2000|0x0111) & 0xF000) == 0x2000
N		#define COLOR_SHIFT_R		(COLOR_BITS_B+COLOR_BITS_G)
N		#define COLOR_SHIFT_G		COLOR_BITS_B
N		#define COLOR_SHIFT_B		0
N	#else
S		#define COLOR_SHIFT_B		(COLOR_BITS_R+COLOR_BITS_G)
S		#define COLOR_SHIFT_G		COLOR_BITS_R
S		#define COLOR_SHIFT_R		0
N	#endif
N
N	// Calculate RED_OF, GREEN_OF, BLUE_OF and RGB2COLOR
N	#if COLOR_BITS_R + COLOR_SHIFT_R == 8
X	#if (((0x2000|0x0111)>>8) & 0x0F) + ((((0x2000|0x0111)>>0) & 0x0F)+(((0x2000|0x0111)>>4) & 0x0F)) == 8
S		#define RED_OF(c)			((c) & (((1<<COLOR_BITS_R)-1) << COLOR_SHIFT_R))
S		#define RGB2COLOR_R(r)		((COLOR_TYPE)((r) & (0xFF & ~((1<<(8-COLOR_BITS_R))-1))))
S	#elif COLOR_BITS_R + COLOR_SHIFT_R > 8
X	#elif (((0x2000|0x0111)>>8) & 0x0F) + ((((0x2000|0x0111)>>0) & 0x0F)+(((0x2000|0x0111)>>4) & 0x0F)) > 8
S		#define RED_OF(c)			(((c) & (((1<<COLOR_BITS_R)-1) << COLOR_SHIFT_R)) >> (COLOR_BITS_R+COLOR_SHIFT_R-8))
S		#define RGB2COLOR_R(r)		(((COLOR_TYPE)((r) & (0xFF & ~((1<<(8-COLOR_BITS_R))-1)))) << (COLOR_BITS_R+COLOR_SHIFT_R-8))
N	#else // COLOR_BITS_R + COLOR_SHIFT_R < 8
N		#define RED_OF(c)			(((c) & (((1<<COLOR_BITS_R)-1) << COLOR_SHIFT_R)) << (8-(COLOR_BITS_R+COLOR_SHIFT_R)))
N		#define RGB2COLOR_R(r)		(((COLOR_TYPE)((r) & (0xFF & ~((1<<(8-COLOR_BITS_R))-1)))) >> (8-(COLOR_BITS_R+COLOR_SHIFT_R)))
N	#endif
N	#if COLOR_BITS_G + COLOR_SHIFT_G == 8
X	#if (((0x2000|0x0111)>>4) & 0x0F) + (((0x2000|0x0111)>>0) & 0x0F) == 8
S		#define GREEN_OF(c)			((c) & (((1<<COLOR_BITS_G)-1) << COLOR_SHIFT_G))
S		#define RGB2COLOR_G(g)		((COLOR_TYPE)((g) & (0xFF & ~((1<<(8-COLOR_BITS_G))-1))))
S	#elif COLOR_BITS_G + COLOR_SHIFT_G > 8
X	#elif (((0x2000|0x0111)>>4) & 0x0F) + (((0x2000|0x0111)>>0) & 0x0F) > 8
S		#define GREEN_OF(c)			(((c) & (((1<<COLOR_BITS_G)-1) << COLOR_SHIFT_G)) >> (COLOR_BITS_G+COLOR_SHIFT_G-8))
S		#define RGB2COLOR_G(g)		(((COLOR_TYPE)((g) & (0xFF & ~((1<<(8-COLOR_BITS_G))-1)))) << (COLOR_BITS_G+COLOR_SHIFT_G-8))
N	#else // COLOR_BITS_G + COLOR_SHIFT_G < 8
N		#define GREEN_OF(c)			(((c) & (((1<<COLOR_BITS_G)-1) << COLOR_SHIFT_G)) << (8-(COLOR_BITS_G+COLOR_SHIFT_G)))
N		#define RGB2COLOR_G(g)		(((COLOR_TYPE)((g) & (0xFF & ~((1<<(8-COLOR_BITS_G))-1)))) >> (8-(COLOR_BITS_G+COLOR_SHIFT_G)))
N	#endif
N	#if COLOR_BITS_B + COLOR_SHIFT_B == 8
X	#if (((0x2000|0x0111)>>0) & 0x0F) + 0 == 8
S		#define BLUE_OF(c)			((c) & (((1<<COLOR_BITS_B)-1) << COLOR_SHIFT_B))
S		#define RGB2COLOR_B(b)		((COLOR_TYPE)((b) & (0xFF & ~((1<<(8-COLOR_BITS_B))-1))))
S	#elif COLOR_BITS_B + COLOR_SHIFT_B > 8
X	#elif (((0x2000|0x0111)>>0) & 0x0F) + 0 > 8
S		#define BLUE_OF(c)			(((c) & (((1<<COLOR_BITS_B)-1) << COLOR_SHIFT_B)) >> (COLOR_BITS_B+COLOR_SHIFT_B-8))
S		#define RGB2COLOR_B(b)		(((COLOR_TYPE)((b) & (0xFF & ~((1<<(8-COLOR_BITS_B))-1)))) << (COLOR_BITS_B+COLOR_SHIFT_B-8))
N	#else // COLOR_BITS_B + COLOR_SHIFT_B < 8
N		#define BLUE_OF(c)			(((c) & (((1<<COLOR_BITS_B)-1) << COLOR_SHIFT_B)) << (8-(COLOR_BITS_B+COLOR_SHIFT_B)))
N		#define RGB2COLOR_B(b)		(((COLOR_TYPE)((b) & (0xFF & ~((1<<(8-COLOR_BITS_B))-1)))) >> (8-(COLOR_BITS_B+COLOR_SHIFT_B)))
N	#endif
N	#define LUMA_OF(c)				((RED_OF(c)+((uint16_t)GREEN_OF(c)<<1)+BLUE_OF(c))>>2)
N	#define EXACT_RED_OF(c)			(((uint16_t)(((c)>>COLOR_SHIFT_R)&((1<<COLOR_BITS_R)-1))*255)/((1<<COLOR_BITS_R)-1))
N	#define EXACT_GREEN_OF(c)		(((uint16_t)(((c)>>COLOR_SHIFT_G)&((1<<COLOR_BITS_G)-1))*255)/((1<<COLOR_BITS_G)-1))
N	#define EXACT_BLUE_OF(c)		(((uint16_t)(((c)>>COLOR_SHIFT_B)&((1<<COLOR_BITS_B)-1))*255)/((1<<COLOR_BITS_B)-1))
N	#define EXACT_LUMA_OF(c)		((EXACT_RED_OF(c)+((uint16_t)EXACT_GREEN_OF(c)<<1)+EXACT_BLUE_OF(c))>>2)
N	#define LUMA2COLOR(l)			(RGB2COLOR_R(l) | RGB2COLOR_G(l) | RGB2COLOR_B(l))
N	#define RGB2COLOR(r,g,b)		(RGB2COLOR_R(r) | RGB2COLOR_G(g) | RGB2COLOR_B(b))
N
N	// Calculate HTML2COLOR
N	#if COLOR_BITS_R + COLOR_SHIFT_R == 24
X	#if (((0x2000|0x0111)>>8) & 0x0F) + ((((0x2000|0x0111)>>0) & 0x0F)+(((0x2000|0x0111)>>4) & 0x0F)) == 24
S		#define HTML2COLOR_R(h)		((h) & ((0xFFL & ~((1<<(8-COLOR_BITS_R))-1))<<16))
S	#elif COLOR_BITS_R + COLOR_SHIFT_R > 24
X	#elif (((0x2000|0x0111)>>8) & 0x0F) + ((((0x2000|0x0111)>>0) & 0x0F)+(((0x2000|0x0111)>>4) & 0x0F)) > 24
S		#define HTML2COLOR_R(h)		(((h) & ((0xFFL & ~((1<<(8-COLOR_BITS_R))-1))<<16)) << (COLOR_BITS_R+COLOR_SHIFT_R-24))
N	#else // COLOR_BITS_R + COLOR_SHIFT_R < 24
N		#define HTML2COLOR_R(h)		(((h) & ((0xFFL & ~((1<<(8-COLOR_BITS_R))-1))<<16)) >> (24-(COLOR_BITS_R+COLOR_SHIFT_R)))
N	#endif
N	#if COLOR_BITS_G + COLOR_SHIFT_G == 16
X	#if (((0x2000|0x0111)>>4) & 0x0F) + (((0x2000|0x0111)>>0) & 0x0F) == 16
S		#define HTML2COLOR_G(h)		((h) & ((0xFFL & ~((1<<(8-COLOR_BITS_G))-1))<<8))
S	#elif COLOR_BITS_G + COLOR_SHIFT_G > 16
X	#elif (((0x2000|0x0111)>>4) & 0x0F) + (((0x2000|0x0111)>>0) & 0x0F) > 16
S		#define HTML2COLOR_G(h)		(((h) & ((0xFFL & ~((1<<(8-COLOR_BITS_G))-1))<<8)) << (COLOR_BITS_G+COLOR_SHIFT_G-16))
N	#else // COLOR_BITS_G + COLOR_SHIFT_G < 16
N		#define HTML2COLOR_G(h)		(((h) & ((0xFFL & ~((1<<(8-COLOR_BITS_G))-1))<<8)) >> (16-(COLOR_BITS_G+COLOR_SHIFT_G)))
N	#endif
N	#if COLOR_BITS_B + COLOR_SHIFT_B == 8
X	#if (((0x2000|0x0111)>>0) & 0x0F) + 0 == 8
S		#define HTML2COLOR_B(h)		((h) & (0xFFL & ~((1<<(8-COLOR_BITS_B))-1)))
S	#elif COLOR_BITS_B + COLOR_SHIFT_B > 8
X	#elif (((0x2000|0x0111)>>0) & 0x0F) + 0 > 8
S		#define HTML2COLOR_B(h)		(((h) & (0xFFL & ~((1<<(8-COLOR_BITS_B))-1))) << (COLOR_BITS_B+COLOR_SHIFT_B-8))
N	#else // COLOR_BITS_B + COLOR_SHIFT_B < 8
N		#define HTML2COLOR_B(h)		(((h) & (0xFFL & ~((1<<(8-COLOR_BITS_B))-1))) >> (8-(COLOR_BITS_B+COLOR_SHIFT_B)))
N	#endif
N	#define HTML2COLOR(h)		((COLOR_TYPE)(HTML2COLOR_R(h) | HTML2COLOR_G(h) | HTML2COLOR_B(h)))
N
N//-------------------------
N//	Gray-scale color system
N//-------------------------
N#elif (GDISP_PIXELFORMAT & GDISP_COLORSYSTEM_MASK) == GDISP_COLORSYSTEM_GRAYSCALE
S	#define COLOR_SYSTEM			GDISP_COLORSYSTEM_GRAYSCALE
S
S	// Calculate the number of bits and shifts
S	#define COLOR_BITS			(GDISP_PIXELFORMAT & 0xFF)
S	#define COLOR_BITS_R		COLOR_BITS
S	#define COLOR_BITS_G		COLOR_BITS
S	#define COLOR_BITS_B		COLOR_BITS
S	#define COLOR_SHIFT_R		0
S	#define COLOR_SHIFT_G		0
S	#define COLOR_SHIFT_B		0
S
S	// From the number of bits determine COLOR_TYPE, COLOR_TYPE_BITS and masking
S	#if COLOR_BITS <= 8
S		#define COLOR_TYPE			uint8_t
S		#define COLOR_TYPE_BITS		8
S	#else
S		#error "GDISP: Cannot define gray-scale color types with more than 8 bits"
S	#endif
S	#if COLOR_TYPE_BITS == COLOR_BITS
S		#define COLOR_NEEDS_MASK	FALSE
S	#else
S		#define COLOR_NEEDS_MASK	TRUE
S	#endif
S	#define COLOR_MASK()			((1 << COLOR_BITS)-1)
S
S	#if COLOR_BITS == 1
S		#define RGB2COLOR(r,g,b)	(((r)|(g)|(b)) ? 1 : 0)
S		#define LUMA2COLOR(l)		((l) ? 1 : 0)
S		#define HTML2COLOR(h)		((h) ? 1 : 0)
S		#define LUMA_OF(c)			((c) ? 255 : 0)
S		#define EXACT_LUMA_OF(c)	LUMA_OF(c)
S	#else
S		// They eye is more sensitive to green
S		#define RGB2COLOR(r,g,b)	((COLOR_TYPE)(((uint16_t)(r)+(g)+(g)+(b)) >> (10-COLOR_BITS)))
S		#define LUMA2COLOR(l)		((COLOR_TYPE)((l)>>(8-COLOR_BITS)))
S		#define HTML2COLOR(h)		((COLOR_TYPE)(((((h)&0xFF0000)>>16)+(((h)&0x00FF00)>>7)+((h)&0x0000FF)) >> (10-COLOR_BITS)))
S		#define LUMA_OF(c)			(((c) & ((1<<COLOR_BITS)-1)) << (8-COLOR_BITS))
S		#define EXACT_LUMA_OF(c)	((((uint16_t)(c) & ((1<<COLOR_BITS)-1))*255)/((1<<COLOR_BITS)-1))
S	#endif
S
S	#define RED_OF(c)			LUMA_OF(c)
S	#define GREEN_OF(c)			LUMA_OF(c)
S	#define BLUE_OF(c)			LUMA_OF(c)
S	#define EXACT_RED_OF(c)		EXACT_LUMA_OF(c)
S	#define EXACT_GREEN_OF(c)	EXACT_LUMA_OF(c)
S	#define EXACT_BLUE_OF(c)	EXACT_LUMA_OF(c)
S
S//-------------------------
S//	Palette color system
S//-------------------------
S#elif (GDISP_PIXELFORMAT & GDISP_COLORSYSTEM_MASK) == GDISP_COLORSYSTEM_PALETTE
S	#define COLOR_SYSTEM			GDISP_COLORSYSTEM_PALETTE
S
S	#error "GDISP: A palette color system is not currently supported"
S
S//-------------------------
S//	Some other color system
S//-------------------------
S#else
S	#error "GDISP: Unsupported color system"
N#endif
N
N/**
N * @brief	The color type definition
N */
Ntypedef COLOR_TYPE			color_t;
Xtypedef uint8_t			color_t;
N
N#endif /* GFX_USE_GDISP */
N
N#endif /* _GDISP_COLORS_H */
N/** @} */
L 213 "..\..\..\..\..\..\external\ugfx\src/gdisp/gdisp.h" 2
N
N/**
N * @brief   The type of a pixel.
N */
Ntypedef color_t		pixel_t;
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Color Utility Functions */
N
N/**
N * @brief   Blend 2 colors according to the alpha
N * @return	The combined color
N *
N * @param[in] fg		The foreground color
N * @param[in] bg		The background color
N * @param[in] alpha		The alpha value (0-255). 0 is all background, 255 is all foreground.
N *
N * @api
N */
Ncolor_t gdispBlendColor(color_t fg, color_t bg, uint8_t alpha);
N
N/**
N * @brief   Find a contrasting color
N * @return	The contrasting color
N *
N * @param[in] color		The color to contrast
N *
N * @api
N */
Ncolor_t gdispContrastColor(color_t color);
N
N/* Base Functions */
N
N/**
N * @brief   Get the specified display
N * @return	The pointer to the display or NULL if the display doesn't exist
N * @note	The GDISP variable contains the display used by the gdispXxxx routines
N * 			as opposed to the gdispGXxxx routines which take an explicit display
N * 			parameter.
N * @note	Displays are numbered from 0 to @p gdispGetDisplayCount() - 1
N *
N * @param[in] display	The display number (0..n)
N *
N * @api
N */
NGDisplay *gdispGetDisplay(unsigned display);
N
N/**
N * @brief   Set the current default display to the specified display
N * @note	The default display is used for the gdispXxxx functions.
N * @note	The default display is contained in the variable GDISP. Using
N * 			this function to set it protects against it being set to a NULL
N * 			value.
N * @note	If a NULL is passed for the dispay this call is ignored.
N *
N * @param[in] g 	The display to use
N *
N * @api
N */
Nvoid gdispSetDisplay(GDisplay *g);
N
N/**
N * @brief   Get the count of currently active displays
N * @return  The count of displays currently in the system
N *
N * @note	Displays are numbered from 0 to @p gdispGetDisplayCount() - 1
N */
Nunsigned gdispGetDisplayCount(void);
N
N/* Property Functions */
N
N/**
N * @brief   Get the display width in pixels.
N *
N * @param[in] g 		The display to use
N *
N * @return	The width of the display
N *
N * @api
N */
Ncoord_t gdispGGetWidth(GDisplay *g);
N#define gdispGetWidth()								gdispGGetWidth(GDISP)
N
N/**
N * @brief   Get the display height in pixels.
N *
N * @param[in] g 		The display to use
N *
N * @return	The height of the display
N *
N * @api
N */
Ncoord_t gdispGGetHeight(GDisplay *g);
N#define gdispGetHeight()							gdispGGetHeight(GDISP)
N
N/**
N * @brief   Get the current display power mode.
N *
N * @param[in] g 		The display to use
N *
N * @return	The current power mode
N *
N * @api
N */
Npowermode_t gdispGGetPowerMode(GDisplay *g);
N#define gdispGetPowerMode()							gdispGGetPowerMode(GDISP)
N
N/**
N * @brief   Get the current display orientation.
N *
N * @param[in] g 		The display to use
N *
N * @return	The current orientation
N *
N * @api
N */
Norientation_t gdispGGetOrientation(GDisplay *g);
N#define gdispGetOrientation()						gdispGGetOrientation(GDISP)
N
N/**
N * @brief   Get the current display backlight brightness.
N *
N * @param[in] g 		The display to use
N *
N * @return	The current backlight value
N *
N * @api
N */
Nuint8_t gdispGGetBacklight(GDisplay *g);
N#define gdispGetBacklight()							gdispGGetBacklight(GDISP)
N
N/**
N * @brief   Get the current display contrast.
N *
N * @param[in] g 		The display to use
N *
N * @return	The current contrast value
N *
N * @api
N */
Nuint8_t gdispGGetContrast(GDisplay *g);
N#define gdispGetContrast()							gdispGGetContrast(GDISP)
N
N/* Drawing Functions */
N
N/**
N * @brief   Flush current drawing operations to the display
N * @note	Some low level drivers do not update the display until
N * 			the display is flushed. For others it is optional but can
N * 			help prevent tearing effects. For some it is ignored.
N * 			Calling it at the end of a logic set of drawing operations
N * 			in your application will ensure controller portability. If you
N * 			know your controller does not need to be flushed there is no
N * 			need to call it (which is in reality most controllers).
N * @note	Even for displays that require flushing, there is no need to
N * 			call this function if GDISP_NEED_AUTOFLUSH is TRUE.
N * 			Calling it again won't hurt though.
N *
N *
N * @param[in] g 	The display to use
N *
N * @api
N */
Nvoid gdispGFlush(GDisplay *g);
N#define gdispFlush()									gdispGFlush(GDISP)
N
N/**
N * @brief   Clear the display to the specified color.
N *
N * @param[in] g 	The display to use
N * @param[in] color The color to use when clearing the screen
N *
N * @api
N */
Nvoid gdispGClear(GDisplay *g, color_t color);
N#define gdispClear(c)									gdispGClear(GDISP, c)
N
N/**
N * @brief   Set a pixel in the specified color.
N *
N * @param[in] g 	The display to use
N * @param[in] x,y   The position to set the pixel.
N * @param[in] color The color to use
N *
N * @api
N */
Nvoid gdispGDrawPixel(GDisplay *g, coord_t x, coord_t y, color_t color);
N#define gdispDrawPixel(x,y,c)							gdispGDrawPixel(GDISP,x,y,c)
N
N/**
N * @brief   Draw a line.
N *
N * @param[in] g 	The display to use
N * @param[in] x0,y0		The start position
N * @param[in] x1,y1 	The end position
N * @param[in] color		The color to use
N *
N * @api
N */
Nvoid gdispGDrawLine(GDisplay *g, coord_t x0, coord_t y0, coord_t x1, coord_t y1, color_t color);
N#define gdispDrawLine(x0,y0,x1,y1,c)					gdispGDrawLine(GDISP,x0,y0,x1,y1,c)
N
N/**
N * @brief   Fill an area with a color.
N *
N * @param[in] g 		The display to use
N * @param[in] x,y		The start position
N * @param[in] cx,cy		The size of the box (outside dimensions)
N * @param[in] color		The color to use
N *
N * @api
N */
Nvoid gdispGFillArea(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, color_t color);
N#define gdispFillArea(x,y,cx,cy,c)						gdispGFillArea(GDISP,x,y,cx,cy,c)
N
N/**
N * @brief   Fill an area using the supplied bitmap.
N * @details The bitmap is in the pixel format specified by the low level driver
N * @note	If a packed pixel format is used and the width doesn't
N *			match a whole number of bytes, the next line will start on a
N *			non-byte boundary (no end-of-line padding).
N * @note	If GDISP_NEED_ASYNC is defined then the buffer must be static
N * 			or at least retained until this call has finished the blit. You can
N * 			tell when all graphics drawing is finished by @p gdispIsBusy() going FALSE.
N *
N * @param[in] g 		The display to use
N * @param[in] x,y		The start position
N * @param[in] cx,cy		The size of the filled area
N * @param[in] srcx,srcy The bitmap position to start the fill form
N * @param[in] srccx		The width of a line in the bitmap
N * @param[in] buffer	The bitmap in the driver's pixel format
N *
N * @api
N */
Nvoid gdispGBlitArea(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, coord_t srcx, coord_t srcy, coord_t srccx, const pixel_t *buffer);
N#define gdispBlitAreaEx(x,y,cx,cy,sx,sy,rx,b)			gdispGBlitArea(GDISP,x,y,cx,cy,sx,sy,rx,b)
N
N/**
N * @brief   Draw a rectangular box.
N *
N * @param[in] g 		The display to use
N * @param[in] x,y		The start position
N * @param[in] cx,cy		The size of the box (outside dimensions)
N * @param[in] color		The color to use
N *
N * @api
N */
Nvoid gdispGDrawBox(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, color_t color);
N#define gdispDrawBox(x,y,cx,cy,c)						gdispGDrawBox(GDISP,x,y,cx,cy,c)
N
N/* Streaming Functions */
N
N#if GDISP_NEED_STREAMING || defined(__DOXYGEN__)
X#if 0 || 0L
S	/**
S	 * @brief   Start a streaming operation.
S	 * @details Stream data to a window on the display sequentially and very fast.
S	 * @pre		GDISP_NEED_STREAMING must be TRUE in your gfxconf.h
S	 * @note	While streaming is in operation - no other calls to GDISP functions
S	 * 			can be made (with the exception of @p gdispBlendColor() and streaming
S	 * 			functions). If a call is made (eg in a multi-threaded application) the other
S	 * 			call is blocked waiting for the streaming operation to finish.
S	 * @note	@p gdispStreamStop() must be called to finish the streaming operation.
S	 * @note	If more data is written than the defined area then the results are unspecified.
S	 * 			Some drivers may wrap back to the beginning of the area, others may just
S	 * 			ignore subsequent data.
S	 * @note	Unlike most operations that clip the defined area to the display to generate
S	 * 			a smaller active area, this call will just silently fail if any of the stream
S	 * 			region lies outside the current clipping area.
S	 * @note	A streaming operation may be terminated early (without writing to every location
S	 * 			in the stream area) by calling @p gdispStreamStop().
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The start position
S	 * @param[in] cx,cy		The size of the streamable area
S	 *
S	 * @api
S	 */
S	void gdispGStreamStart(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy);
S	#define gdispStreamStart(x,y,cx,cy)						gdispGStreamStart(GDISP,x,y,cx,cy)
S
S	/**
S	 * @brief   Send pixel data to the stream.
S	 * @details Write a pixel to the next position in the streamed area and increment the position
S	 * @pre		GDISP_NEED_STREAMING must be TRUE in your gfxconf.h
S	 * @pre		@p gdispStreamStart() has been called.
S	 * @note	If the gdispStreamStart() has not been called (or failed due to clipping), the
S	 * 			data provided here is simply thrown away.
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] color		The color of the pixel to write
S	 *
S	 * @api
S	 */
S	void gdispGStreamColor(GDisplay *g, color_t color);
S	#define gdispStreamColor(c)								gdispGStreamColor(GDISP,c)
S
S	/**
S	 * @brief   Finish the current streaming operation.
S	 * @details	Completes the current streaming operation and allows other GDISP calls to operate again.
S	 * @pre		GDISP_NEED_STREAMING must be TRUE in your gfxconf.h
S	 * @pre		@p gdispStreamStart() has been called.
S	 * @note	If the gdispStreamStart() has not been called (or failed due to clipping), this
S	 * 			call is simply ignored.
S	 *
S	 * @param[in] g 		The display to use
S	 *
S	 * @api
S	 */
S	void gdispGStreamStop(GDisplay *g);
S	#define gdispStreamStop()								gdispGStreamStop(GDISP)
N#endif
N
N/* Clipping Functions */
N
N#if GDISP_NEED_CLIP || defined(__DOXYGEN__)
X#if -1 || 0L
N	/**
N	 * @brief   Clip all drawing to the defined area.
N	 * @pre		GDISP_NEED_CLIP must be TRUE in your gfxconf.h
N	 *
N	 * @param[in] g 		The display to use
N	 * @param[in] x,y		The start position
N	 * @param[in] cx,cy		The size of the clip area
N	 *
N	 * @api
N	 */
N	void gdispGSetClip(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy);
N	#define gdispSetClip(x,y,cx,cy)							gdispGSetClip(GDISP,x,y,cx,cy)
N#endif
N
N/* Circle Functions */
N
N#if GDISP_NEED_CIRCLE || defined(__DOXYGEN__)
X#if 0 || 0L
S	/**
S	 * @brief   Draw a circle.
S	 * @pre		GDISP_NEED_CIRCLE must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The center of the circle
S	 * @param[in] radius	The radius of the circle
S	 * @param[in] color		The color to use
S	 *
S	 * @api
S	 */
S	void gdispGDrawCircle(GDisplay *g, coord_t x, coord_t y, coord_t radius, color_t color);
S	#define gdispDrawCircle(x,y,r,c)						gdispGDrawCircle(GDISP,x,y,r,c)
S
S	/**
S	 * @brief   Draw a filled circle.
S	 * @pre		GDISP_NEED_CIRCLE must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The center of the circle
S	 * @param[in] radius	The radius of the circle
S	 * @param[in] color		The color to use
S	 *
S	 * @api
S	 */
S	void gdispGFillCircle(GDisplay *g, coord_t x, coord_t y, coord_t radius, color_t color);
S	#define gdispFillCircle(x,y,r,c)						gdispGFillCircle(GDISP,x,y,r,c)
N#endif
N
N/* Ellipse Functions */
N
N#if GDISP_NEED_ELLIPSE || defined(__DOXYGEN__)
X#if 0 || 0L
S	/**
S	 * @brief   Draw an ellipse.
S	 * @pre		GDISP_NEED_ELLIPSE must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The center of the ellipse
S	 * @param[in] a,b		The dimensions of the ellipse
S	 * @param[in] color		The color to use
S	 *
S	 * @api
S	 */
S	void gdispGDrawEllipse(GDisplay *g, coord_t x, coord_t y, coord_t a, coord_t b, color_t color);
S	#define gdispDrawEllipse(x,y,a,b,c)						gdispGDrawEllipse(GDISP,x,y,a,b,c)
S
S	/**
S	 * @brief   Draw a filled ellipse.
S	 * @pre		GDISP_NEED_ELLIPSE must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The center of the ellipse
S	 * @param[in] a,b		The dimensions of the ellipse
S	 * @param[in] color		The color to use
S	 *
S	 * @api
S	 */
S	void gdispGFillEllipse(GDisplay *g, coord_t x, coord_t y, coord_t a, coord_t b, color_t color);
S	#define gdispFillEllipse(x,y,a,b,c)						gdispGFillEllipse(GDISP,x,y,a,b,c)
N#endif
N
N/* Arc Functions */
N#if GDISP_NEED_ARCSECTORS || defined(__DOXYGEN__)
X#if 0 || 0L
S	/**
S	 * @brief	Draw a selection of 45 degree arcs of a circle
S	 * @pre		GDISP_NEED_ARCSECTORS must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The center of the circle
S	 * @param[in] radius	The radius of the circle
S	 * @param[in] sectors	Bits determine which sectors are drawn.
S	 * 						Bits go anti-clockwise from the 0 degree mark (y = 0, x is positive), as follows:
S	 *  						bit 0 - upper right right		  -----
S	 *  						bit 1 - upper upper right		 /2   1\
S	 *  						bit 2 - upper upper left		/3     0\
S	 *  						bit 3 - upper left  left		\4     7/
X
S	 *  						bit 4 - lower left  left		 \5   6/
S	 *  						bit 5 - lower lower left		  -----
S	 *  						bit 6 - lower lower right
S	 *  						bit 7 - lower left  left
S	 * @param[in] color		The color to use
S	 *
S	 * @note	This is a more limited versions of the general arc drawing routine. It
S	 * 			doesn't require trig libraries or tables or floating point and is smaller in code size.
S	 * 			There is probably little point in including both this and the general
S	 * 			arc routine as the general arc routine can do everything this can do.
S	 *
S	 * @api
S	 */
S	void gdispGDrawArcSectors(GDisplay *g, coord_t x, coord_t y, coord_t radius, uint8_t sectors, color_t color);
S	#define gdispDrawArcSectors(x,y,r,s,c)						gdispGDrawArcSectors(GDISP,x,y,r,s,c)
S
S	/**
S	 * @brief	Fill a selection of 45 degree arcs of a circle
S	 * @pre		GDISP_NEED_ARCSECTORS must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The center of the circle
S	 * @param[in] radius	The radius of the circle
S	 * @param[in] sectors	Bits determine which sectors are drawn.
S	 * 						Bits go anti-clockwise from the 0 degree mark (y = 0, x is positive), as follows:
S	 *  						bit 0 - upper right right		  -----
S	 *  						bit 1 - upper upper right		 /2   1\
S	 *  						bit 2 - upper upper left		/3     0\
S	 *  						bit 3 - upper left  left		\4     7/
X
S	 *  						bit 4 - lower left  left		 \5   6/
S	 *  						bit 5 - lower lower left		  -----
S	 *  						bit 6 - lower lower right
S	 *  						bit 7 - lower left  left
S	 * @param[in] color		The color to use
S	 *
S	 * @note	This is a more limited versions of the general arc filling routine. It
S	 * 			doesn't require trig libraries or tables or floating point and is smaller in code size.
S	 * 			There is probably little point in including both this and the general
S	 * 			arc routine as the general arc routine can do everything this can do.
S	 *
S	 * @api
S	 */
S	void gdispGFillArcSectors(GDisplay *g, coord_t x, coord_t y, coord_t radius, uint8_t sectors, color_t color);
S	#define gdispFillArcSectors(x,y,r,s,c)						gdispGFillArcSectors(GDISP,x,y,r,s,c)
N#endif
N
N#if GDISP_NEED_ARC || defined(__DOXYGEN__)
X#if 0 || 0L
S	/*
S	 * @brief	Draw an arc.
S	 * @pre		GDISP_NEED_ARC must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x0,y0		The center point
S	 * @param[in] radius	The radius of the arc
S	 * @param[in] start		The start angle (0 to 360)
S	 * @param[in] end		The end angle (0 to 360)
S	 * @param[in] color		The color of the arc
S	 *
S	 * @note		If you are just doing 45 degree angles consider using @p gdispDrawArcSectors() instead.
S	 * @note		This routine requires trig support. It can either come from your C runtime library
S	 * 				cos() and sin() which requires floating point support (and is slow), or you can define GFX_USE_GMISC
S	 * 				and either GMISC_NEED_FIXEDTRIG or GMISC_NEED_FASTTRIG.
S	 * 				GMISC_NEED_FASTTRIG uses table based floating point trig operations.
S	 * 				GMISC_NEED_FIXEDTRIG uses fixed point integer trig operations.
S	 * 				Note accuracy on both the table based options are more than adequate for the one degree
S	 * 				resolution provided by these arc routines. Both are much faster than your C runtime library.
S	 *
S	 * @api
S	 */
S	void gdispGDrawArc(GDisplay *g, coord_t x, coord_t y, coord_t radius, coord_t startangle, coord_t endangle, color_t color);
S	#define gdispDrawArc(x,y,r,s,e,c)						gdispGDrawArc(GDISP,x,y,r,s,e,c)
S
S	/*
S	 * @brief	Draw a filled arc.
S	 * @pre		GDISP_NEED_ARC must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x0,y0		The center point
S	 * @param[in] radius	The radius of the arc
S	 * @param[in] start		The start angle (0 to 360)
S	 * @param[in] end		The end angle (0 to 360)
S	 * @param[in] color		The color of the arc
S	 *
S	 * @note		If you are just doing 45 degree angles consider using @p gdispFillArcSectors() instead.
S	 * @note		This routine requires trig support. It can either come from your C runtime library
S	 * 				cos() and sin() which requires floating point support (and is slow), or you can define GFX_USE_GMISC
S	 * 				and either GMISC_NEED_FIXEDTRIG or GMISC_NEED_FASTTRIG.
S	 * 				GMISC_NEED_FASTTRIG uses table based floating point trig operations.
S	 * 				GMISC_NEED_FIXEDTRIG uses fixed point integer trig operations.
S	 * 				Note accuracy on both the table based options are more than adequate for the one degree
S	 * 				resolution provided by these arc routines. Both are much faster than your C runtime library.
S	 *
S	 * @api
S	 */
S	void gdispGFillArc(GDisplay *g, coord_t x, coord_t y, coord_t radius, coord_t startangle, coord_t endangle, color_t color);
S	#define gdispFillArc(x,y,r,s,e,c)						gdispGFillArc(GDISP,x,y,r,s,e,c)
N#endif
N
N/* Read a pixel Function */
N
N#if GDISP_NEED_PIXELREAD || defined(__DOXYGEN__)
X#if 0 || 0L
S	/**
S	 * @brief   Get the color of a pixel.
S	 * @return  The color of the pixel.
S	 * @pre		GDISP_NEED_PIXELREAD must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The position of the pixel
S	 *
S	 * @api
S	 */
S	color_t gdispGGetPixelColor(GDisplay *g, coord_t x, coord_t y);
S	#define gdispGetPixelColor(x,y)							gdispGGetPixelColor(GDISP,x,y)
N#endif
N
N/* Scrolling Function - clears the area scrolled out */
N
N#if GDISP_NEED_SCROLL || defined(__DOXYGEN__)
X#if 0 || 0L
S	/**
S	 * @brief   Scroll vertically a section of the screen.
S	 * @pre		GDISP_NEED_SCROLL must be set to TRUE in gfxconf.h
S	 * @note    Optional.
S	 * @note    If lines is >= cy, it is equivelent to an area fill with bgcolor.
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x, y		The start of the area to be scrolled
S	 * @param[in] cx, cy	The size of the area to be scrolled
S	 * @param[in] lines		The number of lines to scroll (Can be positive or negative)
S	 * @param[in] bgcolor	The color to fill the newly exposed area.
S	 *
S	 * @api
S	 */
S	void gdispGVerticalScroll(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, int lines, color_t bgcolor);
S	#define gdispVerticalScroll(x,y,cx,cy,l,b)				gdispGVerticalScroll(GDISP,x,y,cx,cy,l,b)
N#endif
N
N/* Set driver specific control */
N
N#if GDISP_NEED_CONTROL || defined(__DOXYGEN__)
X#if 0 || 0L
S	/**
S	 * @brief   Control hardware specific parts of the display. eg powermodes, backlight etc
S	 * @pre		GDISP_NEED_CONTROL must be TRUE in your gfxconf.h
S	 * @note    Depending on the hardware implementation this function may not
S	 *          support some codes. They will be ignored.
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] what		what you want to control
S	 * @param[in] value		The value to be assigned
S	 *
S	 * @api
S	 */
S	void gdispGControl(GDisplay *g, unsigned what, void *value);
S	#define gdispControl(w,v)								gdispGControl(GDISP,w,v)
N#endif
N
N/* Query driver specific data */
N
N#if GDISP_NEED_QUERY || defined(__DOXYGEN__)
X#if 0 || 0L
S	/**
S	 * @brief   Query a property of the display.
S	 * @pre		GDISP_NEED_QUERY must be TRUE in your gfxconf.h
S	 * @note    The result must be typecast to the correct type.
S	 * @note    An unsupported query will return (void *)-1.
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] what		What to query
S	 *
S	 * @api
S	 */
S	void *gdispGQuery(GDisplay *g, unsigned what);
S	#define gdispQuery(w)									gdispGQuery(GDISP,w)
N#endif
N
N#if GDISP_NEED_CONVEX_POLYGON || defined(__DOXYGEN__)
X#if 0 || 0L
S	/**
S	 * @brief   Draw an enclosed polygon (convex, non-convex or complex).
S	 * @pre		GDISP_NEED_CONVEX_POLYGON must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] tx, ty	Transform all points in pntarray by tx, ty
S	 * @param[in] pntarray	An array of points
S	 * @param[in] cnt		The number of points in the array
S	 * @param[in] color		The color to use
S	 *
S	 * @api
S	 */
S	void gdispGDrawPoly(GDisplay *g, coord_t tx, coord_t ty, const point *pntarray, unsigned cnt, color_t color);
S	#define gdispDrawPoly(x,y,p,i,c)						gdispGDrawPoly(GDISP,x,y,p,i,c)
S
S	/**
S	 * @brief   Fill a convex polygon
S	 * @details Doesn't handle non-convex or complex polygons.
S	 * @pre		GDISP_NEED_CONVEX_POLYGON must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] tx, ty	Transform all points in pntarray by tx, ty
S	 * @param[in] pntarray	An array of points
S	 * @param[in] cnt		The number of points in the array
S	 * @param[in] color		The color to use
S	 *
S	 * @note	Convex polygons are those that have no internal angles. That is;
S	 * 			you can draw a line from any point on the polygon to any other point
S	 * 			on the polygon without it going outside the polygon. In our case we generalise
S	 * 			this a little by saying that an infinite horizontal line (at any y value) will cross
S	 * 			no more than two edges on the polygon. Some non-convex polygons do fit this criteria
S	 * 			and can therefore be drawn.
S	 * @note	This routine is designed to be very efficient with even simple display hardware.
S	 *
S	 * @api
S	 */
S	void gdispGFillConvexPoly(GDisplay *g, coord_t tx, coord_t ty, const point *pntarray, unsigned cnt, color_t color);
S	#define gdispFillConvexPoly(x,y,p,i,c)					gdispGFillConvexPoly(GDISP,x,y,p,i,c)
S
S	/**
S	 * @brief   Draw a line with a specified thickness
S	 * @details The line thickness is specified in pixels. The line ends can
S	 *          be selected to be either flat or round.
S	 * @pre		GDISP_NEED_CONVEX_POLYGON must be TRUE in your gfxconf.h
S	 * @note	Uses gdispGFillConvexPoly() internally to perform the drawing.
S	 *
S	 * @param[in] g			The display to use
S	 * @param[in] x0,y0		The start position
S	 * @param[in] x1,y1		The end position
S	 * @param[in] color		The color to use
S	 * @param[in] width		The width of the line
S	 * @param[in] round		Use round ends for the line
S	 *
S	 * @api
S	 */
S	void gdispGDrawThickLine(GDisplay *g, coord_t x0, coord_t y0, coord_t x1, coord_t y1, color_t color, coord_t width, bool_t round);
S	#define gdispDrawThickLine(x0,y0,x1,y1,c,w,r)			gdispGDrawThickLine(GDISP,x0,y0,x1,y1,c,w,r)
N#endif
N
N/* Text Functions */
N
N#if GDISP_NEED_TEXT || defined(__DOXYGEN__)
X#if 0 || 0L
S	/**
S	 * @brief   Draw a text character.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The position for the text
S	 * @param[in] c			The character to draw
S	 * @param[in] font		The font to use
S	 * @param[in] color		The color to use
S	 *
S	 * @api
S	 */
S	void gdispGDrawChar(GDisplay *g, coord_t x, coord_t y, uint16_t c, font_t font, color_t color);
S	#define	gdispDrawChar(x,y,s,f,c)						gdispGDrawChar(GDISP,x,y,s,f,c)
S
S	/**
S	 * @brief   Draw a text character with a filled background.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The position for the text
S	 * @param[in] c			The character to draw
S	 * @param[in] font		The font to use
S	 * @param[in] color		The color to use
S	 * @param[in] bgcolor	The background color to use
S	 *
S	 * @api
S	 */
S	void gdispGFillChar(GDisplay *g, coord_t x, coord_t y, uint16_t c, font_t font, color_t color, color_t bgcolor);
S	#define	gdispFillChar(x,y,s,f,c,b)						gdispGFillChar(GDISP,x,y,s,f,c,b)
S
S	/**
S	 * @brief   Draw a text string.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The position for the text
S	 * @param[in] str		The string to draw
S	 * @param[in] font		The font to use
S	 * @param[in] color		The color to use
S	 *
S	 * @api
S	 */
S	void gdispGDrawString(GDisplay *g, coord_t x, coord_t y, const char *str, font_t font, color_t color);
S	#define	gdispDrawString(x,y,s,f,c)						gdispGDrawString(GDISP,x,y,s,f,c)
S
S	/**
S	 * @brief   Draw a text string.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The position for the text
S	 * @param[in] str		The string to draw
S	 * @param[in] font		The font to use
S	 * @param[in] color		The color to use
S	 * @param[in] bgcolor	The background color to use
S	 *
S	 * @api
S	 */
S	void gdispGFillString(GDisplay *g, coord_t x, coord_t y, const char *str, font_t font, color_t color, color_t bgcolor);
S	#define	gdispFillString(x,y,s,f,c,b)					gdispGFillString(GDISP,x,y,s,f,c,b)
S
S	/**
S	 * @brief   Draw a text string vertically centered within the specified box.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The position for the text (need to define top-right or base-line - check code)
S	 * @param[in] cx,cy		The width and height of the box
S	 * @param[in] str		The string to draw
S	 * @param[in] font		The font to use
S	 * @param[in] color		The color to use
S	 * @param[in] justify	Justify the text left, center or right within the box
S	 *
S	 * @api
S	 */
S	void gdispGDrawStringBox(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, const char* str, font_t font, color_t color, justify_t justify);
S	#define	gdispDrawStringBox(x,y,cx,cy,s,f,c,j)			gdispGDrawStringBox(GDISP,x,y,cx,cy,s,f,c,j)
S
S	/**
S	 * @brief   Draw a text string vertically centered within the specified box. The box background is filled with the specified background color.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 * @note    The entire box is filled
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The position for the text (need to define top-right or base-line - check code)
S	 * @param[in] cx,cy		The width and height of the box
S	 * @param[in] str		The string to draw
S	 * @param[in] font		The font to use
S	 * @param[in] color		The color to use
S	 * @param[in] bgColor	The background color to use
S	 * @param[in] justify	Justify the text left, center or right within the box
S	 *
S	 * @api
S	 */
S	void gdispGFillStringBox(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, const char* str, font_t font, color_t color, color_t bgColor, justify_t justify);
S	#define	gdispFillStringBox(x,y,cx,cy,s,f,c,b,j)			gdispGFillStringBox(GDISP,x,y,cx,cy,s,f,c,b,j)
S
S	/**
S	 * @brief   Get a metric of a font.
S	 * @return  The metric requested in pixels.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] font    The font to test
S	 * @param[in] metric  The metric to measure
S	 *
S	 * @api
S	 */
S	coord_t gdispGetFontMetric(font_t font, fontmetric_t metric);
S
S	/**
S	 * @brief   Get the pixel width of a character.
S	 * @return  The width of the character in pixels. Does not include any between character padding.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] c       The character to draw
S	 * @param[in] font    The font to use
S	 *
S	 * @api
S	 */
S	coord_t gdispGetCharWidth(char c, font_t font);
S
S	/**
S	 * @brief   Get the pixel width of a string of a given character length.
S	 * @return  The width of the string in pixels.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @note	Passing 0 to count has the same effect as calling gdispGetStringWidt()
S	 *
S	 * @param[in] str     The string to measure
S	 * @param[in] font    The font to use
S	 * @param[in] count   The number of characters to take into account
S	 *
S	 * @api
S	 */
S	coord_t gdispGetStringWidthCount(const char* str, font_t font, uint16_t count);
S
S	/**
S	 * @brief   Get the pixel width of an entire string.
S	 * @return  The width of the string in pixels.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] str     The string to measure
S	 * @param[in] font    The font to use
S	 *
S	 * @api
S	 */
S	coord_t gdispGetStringWidth(const char* str, font_t font);
S
S	/**
S	 * @brief	Find a font and return it.
S	 * @details	The supplied name is matched against the font name. A '*' will replace 0 or more characters.
S	 * @return	Returns a font or NULL if no matching font could be found.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] name		The font name to find.
S	 *
S	 * @note				Wildcard matching will match the shortest possible match.
S	 *
S	 * @api
S	 */
S	font_t gdispOpenFont(const char *name);
S
S	/**
S	 * @brief	Release a font after use.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] font		The font to release.
S	 *
S	 * @api
S	 */
S	void gdispCloseFont(font_t font);
S
S	/**
S	 * @brief	Make a scaled copy of an existing font.
S	 * @details	Allocates memory for new font metadata using gfxAlloc, remember to close font after use!
S	 * @return	A new font or NULL if out of memory.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] font	The base font to use.
S	 * @param[in] scale_x	The scale factor in horizontal direction.
S	 * @param[in] scale_y	The scale factor in vertical direction.
S	 */
S	font_t gdispScaleFont(font_t font, uint8_t scale_x, uint8_t scale_y);
S
S	/**
S	 * @brief	Get the name of the specified font.
S	 * @returns	The name of the font.
S	 * @pre		GDISP_NEED_TEXT must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] font		The font to get the name for.
S	 *
S	 * @api
S	 */
S	const char *gdispGetFontName(font_t font);
N#endif
N
N/* Extra Arc Functions */
N
N#if GDISP_NEED_ARC || GDISP_NEED_ARCSECTORS || defined(__DOXYGEN__)
X#if 0 || 0 || 0L
S	/**
S	 * @brief   Draw a rectangular box with rounded corners
S	 * @pre		GDISP_NEED_ARC or GDISP_NEED_ARCSECTORS must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The start position
S	 * @param[in] cx,cy		The size of the box (outside dimensions)
S	 * @param[in] radius	The radius of the rounded corners
S	 * @param[in] color		The color to use
S	 *
S	 * @api
S	 */
S	void gdispGDrawRoundedBox(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, coord_t radius, color_t color);
S	#define gdispDrawRoundedBox(x,y,cx,cy,r,c)		gdispGDrawRoundedBox(GDISP,x,y,cx,cy,r,c)
S
S	/**
S	 * @brief   Draw a filled rectangular box with rounded corners
S	 * @pre		GDISP_NEED_ARC or GDISP_NEED_ARCSECTORS must be TRUE in your gfxconf.h
S	 *
S	 * @param[in] g 		The display to use
S	 * @param[in] x,y		The start position
S	 * @param[in] cx,cy		The size of the box (outside dimensions)
S	 * @param[in] radius	The radius of the rounded corners
S	 * @param[in] color		The color to use
S	 *
S	 * @api
S	 */
S	void gdispGFillRoundedBox(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, coord_t radius, color_t color);
S	#define gdispFillRoundedBox(x,y,cx,cy,r,c)		gdispGFillRoundedBox(GDISP,x,y,cx,cy,r,c)
N#endif
N
N/*
N * Macro definitions
N */
N
N/* Now obsolete functions */
N#define gdispBlitArea(x, y, cx, cy, buffer)			gdispGBlitArea(GDISP, x, y, cx, cy, 0, 0, cx, buffer)
N
N/* Macro definitions for common gets and sets */
N
N/**
N * @brief   Set the display power mode.
N * @note    Ignored if not supported by the display.
N *
N * @param[in] g 			The display to use
N * @param[in] powerMode		The new power mode
N *
N * @api
N */
N#define gdispGSetPowerMode(g, powerMode)			gdispGControl((g), GDISP_CONTROL_POWER, (void *)(unsigned)(powerMode))
N#define gdispSetPowerMode(powerMode)				gdispGControl(GDISP, GDISP_CONTROL_POWER, (void *)(unsigned)(powerMode))
N
N/**
N * @brief   Set the display orientation.
N * @note    Ignored if not supported by the display.
N *
N * @param[in] g 					The display to use
N * @param[in] newOrientation		The new orientation
N *
N * @api
N */
N#define gdispGSetOrientation(g, newOrientation)		gdispGControl((g), GDISP_CONTROL_ORIENTATION, (void *)(unsigned)(newOrientation))
N#define gdispSetOrientation(newOrientation)			gdispGControl(GDISP, GDISP_CONTROL_ORIENTATION, (void *)(unsigned)(newOrientation))
N
N/**
N * @brief   Set the display backlight.
N * @note    Ignored if not supported by the display.
N *
N * @param[in] g 			The display to use
N * @param[in] percent		The new brightness (0 - 100%)
N *
N * @note	For displays that only support backlight off and on,
N * 			0 = off, anything else = on
N *
N * @api
N */
N#define gdispGSetBacklight(g, percent)				gdispGControl((g), GDISP_CONTROL_BACKLIGHT, (void *)(unsigned)(percent))
N#define gdispSetBacklight(percent)					gdispGControl(GDISP, GDISP_CONTROL_BACKLIGHT, (void *)(unsigned)(percent))
N
N/**
N * @brief   Set the display contrast.
N * @note    Ignored if not supported by the display.
N *
N * @param[in] g 			The display to use
N * @param[in] percent		The new contrast (0 - 100%)
N *
N * @api
N */
N#define gdispGSetContrast(g, percent)				gdispGControl((g), GDISP_CONTROL_CONTRAST, (void *)(unsigned)(percent))
N#define gdispSetContrast(percent)					gdispGControl(GDISP, GDISP_CONTROL_CONTRAST, (void *)(unsigned)(percent))
N
N/* More interesting macros */
N
N/**
N * @brief   Reset the clip area to the full screen
N *
N * @param[in] g 		The display to use
N *
N * @api
N */
N#define gdispGUnsetClip(g)							gdispGSetClip((g),0,0,gdispGGetWidth(g),gdispGGetHeight(g))
N#define gdispUnsetClip()							gdispGUnsetClip(GDISP)
N
N#ifdef __cplusplus
S}
N#endif
N
N#if GDISP_NEED_IMAGE || defined(__DOXYGEN__)
X#if 0 || 0L
S	#include "gdisp_image.h"
N#endif
N#if GDISP_NEED_PIXMAP || defined(__DOXYGEN__)
X#if 0 || 0L
S	#include "gdisp_pixmap.h"
N#endif
N
N
N#endif /* GFX_USE_GDISP */
N
N#endif /* _GDISP_H */
N/** @} */
L 209 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gwin/gwin.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gwin/gwin.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gwin/gwin.h
N *
N * @defgroup Window Window
N * @ingroup Windows
N *
N * @brief		The basic window implementation (base class).
N *
N * @details		GWIN provides a basic window manager which allows it to easily
N *				create and destroy different windows at runtime. Each window
N *				will have it's own properties such as colors as well as
N *				it's own drawing origin.
N *
N * @pre		GFX_USE_GWIN must be set to TRUE in your gfxconf.h
N * @{
N */
N
N#ifndef _GWIN_H
N#define _GWIN_H
N
N#include "../../gfx.h"
N
N#if GFX_USE_GWIN || defined(__DOXYGEN__)
X#if 0 || 0L
S
S/* Forward declaration */
Stypedef struct GWindowObject *GHandle;
S
S/**
S * @brief	A window object structure
S * @note	Do not access the members directly. Treat it as a black-box and use the method functions.
S * @{
S */
Stypedef struct GWindowObject {
S	#if GWIN_NEED_WINDOWMANAGER
S		// This MUST be the first member of the structure
S		gfxQueueASyncItem	wmq;				/**< The next window (for the window manager) */
S	#endif
S	const struct gwinVMT*	vmt;				/**< The VMT for this GWIN */
S	GDisplay *				display;			/**< The display this window is on */
S	coord_t					x;					/**< The position relative to the screen */
S	coord_t					y;					/**< The position relative to the screen */
S	coord_t					width;				/**< The width of this window */
S	coord_t					height;				/**< The height of this window */
S	color_t					color;				/**< The current foreground drawing color */
S	color_t					bgcolor;			/**< The current background drawing color */
S	uint32_t				flags;				/**< Window flags (the meaning is private to the GWIN class) */
S	#if GDISP_NEED_TEXT
S		font_t				font;				/**< The current font */
S	#endif
S	#if GWIN_NEED_CONTAINERS
S		GHandle				parent;				/**< The parent window */
S	#endif
S} GWindowObject, * GHandle;
S/** @} */
S
S/**
S * @brief	The structure to initialise a GWIN.
S *
S * @note	Some gwin's will need extra parameters.
S * @note	The dimensions and position may be changed to fit on the real screen.
S * @note	If you create this structure on the stack, you should always memset
S * 			it to all zero's first in case a future version of the software
S * 			add's extra fields. Alternatively you can use @p gwinClearInit()
S * 			to clear it.
S *
S * @{
S */
Stypedef struct GWindowInit {
S	coord_t			x;								/**< The initial position relative to its parent */
S	coord_t			y;								/**< The initial position relative to its parent */
S	coord_t			width;							/**< The width */
S	coord_t			height;							/**< The height */
S	bool_t			show;							/**< Should the window be visible initially */
S	#if GWIN_NEED_CONTAINERS
S		GHandle		parent;							/**< The parent - must be a container or NULL */
S	#endif
S} GWindowInit;
S/** @} */
S
S/**
S * @brief	A window's minimized, maximized or normal size
S */
Stypedef enum { GWIN_NORMAL, GWIN_MAXIMIZE, GWIN_MINIMIZE } GWindowMinMax;
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/*-------------------------------------------------
S * Window Manager functions
S *-------------------------------------------------*/
S
S#if GWIN_NEED_WINDOWMANAGER || defined(__DOXYGEN__)
S	// Forward definition
S	struct GWindowManager;
S
S	/**
S	 * @brief   Set the window manager for the GWIN system.
S	 *
S	 * @param[in] gwm		The window manager to use. Can be NULL to turn off the existing window manager.
S	 *
S	 * @note				A window manager is responsible for handling when window visibility is changed or
S	 * 						a window is resized for moved. Note that only saved window states will be redrawn. Each
S	 * 						window type can save different information (or none at all). See the documentation on each window
S	 * 						type to see which information it saves (and can therefore be automatically redrawn).
S	 * 						For window types that do not save any state information, the window manager determines what to do.
S	 * 						Generally it will just clear the window to its background color.
S	 *
S	 * @api
S	 */
S	void gwinSetWindowManager(struct GWindowManager *gwm);
S#endif
S
S/*-------------------------------------------------
S * Functions that affect all windows
S *-------------------------------------------------*/
S
S	/**
S	 * @brief	Clear a GWindowInit structure to all zero's
S	 * @note	This function is provided just to prevent problems
S	 * 			on operating systems where using memset() causes issues
S	 * 			in the users application.
S	 *
S	 * @param[in] pwi	The GWindowInit structure to clear
S	 *
S	 * @api
S	 */
S	void gwinClearInit(GWindowInit *pwi);
S
S	/**
S	 * @brief	Set the default foreground color for all new GWIN windows
S	 *
S	 * @param[in] clr	The color to be set
S	 *
S	 * @api
S	 */
S	void gwinSetDefaultColor(color_t clr);
S
S	/**
S	 * @brief	Get the default foreground color for all new GWIN windows
S	 *
S	 * @return	The current default color for all new GWIN windows
S	 *
S	 * @api
S	 */
S	color_t gwinGetDefaultColor(void);
S
S	/**
S	 * @brief	Set the default background color for all new GWIN windows
S	 *
S	 * @param[in] bgclr	The background color
S	 *
S	 * @api
S	 */
S	void gwinSetDefaultBgColor(color_t bgclr);
S
S	/**
S	 * @brief	Get the default background color for all new GWIN windows
S	 *
S	 * @return	The current default background color for all new GWIN windows
S	 *
S	 * @api
S	 */
S	color_t gwinGetDefaultBgColor(void);
S
S	#if GDISP_NEED_TEXT || defined(__DOXYGEN__)
S		/**
S		 * @brief	Set the default font for all new GWIN windows
S		 *
S		 * @param[in] font	The new font to be set
S		 *
S		 * @api
S		 */
S		void gwinSetDefaultFont(font_t font);
S
S		/**
S		 * @brief	Get the current default font
S		 *
S		 * @return	The current default font
S		 *
S		 * @api
S		 */
S		font_t gwinGetDefaultFont(void);
S	#endif
S
S/*-------------------------------------------------
S * Base functions
S *-------------------------------------------------*/
S
S	/**
S	 * @brief   Create a basic window.
S	 * @return  NULL if there is no resultant drawing area, otherwise a window handle.
S	 *
S	 * @param[in] g			The GDisplay to display this window on
S	 * @param[in] pgw		The window structure to initialize. If this is NULL the structure is dynamically allocated.
S	 * @param[in] pInit		How to initialise the window
S	 *
S	 * @note				The drawing color and the background color get set to the current defaults. If you haven't called
S	 * 						@p gwinSetDefaultColor() or @p gwinSetDefaultBgColor() then these are White and Black respectively.
S	 * @note				The font gets set to the current default font. If you haven't called @p gwinSetDefaultFont() then there
S	 * 						is no default font and text drawing operations will no nothing.
S	 * @note				A basic window does not save the drawing state. It is not automatically redrawn if the window is moved or
S	 * 						its visibility state is changed.
S	 *
S	 * @api
S	 */
S	GHandle gwinGWindowCreate(GDisplay *g, GWindowObject *pgw, const GWindowInit *pInit);
S	#define gwinWindowCreate(pgw, pInit)		gwinGWindowCreate(GDISP, pgw, pInit);
S
S	/**
S	 * @brief   Destroy a window (of any type). Releases any dynamically allocated memory.
S	 *
S	 * @param[in] gh		The window handle
S	 *
S	 * @api
S	 */
S	void gwinDestroy(GHandle gh);
S
S	/**
S	 * @brief	Get the real class name of the GHandle
S	 * @details	Returns a string describing the object class.
S	 *
S	 * @param[in] gh	The window
S	 *
S	 * @return	A string describing the object class.
S	 *
S	 * @api
S	 */
S	const char* gwinGetClassName(GHandle gh);
S
S	/**
S	 * @brief	Get an ID that uniquely describes the class of the GHandle
S	 *
S	 * @param[in] gh	The window
S	 *
S	 * @api
S	 */
S	#define gwinGetClassID(gh)		((void *)((gh)->vmt))
S
S	/**
S	 * @brief	Get the X coordinate of the window
S	 * @details	Returns the X coordinate of the origin of the window.
S	 *			The coordinate is relative to the physical screen zero point.
S	 *
S	 * @param[in] gh	The window
S	 *
S	 * @api
S	 */
S	#define gwinGetScreenX(gh)			((gh)->x)
S
S	/**
S	 * @brief	Get the Y coordinate of the window
S	 * @details	Returns the Y coordinate of the origin of the window.
S	 *			The coordinate is relative to the physical screen zero point.
S	 *
S	 * @param[in] gh	The window
S	 *
S	 * @api
S	 */
S	#define gwinGetScreenY(gh)			((gh)->y)
S
S	/**
S	 * @brief	Get the width of the window
S	 *
S	 * @param[in] gh	The window
S	 *
S	 * @api
S	 */
S	#define gwinGetWidth(gh)			((gh)->width)
S
S	/**
S	 * @brief	Get the height of the window
S	 *
S	 * @param[in] gh	The window
S	 *
S	 * @api
S	 */
S	#define gwinGetHeight(gh)			((gh)->height)
S
S	/**
S	 * @brief	Set foreground color
S	 * @details Set the color which will be used to draw
S	 *
S	 * @param[in] gh	The window
S	 * @param[in] clr	The color to be set
S	 *
S	 * @api
S	 */
S	#define gwinSetColor(gh, clr)		(gh)->color = (clr)
S
S	/**
S	 * @brief	Set background color
S	 * @details	Set the color which will be used as background
S	 * @note	gwinClear() must be called to set the background color
S	 *
S	 * @param[in] gh	The window
S	 * @param[in] bgclr	The background color
S	 *
S	 * @api
S	 */
S	#define gwinSetBgColor(gh, bgclr)	(gh)->bgcolor = (bgclr)
S
S	/**
S	 * @brief	Get the foreground color of a window
S	 *
S	 * @param[in] gh	The window
S	 *
S	 * @api
S	 */
S	#define gwinGetColor(gh)			(gh)->color
S
S	/**
S	 * @brief	Get the background color of a window
S	 *
S	 * @param[in] gh	The window
S	 *
S	 * @api
S	 */
S	#define gwinGetBgColor(gh)			(gh)->bgcolor
S
S	/**
S	 * @brief	Sets whether a window is visible or not
S	 *
S	 * @param[in] gh		The window
S	 * @param[in] visible	Whether the window should be visible or not
S	 *
S	 * @note	When a window is marked as not visible, drawing operations
S	 * 			on the window do nothing.
S	 * @note	When a window is marked as visible, it is not automatically
S	 * 			redrawn as many window types don't remember their drawing state.
S	 * 			Widgets such as Buttons, Sliders etc will be redrawn.
S	 * @note	If there is no window manager in use, when a window is marked
S	 * 			as not visible, nothing is done to remove the window from the screen.
S	 * 			When there is a window manager, it is up to the window manager to
S	 * 			handle what happens.
S	 * @note	Even when you mark a window as visible, it may still not be displayed
S	 * 			if it's parent is invisible. When the parent becomes visible this child
S	 * 			will automatically be shown because it is already marked as visible.
S	 *
S	 * @api
S	 */
S	void gwinSetVisible(GHandle gh, bool_t visible);
S
S	/**
S	 * @brief	Makes a widget become visible
S	 *
S	 * @param[in] gh		The window handle
S	 *
S	 * @api
S	 */
S	#define gwinShow(gh)		gwinSetVisible(gh, TRUE)
S
S	/**
S	 * @brief	Makes a widget become invisible
S	 *
S	 * @param[in] gh		The window handle
S	 *
S	 * @api
S	 */
S	#define gwinHide(gh)		gwinSetVisible(gh, FALSE)
S
S	/**
S	 * @brief	Gets the visibility of a window
S	 * @return	TRUE if visible
S	 *
S	 * @note	It is possible for a child to be marked as visible by @p gwinSetVisible()
S	 * 			but for this call to return FALSE if one of its parents are not visible.
S	 *
S	 * @param[in] gh		The window
S	 *
S	 * @api
S	 */
S	bool_t gwinGetVisible(GHandle gh);
S
S	/**
S	 * @brief	Enable or disable a window
S	 *
S	 * @param[in] gh		The window handle
S	 * @param[in] enabled	Enable or disable the window
S	 *
S	 * @note	The window is automatically redrawn if it supports self-redrawing.
S	 * @note	Even when you mark a window as enabled, it may still remain disabled
S	 * 			if it's parent is disabled. When the parent becomes enabled this child
S	 * 			will automatically be enabled because it is already marked as enabled.
S	 *
S	 * @api
S	 */
S	void gwinSetEnabled(GHandle gh, bool_t enabled);
S
S	/**
S	 * @brief	Enables a widget
S	 *
S	 * @param[in] gh		The window handle
S	 *
S	 * @api
S	 */
S	#define gwinEnable(gh)		gwinSetEnabled(gh, TRUE)
S
S	/**
S	 * @brief	Disables a widget
S	 *
S	 * @param[in] gh		The window handle
S	 *
S	 * @api
S	 */
S	#define gwinDisable(gh)		gwinSetEnabled(gh, FALSE)
S
S	/**
S	 * @brief	Gets the enabled state of a window
S	 * @return	TRUE if enabled
S	 *
S	 * @note	It is possible for a child to be marked as enabled by @p gwinSetEnabled()
S	 * 			but for this call to return FALSE if one of its parents are not enabled.
S	 *
S	 * @param[in] gh		The window
S	 *
S	 * @api
S	 */
S	bool_t gwinGetEnabled(GHandle gh);
S
S	/**
S	 * @brief	Move a window
S	 *
S	 * @param[in] gh		The window
S	 * @param[in] x, y		The new position (screen relative) for this window
S	 *
S	 * @note	The final window position may not be the requested position. Windows
S	 * 			are clipped to the screen area and the window manager may also affect the position.
S	 * @note	The window is redrawn if it is visible. See the comments in @p gwinSetVisible()
S	 * 			with regard to what can be redrawn and what can't.
S	 * @note	It is up to the window manager to determine what happens with the screen area
S	 * 			uncovered by moving the window. When there is no window manager, nothing
S	 * 			is done with the uncovered area.
S	 *
S	 * @api
S	 */
S	void gwinMove(GHandle gh, coord_t x, coord_t y);
S
S	/**
S	 * @brief	Resize a window
S	 *
S	 * @param[in] gh				The window
S	 * @param[in] width, height		The new size of the window
S	 *
S	 * @note	The final window size may not be the requested size. Windows
S	 * 			are clipped to the screen area and the window manager may also affect the size.
S	 * @note	The window is redrawn if it is visible. See the comments in @p gwinSetVisible()
S	 * 			with regard to what can be redrawn and what can't.
S	 * @note	It is up to the window manager to determine what happens with any screen area
S	 * 			uncovered by resizing the window. When there is no window manager, nothing
S	 * 			is done with the uncovered area.
S	 *
S	 * @api
S	 */
S	void gwinResize(GHandle gh, coord_t width, coord_t height);
S
S	/**
S	 * @brief	Redraw a window
S	 *
S	 * @param[in] gh				The window
S	 *
S	 * @note	This is normally never required as windows and widgets will redraw as required.
S	 * 			Note that some windows are incapable of redrawing themselves as they don't save
S	 * 			their drawing state.
S	 *
S	 * @api
S	 */
S	void gwinRedraw(GHandle gh);
S
S	#if GWIN_NEED_WINDOWMANAGER || defined (__DOXYGEN__)
S		/**
S		 * @brief	Redraw a display
S		 *
S		 * @param[in] g				The display to redraw. Passing NULL will redraw all displays.
S		 * @param[in] preserve		Should the redraw try to preserve existing screen data for those
S		 * 							windows that can't redraw themselves?
S		 *
S		 * @note	This is normally never required as windows and widgets will redraw as required.
S		 * @note	Some windows are incapable of redrawing themselves as they don't save
S		 * 			their drawing state.
S		 * @note	This does not clear the background - just redraws the gwin windows (where possible)
S		 *
S		 * @api
S		 */
S		void gwinRedrawDisplay(GDisplay *g, bool_t preserve);
S
S		/**
S		 * @brief	Minimize, Maximize or Restore a window
S		 * @pre		GWIN_NEED_WINDOWMANAGER must be TRUE
S		 *
S		 * @param[in] gh				The window
S		 * @param[in] minmax			The new minimized/maximized state
S		 *
S		 * @note	The final window state may not be the requested state. Window Managers
S		 * 			do not need to implement changing the minmax state. If there is no
S		 * 			window manager this call is ignored.
S		 * @note	The window is redrawn if it is changed. See the comments in @p gwinSetVisible()
S		 * 			with regard to what can be redrawn and what can't.
S		 * @note	It is up to the window manager to determine what happens with any screen area
S		 * 			uncovered by resizing the window.
S		 * @note	When a window is minimised it may be asked to draw the window or the window
S		 * 			manager may draw the minimised window.
S		 *
S		 * @api
S		 */
S		void gwinSetMinMax(GHandle gh, GWindowMinMax minmax);
S
S		/**
S		 * @brief	Get the Minimized/Maximized state of a window
S		 * @pre		GWIN_NEED_WINDOWMANAGER must be TRUE
S		 *
S		 * @param[in] gh				The window
S		 *
S		 * @return	GWIN_NORMAL, GWIN_MAXIMIZE or GWIN_MINIMIZE
S		 *
S		 * @api
S		 */
S		GWindowMinMax gwinGetMinMax(GHandle gh);
S
S		/**
S		 * @brief	Raise a window to the top of the z-order
S		 * @pre		GWIN_NEED_WINDOWMANAGER must be TRUE
S		 *
S		 * @param[in] gh				The window
S		 *
S		 * @note	The window z-order is only supported by some window managers. See the comments
S		 * 			in @p gwinSetVisible() with regard to what can be redrawn and what can't.
S		 *
S		 * @api
S		 */
S		void gwinRaise(GHandle gh);
S
S		/**
S		 * @brief	Get the next window in the z-order
S		 * @return	The next window or NULL if no more windows
S		 *
S		 * @param[in] gh		The previous window or NULL to get the first window
S		 *
S		 * @note	This returns the next window in the system from top to bottom.
S		 * @note	Where there are parent child relationships, this ignores them
S		 * 			and will list all windows in the system. There is no defined
S		 * 			order between children of siblings and they can in fact be mixed
S		 * 			in order. The only relationship honored is that parents will be
S		 * 			listed before their children.
S		 *
S		 * @api
S		 */
S		GHandle gwinGetNextWindow(GHandle gh);
S
S		/**
S		 * @brief	Set a window or widget to flash
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] flash		Enable or disable the flashing of the window
S		 *
S		 * @note	The window is automatically redrawn if it supports self-redrawing.
S		 * @note	When a window is set to flash, its appearance changes in some
S		 * 			way every flash period (GWIN_FLASHING_PERIOD). How its appearance
S		 * 			changes depends on the draw for each window/widget.
S		 *
S		 * @pre		Requires GWIN_NEED_FLASHING to be TRUE
S		 *
S		 * @api
S		 */
S		void gwinSetFlashing(GHandle gh, bool_t flash);
S
S		/**
S		 * @brief	Enables flashing of a window or widget
S		 *
S		 * @param[in] gh		The window handle
S		 *
S		 * @api
S		 */
S		#define gwinFlash(gh)		gwinSetFlashing(gh, TRUE)
S
S		/**
S		 * @brief	Disables a widget
S		 *
S		 * @param[in] gh		The window handle
S		 *
S		 * @api
S		 */
S		#define gwinNoFlash(gh)		gwinSetFlashing(gh, FALSE)
S	#endif
S
S	#if GDISP_NEED_TEXT || defined(__DOXYGEN__)
S		/**
S		 * @brief   Set the current font for this window.
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] font		The font to use for text functions
S		 *
S		 * @api
S		 */
S		void gwinSetFont(GHandle gh, font_t font);
S	#endif
S
S/*-------------------------------------------------
S * Drawing functions
S *-------------------------------------------------*/
S
S	/**
S	 * @brief   Clear the window
S	 * @note	Uses the current background color to clear the window
S	 *
S	 * @param[in] gh		The window handle
S	 *
S	 * @api
S	 */
S	void gwinClear(GHandle gh);
S
S	/**
S	 * @brief   Set a pixel in the window
S	 * @note	Uses the current foreground color to set the pixel
S	 * @note	May leave GDISP clipping to this window's dimensions
S	 *
S	 * @param[in] gh		The window handle
S	 * @param[in] x,y		The coordinates of the pixel
S	 *
S	 * @api
S	 */
S	void gwinDrawPixel(GHandle gh, coord_t x, coord_t y);
S
S	/**
S	 * @brief   Draw a line in the window
S	 * @note	Uses the current foreground color to draw the line
S	 * @note	May leave GDISP clipping to this window's dimensions
S	 *
S	 * @param[in] gh		The window handle
S	 * @param[in] x0,y0		The start position
S	 * @param[in] x1,y1 	The end position
S	 *
S	 * @api
S	 */
S	void gwinDrawLine(GHandle gh, coord_t x0, coord_t y0, coord_t x1, coord_t y1);
S
S	/**
S	 * @brief   Draw a box in the window
S	 * @note	Uses the current foreground color to draw the box
S	 * @note	May leave GDISP clipping to this window's dimensions
S	 *
S	 * @param[in] gh		The window handle
S	 * @param[in] x,y		The start position
S	 * @param[in] cx,cy		The size of the box (outside dimensions)
S	 *
S	 * @api
S	 */
S	void gwinDrawBox(GHandle gh, coord_t x, coord_t y, coord_t cx, coord_t cy);
S
S	/**
S	 * @brief   Fill an rectangular area in the window
S	 * @note	Uses the current foreground color to fill the box
S	 * @note	May leave GDISP clipping to this window's dimensions
S	 *
S	 * @param[in] gh		The window handle
S	 * @param[in] x,y		The start position
S	 * @param[in] cx,cy		The size of the box (outside dimensions)
S	 *
S	 * @api
S	 */
S	void gwinFillArea(GHandle gh, coord_t x, coord_t y, coord_t cx, coord_t cy);
S
S	/**
S	 * @brief   Fill an area in the window using the supplied bitmap.
S	 * @details The bitmap is in the pixel format specified by the low level driver
S	 * @note	If GDISP_NEED_ASYNC is defined then the buffer must be static
S	 * 			or at least retained until this call has finished the blit. You can
S	 * 			tell when all graphics drawing is finished by @p gdispIsBusy() going FALSE.
S	 * @note	May leave GDISP clipping to this window's dimensions
S	 *
S	 * @param[in] gh		The window handle
S	 * @param[in] x, y		The start filled area
S	 * @param[in] cx, cy	The width and height to be filled
S	 * @param[in] srcx, srcy	The bitmap position to start the fill from
S	 * @param[in] srccx		The width of a line in the bitmap.
S	 * @param[in] buffer	The pixels to use to fill the area.
S	 *
S	 * @api
S	 */
S	void gwinBlitArea(GHandle gh, coord_t x, coord_t y, coord_t cx, coord_t cy, coord_t srcx, coord_t srcy, coord_t srccx, const pixel_t *buffer);
S
S/*-------------------------------------------------
S * Circle, ellipse, arc and arc-sectors functions
S *-------------------------------------------------*/
S
S	#if GDISP_NEED_CIRCLE || defined(__DOXYGEN__)
S		/**
S		 * @brief   Draw a circle in the window.
S		 * @note	Uses the current foreground color to draw the circle
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x, y		The center of the circle
S		 * @param[in] radius	The radius of the circle
S		 *
S		 * @api
S		 */
S		void gwinDrawCircle(GHandle gh, coord_t x, coord_t y, coord_t radius);
S
S		/**
S		 * @brief   Draw a filled circle in the window.
S		 * @note	Uses the current foreground color to draw the filled circle
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x, y		The center of the circle
S		 * @param[in] radius	The radius of the circle
S		 *
S		 * @api
S		 */
S		void gwinFillCircle(GHandle gh, coord_t x, coord_t y, coord_t radius);
S	#endif
S
S	#if GDISP_NEED_ELLIPSE || defined(__DOXYGEN__)
S		/**
S		 * @brief   Draw an ellipse.
S		 * @note	Uses the current foreground color to draw the ellipse
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The center of the ellipse
S		 * @param[in] a,b		The dimensions of the ellipse
S		 *
S		 * @api
S		 */
S		void gwinDrawEllipse(GHandle gh, coord_t x, coord_t y, coord_t a, coord_t b);
S
S		/**
S		 * @brief   Draw an filled ellipse.
S		 * @note	Uses the current foreground color to draw the filled ellipse
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The center of the ellipse
S		 * @param[in] a,b		The dimensions of the ellipse
S		 *
S		 * @api
S		 */
S		void gwinFillEllipse(GHandle gh, coord_t x, coord_t y, coord_t a, coord_t b);
S	#endif
S
S	#if GDISP_NEED_ARC || defined(__DOXYGEN__)
S		/*
S		 * @brief	Draw an arc in the window.
S		 * @note	Uses the current foreground color to draw the arc
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The center point
S		 * @param[in] radius	The radius of the arc
S		 * @param[in] start		The start angle (0 to 360)
S		 * @param[in] end		The end angle (0 to 360)
S		 *
S		 * @api
S		 */
S		void gwinDrawArc(GHandle gh, coord_t x, coord_t y, coord_t radius, coord_t startangle, coord_t endangle);
S
S		/*
S		 * @brief	Draw a filled arc in the window.
S		 * @note	Uses the current foreground color to draw the filled arc
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The center point
S		 * @param[in] radius	The radius of the arc
S		 * @param[in] start		The start angle (0 to 360)
S		 * @param[in] end		The end angle (0 to 360)
S		 *
S		 * @api
S		 */
S		void gwinFillArc(GHandle gh, coord_t x, coord_t y, coord_t radius, coord_t startangle, coord_t endangle);
S	#endif
S
S	#if GDISP_NEED_ARCSECTORS || defined(__DOXYGEN__)
S		/*
S		 * @brief	Draw a selection of 45 degree arcs of a circle in the window.
S		 * @note	Uses the current foreground color to draw the arc sector
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The center of the circle
S		 * @param[in] radius	The radius of the circle
S		 * @param[in] sectors	Bits determine which sectors are drawn.
S		 * 						Bits go anti-clockwise from the 0 degree mark (y = 0, x is positive), as follows:
S		 *  						bit 0 - upper right right		  -----
S		 *  						bit 1 - upper upper right		 /2   1\
S		 *  						bit 2 - upper upper left		/3     0\
S		 *  						bit 3 - upper left  left		\4     7/
X
S		 *  						bit 4 - lower left  left		 \5   6/
S		 *  						bit 5 - lower lower left		  -----
S		 *  						bit 6 - lower lower right
S		 *  						bit 7 - lower left  left
S		 *
S		 * @api
S		 */
S		void gwinDrawArcSectors(GHandle gh, coord_t x, coord_t y, coord_t radius, uint8_t sectors);
S
S		/*
S		 * @brief	Draw a filled selection of 45 degree arcs of a circle in the window.
S		 * @note	Uses the current foreground color to draw the arc sector
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The center of the circle
S		 * @param[in] radius	The radius of the circle
S		 * @param[in] sectors	Bits determine which sectors are drawn.
S		 * 						Bits go anti-clockwise from the 0 degree mark (y = 0, x is positive), as follows:
S		 *  						bit 0 - upper right right		  -----
S		 *  						bit 1 - upper upper right		 /2   1\
S		 *  						bit 2 - upper upper left		/3     0\
S		 *  						bit 3 - upper left  left		\4     7/
X
S		 *  						bit 4 - lower left  left		 \5   6/
S		 *  						bit 5 - lower lower left		  -----
S		 *  						bit 6 - lower lower right
S		 *  						bit 7 - lower left  left
S		 *
S		 * @api
S		 */
S		void gwinFillArcSectors(GHandle gh, coord_t x, coord_t y, coord_t radius, uint8_t sectors);
S	#endif
S
S/*-------------------------------------------------
S * Pixel read-back functions
S *-------------------------------------------------*/
S
S	#if GDISP_NEED_PIXELREAD || defined(__DOXYGEN__)
S		/**
S		 * @brief   Get the color of a pixel in the window.
S		 * @return  The color of the pixel.
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The position in the window
S		 *
S		 * @api
S		 */
S		color_t gwinGetPixelColor(GHandle gh, coord_t x, coord_t y);
S	#endif
S
S/*-------------------------------------------------
S * Text functions
S *-------------------------------------------------*/
S
S	#if GDISP_NEED_TEXT || defined(__DOXYGEN__)
S		/**
S		 * @brief   Draw a text character at the specified position in the window.
S		 * @pre		The font must have been set.
S		 * @note	Uses the current foreground color to draw the character
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The position for the text
S		 * @param[in] c			The character to draw
S		 *
S		 * @api
S		 */
S		void gwinDrawChar(GHandle gh, coord_t x, coord_t y, char c);
S
S		/**
S		 * @brief   Draw a text character with a filled background at the specified position in the window.
S		 * @pre		The font must have been set.
S		 * @note	Uses the current foreground color to draw the character and fills the background using the background drawing color
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The position for the text
S		 * @param[in] c			The character to draw
S		 *
S		 * @api
S		 */
S		void gwinFillChar(GHandle gh, coord_t x, coord_t y, char c);
S
S		/**
S		 * @brief   Draw a text string in the window
S		 * @pre		The font must have been set.
S		 * @note	Uses the current foreground color to draw the character
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The position for the text
S		 * @param[in] str		The string to draw
S		 *
S		 * @api
S		 */
S		void gwinDrawString(GHandle gh, coord_t x, coord_t y, const char *str);
S
S		/**
S		 * @brief   Draw a text string with a filled background in the window
S		 * @pre		The font must have been set.
S		 * @note	Uses the current foreground color to draw the character and fills the background using the background drawing color
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The position for the text
S		 * @param[in] str		The string to draw
S		 *
S		 * @api
S		 */
S		void gwinFillString(GHandle gh, coord_t x, coord_t y, const char *str);
S
S		/**
S		 * @brief   Draw a text string verticly centered within the specified box.
S		 * @pre		The font must have been set.
S		 * @note	Uses the current foreground color to draw the character.
S		 * @note    The specified box does not need to align with the window box
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The position for the text (need to define top-right or base-line - check code)
S		 * @param[in] cx,cy		The width and height of the box
S		 * @param[in] str		The string to draw
S		 * @param[in] justify	Justify the text left, center or right within the box
S		 *
S		 * @api
S		 */
S		void gwinDrawStringBox(GHandle gh, coord_t x, coord_t y, coord_t cx, coord_t cy, const char* str, justify_t justify);
S
S		/**
S		 * @brief   Draw a text string verticly centered within the specified filled box.
S		 * @pre		The font must have been set.
S		 * @note	Uses the current foreground color to draw the character and fills the background using the background drawing color
S		 * @note    The entire box is filled. Note this box does not need to align with the window box
S		 * @note	May leave GDISP clipping to this window's dimensions
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] x,y		The position for the text (need to define top-right or base-line - check code)
S		 * @param[in] cx,cy		The width and height of the box
S		 * @param[in] str		The string to draw
S		 * @param[in] justify	Justify the text left, center or right within the box
S		 *
S		 * @api
S		 */
S		void gwinFillStringBox(GHandle gh, coord_t x, coord_t y, coord_t cx, coord_t cy, const char* str, justify_t justify);
S	#endif
S
S/*-------------------------------------------------
S * Polygon functions
S *-------------------------------------------------*/
S
S	#if GDISP_NEED_CONVEX_POLYGON || defined(__DOXYGEN__)
S		/**
S		 * @brief   Draw an enclosed polygon (convex, non-convex or complex).
S		 *
S		 * @note	Uses the current foreground color.
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] tx, ty	Transform all points in pntarray by tx, ty
S		 * @param[in] pntarray	An array of points
S		 * @param[in] cnt		The number of points in the array
S		 *
S		 * @api
S		 */
S		void gwinDrawPoly(GHandle gh, coord_t tx, coord_t ty, const point *pntarray, unsigned cnt);
S
S		/**
S		 * @brief   Fill a convex polygon
S		 * @details Doesn't handle non-convex or complex polygons.
S		 *
S		 * @note	Uses the current foreground color.
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] tx, ty	Transform all points in pntarray by tx, ty
S		 * @param[in] pntarray	An array of points
S		 * @param[in] cnt		The number of points in the array
S		 *
S		 * @note	Convex polygons are those that have no internal angles. That is;
S		 * 			you can draw a line from any point on the polygon to any other point
S		 * 			on the polygon without it going outside the polygon. In our case we generalise
S		 * 			this a little by saying that an infinite horizontal line (at any y value) will cross
S		 * 			no more than two edges on the polygon. Some non-convex polygons do fit this criteria
S		 * 			and can therefore be drawn.
S		 * @note	This routine is designed to be very efficient with even simple display hardware.
S		 *
S		 * @api
S		 */
S		void gwinFillConvexPoly(GHandle gh, coord_t tx, coord_t ty, const point *pntarray, unsigned cnt);
S	
S		/**
S		 * @brief	Draw a thick line in the window
S		 * @details	The line thickness is specified in pixels. The line ends can
S		 *		be selected to be either flat or round.
S		 * @note	Uses gdispGFillConvexPoly() internally to perform the drawing.
S		 * @note	Uses the current foreground color to draw the line
S		 * 
S		 * @param[in] gh		The window handle
S		 * @param[in] x0,y0		The start position
S		 * @param[in] x1,y1		The end position
S		 * @param[in] width		The width of the line
S		 * @param[in] round		Use round ends for the line
S		 * 
S		 * @api
S		 */
S		void gwinDrawThickLine(GHandle gh, coord_t x0, coord_t y0, coord_t x1, coord_t y1, coord_t width, bool_t round);
S	#endif
S
S/*-------------------------------------------------
S * Image functions
S *-------------------------------------------------*/
S
S	#if GDISP_NEED_IMAGE || defined(__DOXYGEN__)
S		/**
S		 * @brief	Draw the image
S		 * @return	GDISP_IMAGE_ERR_OK (0) on success or an error code.
S		 *
S		 * @param[in] gh		The window handle
S		 * @param[in] img   	The image structure
S		 * @param[in] x,y		The window location to draw the image
S		 * @param[in] cx,cy		The area on the screen to draw
S		 * @param[in] sx,sy		The image position to start drawing at
S		 *
S		 * @pre		gdispImageOpen() must have returned successfully.
S		 *
S		 * @note	If sx,sy + cx,cy is outside the image boundaries the area outside the image
S		 * 			is simply not drawn.
S		 * @note	If @p gdispImageCache() has been called first for this frame, this routine will draw using a
S		 * 			fast blit from the cached frame. If not, it reads the input and decodes it as it
S		 * 			is drawing. This may be significantly slower than if the image has been cached (but
S		 * 			uses a lot less RAM)
S		 *
S		 * @api
S		 */
S		gdispImageError gwinDrawImage(GHandle gh, gdispImage *img, coord_t x, coord_t y, coord_t cx, coord_t cy, coord_t sx, coord_t sy);
S	#endif
S
S#ifdef __cplusplus
S}
S#endif
S
S/*-------------------------------------------------
S * Additional functionality
S *-------------------------------------------------*/
S
S	/* Include widgets */
S	#if GWIN_NEED_WIDGET || defined(__DOXYGEN__)
S		#include "gwin_widget.h"
S	#endif
S
S	/* Include containers */
S	#if GWIN_NEED_CONTAINERS || defined(__DOXYGEN__)
S		#include "gwin_container.h"
S	#endif
S
S	/* Include vanilla window objects */
S	#if GWIN_NEED_CONSOLE || defined(__DOXYGEN__)
S		#include "gwin_console.h"
S	#endif
S	#if GWIN_NEED_GRAPH || defined(__DOXYGEN__)
S		#include "gwin_graph.h"
S	#endif
S	#if GWIN_NEED_IMAGE || defined(__DOXYGEN__)
S		#include "gwin_image.h"
S	#endif
S	#if GWIN_NEED_GL3D || defined(__DOXYGEN__)
S		#include "gwin_gl3d.h"
S	#endif
S
N#endif /* GFX_USE_GWIN */
N
N#endif /* _GWIN_H */
N/** @} */
L 210 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/ginput/ginput.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/ginput/ginput.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/ginput/ginput.h
N *
N * @addtogroup GINPUT
N *
N * @brief		Module to interface different hardware input sources such as touchscreens
N *
N * @details		GINPUT provides an easy and common interface to use different input devices
N *				such as touchscreens and mices.
N *
N * @pre			GFX_USE_GINPUT must be set to TRUE in your gfxconf.h
N *
N * @{
N */
N#ifndef _GINPUT_H
N#define _GINPUT_H
N
N#include "../../gfx.h"
N
N#if GFX_USE_GINPUT || defined(__DOXYGEN__)
X#if 0 || 0L
S
S/* How to use...
S
S	1. Get source handles for all the inputs you are interested in.
S		- Attempting to get a handle for one instance of an input more than once will return the same handle
S	2. Create a listener
S	3. Assign inputs to your listener.
S		- Inputs can be assigned or released from a listener at any time.
S		- An input can be assigned to more than one listener.
S	4. Loop on getting listener events
S	5. When complete destroy the listener
S*/
S
S// Include various ginput types
S#include "ginput_mouse.h"
S#include "ginput_keyboard.h"
S#include "ginput_toggle.h"
S#include "ginput_dial.h"
S
N#endif /* GFX_USE_GINPUT */
N
N#endif /* _GINPUT_H */
N/** @} */
L 211 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gadc/gadc.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gadc/gadc.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gadc/gadc.h
N *
N * @addtogroup GADC
N *
N * @brief	Module to abstract the very variable ADC interfaces of the underlying systems
N *
N * @details	The reason why ChibiOS/GFX has it's own ADC abstraction is because
N *			the Chibi-OS drivers are very CPU specific and do not
N *			provide a way across all hardware platforms to create periodic
N *			ADC conversions. There are also issues with devices with different
N *			characteristics or periodic requirements on the same ADC
N *			device (but different channels). This layer attempts to solve these
N *			problems to provide a architecture neutral API. It also provides extra
N *			features such as multi-buffer chaining for high speed ADC sources.
N *			It provides one high speed virtual ADC device (eg a microphone) and
N *			numerous low speed (less than 100Hz) virtual ADC devices (eg dials,
N *			temperature sensors etc). The high speed device has timer based polling
N *			to ensure exact conversion periods and a buffer management system.
N *			The low speed devices are assumed to be non-critical timing devices
N *			and do not have any buffer management.
N *			Note that while only one high speed device has been provided it can
N *			be used to read multiple physical ADC channels on the one physical
N *			ADC device.
N *			All callback routines are thread based unlike the Chibi-OS interrupt based
N *			routines.
N *
N * @{
N */
N
N#ifndef _GADC_H
N#define _GADC_H
N
N#include "../../gfx.h"
N
N#if GFX_USE_GADC || defined(__DOXYGEN__)
X#if 0 || 0L
S
S/* Include the driver defines */
S#include "gadc_lld_config.h"
S
S/*===========================================================================*/
S/* Type definitions                                                          */
S/*===========================================================================*/
S
S// Event types for GADC
S#define GEVENT_ADC			(GEVENT_GADC_FIRST+0)
S
S/**
S * @brief   The High Speed ADC event structure.
S * @{
S */
Stypedef struct GEventADC_t {
S	#if GFX_USE_GEVENT || defined(__DOXYGEN__)
S		/**
S		 * @brief The type of this event (GEVENT_ADC)
S		 */
S		GEventType		type;
S	#endif
S
S	/**
S	 * @brief The event flags
S	 */
S	uint16_t		flags;
S		/**
S		 * @brief   The event flag values.
S		 * @{
S		 */
S		#define	GADC_HSADC_LOSTEVENT		0x0001		/**< @brief The last GEVENT_HSDADC event was lost */
S		#define	GADC_HSADC_RUNNING			0x0002		/**< @brief The High Speed ADC is currently running */
S		#define	GADC_HSADC_GOTBUFFER		0x0004		/**< @brief A buffer is ready for processing */
S		#define	GADC_HSADC_STALL			0x0008		/**< @brief The High Speed ADC has stalled due to no free buffers */
S		/** @} */
S} GEventADC;
S/** @} */
S
S/**
S * @brief A callback function (executed in a thread context) for a low speed conversion
S */
Stypedef void (*GADCCallbackFunction)(adcsample_t *buffer, void *param);
S
S/**
S * @brief A callback function (executed in an ISR context) for a high speed conversion
S */
Stypedef void (*GADCISRCallbackFunction)(void);
S
S/*===========================================================================*/
S/* External declarations.                                                    */
S/*===========================================================================*/
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/**
S * @brief				Initialise the high speed ADC.
S * @details				Initialises but does not start the conversions.
S *
S * @param[in] physdev			A value passed to describe which physical ADC devices/channels to use.
S * @param[in] frequency			The frequency to create ADC conversions
S *
S * @note				If the high speed ADC is running it will be stopped. The Event subsystem is
S * 						disconnected from the high speed ADC and any binary semaphore event is forgotten.
S * @note				ChibiOS ONLY: Due to a bug in ChibiOS each buffer on the free-list must contain an even number of
S * 						samples and for multi-channel devices it must hold a number of samples that is evenly divisible
S * 						by 2 times the number of active channels.
S * @note				The physdev parameter may be used to turn on more than one ADC channel.
S * 						Each channel is then interleaved into the provided buffer. Make sure your buffers all hold
S * 						a number of samples evenly divisible by the number of active channels.
S * 						As an example, if physdev turns on 2 devices then the buffer contains
S * 						alternate device samples and the buffer must contain multiples of 2 samples.
S * 						The exact meaning of physdev is hardware dependent.
S * @note				While the high speed ADC is running, low speed conversions can only occur at
S * 						the frequency of the high speed events. Thus if high speed events are
S * 						being created at 50Hz (eg 100 samples/buffer, frequency = 5kHz) then the maximum
S * 						frequency for low speed conversions will be 50Hz.
S * @note				Only a single sample format is supported - that provided by the GADC driver. That sample
S * 						format applies to both high speed and low speed sampling.
S *
S * @api
S */
Svoid gadcHighSpeedInit(uint32_t physdev, uint32_t frequency);
S
S#if GFX_USE_GEVENT || defined(__DOXYGEN__)
S	/**
S	 * @brief   			Turn on sending results to the GEVENT sub-system.
S	 * @details				Returns a GSourceHandle to listen for GEVENT_ADC events.
S	 *
S	 * @note				The high speed ADC will not use the GEVENT system unless this is
S	 * 						called first. This saves processing time if the application does
S	 * 						not want to use the GEVENT sub-system for the high speed ADC.
S	 * 						Once turned on it can only be turned off by calling @p gadcHighSpeedInit() again.
S	 * @note				The high speed ADC is capable of signalling via this method, an ISR callback and a
S	 * 						binary semaphore at the same time.
S	 *
S	 * @return				The GSourceHandle
S	 *
S	 * @api
S	 */
S	GSourceHandle gadcHighSpeedGetSource(void);
S#endif
S
S/**
S * @brief				Allow retrieving of results from the high speed ADC using an ISR callback.
S *
S * @param[in] isrfn			The callback function (called in an ISR context).
S *
S * @note				Passing a NULL for isrfn will turn off signalling via this method as will calling
S * 						@p gadcHighSpeedInit().
S * @note				The high speed ADC is capable of signalling via this method, a blocked thread and the GEVENT
S * 						sub-system at the same time.
S *
S * @api
S */
Svoid gadcHighSpeedSetISRCallback(GADCISRCallbackFunction isrfn);
S
S/**
S * @brief		Get a filled buffer from the ADC
S * @return		A GDataBuffer pointer or NULL if the timeout is exceeded
S *
S * @param[in] ms	The maximum amount of time in milliseconds to wait for data if some is not currently available.
S *
S * @note		After processing the data, your application must return the buffer to the free-list so that
S * 				it can be used again. This can be done using @p gfxBufferRelease().
S * @note		A buffer may be returned to the free-list before you have finished processing it provided you finish
S * 				processing it before GADC re-uses it. This is useful when RAM usage is critical to reduce the number
S * 				of buffers required. It works before the free list is a FIFO queue and therefore buffers are kept
S * 				in the queue as long as possible before they are re-used.
S * @note		The function ending with "I" is the interrupt class function.
S * @api
S * @{
S */
SGDataBuffer *gadcHighSpeedGetData(delaytime_t ms);
SGDataBuffer *gadcHighSpeedGetDataI(void);
S/** @} */
S
S/**
S * @brief   Start the high speed ADC conversions.
S * @pre		It must have been initialised first with @p gadcHighSpeedInit()
S *
S * @api
S */
Svoid gadcHighSpeedStart(void);
S
S/**
S * @brief   Stop the high speed ADC conversions.
S *
S * @api
S */
Svoid gadcHighSpeedStop(void);
S
S/**
S * @brief	Perform a single low speed ADC conversion
S * @details	Blocks until the conversion is complete
S * @pre		This should not be called from within a GTimer callback as this routine
S * 			blocks until the conversion is ready.
S *
S * @param[in] physdev		A value passed to describe which physical ADC devices/channels to use.
S * @param[in] buffer		The static buffer to put the ADC samples into.
S *
S * @note	This may take a while to complete if the high speed ADC is running as the
S * 			conversion is interleaved with the high speed ADC conversions on a buffer
S * 			completion.
S * @note	The result buffer must be large enough to store one sample per device
S * 			described by the 'physdev' parameter.
S * @note	Specifying more than one device in physdev is possible but discouraged as the
S * 			calculations to ensure the high speed ADC correctness will be incorrect. Symptoms
S * 			from over-running the high speed ADC include high speed device stalling or samples being lost.
S *
S * @api
S */
Svoid gadcLowSpeedGet(uint32_t physdev, adcsample_t *buffer);
S
S/**
S * @brief	Perform a low speed ADC conversion with callback (in a thread context)
S * @details	Returns FALSE if internal memory allocation fails
S *
S * @param[in] physdev		A value passed to describe which physical ADC devices/channels to use.
S * @param[in] buffer		The static buffer to put the ADC samples into.
S * @param[in] fn			The callback function to call when the conversion is complete.
S * @param[in] param			A parameter to pass to the callback function.
S *
S * @return					FALSE if no free low speed ADC slots.
S *
S * @note	This may be safely called from within a GTimer callback.
S * @note	The callback may take a while to occur if the high speed ADC is running as the
S * 			conversion is interleaved with the high speed ADC conversions on a buffer
S * 			completion.
S * @note	The result buffer must be large enough to store one sample per device
S * 			described by the 'physdev' parameter.
S * @note	Specifying more than one device in physdev is possible but discouraged as the
S * 			calculations to ensure the high speed ADC correctness will be incorrect. Symptoms
S * 			from over-running the high speed ADC include high speed samples being lost.
S *
S * @api
S */
Sbool_t gadcLowSpeedStart(uint32_t physdev, adcsample_t *buffer, GADCCallbackFunction fn, void *param);
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* GFX_USE_GADC */
N
N#endif /* _GADC_H */
N/** @} */
L 212 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N#include "src/gaudio/gaudio.h"
L 1 "..\..\..\..\..\..\external\ugfx\src/gaudio/gaudio.h" 1
N/*
N * This file is subject to the terms of the GFX License. If a copy of
N * the license was not distributed with this file, you can obtain one at:
N *
N *              http://ugfx.org/license.html
N */
N
N/**
N * @file    src/gaudio/gaudio.h
N *
N * @addtogroup GAUDIO
N *
N * @brief	Module to handle audio recording and play-back
N *
N * @{
N */
N
N#ifndef _GAUDIO_H
N#define _GAUDIO_H
N
N#include "../../gfx.h"
N
N#if GFX_USE_GAUDIO || defined(__DOXYGEN__)
X#if 0 || 0L
S
S/* Include the driver defines */
S#if GAUDIO_NEED_PLAY
S	#include "gaudio_play_config.h"
S#endif
S#if GAUDIO_NEED_RECORD
S	#include "gaudio_record_config.h"
S#endif
S
S/*===========================================================================*/
S/* Type definitions                                                          */
S/*===========================================================================*/
S
S// Event types for GAUDIO
S#define GEVENT_AUDIO_PLAY			(GEVENT_GAUDIO_FIRST+0)
S#define GEVENT_AUDIO_RECORD			(GEVENT_GAUDIO_FIRST+1)
S
S#if GFX_USE_GEVENT || defined(__DOXYGEN__)
S	/**
S	 * @brief   The Audio play event structure.
S	 * @{
S	 */
S	typedef struct GEventAudioPlay_t {
S		/**
S		 * @brief The type of this event (GEVENT_AUDIO_PLAY)
S		 */
S		GEventType				type;
S		/**
S		 * @brief The event flags
S		 */
S		uint16_t				flags;
S			/**
S			 * @brief   The event flag values.
S			 * @{
S			 */
S			#define	GAUDIO_PLAY_LOSTEVENT		0x0001		/**< @brief The last GEVENT_AUDIO_PLAY event was lost */
S			#define	GAUDIO_PLAY_PLAYING			0x0002		/**< @brief The audio out system is currently playing */
S			#define	GAUDIO_PLAY_FREEBLOCK		0x0004		/**< @brief An audio buffer has been freed */
S			/** @} */
S	} GEventAudioPlay;
S	/** @} */
S
S	/**
S	 * @brief   The Audio record event structure.
S	 * @{
S	 */
S	typedef struct GEventAudioRecord_t {
S		/**
S		 * @brief The type of this event (GEVENT_AUDIO_RECORD)
S		 */
S		GEventType				type;
S		/**
S		 * @brief The event flags
S		 */
S		uint16_t				flags;
S			/**
S			 * @brief   The event flag values.
S			 * @{
S			 */
S			#define	GAUDIO_RECORD_LOSTEVENT		0x0001		/**< @brief The last GEVENT_AUDIO_IN event was lost */
S			#define	GAUDIO_RECORD_RECORDING		0x0002		/**< @brief The audio recording system is currently recording */
S			#define	GAUDIO_RECORD_GOTBUFFER		0x0004		/**< @brief An audio buffer is ready for processing */
S			#define	GAUDIO_RECORD_STALL			0x0008		/**< @brief The recording process has stalled due to no free buffers */
S			/** @} */
S	} GEventAudioRecord;
S	/** @} */
S#endif
S
S/*===========================================================================*/
S/* External declarations.                                                    */
S/*===========================================================================*/
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S#if GAUDIO_NEED_PLAY || defined(__DOXYGEN__)
S	/**
S	 * @brief		Set the audio device to play on the specified channel and with the specified
S	 * 				sample frequency.
S	 * @return		TRUE is successful, FALSE if the driver doesn't accept those parameters.
S	 *
S	 * @param[in] channel	The audio output channel to use. Can be set from 0 to GAUDIO_PLAY_NUM_CHANNELS - 1
S	 * @param[in] frequency	The audio sample rate in samples per second
S	 * @param[in] format	The audio sample format
S	 *
S	 * @note		Some channels are mono, and some are stereo. See your driver config file
S	 * 				to determine which channels to use and whether they are stereo or not.
S	 * @note		Only one channel can be playing at a time. Calling this will stop any
S	 * 				currently playing channel.
S	 *
S	 * @api
S	 */
S	bool_t gaudioPlayInit(uint16_t channel, uint32_t frequency, ArrayDataFormat format);
S
S	/**
S	 * @brief		Play the specified sample data.
S	 * @details		The sample data is output to the audio channel. On completion the buffer is returned to the free-list.
S	 * @pre			@p gaudioPlayInit must have been called first to set the channel and sample frequency.
S	 *
S	 * @param[in] paud	The audio sample buffer to play. It can be NULL (used to restart paused audio)
S	 *
S	 * @note		Calling this will cancel any pause.
S	 * @note		Before calling this function the len field of the GDataBuffer structure must be
S	 * 				specified (in bytes).
S	 * @note		For stereo channels the sample data is interleaved in the buffer.
S	 * @note		This call returns before the data has completed playing. Subject to available buffers (which
S	 * 				can be obtained from the free-list), any number of buffers may be played. They will be queued
S	 * 				for playing in the order they are supplied to this routine and played when previous buffers are
S	 * 				complete. In this way continuous playing can be obtained without audio gaps.
S	 *
S	 * @api
S	 */
S	void gaudioPlay(GDataBuffer *paud);
S
S	/**
S	 * @brief		Pause any currently playing sounds.
S	 *
S	 * @note		If nothing is currently playing this routine does nothing. To restart playing call @p gaudioPlay()
S	 * 				with or without a new sample buffer.
S	 * @note		Some drivers will not respond until a buffer boundary.
S	 *
S	 * @api
S	 */
S	void gaudioPlayPause(void);
S
S	/**
S	 * @brief		Stop any currently playing sounds.
S	 *
S	 * @note		This stops any playing sounds and returns any currently queued buffers back to the free-list.
S	 * @note		Some drivers will not respond until a buffer boundary.
S	 *
S	 * @api
S	 */
S	void gaudioPlayStop(void);
S
S	/**
S	 * @brief				Set the output volume.
S	 * @return				TRUE if successful.
S	 *
S	 * @param[in] vol		0->255 (0 = muted)
S	 *
S	 * @note				Some drivers may not support this. They will return FALSE.
S	 * @note				For stereo devices, both channels are set to the same volume.
S	 *
S	 * @api
S	 */
S	bool_t gaudioPlaySetVolume(uint8_t vol);
S
S	#if GFX_USE_GEVENT || defined(__DOXYGEN__)
S		/**
S		 * @brief   			Turn on sending results to the GEVENT sub-system.
S		 * @details				Returns a GSourceHandle to listen for GEVENT_AUDIO_OUT events.
S		 *
S		 * @note				The audio output will not use the GEVENT system unless this is
S		 * 						called first. This saves processing time if the application does
S		 * 						not want to use the GEVENT sub-system for audio output.
S		 * 						Once turned on it can only be turned off by calling @p gaudioPlayInit() again.
S		 * @note				The audio output is capable of signaling via this method and other methods
S		 * 						at the same time.
S		 *
S		 * @return				The GSourceHandle
S		 *
S		 * @api
S		 */
S		GSourceHandle gaudioPlayGetSource(void);
S	#endif
S
S	/**
S	 * @brief		Wait for any currently playing sounds to complete
S	 * @return		TRUE if there is now nothing playing or FALSE if the timeout is exceeded
S	 *
S	 * @param[in] ms	The maximum amount of time in milliseconds to wait for playing to complete.
S	 *
S	 * @api
S	 */
S	bool_t gaudioPlayWait(delaytime_t ms);
S#endif
S
S#if GAUDIO_NEED_RECORD || defined(__DOXYGEN__)
S	/**
S	 * @brief		Initialise (but not start) the Audio Recording sub-system.
S	 * @details		Returns FALSE for an invalid channel or other invalid parameter.
S	 *
S	 * @param[in] channel		The channel to convert. Can be set from 0 to GAUDIO_RECORD_NUM_CHANNELS - 1
S	 * @param[in] frequency		The sample frequency
S	 * @param[in] format		The audio sample format requested
S	 *
S	 * @note				Only one channel is active at a time. If an audio input is running it will be stopped.
S	 * 						The Event subsystem is disconnected from the audio subsystem and any binary semaphore
S	 * 						event is forgotten.
S	 * @note				Some channels may be stereo channels which return twice as much sample data with
S	 * 						the left and right channel data interleaved. Other channels may be mono channels.
S	 * 						Where stereo channels exist the low level driver may also
S	 * 						offer the left and right channels separately.
S	 * @note				Due to a bug in Chibi-OS each buffer on the free-list must contain an even number of
S	 * 						samples and for stereo devices it must hold a number of samples that is evenly divisible by 4.
S	 * 						This requirement applies only to ChibiOS where the audio driver uses
S	 * 						a ChibiOS hal driver like the cpu ADC driver. This applies even it is used indirectly via
S	 * 						the uGFX GADC driver.
S	 * @note				The number of samples for stereo devices will be double the number of conversions.
S	 * 						Make sure you allocate your buffers large enough. Each channel is then interleaved
S	 * 						into the provided buffer.
S	 *
S	 * @return				FALSE if invalid channel or parameter
S	 *
S	 * @api
S	 */
S	bool_t gaudioRecordInit(uint16_t channel, uint32_t frequency, ArrayDataFormat format);
S
S	/**
S	 * @brief   Start the audio recording.
S	 * @pre		It must have been initialised first with @p gaudioRecordInit()
S	 *
S	 * @api
S	 */
S	void gaudioRecordStart(void);
S
S	/**
S	 * @brief   Stop the audio recording.
S	 *
S	 * @note	All audio recording data that has not yet been retrieved is automatically
S	 * 			returned to the free-list.
S	 * @api
S	 */
S	void gaudioRecordStop(void);
S
S	/**
S	 * @brief		Get a filled audio buffer from the recording list
S	 * @return		A GDataBuffer pointer or NULL if the timeout is exceeded
S	 *
S	 * @param[in] ms	The maximum amount of time in milliseconds to wait for data if some is not currently available.
S	 *
S	 * @note		After processing the audio data, your application must return the buffer to the free-list so that
S	 * 				it can be used to record more audio into. This can be done via the play list using @p gaudioPlay() or
S	 * 				directly using @p gfxBufferRelease().
S	 * @note		A buffer may be returned to the free-list before you have finished processing it provided you finish
S	 * 				processing it before GADC re-uses it. This is useful when RAM usage is critical to reduce the number
S	 * 				of buffers required. It works before the free list is a FIFO queue and therefore buffers are kept
S	 * 				in the queue as long as possible before they are re-used.
S	 *
S	 * @api
S	 */
S	GDataBuffer *gaudioRecordGetData(delaytime_t ms);
S
S	#if GFX_USE_GEVENT || defined(__DOXYGEN__)
S		/**
S		 * @brief   			Turn on sending results to the GEVENT sub-system.
S		 * @details				Returns a GSourceHandle to listen for GEVENT_AUDIO_RECORD events.
S		 *
S		 * @note				Audio recording will not use the GEVENT system unless this is
S		 * 						called first. This saves processing time if the application does
S		 * 						not want to use the GEVENT sub-system for audio recording.
S		 * 						Once turned on it can only be turned off by calling @p gaudioRecordInit() again.
S		 * @note				The audio input is capable of signaling via this and other methods
S		 * 						at the same time.
S		 *
S		 * @return				The GSourceHandle
S		 *
S		 * @api
S		 */
S		GSourceHandle gaudioRecordGetSource(void);
S	#endif
S#endif
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* GFX_USE_GAUDIO */
N
N#endif /* _GAUDIO_H */
N/** @} */
N
L 213 "..\..\..\..\..\..\external\ugfx\gfx.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N	/**
N	 * @brief	The one call to start it all
N	 *
N	 * @note	This will initialise each sub-system that has been turned on.
N	 * 			For example, if GFX_USE_GDISP is defined then display will be initialised
N	 * 			and cleared to black.
N	 * @note	If you define GFX_OS_NO_INIT as TRUE in your gfxconf.h file then ugfx doesn't try to
N	 * 			initialise the operating system for you when you call @p gfxInit().
N	 * @note	If you define GFX_OS_EXTRA_INIT_FUNCTION in your gfxconf.h file the macro is the
N	 * 			name of a void function with no parameters that is called immediately after
N	 * 			operating system initialisation (whether or not GFX_OS_NO_INIT is set).
N	 * @note	If you define GFX_OS_EXTRA_DEINIT_FUNCTION in your gfxconf.h file the macro is the
N	 * 			name of a void function with no parameters that is called immediately before
N	 * 			operating system de-initialisation (as ugfx is exiting).
N	 *
N	 * @api
N	 */
N	void gfxInit(void);
N
N	/**
N	 * @brief	The one call to end it all
N	 *
N	 * @note	This will de-initialise each sub-system that has been turned on.
N	 *
N	 * @api
N	 */
N	void gfxDeinit(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _GFX_H */
N/** @} */
N
L 63 "..\..\..\main.c" 2
N
N
N
N
Nuint8_t toggle =0;
N
N#define IS_SRVC_CHANGED_CHARACT_PRESENT  1                                          /**< Include or not the service_changed characteristic. if not enabled, the server's database cannot be changed for the lifetime of the device*/
N
N#if (NRF_SD_BLE_API_VERSION == 3)
X#if (3 == 3)
N#define NRF_BLE_MAX_MTU_SIZE             GATT_MTU_SIZE_DEFAULT                      /**< MTU size used in the softdevice enabling and to reply to a BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST event. */
N#endif
N
N#define CENTRAL_LINK_COUNT               0                                          /**< Number of central links used by the application. When changing this number remember to adjust the RAM settings*/
N#define PERIPHERAL_LINK_COUNT            1                                          /**< Number of peripheral links used by the application. When changing this number remember to adjust the RAM settings*/
N
N#define DEVICE_NAME                      "noneNordic"                                /**< Name of device. Will be included in the advertising data. */
N#define MANUFACTURER_NAME                "noneSemi"                   						  /**< Manufacturer. Will be passed to Device Information Service. */
N#define APP_ADV_INTERVAL                 300                                        /**< The advertising interval (in units of 0.625 ms. This value corresponds to 187.5 ms). */
N#define APP_ADV_TIMEOUT_IN_SECONDS       180                                        /**< The advertising timeout in units of seconds. */
N
N#define APP_TIMER_PRESCALER              0                                          /**< Value of the RTC1 PRESCALER register. */
N#define APP_TIMER_OP_QUEUE_SIZE          4                                          /**< Size of timer operation queues. */
N
N#define MIN_CONN_INTERVAL                MSEC_TO_UNITS(100, UNIT_1_25_MS)           /**< Minimum acceptable connection interval (0.1 seconds). */
N#define MAX_CONN_INTERVAL                MSEC_TO_UNITS(200, UNIT_1_25_MS)           /**< Maximum acceptable connection interval (0.2 second). */
N#define SLAVE_LATENCY                    0                                          /**< Slave latency. */
N#define CONN_SUP_TIMEOUT                 MSEC_TO_UNITS(4000, UNIT_10_MS)            /**< Connection supervisory timeout (4 seconds). */
N
N#define FIRST_CONN_PARAMS_UPDATE_DELAY   APP_TIMER_TICKS(5000, APP_TIMER_PRESCALER) /**< Time from initiating event (connect or start of notification) to first time sd_ble_gap_conn_param_update is called (5 seconds). */
N#define NEXT_CONN_PARAMS_UPDATE_DELAY    APP_TIMER_TICKS(30000, APP_TIMER_PRESCALER)/**< Time between each call to sd_ble_gap_conn_param_update after the first call (30 seconds). */
N#define MAX_CONN_PARAMS_UPDATE_COUNT     3                                          /**< Number of attempts before giving up the connection parameter negotiation. */
N
N#define SEC_PARAM_BOND                   1                                          /**< Perform bonding. */
N#define SEC_PARAM_MITM                   0                                          /**< Man In The Middle protection not required. */
N#define SEC_PARAM_LESC                   0                                          /**< LE Secure Connections not enabled. */
N#define SEC_PARAM_KEYPRESS               0                                          /**< Keypress notifications not enabled. */
N#define SEC_PARAM_IO_CAPABILITIES        BLE_GAP_IO_CAPS_NONE                       /**< No I/O capabilities. */
N#define SEC_PARAM_OOB                    0                                          /**< Out Of Band data not available. */
N#define SEC_PARAM_MIN_KEY_SIZE           7                                          /**< Minimum encryption key size. */
N#define SEC_PARAM_MAX_KEY_SIZE           16                                         /**< Maximum encryption key size. */
N
N#define DEAD_BEEF                        0xDEADBEEF                                 /**< Value used as error code on stack dump, can be used to identify stack location on stack unwind. */
N
Nstatic uint16_t                          m_conn_handle = BLE_CONN_HANDLE_INVALID;   /**< Handle of the current connection. */
Xstatic uint16_t                          m_conn_handle = 0xFFFF;    
Nstatic nrf_ble_qwr_t                     m_qwr;                                     /**< Queued Writes structure.*/
N
NAPP_TIMER_DEF(m_ui_update_id);
Xstatic app_timer_t m_ui_update_id_data = { {0} }; static const app_timer_id_t m_ui_update_id = &m_ui_update_id_data;
N
Nble_bas_battery_level_t m_batt;
N 
Nuint32_t m_test=0;
Nuint8_t  m_bpm[16];
N
N	
Nuint32_t m_msTick;
N
N// YOUR_JOB: Use UUIDs for service(s) used in your application.
Nstatic ble_uuid_t m_adv_uuids[] = {{BLE_UUID_DEVICE_INFORMATION_SERVICE, BLE_UUID_TYPE_BLE}}; /**< Universally unique service identifiers. */
Xstatic ble_uuid_t m_adv_uuids[] = {{0x180A, 0x01}};  
N
Nvoid SysTick_Handler(void){
N		m_msTick++;
N}
N
Nsystemticks_t gfxSystemTicks(void)
N{
N	return m_msTick;
N}
N
Nsystemticks_t gfxMillisecondsToTicks(delaytime_t ms)
N{
N	return m_msTick;
N}
N
N
Nvoid ui_handler(void * p_context)
N{
N
N}
N
N/**@brief Callback function for asserts in the SoftDevice.
N *
N * @details This function will be called in case of an assert in the SoftDevice.
N *
N * @warning This handler is an example only and does not fit a final product. You need to analyze
N *          how your product is supposed to react in case of Assert.
N * @warning On assert from the SoftDevice, the system can only recover on reset.
N *
N * @param[in] line_num   Line number of the failing ASSERT call.
N * @param[in] file_name  File name of the failing ASSERT call.
N */
Nvoid assert_nrf_callback(uint16_t line_num, const uint8_t * p_file_name)
N{
N    app_error_handler(DEAD_BEEF, line_num, p_file_name);
X    app_error_handler(0xDEADBEEF, line_num, p_file_name);
N}
N
N
N/**@brief Function for handling File Data Storage events.
N *
N * @param[in] p_evt  Peer Manager event.
N * @param[in] cmd
N */
Nstatic void fds_evt_handler(fds_evt_t const * const p_evt)
N{
N    if (p_evt->id == FDS_EVT_GC)
N    {
N        NRF_LOG_INFO("GC completed\n");
X        if ((0 >= 3U) && (3U <= 0)) { nrf_log_frontend_std_0(3U, "APP" ":" "INFO:" "GC completed\n"); };
N    }
N}
N
N
N
N
N/**@brief Function for the Timer initialization.
N *
N * @details Initializes the timer module. This creates and starts application timers.
N */
Nstatic void timers_init(void)
N{
N
N    // Initialize timer module.
N    APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, false);
X    do { static uint32_t APP_TIMER_BUF[(((( ( (((4) + 1) * 24) ) )) + (sizeof(uint32_t)) - 1) / (sizeof(uint32_t)))]; uint32_t ERR_CODE = app_timer_init((0), (4) + 1, APP_TIMER_BUF, 0); do { const uint32_t LOCAL_ERR_CODE = (ERR_CODE); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0); } while (0);
N
N    // Create timers.
N
N    /* YOUR_JOB: Create any timers to be used by the application.
N                 Below is an example of how to create a timer.
N    uint32_t err_code;
N    err_code = app_timer_create(&m_app_timer_id, APP_TIMER_MODE_REPEATED, timer_timeout_handler);
N    APP_ERROR_CHECK(err_code); */
N		app_timer_create(&m_ui_update_id, APP_TIMER_MODE_REPEATED, ui_handler);
N}
N
N
N/**@brief Function for the GAP initialization.
N *
N * @details This function sets up all the necessary GAP (Generic Access Profile) parameters of the
N *          device including the device name, appearance, and the preferred connection parameters.
N */
Nstatic void gap_params_init(void)
N{
N    uint32_t                err_code;
N    ble_gap_conn_params_t   gap_conn_params;
N    ble_gap_conn_sec_mode_t sec_mode;
N
N    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);
X    do {(&sec_mode)->sm = 1; (&sec_mode)->lv = 1;} while(0);
N
N    err_code = sd_ble_gap_device_name_set(&sec_mode,
N                                          (const uint8_t *)DEVICE_NAME,
X                                          (const uint8_t *)"noneNordic",
N                                          strlen(DEVICE_NAME));
X                                          strlen("noneNordic"));
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    /* YOUR_JOB: Use an appearance value matching the application's use case.
N    err_code = sd_ble_gap_appearance_set(BLE_APPEARANCE_);
N    APP_ERROR_CHECK(err_code); */
N
N    memset(&gap_conn_params, 0, sizeof(gap_conn_params));
N
N    gap_conn_params.min_conn_interval = MIN_CONN_INTERVAL;
X    gap_conn_params.min_conn_interval = (((100) * 1000) / (UNIT_1_25_MS));
N    gap_conn_params.max_conn_interval = MAX_CONN_INTERVAL;
X    gap_conn_params.max_conn_interval = (((200) * 1000) / (UNIT_1_25_MS));
N    gap_conn_params.slave_latency     = SLAVE_LATENCY;
X    gap_conn_params.slave_latency     = 0;
N    gap_conn_params.conn_sup_timeout  = CONN_SUP_TIMEOUT;
X    gap_conn_params.conn_sup_timeout  = (((4000) * 1000) / (UNIT_10_MS));
N
N    err_code = sd_ble_gap_ppcp_set(&gap_conn_params);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N}
N
N
N/**@brief Function for initializing services that will be used by the application.
N */
Nstatic void services_init(void)
N{
N    nrf_ble_qwr_init_t qwr_init;
N    uint32_t           err_code;
N
N    // Initialize Queued Write Module
N    memset(&qwr_init, 0, sizeof(qwr_init));
N    qwr_init.mem_buffer.len   = 0;
N    qwr_init.mem_buffer.p_mem = NULL;
X    qwr_init.mem_buffer.p_mem = 0;
N
N    err_code = nrf_ble_qwr_init(&m_qwr, &qwr_init);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    err_code = bluetooth_init();
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N}
N
N
N/**@brief Function for handling the Connection Parameters Module.
N *
N * @details This function will be called for all events in the Connection Parameters Module which
N *          are passed to the application.
N *          @note All this function does is to disconnect. This could have been done by simply
N *                setting the disconnect_on_fail config parameter, but instead we use the event
N *                handler mechanism to demonstrate its use.
N *
N * @param[in] p_evt  Event received from the Connection Parameters Module.
N */
Nstatic void on_conn_params_evt(ble_conn_params_evt_t * p_evt)
N{
N    uint32_t err_code;
N
N    if (p_evt->evt_type == BLE_CONN_PARAMS_EVT_FAILED)
N    {
N        err_code = sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);
X        err_code = sd_ble_gap_disconnect(m_conn_handle, 0x3B);
N        APP_ERROR_CHECK(err_code);
X        do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N    }
N}
N
N
N/**@brief Function for handling a Connection Parameters error.
N *
N * @param[in] nrf_error  Error code containing information about what went wrong.
N */
Nstatic void conn_params_error_handler(uint32_t nrf_error)
N{
N    APP_ERROR_HANDLER(nrf_error);
X    do { app_error_handler_bare((nrf_error)); } while (0);
N}
N
N
N/**@brief Function for initializing the Connection Parameters module.
N */
Nstatic void conn_params_init(void)
N{
N    uint32_t               err_code;
N    ble_conn_params_init_t cp_init;
N
N    memset(&cp_init, 0, sizeof(cp_init));
N
N    cp_init.p_conn_params                  = NULL;
X    cp_init.p_conn_params                  = 0;
N    cp_init.first_conn_params_update_delay = FIRST_CONN_PARAMS_UPDATE_DELAY;
X    cp_init.first_conn_params_update_delay = ((uint32_t)((((5000) * (uint64_t)32768) + ((((0) + 1) * 1000) / 2)) / (((0) + 1) * 1000)));
N    cp_init.next_conn_params_update_delay  = NEXT_CONN_PARAMS_UPDATE_DELAY;
X    cp_init.next_conn_params_update_delay  = ((uint32_t)((((30000) * (uint64_t)32768) + ((((0) + 1) * 1000) / 2)) / (((0) + 1) * 1000)));
N    cp_init.max_conn_params_update_count   = MAX_CONN_PARAMS_UPDATE_COUNT;
X    cp_init.max_conn_params_update_count   = 3;
N    cp_init.start_on_notify_cccd_handle    = BLE_GATT_HANDLE_INVALID;
X    cp_init.start_on_notify_cccd_handle    = 0x0000;
N    cp_init.disconnect_on_fail             = false;
X    cp_init.disconnect_on_fail             = 0;
N    cp_init.evt_handler                    = on_conn_params_evt;
N    cp_init.error_handler                  = conn_params_error_handler;
N
N    err_code = ble_conn_params_init(&cp_init);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N}
N
N
N/**@brief Function for starting timers.
N*/
Nstatic void application_timers_start(void)
N{
N    /* YOUR_JOB: Start your timers. below is an example of how to start a timer.
N    uint32_t err_code;
N    err_code = app_timer_start(m_app_timer_id, TIMER_INTERVAL, NULL);
N    APP_ERROR_CHECK(err_code); */
N		app_timer_start(m_ui_update_id, APP_TIMER_TICKS(100,0), NULL);
X		app_timer_start(m_ui_update_id, ((uint32_t)((((100) * (uint64_t)32768) + ((((0) + 1) * 1000) / 2)) / (((0) + 1) * 1000))), 0);
N}
N
N
N/**@brief Function for putting the chip into sleep mode.
N *
N * @note This function will not return.
N */
Nstatic void sleep_mode_enter(void)
N{
N    uint32_t err_code = bsp_indication_set(BSP_INDICATE_IDLE);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    // Prepare wakeup buttons.
N    err_code = bsp_btn_ble_sleep_mode_prepare();
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    // Go to system-off mode (this function will not return; wakeup will cause a reset).
N    err_code = sd_power_system_off();
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N}
N
N
N/**@brief Function for handling advertising events.
N *
N * @details This function will be called for advertising events which are passed to the application.
N *
N * @param[in] ble_adv_evt  Advertising event.
N */
Nstatic void on_adv_evt(ble_adv_evt_t ble_adv_evt)
N{
N    uint32_t err_code;
N
N    switch (ble_adv_evt)
N    {
N        case BLE_ADV_EVT_FAST:
N            NRF_LOG_INFO("Fast Advertising\r\n");
X            if ((0 >= 3U) && (3U <= 0)) { nrf_log_frontend_std_0(3U, "APP" ":" "INFO:" "Fast Advertising\r\n"); };
N            err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING);
N            APP_ERROR_CHECK(err_code);
X            do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            break;
N        case BLE_ADV_EVT_IDLE:
N            sleep_mode_enter();
N            break;
N        default:
N            break;
N    }
N}
N
N
N/**@brief Function for handling the Application's BLE Stack events.
N *
N * @param[in] p_ble_evt  Bluetooth stack event.
N */
Nstatic void on_ble_evt(ble_evt_t * p_ble_evt)
N{
N    uint32_t err_code;
N
N    switch (p_ble_evt->header.evt_id)
N            {
N        case BLE_GAP_EVT_CONNECTED:
N            NRF_LOG_INFO("Connected\r\n");
X            if ((0 >= 3U) && (3U <= 0)) { nrf_log_frontend_std_0(3U, "APP" ":" "INFO:" "Connected\r\n"); };
N            err_code = bsp_indication_set(BSP_INDICATE_CONNECTED);
N            APP_ERROR_CHECK(err_code);
X            do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            m_conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
N            break; // BLE_GAP_EVT_CONNECTED
N
N        case BLE_GAP_EVT_DISCONNECTED:
N            NRF_LOG_INFO("Disconnected\r\n");
X            if ((0 >= 3U) && (3U <= 0)) { nrf_log_frontend_std_0(3U, "APP" ":" "INFO:" "Disconnected\r\n"); };
N            m_conn_handle = BLE_CONN_HANDLE_INVALID;
X            m_conn_handle = 0xFFFF;
N            break; // BLE_GAP_EVT_DISCONNECTED
N
N        case BLE_GATTC_EVT_TIMEOUT:
N            // Disconnect on GATT Client timeout event.
N            NRF_LOG_DEBUG("GATT Client Timeout.\r\n");
X            if ((0 >= 4U) && (4U <= 0)) { nrf_log_frontend_std_0(4U, "APP" ":" "DEBUG:" "GATT Client Timeout.\r\n"); };
N            err_code = sd_ble_gap_disconnect(p_ble_evt->evt.gattc_evt.conn_handle,
N                                             BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
X                                             0x13);
N            APP_ERROR_CHECK(err_code);
X            do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            break; // BLE_GATTC_EVT_TIMEOUT
N
N        case BLE_GATTS_EVT_TIMEOUT:
N            // Disconnect on GATT Server timeout event.
N            NRF_LOG_DEBUG("GATT Server Timeout.\r\n");
X            if ((0 >= 4U) && (4U <= 0)) { nrf_log_frontend_std_0(4U, "APP" ":" "DEBUG:" "GATT Server Timeout.\r\n"); };
N            err_code = sd_ble_gap_disconnect(p_ble_evt->evt.gatts_evt.conn_handle,
N                                             BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
X                                             0x13);
N            APP_ERROR_CHECK(err_code);
X            do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            break; // BLE_GATTS_EVT_TIMEOUT
N
N#if (NRF_SD_BLE_API_VERSION == 3)
X#if (3 == 3)
N        case BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST:
N            err_code = sd_ble_gatts_exchange_mtu_reply(p_ble_evt->evt.gatts_evt.conn_handle,
N                                                       NRF_BLE_MAX_MTU_SIZE);
X                                                       23);
N            APP_ERROR_CHECK(err_code);
X            do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            break; // BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST
N#endif
N
N        default:
N            // No implementation needed.
N            break;
N    }
N}
N
N
N/**@brief Function for dispatching a BLE stack event to all modules with a BLE stack event handler.
N *
N * @details This function is called from the BLE Stack event interrupt handler after a BLE stack
N *          event has been received.
N *
N * @param[in] p_ble_evt  Bluetooth stack event.
N */
Nstatic void ble_evt_dispatch(ble_evt_t * p_ble_evt)
N{
N    ble_conn_state_on_ble_evt(p_ble_evt);
N    pm_on_ble_evt(p_ble_evt);
N    ble_conn_params_on_ble_evt(p_ble_evt);
N    bsp_btn_ble_on_ble_evt(p_ble_evt);
N    ble_advertising_on_ble_evt(p_ble_evt);
N    on_ble_evt(p_ble_evt);
N    bluetooth_on_ble_evt(p_ble_evt);
N    nrf_ble_qwr_on_ble_evt(&m_qwr, p_ble_evt);
N}
N
N
N/**@brief Function for dispatching a system event to interested modules.
N *
N * @details This function is called from the System event interrupt handler after a system
N *          event has been received.
N *
N * @param[in] sys_evt  System stack event.
N */
Nstatic void sys_evt_dispatch(uint32_t sys_evt)
N{
N    // Dispatch the system event to the fstorage module, where it will be
N    // dispatched to the Flash Data Storage (FDS) module.
N    fs_sys_event_handler(sys_evt);
N
N    // Dispatch to the Advertising module last, since it will check if there are any
N    // pending flash operations in fstorage. Let fstorage process system events first,
N    // so that it can report correctly to the Advertising module.
N    ble_advertising_on_sys_evt(sys_evt);
N}
N
N
N/**@brief Function for initializing the BLE stack.
N *
N * @details Initializes the SoftDevice and the BLE event interrupt.
N */
Nstatic void ble_stack_init(void)
N{
N    uint32_t err_code;
N
N    nrf_clock_lf_cfg_t clock_lf_cfg = NRF_CLOCK_LFCLKSRC;
X    nrf_clock_lf_cfg_t clock_lf_cfg = {. source = (1), . rc_ctiv = 0, . rc_temp_ctiv = 0, . xtal_accuracy = (7)};
N
N    // Initialize the SoftDevice handler module.
N    SOFTDEVICE_HANDLER_INIT(&clock_lf_cfg, NULL);
X    do { static uint32_t BLE_EVT_BUFFER[((((sizeof(ble_evt_t) + (23))) + (sizeof(uint32_t)) - 1) / (sizeof(uint32_t)))]; uint32_t ERR_CODE; ERR_CODE = softdevice_handler_init((&clock_lf_cfg), BLE_EVT_BUFFER, sizeof(BLE_EVT_BUFFER), 0); do { const uint32_t LOCAL_ERR_CODE = (ERR_CODE); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0); } while (0);
N
N    ble_enable_params_t ble_enable_params;
N    err_code = softdevice_enable_get_default_config(CENTRAL_LINK_COUNT,
X    err_code = softdevice_enable_get_default_config(0,
N                                                    PERIPHERAL_LINK_COUNT,
X                                                    1,
N                                                    &ble_enable_params);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    //Check the ram settings against the used number of links
N    CHECK_RAM_START_ADDR(CENTRAL_LINK_COUNT,PERIPHERAL_LINK_COUNT);
X    ;
N
N    // Enable BLE stack.
N#if (NRF_SD_BLE_API_VERSION == 3)
X#if (3 == 3)
N    ble_enable_params.gatt_enable_params.att_mtu = NRF_BLE_MAX_MTU_SIZE;
X    ble_enable_params.gatt_enable_params.att_mtu = 23;
N#endif
N    err_code = softdevice_enable(&ble_enable_params);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    // Register with the SoftDevice handler module for BLE events.
N    err_code = softdevice_ble_evt_handler_set(ble_evt_dispatch);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    // Register with the SoftDevice handler module for system events.
N    err_code = softdevice_sys_evt_handler_set(sys_evt_dispatch);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N}
N
N
N/**@brief Function for handling events from the BSP module.
N *
N * @param[in]   event   Event generated by button press.
N */
Nvoid bsp_event_handler(bsp_event_t event)
N{
N    uint32_t err_code;
N    switch (event)
N    {
N        case BSP_EVENT_SLEEP:
N            sleep_mode_enter();
N            break;
N
N        case BSP_EVENT_DISCONNECT:
N            err_code = sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
X            err_code = sd_ble_gap_disconnect(m_conn_handle, 0x13);
N            if (err_code != NRF_ERROR_INVALID_STATE)
X            if (err_code != ((0x0) + 8))
N            {
N                APP_ERROR_CHECK(err_code);
X                do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            }
N            break;
N
N        case BSP_EVENT_WHITELIST_OFF:
N            if (m_conn_handle == BLE_CONN_HANDLE_INVALID)
X            if (m_conn_handle == 0xFFFF)
N            {
N                err_code = ble_advertising_restart_without_whitelist();
N                if (err_code != NRF_ERROR_INVALID_STATE)
X                if (err_code != ((0x0) + 8))
N                {
N                    APP_ERROR_CHECK(err_code);
X                    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N                }
N            }
N            break;
N
N        default:
N            break;
N    }
N}
N
N
N/**@brief Function for handling Peer Manager events.
N *
N * @param[in] p_evt  Peer Manager event.
N */
Nstatic void pm_evt_handler(pm_evt_t const * p_evt)
N{
N    ret_code_t err_code;
N
N    switch (p_evt->evt_id)
N    {
N        case PM_EVT_BONDED_PEER_CONNECTED:
N            NRF_LOG_DEBUG("Connected to previously bonded device\r\n");
X            if ((0 >= 4U) && (4U <= 0)) { nrf_log_frontend_std_0(4U, "APP" ":" "DEBUG:" "Connected to previously bonded device\r\n"); };
N            err_code = pm_peer_rank_highest(p_evt->peer_id);
N            if (err_code != NRF_ERROR_BUSY)
X            if (err_code != ((0x0) + 17))
N            {
N                APP_ERROR_CHECK(err_code);
X                do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            }
N            break; // PM_EVT_BONDED_PEER_CONNECTED
N
N        case PM_EVT_CONN_SEC_START:
N            break; // PM_EVT_CONN_SEC_START
N
N        case PM_EVT_CONN_SEC_SUCCEEDED:
N            NRF_LOG_DEBUG("Link secured. Role: %d. conn_handle: %d, Procedure: %d\r\n",
N                                 ble_conn_state_role(p_evt->conn_handle),
N                                 p_evt->conn_handle,
N                                 p_evt->params.conn_sec_succeeded.procedure);
X            if ((0 >= 4U) && (4U <= 0)) { nrf_log_frontend_std_3(4U, "APP" ":" "DEBUG:" "Link secured. Role: %d. conn_handle: %d, Procedure: %d\r\n", ble_conn_state_role(p_evt->conn_handle), p_evt->conn_handle, p_evt->params . conn_sec_succeeded . procedure); };
N            err_code = pm_peer_rank_highest(p_evt->peer_id);
N            if (err_code != NRF_ERROR_BUSY)
X            if (err_code != ((0x0) + 17))
N            {
N                APP_ERROR_CHECK(err_code);
X                do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            }
N            break;  // PM_EVT_CONN_SEC_SUCCEEDED
N
N        case PM_EVT_CONN_SEC_FAILED:
N
N            /** In some cases, when securing fails, it can be restarted directly. Sometimes it can
N             *  be restarted, but only after changing some Security Parameters. Sometimes, it cannot
N             *  be restarted until the link is disconnected and reconnected. Sometimes it is
N             *  impossible, to secure the link, or the peer device does not support it. How to
N             *  handle this error is highly application dependent. */
N            switch (p_evt->params.conn_sec_failed.error)
N            {
N                case PM_CONN_SEC_ERROR_PIN_OR_KEY_MISSING:
X                case (0x1000 + 0x06):
N                    // Rebond if one party has lost its keys.
N                    err_code = pm_conn_secure(p_evt->conn_handle, true);
X                    err_code = pm_conn_secure(p_evt->conn_handle, 1);
N                    if (err_code != NRF_ERROR_INVALID_STATE)
X                    if (err_code != ((0x0) + 8))
N                    {
N                        APP_ERROR_CHECK(err_code);
X                        do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N                    }
N                    break;
N
N                default:
N                    break;
N            }
N            break; // PM_EVT_CONN_SEC_FAILED
N
N        case PM_EVT_CONN_SEC_CONFIG_REQ:
N        {
N            // Reject pairing request from an already bonded peer.
N            pm_conn_sec_config_t conn_sec_config = {.allow_repairing = false};
X            pm_conn_sec_config_t conn_sec_config = {.allow_repairing = 0};
N            pm_conn_sec_config_reply(p_evt->conn_handle, &conn_sec_config);
N        } break; // PM_EVT_CONN_SEC_CONFIG_REQ
N
N        case PM_EVT_STORAGE_FULL:
N            // Run garbage collection on the flash.
N            err_code = fds_gc();
N            if (err_code != NRF_ERROR_BUSY)
X            if (err_code != ((0x0) + 17))
N            {
N                APP_ERROR_CHECK(err_code);
X                do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            }
N            break; // PM_EVT_STORAGE_FULL
N
N        case PM_EVT_ERROR_UNEXPECTED:
N            // A likely fatal error occurred. Assert.
N            APP_ERROR_CHECK(p_evt->params.error_unexpected.error);
X            do { const uint32_t LOCAL_ERR_CODE = (p_evt->params . error_unexpected . error); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            break;
N
N        case PM_EVT_PEER_DATA_UPDATE_SUCCEEDED:
N            break; // PM_EVT_PEER_DATA_UPDATE_SUCCEEDED
N
N        case PM_EVT_PEER_DATA_UPDATE_FAILED:
N            // Assert.
N            APP_ERROR_CHECK_BOOL(false);
X            do { const uint32_t LOCAL_BOOLEAN_VALUE = (0); if (!LOCAL_BOOLEAN_VALUE) { do { app_error_handler_bare((0)); } while (0); } } while (0);
N            break; // PM_EVT_ERROR_UNEXPECTED
N
N        case PM_EVT_PEER_DELETE_SUCCEEDED:
N            break; // PM_EVT_PEER_DELETE_SUCCEEDED
N
N        case PM_EVT_PEER_DELETE_FAILED:
N            // Assert.
N            APP_ERROR_CHECK(p_evt->params.peer_delete_failed.error);
X            do { const uint32_t LOCAL_ERR_CODE = (p_evt->params . peer_delete_failed . error); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            break; // PM_EVT_PEER_DELETE_FAILED
N
N        case PM_EVT_PEERS_DELETE_SUCCEEDED:
N            break; // PM_EVT_PEERS_DELETE_SUCCEEDED
N
N        case PM_EVT_PEERS_DELETE_FAILED:
N            // Assert.
N            APP_ERROR_CHECK(p_evt->params.peers_delete_failed_evt.error);
X            do { const uint32_t LOCAL_ERR_CODE = (p_evt->params . peers_delete_failed_evt . error); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N            break; // PM_EVT_PEERS_DELETE_FAILED
N
N        case PM_EVT_LOCAL_DB_CACHE_APPLIED:
N            break; // PM_EVT_LOCAL_DB_CACHE_APPLIED
N
N        case PM_EVT_LOCAL_DB_CACHE_APPLY_FAILED:
N            // The local database has likely changed, send service changed indications.
N            pm_local_database_has_changed();
N            break; // PM_EVT_LOCAL_DB_CACHE_APPLY_FAILED
N
N        case PM_EVT_SERVICE_CHANGED_IND_SENT:
N            break; // PM_EVT_SERVICE_CHANGED_IND_SENT
N
N        case PM_EVT_SERVICE_CHANGED_IND_CONFIRMED:
N            break; // PM_EVT_SERVICE_CHANGED_IND_SENT
N
N        default:
N            // No implementation needed.
N            break;
N    }
N}
N
N
N
N
N
N
N/**@brief Function for the Peer Manager initialization.
N *
N * @param[in] erase_bonds  Indicates whether bonding information should be cleared from
N *                         persistent storage during initialization of the Peer Manager.
N */
Nstatic void peer_manager_init(bool erase_bonds)
Xstatic void peer_manager_init(_Bool erase_bonds)
N{
N    ble_gap_sec_params_t sec_param;
N    ret_code_t           err_code;
N
N    err_code = pm_init();
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    if (erase_bonds)
N    {
N        err_code = pm_peers_delete();
N        APP_ERROR_CHECK(err_code);
X        do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N    }
N
N    memset(&sec_param, 0, sizeof(ble_gap_sec_params_t));
N
N    // Security parameters to be used for all security procedures.
N    sec_param.bond           = SEC_PARAM_BOND;
X    sec_param.bond           = 1;
N    sec_param.mitm           = SEC_PARAM_MITM;
X    sec_param.mitm           = 0;
N    sec_param.io_caps        = SEC_PARAM_IO_CAPABILITIES;
X    sec_param.io_caps        = 0x03;
N    sec_param.oob            = SEC_PARAM_OOB;
X    sec_param.oob            = 0;
N    sec_param.min_key_size   = SEC_PARAM_MIN_KEY_SIZE;
X    sec_param.min_key_size   = 7;
N    sec_param.max_key_size   = SEC_PARAM_MAX_KEY_SIZE;
X    sec_param.max_key_size   = 16;
N    sec_param.kdist_own.enc  = 1;
N    sec_param.kdist_own.id   = 1;
N    sec_param.kdist_peer.enc = 1;
N    sec_param.kdist_peer.id  = 1;
N
N    err_code = pm_sec_params_set(&sec_param);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    err_code = pm_register(pm_evt_handler);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    err_code = fds_register(fds_evt_handler);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N}
N
N
N/**@brief Function for initializing the Advertising functionality.
N */
Nstatic void advertising_init(void)
N{
N    uint32_t      err_code;
N    ble_advdata_t advdata;
N
N    // Build advertising data struct to pass into @ref ble_advertising_init.
N    memset(&advdata, 0, sizeof(advdata));
N
N    advdata.name_type               = BLE_ADVDATA_FULL_NAME;
N    advdata.include_appearance      = true;
X    advdata.include_appearance      = 1;
N    advdata.flags                   = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;
X    advdata.flags                   = ((0x02) | (0x04));
N    advdata.uuids_complete.uuid_cnt = sizeof(m_adv_uuids) / sizeof(m_adv_uuids[0]);
N    advdata.uuids_complete.p_uuids  = m_adv_uuids;
N
N    ble_adv_modes_config_t options = {0};
N    options.ble_adv_fast_enabled  = true;
X    options.ble_adv_fast_enabled  = 1;
N    options.ble_adv_fast_interval = APP_ADV_INTERVAL;
X    options.ble_adv_fast_interval = 300;
N    options.ble_adv_fast_timeout  = APP_ADV_TIMEOUT_IN_SECONDS;
X    options.ble_adv_fast_timeout  = 180;
N
N    err_code = ble_advertising_init(&advdata, NULL, &options, on_adv_evt, NULL);
X    err_code = ble_advertising_init(&advdata, 0, &options, on_adv_evt, 0);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N}
N
N
N/**@brief Function for initializing buttons and leds.
N *
N * @param[out] p_erase_bonds  Will be true if the clear bonding button was pressed to wake the application up.
N */
Nstatic void buttons_leds_init(bool * p_erase_bonds)
Xstatic void buttons_leds_init(_Bool * p_erase_bonds)
N{
N    bsp_event_t startup_event;
N
N    uint32_t err_code = bsp_init(BSP_INIT_LED | BSP_INIT_BUTTONS,
X    uint32_t err_code = bsp_init((1 << 0) | (1 << 1),
N                                 APP_TIMER_TICKS(100, APP_TIMER_PRESCALER),
X                                 ((uint32_t)((((100) * (uint64_t)32768) + ((((0) + 1) * 1000) / 2)) / (((0) + 1) * 1000))),
N                                 bsp_event_handler);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    err_code = bsp_btn_ble_init(NULL, &startup_event);
X    err_code = bsp_btn_ble_init(0, &startup_event);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    *p_erase_bonds = (startup_event == BSP_EVENT_CLEAR_BONDING_DATA);
N}
N
N
N/**@brief Function for the Power manager.
N */
Nstatic void power_manage(void)
N{
N    uint32_t err_code = sd_app_evt_wait();
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N}
N
N
N/**@brief Function for application main entry.
N */
Nint main(void)
N{
N    uint32_t err_code;
N    bool erase_bonds;
X    _Bool erase_bonds;
N		
N		SysTick_Config(SystemCoreClock/1000); // once every 1ms
N	
N    err_code = NRF_LOG_INIT(NULL);
X    err_code = ((0x0) + 0);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N
N    // Initialize.
N    timers_init();
N    buttons_leds_init(&erase_bonds);
N    ble_stack_init();
N    peer_manager_init(erase_bonds);
N    if (erase_bonds == true)
X    if (erase_bonds == 1)
N    {
N        NRF_LOG_INFO("Bonds erased!\r\n");
X        if ((0 >= 3U) && (3U <= 0)) { nrf_log_frontend_std_0(3U, "APP" ":" "INFO:" "Bonds erased!\r\n"); };
N    }
N    gap_params_init();
N    advertising_init();
N    services_init();
N    conn_params_init();
N		
N		
N		ble_bas_t * m_bas = return_ble_bas_t();
N
N
N		m_batt.level = 0x01;
N		ble_bas_battery_level_set (m_bas, &m_batt);
N		
N    // Start execution.
N    application_timers_start();
N    NRF_LOG_INFO("Bluetooth Dev Studio Start Advertising \r\n");
X    if ((0 >= 3U) && (3U <= 0)) { nrf_log_frontend_std_0(3U, "APP" ":" "INFO:" "Bluetooth Dev Studio Start Advertising \r\n"); };
N    err_code = ble_advertising_start(BLE_ADV_MODE_FAST);
N    APP_ERROR_CHECK(err_code);
X    do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N		
N		
N		gfxInit();
N		gdispGFillArea (GDISP, 0, 0, 1, 0, 0x07);
N		//gdispGDrawPixel(GDISP,0,0,0x07);
N		// gdispGDrawPixel(GDISP,1,0,0x07);
N		//memset(fb,0x00,LS013_BYTES_LINE*LS013_YRES);
N		//rgb
N		//ls013_init();
N		//ls013_clearframe();
N		
N		//printImage(fb,0,0,(uint8_t *) superman_h,sizeof(superman_h));	
N		
N		//fillWindow(fb,0,0,128,128,0x07);
N		//ls013_drawPixel(fb, 126, 0, 0x07);
N		//printText(fb,20,20,"HALLO WELT 123",14,0x00);	
N
N		//ls013_showframe(fb);
N		
N		APP_ERROR_CHECK(err_code);
X		do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler_bare((LOCAL_ERR_CODE)); } while (0); } } while (0);
N    // Enter main loop.
N    for (;;)
N    {		
N        if (NRF_LOG_PROCESS() == false)
X        if (0 == 0)
N        {
N            power_manage();
N        }
N    }
N}
N
N/**
N * @}
N */
