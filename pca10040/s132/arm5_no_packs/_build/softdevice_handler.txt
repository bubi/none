; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\softdevice_handler.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\softdevice_handler.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\softdevice_handler.crf ..\..\..\..\..\..\components\softdevice\common\softdevice_handler\softdevice_handler.c]
                          THUMB

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;1636    */
;;;1637   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1638   {
;;;1639     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L1.20|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1640   }
000010  4770              BX       lr
;;;1641   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0942              LSRS     r2,r0,#5
00000a  0092              LSLS     r2,r2,#2
00000c  f10222e0          ADD      r2,r2,#0xe000e000
000010  f8c21100          STR      r1,[r2,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.SWI2_EGU2_IRQHandler||, CODE, READONLY, ALIGN=2

                  SWI2_EGU2_IRQHandler PROC
;;;387     */
;;;388    void SOFTDEVICE_EVT_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;389    {
;;;390        if (m_evt_schedule_func != NULL)
000002  480a              LDR      r0,|L3.44|
000004  6800              LDR      r0,[r0,#0]  ; m_evt_schedule_func
000006  b168              CBZ      r0,|L3.36|
;;;391        {
;;;392            uint32_t err_code = m_evt_schedule_func();
000008  4808              LDR      r0,|L3.44|
00000a  6800              LDR      r0,[r0,#0]  ; m_evt_schedule_func
00000c  4780              BLX      r0
00000e  4604              MOV      r4,r0
;;;393            APP_ERROR_CHECK(err_code);
000010  bf00              NOP      
000012  4625              MOV      r5,r4
000014  b125              CBZ      r5,|L3.32|
000016  bf00              NOP      
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       app_error_handler_bare
00001e  bf00              NOP      
                  |L3.32|
000020  bf00              NOP      
;;;394        }
000022  e001              B        |L3.40|
                  |L3.36|
;;;395        else
;;;396        {
;;;397            intern_softdevice_events_execute();
000024  f7fffffe          BL       intern_softdevice_events_execute
                  |L3.40|
;;;398        }
;;;399    }
000028  bd70              POP      {r4-r6,pc}
;;;400    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      m_evt_schedule_func

                          AREA ||i.__sd_nvic_app_accessible_irq||, CODE, READONLY, ALIGN=2

                  __sd_nvic_app_accessible_irq PROC
;;;162     */
;;;163    static inline uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn)
000000  4601              MOV      r1,r0
;;;164    {
;;;165      if (IRQn < 32)
000002  2920              CMP      r1,#0x20
000004  da08              BGE      |L4.24|
;;;166      {
;;;167        return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
000006  2001              MOVS     r0,#1
000008  4088              LSLS     r0,r0,r1
00000a  4a0a              LDR      r2,|L4.52|
00000c  4010              ANDS     r0,r0,r2
00000e  b108              CBZ      r0,|L4.20|
000010  2001              MOVS     r0,#1
                  |L4.18|
;;;168      }
;;;169    #ifdef NRF52
;;;170      else if (IRQn < 64)
;;;171      {
;;;172        return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
;;;173      }
;;;174    #endif
;;;175      else
;;;176      {
;;;177        return 1;
;;;178      }
;;;179    }
000012  4770              BX       lr
                  |L4.20|
000014  2000              MOVS     r0,#0                 ;167
000016  e7fc              B        |L4.18|
                  |L4.24|
000018  2940              CMP      r1,#0x40              ;170
00001a  da09              BGE      |L4.48|
00001c  f1a10020          SUB      r0,r1,#0x20           ;172
000020  2201              MOVS     r2,#1                 ;172
000022  fa02f000          LSL      r0,r2,r0              ;172
000026  b108              CBZ      r0,|L4.44|
000028  2001              MOVS     r0,#1                 ;172
00002a  e7f2              B        |L4.18|
                  |L4.44|
00002c  2000              MOVS     r0,#0                 ;172
00002e  e7f0              B        |L4.18|
                  |L4.48|
000030  2001              MOVS     r0,#1                 ;177
000032  e7ee              B        |L4.18|
;;;180    
                          ENDP

                  |L4.52|
                          DCD      0xbcff06fc

                          AREA ||i.intern_softdevice_events_execute||, CODE, READONLY, ALIGN=2

                  intern_softdevice_events_execute PROC
;;;105    
;;;106    void intern_softdevice_events_execute(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;107    {
;;;108        if (!m_softdevice_enabled)
000002  4827              LDR      r0,|L5.160|
000004  7800              LDRB     r0,[r0,#0]  ; m_softdevice_enabled
000006  b900              CBNZ     r0,|L5.10|
                  |L5.8|
;;;109        {
;;;110            // SoftDevice not enabled. This can be possible if the SoftDevice was enabled by the
;;;111            // application without using this module's API (i.e softdevice_handler_init)
;;;112    
;;;113            return;
;;;114        }
;;;115    #if CLOCK_ENABLED
;;;116        bool no_more_soc_evts = false;
;;;117    #else
;;;118        bool no_more_soc_evts = (m_sys_evt_handler == NULL);
;;;119    #endif
;;;120    #ifdef BLE_STACK_SUPPORT_REQD
;;;121        bool no_more_ble_evts = (m_ble_evt_handler == NULL);
;;;122    #endif
;;;123    #ifdef ANT_STACK_SUPPORT_REQD
;;;124        bool no_more_ant_evts = (m_ant_evt_handler == NULL);
;;;125    #endif
;;;126    
;;;127        for (;;)
;;;128        {
;;;129            uint32_t err_code;
;;;130    
;;;131            if (!no_more_soc_evts)
;;;132            {
;;;133                if (m_suspended)
;;;134                {
;;;135                    // Cancel pulling next event if event handler was suspended by user.
;;;136                    return;
;;;137                }
;;;138    
;;;139                uint32_t evt_id;
;;;140    
;;;141                // Pull event from SOC.
;;;142                err_code = sd_evt_get(&evt_id);
;;;143    
;;;144                if (err_code == NRF_ERROR_NOT_FOUND)
;;;145                {
;;;146                    no_more_soc_evts = true;
;;;147                }
;;;148                else if (err_code != NRF_SUCCESS)
;;;149                {
;;;150                    APP_ERROR_HANDLER(err_code);
;;;151                }
;;;152                else
;;;153                {
;;;154                    // Call application's SOC event handler.
;;;155    #if (CLOCK_ENABLED && defined(SOFTDEVICE_PRESENT))
;;;156                    nrf_drv_clock_on_soc_event(evt_id);
;;;157                    if (m_sys_evt_handler)
;;;158                    {
;;;159                        m_sys_evt_handler(evt_id);
;;;160                    }
;;;161    #else
;;;162                    m_sys_evt_handler(evt_id);
;;;163    #endif
;;;164                }
;;;165            }
;;;166    
;;;167    #ifdef BLE_STACK_SUPPORT_REQD
;;;168            // Fetch BLE Events.
;;;169            if (!no_more_ble_evts)
;;;170            {
;;;171                if (m_suspended)
;;;172                {
;;;173                    // Cancel pulling next event if event handler was suspended by user.
;;;174                    return;
;;;175                }
;;;176    
;;;177                // Pull event from stack
;;;178                uint16_t evt_len = m_ble_evt_buffer_size;
;;;179    
;;;180                err_code = sd_ble_evt_get(mp_ble_evt_buffer, &evt_len);
;;;181                if (err_code == NRF_ERROR_NOT_FOUND)
;;;182                {
;;;183                    no_more_ble_evts = true;
;;;184                }
;;;185                else if (err_code != NRF_SUCCESS)
;;;186                {
;;;187                    APP_ERROR_HANDLER(err_code);
;;;188                }
;;;189                else
;;;190                {
;;;191                    // Call application's BLE stack event handler.
;;;192                    m_ble_evt_handler((ble_evt_t *)mp_ble_evt_buffer);
;;;193                }
;;;194            }
;;;195    #endif
;;;196    
;;;197    #ifdef ANT_STACK_SUPPORT_REQD
;;;198            // Fetch ANT Events.
;;;199            if (!no_more_ant_evts)
;;;200            {
;;;201                if (m_suspended)
;;;202                {
;;;203                    // Cancel pulling next event if event handler was suspended by user.
;;;204                    return;
;;;205                }
;;;206    
;;;207                // Pull event from stack
;;;208                err_code = sd_ant_event_get(&m_ant_evt_buffer.channel,
;;;209                                            &m_ant_evt_buffer.event,
;;;210                                            m_ant_evt_buffer.msg.evt_buffer);
;;;211                if (err_code == NRF_ERROR_NOT_FOUND)
;;;212                {
;;;213                    no_more_ant_evts = true;
;;;214                }
;;;215                else if (err_code != NRF_SUCCESS)
;;;216                {
;;;217                    APP_ERROR_HANDLER(err_code);
;;;218                }
;;;219                else
;;;220                {
;;;221                    // Call application's ANT stack event handler.
;;;222                    m_ant_evt_handler(&m_ant_evt_buffer);
;;;223                }
;;;224            }
;;;225    #endif
;;;226    
;;;227            if (no_more_soc_evts)
;;;228            {
;;;229                // There are no remaining System (SOC) events to be fetched from the SoftDevice.
;;;230    #if defined(ANT_STACK_SUPPORT_REQD) && defined(BLE_STACK_SUPPORT_REQD)
;;;231                // Check if there are any remaining BLE and ANT events.
;;;232                if (no_more_ble_evts && no_more_ant_evts)
;;;233                {
;;;234                    break;
;;;235                }
;;;236    #elif defined(BLE_STACK_SUPPORT_REQD)
;;;237                // Check if there are any remaining BLE events.
;;;238                if (no_more_ble_evts)
;;;239                {
;;;240                    break;
;;;241                }
;;;242    #elif defined(ANT_STACK_SUPPORT_REQD)
;;;243                // Check if there are any remaining ANT events.
;;;244                if (no_more_ant_evts)
;;;245                {
;;;246                    break;
;;;247                }
;;;248    #else
;;;249                // No need to check for BLE or ANT events since there is no support for BLE and ANT
;;;250                // required.
;;;251                break;
;;;252    #endif
;;;253            }
;;;254        }
;;;255    }
000008  bdf8              POP      {r3-r7,pc}
                  |L5.10|
00000a  2500              MOVS     r5,#0                 ;116
00000c  4825              LDR      r0,|L5.164|
00000e  6800              LDR      r0,[r0,#0]            ;121  ; m_ble_evt_handler
000010  b908              CBNZ     r0,|L5.22|
000012  2001              MOVS     r0,#1                 ;121
000014  e000              B        |L5.24|
                  |L5.22|
000016  2000              MOVS     r0,#0                 ;121
                  |L5.24|
000018  4606              MOV      r6,r0                 ;121
00001a  bf00              NOP                            ;127
                  |L5.28|
00001c  b9dd              CBNZ     r5,|L5.86|
00001e  4822              LDR      r0,|L5.168|
000020  7800              LDRB     r0,[r0,#0]            ;133  ; m_suspended
000022  b100              CBZ      r0,|L5.38|
000024  e7f0              B        |L5.8|
                  |L5.38|
000026  4668              MOV      r0,sp                 ;142
000028  df48              SVC      #0x48                 ;142
00002a  4604              MOV      r4,r0                 ;142
00002c  2c05              CMP      r4,#5                 ;144
00002e  d101              BNE      |L5.52|
000030  2501              MOVS     r5,#1                 ;146
000032  e00f              B        |L5.84|
                  |L5.52|
000034  b124              CBZ      r4,|L5.64|
000036  bf00              NOP                            ;150
000038  4620              MOV      r0,r4                 ;150
00003a  f7fffffe          BL       app_error_handler_bare
00003e  e009              B        |L5.84|
                  |L5.64|
000040  9800              LDR      r0,[sp,#0]            ;156
000042  f7fffffe          BL       nrf_drv_clock_on_soc_event
000046  4819              LDR      r0,|L5.172|
000048  6800              LDR      r0,[r0,#0]            ;157  ; m_sys_evt_handler
00004a  b118              CBZ      r0,|L5.84|
00004c  4917              LDR      r1,|L5.172|
00004e  9800              LDR      r0,[sp,#0]            ;159
000050  6809              LDR      r1,[r1,#0]            ;159  ; m_sys_evt_handler
000052  4788              BLX      r1                    ;159
                  |L5.84|
000054  bf00              NOP                            ;165
                  |L5.86|
000056  b9de              CBNZ     r6,|L5.144|
000058  4813              LDR      r0,|L5.168|
00005a  7800              LDRB     r0,[r0,#0]            ;171  ; m_suspended
00005c  b100              CBZ      r0,|L5.96|
00005e  e7d3              B        |L5.8|
                  |L5.96|
000060  4813              LDR      r0,|L5.176|
000062  8800              LDRH     r0,[r0,#0]            ;178  ; m_ble_evt_buffer_size
000064  9000              STR      r0,[sp,#0]            ;178
000066  4669              MOV      r1,sp                 ;180
000068  4812              LDR      r0,|L5.180|
00006a  6800              LDR      r0,[r0,#0]            ;180  ; mp_ble_evt_buffer
00006c  df61              SVC      #0x61                 ;180
00006e  4604              MOV      r4,r0                 ;180
000070  2c05              CMP      r4,#5                 ;181
000072  d101              BNE      |L5.120|
000074  2601              MOVS     r6,#1                 ;183
000076  e00a              B        |L5.142|
                  |L5.120|
000078  b124              CBZ      r4,|L5.132|
00007a  bf00              NOP                            ;187
00007c  4620              MOV      r0,r4                 ;187
00007e  f7fffffe          BL       app_error_handler_bare
000082  e004              B        |L5.142|
                  |L5.132|
000084  480b              LDR      r0,|L5.180|
000086  6800              LDR      r0,[r0,#0]            ;192  ; mp_ble_evt_buffer
000088  4906              LDR      r1,|L5.164|
00008a  6809              LDR      r1,[r1,#0]            ;192  ; m_ble_evt_handler
00008c  4788              BLX      r1                    ;192
                  |L5.142|
00008e  bf00              NOP                            ;194
                  |L5.144|
000090  b10d              CBZ      r5,|L5.150|
000092  b106              CBZ      r6,|L5.150|
000094  e000              B        |L5.152|
                  |L5.150|
000096  e7c1              B        |L5.28|
                  |L5.152|
000098  bf00              NOP                            ;240
00009a  bf00              NOP      
00009c  e7b4              B        |L5.8|
;;;256    
                          ENDP

00009e  0000              DCW      0x0000
                  |L5.160|
                          DCD      m_softdevice_enabled
                  |L5.164|
                          DCD      m_ble_evt_handler
                  |L5.168|
                          DCD      m_suspended
                  |L5.172|
                          DCD      m_sys_evt_handler
                  |L5.176|
                          DCD      m_ble_evt_buffer_size
                  |L5.180|
                          DCD      mp_ble_evt_buffer

                          AREA ||i.sd_check_ram_start||, CODE, READONLY, ALIGN=2

                  sd_check_ram_start PROC
;;;485    /*lint --e{10} --e{19} --e{27} --e{40} --e{529} -save suppress Error 27: Illegal character */
;;;486    uint32_t sd_check_ram_start(uint32_t sd_req_ram_start)
000000  b508              PUSH     {r3,lr}
;;;487    {
000002  4601              MOV      r1,r0
;;;488    #if (defined(S130) || defined(S132) || defined(S332))
;;;489    #if defined ( __CC_ARM )
;;;490        extern uint32_t Image$$RW_IRAM1$$Base;
;;;491        const volatile uint32_t ram_start = (uint32_t) &Image$$RW_IRAM1$$Base;
000004  4804              LDR      r0,|L6.24|
000006  9000              STR      r0,[sp,#0]
;;;492    #elif defined ( __ICCARM__ )
;;;493        extern uint32_t __ICFEDIT_region_RAM_start__;
;;;494        volatile uint32_t ram_start = (uint32_t) &__ICFEDIT_region_RAM_start__;
;;;495    #elif defined   ( __GNUC__ )
;;;496        extern uint32_t __data_start__;
;;;497        volatile uint32_t ram_start = (uint32_t) &__data_start__;
;;;498    #endif//__CC_ARM
;;;499        if (ram_start != sd_req_ram_start)
000008  9800              LDR      r0,[sp,#0]
00000a  4288              CMP      r0,r1
00000c  d001              BEQ      |L6.18|
;;;500        {
;;;501            NRF_LOG_WARNING("RAM START ADDR 0x%x should be adjusted to 0x%x\r\n",
;;;502                      ram_start,
;;;503                      sd_req_ram_start);
;;;504            NRF_LOG_WARNING("RAM SIZE should be adjusted to 0x%x \r\n",
;;;505                    ram_end_address_get() - sd_req_ram_start);
;;;506            return NRF_SUCCESS;
00000e  2000              MOVS     r0,#0
                  |L6.16|
;;;507        }
;;;508    #endif//defined(S130) || defined(S132) || defined(S332)
;;;509        return NRF_SUCCESS;
;;;510    }
000010  bd08              POP      {r3,pc}
                  |L6.18|
000012  2000              MOVS     r0,#0                 ;509
000014  e7fc              B        |L6.16|
;;;511    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      ||Image$$RW_IRAM1$$Base||

                          AREA ||i.sd_nvic_EnableIRQ||, CODE, READONLY, ALIGN=2

                  sd_nvic_EnableIRQ PROC
;;;228     */
;;;229    static inline uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231      if (!__sd_nvic_app_accessible_irq(IRQn))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       __sd_nvic_app_accessible_irq
00000a  b910              CBNZ     r0,|L7.18|
;;;232      {
;;;233        return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
00000c  f2420001          MOV      r0,#0x2001
                  |L7.16|
;;;234      }
;;;235      if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
;;;236      {
;;;237        return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
;;;238      }
;;;239    
;;;240      if (nrf_nvic_state.__cr_flag)
;;;241      {
;;;242        nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
;;;243      }
;;;244      else
;;;245      {
;;;246        NVIC_EnableIRQ(IRQn);
;;;247      }
;;;248      return NRF_SUCCESS;
;;;249    }
000010  bd10              POP      {r4,pc}
                  |L7.18|
000012  4621              MOV      r1,r4                 ;235
000014  2900              CMP      r1,#0                 ;235
000016  da06              BGE      |L7.38|
000018  4a19              LDR      r2,|L7.128|
00001a  f001030f          AND      r3,r1,#0xf            ;235
00001e  1f1b              SUBS     r3,r3,#4              ;235
000020  5cd2              LDRB     r2,[r2,r3]            ;235
000022  0952              LSRS     r2,r2,#5              ;235
000024  e002              B        |L7.44|
                  |L7.38|
000026  4a17              LDR      r2,|L7.132|
000028  5c52              LDRB     r2,[r2,r1]            ;235
00002a  0952              LSRS     r2,r2,#5              ;235
                  |L7.44|
00002c  4610              MOV      r0,r2                 ;235
00002e  2808              CMP      r0,#8                 ;235
000030  d301              BCC      |L7.54|
000032  2100              MOVS     r1,#0                 ;235
000034  e009              B        |L7.74|
                  |L7.54|
000036  b128              CBZ      r0,|L7.68|
000038  2801              CMP      r0,#1                 ;235
00003a  d003              BEQ      |L7.68|
00003c  2804              CMP      r0,#4                 ;235
00003e  d001              BEQ      |L7.68|
000040  2805              CMP      r0,#5                 ;235
000042  d101              BNE      |L7.72|
                  |L7.68|
000044  2100              MOVS     r1,#0                 ;235
000046  e000              B        |L7.74|
                  |L7.72|
000048  2101              MOVS     r1,#1                 ;235
                  |L7.74|
00004a  b911              CBNZ     r1,|L7.82|
00004c  f2420002          MOV      r0,#0x2002            ;237
000050  e7de              B        |L7.16|
                  |L7.82|
000052  480d              LDR      r0,|L7.136|
000054  6880              LDR      r0,[r0,#8]            ;240  ; nrf_nvic_state
000056  b168              CBZ      r0,|L7.116|
000058  0960              LSRS     r0,r4,#5              ;242
00005a  490b              LDR      r1,|L7.136|
00005c  f8510020          LDR      r0,[r1,r0,LSL #2]     ;242
000060  f004021f          AND      r2,r4,#0x1f           ;242
000064  2101              MOVS     r1,#1                 ;242
000066  4091              LSLS     r1,r1,r2              ;242
000068  4308              ORRS     r0,r0,r1              ;242
00006a  0961              LSRS     r1,r4,#5              ;242
00006c  4a06              LDR      r2,|L7.136|
00006e  f8420021          STR      r0,[r2,r1,LSL #2]     ;242
000072  e002              B        |L7.122|
                  |L7.116|
000074  4620              MOV      r0,r4                 ;246
000076  f7fffffe          BL       NVIC_EnableIRQ
                  |L7.122|
00007a  2000              MOVS     r0,#0                 ;248
00007c  e7c8              B        |L7.16|
;;;250    
                          ENDP

00007e  0000              DCW      0x0000
                  |L7.128|
                          DCD      0xe000ed18
                  |L7.132|
                          DCD      0xe000e400
                  |L7.136|
                          DCD      nrf_nvic_state

                          AREA ||i.softdevice_ble_evt_handler_set||, CODE, READONLY, ALIGN=2

                  softdevice_ble_evt_handler_set PROC
;;;350    #ifdef BLE_STACK_SUPPORT_REQD
;;;351    uint32_t softdevice_ble_evt_handler_set(ble_evt_handler_t ble_evt_handler)
000000  4601              MOV      r1,r0
;;;352    {
;;;353        VERIFY_PARAM_NOT_NULL(ble_evt_handler);
000002  bf00              NOP      
000004  b909              CBNZ     r1,|L8.10|
000006  200e              MOVS     r0,#0xe
                  |L8.8|
;;;354    
;;;355        m_ble_evt_handler = ble_evt_handler;
;;;356    
;;;357        return NRF_SUCCESS;
;;;358    }
000008  4770              BX       lr
                  |L8.10|
00000a  bf00              NOP                            ;353
00000c  4801              LDR      r0,|L8.20|
00000e  6001              STR      r1,[r0,#0]            ;355  ; m_ble_evt_handler
000010  2000              MOVS     r0,#0                 ;357
000012  e7f9              B        |L8.8|
;;;359    #endif
                          ENDP

                  |L8.20|
                          DCD      m_ble_evt_handler

                          AREA ||i.softdevice_enable||, CODE, READONLY, ALIGN=2

                  softdevice_enable PROC
;;;511    
;;;512    uint32_t softdevice_enable(ble_enable_params_t * p_ble_enable_params)
000000  b57c              PUSH     {r2-r6,lr}
;;;513    {
000002  4604              MOV      r4,r0
;;;514    #if (defined(S130) || defined(S132) || defined(S332))
;;;515        uint32_t err_code;
;;;516        uint32_t app_ram_base;
;;;517    
;;;518    #if defined ( __CC_ARM )
;;;519        extern uint32_t Image$$RW_IRAM1$$Base;
;;;520        const volatile uint32_t ram_start = (uint32_t) &Image$$RW_IRAM1$$Base;
000004  4807              LDR      r0,|L9.36|
000006  9000              STR      r0,[sp,#0]
;;;521    #elif defined ( __ICCARM__ )
;;;522        extern uint32_t __ICFEDIT_region_RAM_start__;
;;;523        volatile uint32_t ram_start = (uint32_t) &__ICFEDIT_region_RAM_start__;
;;;524    #elif defined   ( __GNUC__ )
;;;525        extern uint32_t __data_start__;
;;;526        volatile uint32_t ram_start = (uint32_t) &__data_start__;
;;;527    #endif
;;;528    
;;;529        app_ram_base = ram_start;
000008  9800              LDR      r0,[sp,#0]
00000a  9001              STR      r0,[sp,#4]
;;;530        NRF_LOG_INFO("sd_ble_enable: RAM START at 0x%x\r\n",
;;;531                        app_ram_base);
;;;532        err_code = sd_ble_enable(p_ble_enable_params, &app_ram_base);
00000c  a901              ADD      r1,sp,#4
00000e  4620              MOV      r0,r4
000010  df60              SVC      #0x60
000012  4605              MOV      r5,r0
;;;533    
;;;534        if (app_ram_base != ram_start)
000014  e9dd1000          LDRD     r1,r0,[sp,#0]
000018  4288              CMP      r0,r1
00001a  d100              BNE      |L9.30|
;;;535        {
;;;536            NRF_LOG_WARNING("sd_ble_enable: app_ram_base should be adjusted to 0x%x\r\n",
;;;537                    app_ram_base);
;;;538            NRF_LOG_WARNING("ram size should be adjusted to 0x%x \r\n",
;;;539                    ram_end_address_get() - app_ram_base);
;;;540        }
;;;541        else if (err_code != NRF_SUCCESS)
00001c  bf00              NOP      
                  |L9.30|
;;;542        {
;;;543            NRF_LOG_ERROR("sd_ble_enable: error 0x%x\r\n", err_code);
;;;544        }
;;;545        return err_code;
00001e  4628              MOV      r0,r5
;;;546    #else
;;;547        return NRF_SUCCESS;
;;;548    #endif   //defined(S130) || defined(S132) || defined(S332)
;;;549    
;;;550    }
000020  bd7c              POP      {r2-r6,pc}
;;;551    /*lint -restore*/
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      ||Image$$RW_IRAM1$$Base||

                          AREA ||i.softdevice_enable_get_default_config||, CODE, READONLY, ALIGN=1

                  softdevice_enable_get_default_config PROC
;;;440    #if defined(BLE_STACK_SUPPORT_REQD)
;;;441    uint32_t softdevice_enable_get_default_config(uint8_t central_links_count,
000000  b570              PUSH     {r4-r6,lr}
;;;442                                                  uint8_t periph_links_count,
;;;443                                                  ble_enable_params_t * p_ble_enable_params)
;;;444    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;445        memset(p_ble_enable_params, 0, sizeof(ble_enable_params_t));
000008  211c              MOVS     r1,#0x1c
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;446        p_ble_enable_params->common_enable_params.vs_uuid_count   = 1;
000010  2001              MOVS     r0,#1
000012  8020              STRH     r0,[r4,#0]
;;;447        p_ble_enable_params->gatts_enable_params.attr_tab_size    = SOFTDEVICE_GATTS_ATTR_TAB_SIZE;
000014  2100              MOVS     r1,#0
000016  61a1              STR      r1,[r4,#0x18]
;;;448        p_ble_enable_params->gatts_enable_params.service_changed  = SOFTDEVICE_GATTS_SRV_CHANGED;
000018  2000              MOVS     r0,#0
00001a  7520              STRB     r0,[r4,#0x14]
;;;449        p_ble_enable_params->gap_enable_params.periph_conn_count  = periph_links_count;
00001c  7226              STRB     r6,[r4,#8]
;;;450        p_ble_enable_params->gap_enable_params.central_conn_count = central_links_count;
00001e  7265              STRB     r5,[r4,#9]
;;;451        if (p_ble_enable_params->gap_enable_params.central_conn_count != 0)
000020  7a60              LDRB     r0,[r4,#9]
000022  b108              CBZ      r0,|L10.40|
;;;452        {
;;;453            p_ble_enable_params->gap_enable_params.central_sec_count  = SOFTDEVICE_CENTRAL_SEC_COUNT;
000024  2101              MOVS     r1,#1
000026  72a1              STRB     r1,[r4,#0xa]
                  |L10.40|
;;;454        }
;;;455    
;;;456        return NRF_SUCCESS;
000028  2000              MOVS     r0,#0
;;;457    }
00002a  bd70              POP      {r4-r6,pc}
;;;458    
                          ENDP


                          AREA ||i.softdevice_fault_handler||, CODE, READONLY, ALIGN=1

                  softdevice_fault_handler PROC
;;;100     */
;;;101    void softdevice_fault_handler(uint32_t id, uint32_t pc, uint32_t info)
000000  b570              PUSH     {r4-r6,lr}
;;;102    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;103        app_error_fault_handler(id, pc, info);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       app_error_fault_handler
;;;104    }
000012  bd70              POP      {r4-r6,pc}
;;;105    
                          ENDP


                          AREA ||i.softdevice_handler_init||, CODE, READONLY, ALIGN=2

                  softdevice_handler_init PROC
;;;261    
;;;262    uint32_t softdevice_handler_init(nrf_clock_lf_cfg_t *           p_clock_lf_cfg,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;263                                     void *                         p_ble_evt_buffer,
;;;264                                     uint16_t                       ble_evt_buffer_size,
;;;265                                     softdevice_evt_schedule_func_t evt_schedule_func)
;;;266    {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;267        uint32_t err_code;
;;;268    
;;;269        // Save configuration.
;;;270    #if defined (BLE_STACK_SUPPORT_REQD)
;;;271        // Check that buffer is not NULL.
;;;272        if (p_ble_evt_buffer == NULL)
00000c  b914              CBNZ     r4,|L12.20|
;;;273        {
;;;274            return NRF_ERROR_INVALID_PARAM;
00000e  2007              MOVS     r0,#7
                  |L12.16|
;;;275        }
;;;276    
;;;277        // Check that buffer is correctly aligned.
;;;278        if (!is_word_aligned(p_ble_evt_buffer))
;;;279        {
;;;280            return NRF_ERROR_INVALID_PARAM;
;;;281        }
;;;282    
;;;283        mp_ble_evt_buffer     = (uint8_t *)p_ble_evt_buffer;
;;;284        m_ble_evt_buffer_size = ble_evt_buffer_size;
;;;285    #else
;;;286        // The variables p_ble_evt_buffer and ble_evt_buffer_size is not needed if BLE Stack support
;;;287        // is not required.
;;;288        UNUSED_PARAMETER(p_ble_evt_buffer);
;;;289        UNUSED_PARAMETER(ble_evt_buffer_size);
;;;290    #endif
;;;291    
;;;292        m_evt_schedule_func = evt_schedule_func;
;;;293    
;;;294        // Initialize SoftDevice.
;;;295    #if (CLOCK_ENABLED && defined(SOFTDEVICE_PRESENT))
;;;296        bool power_clock_isr_enabled = isr_enable_check(POWER_CLOCK_IRQn);
;;;297        if (power_clock_isr_enabled)
;;;298        {
;;;299            NVIC_DisableIRQ(POWER_CLOCK_IRQn);
;;;300        }
;;;301    #endif
;;;302    #if defined(S212) || defined(S332)
;;;303        err_code = sd_softdevice_enable(p_clock_lf_cfg, softdevice_fault_handler, ANT_LICENSE_KEY);
;;;304    #else
;;;305        err_code = sd_softdevice_enable(p_clock_lf_cfg, softdevice_fault_handler);
;;;306    #endif
;;;307    
;;;308        if (err_code != NRF_SUCCESS)
;;;309        {
;;;310    #if (CLOCK_ENABLED && defined(SOFTDEVICE_PRESENT))
;;;311            if (power_clock_isr_enabled)
;;;312            {
;;;313                NVIC_EnableIRQ(POWER_CLOCK_IRQn);
;;;314            }
;;;315    #endif
;;;316            return err_code;
;;;317        }
;;;318    
;;;319        m_softdevice_enabled = true;
;;;320    #if (CLOCK_ENABLED && defined(SOFTDEVICE_PRESENT))
;;;321        nrf_drv_clock_on_sd_enable();
;;;322    #endif
;;;323    
;;;324        // Enable BLE event interrupt (interrupt priority has already been set by the stack).
;;;325    #ifdef SOFTDEVICE_PRESENT
;;;326        return sd_nvic_EnableIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ);
;;;327    #else
;;;328        //In case of Serialization NVIC must be accessed directly.
;;;329        NVIC_EnableIRQ(SOFTDEVICE_EVT_IRQ);
;;;330        return NRF_SUCCESS;
;;;331    #endif
;;;332    }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L12.20|
000014  4620              MOV      r0,r4                 ;278
000016  f0000103          AND      r1,r0,#3              ;278
00001a  b909              CBNZ     r1,|L12.32|
00001c  2101              MOVS     r1,#1                 ;278
00001e  e000              B        |L12.34|
                  |L12.32|
000020  2100              MOVS     r1,#0                 ;278
                  |L12.34|
000022  b909              CBNZ     r1,|L12.40|
000024  2007              MOVS     r0,#7                 ;280
000026  e7f3              B        |L12.16|
                  |L12.40|
000028  4817              LDR      r0,|L12.136|
00002a  6004              STR      r4,[r0,#0]            ;283  ; mp_ble_evt_buffer
00002c  4817              LDR      r0,|L12.140|
00002e  8007              STRH     r7,[r0,#0]            ;284
000030  4817              LDR      r0,|L12.144|
000032  f8c08000          STR      r8,[r0,#0]            ;292  ; m_evt_schedule_func
000036  2000              MOVS     r0,#0                 ;296
000038  0941              LSRS     r1,r0,#5              ;296
00003a  0089              LSLS     r1,r1,#2              ;296
00003c  f10121e0          ADD      r1,r1,#0xe000e000     ;296
000040  f8d11100          LDR      r1,[r1,#0x100]        ;296
000044  2201              MOVS     r2,#1                 ;296
000046  4082              LSLS     r2,r2,r0              ;296
000048  4011              ANDS     r1,r1,r2              ;296
00004a  b109              CBZ      r1,|L12.80|
00004c  2101              MOVS     r1,#1                 ;296
00004e  e000              B        |L12.82|
                  |L12.80|
000050  2100              MOVS     r1,#0                 ;296
                  |L12.82|
000052  460e              MOV      r6,r1                 ;296
000054  bf00              NOP                            ;296
000056  b116              CBZ      r6,|L12.94|
000058  2000              MOVS     r0,#0                 ;299
00005a  f7fffffe          BL       NVIC_DisableIRQ
                  |L12.94|
00005e  490d              LDR      r1,|L12.148|
000060  4648              MOV      r0,r9                 ;305
000062  df10              SVC      #0x10                 ;305
000064  4605              MOV      r5,r0                 ;305
000066  b12d              CBZ      r5,|L12.116|
000068  b116              CBZ      r6,|L12.112|
00006a  2000              MOVS     r0,#0                 ;313
00006c  f7fffffe          BL       NVIC_EnableIRQ
                  |L12.112|
000070  4628              MOV      r0,r5                 ;316
000072  e7cd              B        |L12.16|
                  |L12.116|
000074  2001              MOVS     r0,#1                 ;319
000076  4908              LDR      r1,|L12.152|
000078  7008              STRB     r0,[r1,#0]            ;319
00007a  f7fffffe          BL       nrf_drv_clock_on_sd_enable
00007e  2016              MOVS     r0,#0x16              ;326
000080  f7fffffe          BL       sd_nvic_EnableIRQ
000084  e7c4              B        |L12.16|
;;;333    
                          ENDP

000086  0000              DCW      0x0000
                  |L12.136|
                          DCD      mp_ble_evt_buffer
                  |L12.140|
                          DCD      m_ble_evt_buffer_size
                  |L12.144|
                          DCD      m_evt_schedule_func
                  |L12.148|
                          DCD      softdevice_fault_handler
                  |L12.152|
                          DCD      m_softdevice_enabled

                          AREA ||i.softdevice_handler_is_enabled||, CODE, READONLY, ALIGN=2

                  softdevice_handler_is_enabled PROC
;;;256    
;;;257    bool softdevice_handler_is_enabled(void)
000000  4801              LDR      r0,|L13.8|
;;;258    {
;;;259        return m_softdevice_enabled;
000002  7800              LDRB     r0,[r0,#0]  ; m_softdevice_enabled
;;;260    }
000004  4770              BX       lr
;;;261    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      m_softdevice_enabled

                          AREA ||i.softdevice_handler_is_suspended||, CODE, READONLY, ALIGN=2

                  softdevice_handler_is_suspended PROC
;;;434    
;;;435    bool softdevice_handler_is_suspended()
000000  4801              LDR      r0,|L14.8|
;;;436    {
;;;437        return m_suspended;
000002  7800              LDRB     r0,[r0,#0]  ; m_suspended
;;;438    }
000004  4770              BX       lr
;;;439    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      m_suspended

                          AREA ||i.softdevice_handler_resume||, CODE, READONLY, ALIGN=2

                  softdevice_handler_resume PROC
;;;412    
;;;413    void softdevice_handler_resume()
000000  b570              PUSH     {r4-r6,lr}
;;;414    {
;;;415        if (!m_suspended) return;
000002  4819              LDR      r0,|L15.104|
000004  7800              LDRB     r0,[r0,#0]  ; m_suspended
000006  b900              CBNZ     r0,|L15.10|
                  |L15.8|
;;;416        m_suspended = false;
;;;417    
;;;418    #ifdef SOFTDEVICE_PRESENT
;;;419        ret_code_t err_code;
;;;420    
;;;421        // Force calling ISR again to make sure that events not pulled previously
;;;422        // has been processed.
;;;423        err_code = sd_nvic_SetPendingIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ);
;;;424        APP_ERROR_CHECK(err_code);
;;;425        err_code = sd_nvic_EnableIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ);
;;;426        APP_ERROR_CHECK(err_code);
;;;427    #else
;;;428        NVIC_SetPendingIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ);
;;;429        NVIC_EnableIRQ(SOFTDEVICE_EVT_IRQ);
;;;430    #endif
;;;431    
;;;432        return;
;;;433    }
000008  bd70              POP      {r4-r6,pc}
                  |L15.10|
00000a  2000              MOVS     r0,#0                 ;416
00000c  4916              LDR      r1,|L15.104|
00000e  7008              STRB     r0,[r1,#0]            ;416
000010  2416              MOVS     r4,#0x16              ;423
000012  4620              MOV      r0,r4                 ;423
000014  f7fffffe          BL       __sd_nvic_app_accessible_irq
000018  b158              CBZ      r0,|L15.50|
00001a  bf00              NOP                            ;423
00001c  f004011f          AND      r1,r4,#0x1f           ;423
000020  2001              MOVS     r0,#1                 ;423
000022  4088              LSLS     r0,r0,r1              ;423
000024  4911              LDR      r1,|L15.108|
000026  0962              LSRS     r2,r4,#5              ;423
000028  f8410022          STR      r0,[r1,r2,LSL #2]     ;423
00002c  bf00              NOP                            ;423
00002e  2000              MOVS     r0,#0                 ;423
000030  e001              B        |L15.54|
                  |L15.50|
000032  f2420001          MOV      r0,#0x2001            ;423
                  |L15.54|
000036  4605              MOV      r5,r0                 ;423
000038  bf00              NOP                            ;424
00003a  462c              MOV      r4,r5                 ;424
00003c  b124              CBZ      r4,|L15.72|
00003e  bf00              NOP                            ;424
000040  4620              MOV      r0,r4                 ;424
000042  f7fffffe          BL       app_error_handler_bare
000046  bf00              NOP                            ;424
                  |L15.72|
000048  bf00              NOP                            ;424
00004a  2016              MOVS     r0,#0x16              ;425
00004c  f7fffffe          BL       sd_nvic_EnableIRQ
000050  4605              MOV      r5,r0                 ;425
000052  bf00              NOP                            ;426
000054  462c              MOV      r4,r5                 ;426
000056  b124              CBZ      r4,|L15.98|
000058  bf00              NOP                            ;426
00005a  4620              MOV      r0,r4                 ;426
00005c  f7fffffe          BL       app_error_handler_bare
000060  bf00              NOP                            ;426
                  |L15.98|
000062  bf00              NOP                            ;426
000064  bf00              NOP                            ;432
000066  e7cf              B        |L15.8|
;;;434    
                          ENDP

                  |L15.104|
                          DCD      m_suspended
                  |L15.108|
                          DCD      0xe000e200

                          AREA ||i.softdevice_handler_sd_disable||, CODE, READONLY, ALIGN=2

                  softdevice_handler_sd_disable PROC
;;;334    
;;;335    uint32_t softdevice_handler_sd_disable(void)
000000  b510              PUSH     {r4,lr}
;;;336    {
;;;337        uint32_t err_code = sd_softdevice_disable();
000002  df11              SVC      #0x11
000004  4604              MOV      r4,r0
;;;338    #if (CLOCK_ENABLED && defined(SOFTDEVICE_PRESENT))
;;;339        if (err_code == NRF_SUCCESS)
000006  b924              CBNZ     r4,|L16.18|
;;;340        {
;;;341            m_softdevice_enabled = false;
000008  2000              MOVS     r0,#0
00000a  4903              LDR      r1,|L16.24|
00000c  7008              STRB     r0,[r1,#0]
;;;342            nrf_drv_clock_on_sd_disable();
00000e  f7fffffe          BL       nrf_drv_clock_on_sd_disable
                  |L16.18|
;;;343        }
;;;344    #else
;;;345        m_softdevice_enabled = !(err_code == NRF_SUCCESS);
;;;346    #endif
;;;347        return err_code;
000012  4620              MOV      r0,r4
;;;348    }
000014  bd10              POP      {r4,pc}
;;;349    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      m_softdevice_enabled

                          AREA ||i.softdevice_handler_suspend||, CODE, READONLY, ALIGN=2

                  softdevice_handler_suspend PROC
;;;400    
;;;401    void softdevice_handler_suspend()
000000  b570              PUSH     {r4-r6,lr}
;;;402    {
;;;403    #ifdef SOFTDEVICE_PRESENT
;;;404        ret_code_t err_code = sd_nvic_DisableIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ);
000002  2416              MOVS     r4,#0x16
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       __sd_nvic_app_accessible_irq
00000a  b910              CBNZ     r0,|L17.18|
00000c  f2420001          MOV      r0,#0x2001
000010  e014              B        |L17.60|
                  |L17.18|
000012  4811              LDR      r0,|L17.88|
000014  6880              LDR      r0,[r0,#8]  ; nrf_nvic_state
000016  b168              CBZ      r0,|L17.52|
000018  0960              LSRS     r0,r4,#5
00001a  490f              LDR      r1,|L17.88|
00001c  f8510020          LDR      r0,[r1,r0,LSL #2]
000020  f004021f          AND      r2,r4,#0x1f
000024  2101              MOVS     r1,#1
000026  4091              LSLS     r1,r1,r2
000028  4388              BICS     r0,r0,r1
00002a  0961              LSRS     r1,r4,#5
00002c  4a0a              LDR      r2,|L17.88|
00002e  f8420021          STR      r0,[r2,r1,LSL #2]
000032  e002              B        |L17.58|
                  |L17.52|
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       NVIC_DisableIRQ
                  |L17.58|
00003a  2000              MOVS     r0,#0
                  |L17.60|
00003c  4605              MOV      r5,r0
;;;405        APP_ERROR_CHECK(err_code);
00003e  bf00              NOP      
000040  462c              MOV      r4,r5
000042  b124              CBZ      r4,|L17.78|
000044  bf00              NOP      
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       app_error_handler_bare
00004c  bf00              NOP      
                  |L17.78|
00004e  bf00              NOP      
;;;406    #else
;;;407        NVIC_DisableIRQ(SOFTDEVICE_EVT_IRQ);
;;;408    #endif
;;;409        m_suspended = true;
000050  2001              MOVS     r0,#1
000052  4902              LDR      r1,|L17.92|
000054  7008              STRB     r0,[r1,#0]
;;;410        return;
;;;411    }
000056  bd70              POP      {r4-r6,pc}
;;;412    
                          ENDP

                  |L17.88|
                          DCD      nrf_nvic_state
                  |L17.92|
                          DCD      m_suspended

                          AREA ||i.softdevice_sys_evt_handler_set||, CODE, READONLY, ALIGN=2

                  softdevice_sys_evt_handler_set PROC
;;;373    
;;;374    uint32_t softdevice_sys_evt_handler_set(sys_evt_handler_t sys_evt_handler)
000000  4601              MOV      r1,r0
;;;375    {
;;;376        VERIFY_PARAM_NOT_NULL(sys_evt_handler);
000002  bf00              NOP      
000004  b909              CBNZ     r1,|L18.10|
000006  200e              MOVS     r0,#0xe
                  |L18.8|
;;;377    
;;;378        m_sys_evt_handler = sys_evt_handler;
;;;379    
;;;380        return NRF_SUCCESS;
;;;381    }
000008  4770              BX       lr
                  |L18.10|
00000a  bf00              NOP                            ;376
00000c  4801              LDR      r0,|L18.20|
00000e  6001              STR      r1,[r0,#0]            ;378  ; m_sys_evt_handler
000010  2000              MOVS     r0,#0                 ;380
000012  e7f9              B        |L18.8|
;;;382    
                          ENDP

                  |L18.20|
                          DCD      m_sys_evt_handler

                          AREA ||.data||, DATA, ALIGN=2

                  m_evt_schedule_func
                          DCD      0x00000000
                  m_softdevice_enabled
000004  00                DCB      0x00
                  m_suspended
000005  000000            DCB      0x00,0x00,0x00
                  mp_ble_evt_buffer
                          DCD      0x00000000
                  m_ble_evt_buffer_size
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  m_ble_evt_handler
                          DCD      0x00000000
                  m_sys_evt_handler
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\softdevice\\common\\softdevice_handler\\softdevice_handler.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_softdevice_handler_c_a07f8f21____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_softdevice_handler_c_a07f8f21____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_softdevice_handler_c_a07f8f21____REVSH|
#line 402
|__asm___20_softdevice_handler_c_a07f8f21____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_softdevice_handler_c_a07f8f21____RRX|
#line 587
|__asm___20_softdevice_handler_c_a07f8f21____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
