L 1 "..\..\..\..\..\..\components\libraries\log\src\nrf_log_backend_serial.c"
N/* Copyright (c) 2016 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N#include "sdk_config.h"
L 1 "..\config\sdk_config.h" 1
N
N
N#ifndef SDK_CONFIG_H
N#define SDK_CONFIG_H
N// <<< Use Configuration Wizard in Context Menu >>>\n
N#ifdef USE_APP_CONFIG
S#include "app_config.h"
N#endif
N// <h> nRF_BLE 
N
N//==========================================================
N// <q> BLE_ADVERTISING_ENABLED  - ble_advertising - Advertising module
N 
N
N#ifndef BLE_ADVERTISING_ENABLED
N#define BLE_ADVERTISING_ENABLED 1
N#endif
N
N// <q> BLE_DTM_ENABLED  - ble_dtm - Module for testing RF/PHY using DTM commands
N 
N
N#ifndef BLE_DTM_ENABLED
N#define BLE_DTM_ENABLED 0
N#endif
N
N// <q> BLE_RACP_ENABLED  - ble_racp - Record Access Control Point library
N 
N
N#ifndef BLE_RACP_ENABLED
N#define BLE_RACP_ENABLED 0
N#endif
N
N// <q> NRF_BLE_QWR_ENABLED  - nrf_ble_qwr - Queued writes support module (prepare/execute write)
N 
N
N#ifndef NRF_BLE_QWR_ENABLED
N#define NRF_BLE_QWR_ENABLED 1
N#endif
N
N// <q> PEER_MANAGER_ENABLED  - peer_manager - Peer Manager
N 
N
N#ifndef PEER_MANAGER_ENABLED
N#define PEER_MANAGER_ENABLED 1
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_BLE_Services 
N
N//==========================================================
N// <q> BLE_ANCS_C_ENABLED  - ble_ancs_c - Apple Notification Service Client
N 
N
N#ifndef BLE_ANCS_C_ENABLED
N#define BLE_ANCS_C_ENABLED 0
N#endif
N
N// <q> BLE_ANS_C_ENABLED  - ble_ans_c - Alert Notification Service Client
N 
N
N#ifndef BLE_ANS_C_ENABLED
N#define BLE_ANS_C_ENABLED 0
N#endif
N
N// <q> BLE_BAS_C_ENABLED  - ble_bas_c - Battery Service Client
N 
N
N#ifndef BLE_BAS_C_ENABLED
N#define BLE_BAS_C_ENABLED 0
N#endif
N
N// <q> BLE_BAS_ENABLED  - ble_bas - Battery Service
N 
N
N#ifndef BLE_BAS_ENABLED
N#define BLE_BAS_ENABLED 1
N#endif
N
N// <q> BLE_CSCS_ENABLED  - ble_cscs - Cycling Speed and Cadence Service
N 
N
N#ifndef BLE_CSCS_ENABLED
N#define BLE_CSCS_ENABLED 0
N#endif
N
N// <q> BLE_CTS_C_ENABLED  - ble_cts_c - Current Time Service Client
N 
N
N#ifndef BLE_CTS_C_ENABLED
N#define BLE_CTS_C_ENABLED 0
N#endif
N
N// <q> BLE_DIS_ENABLED  - ble_dis - Device Information Service
N 
N
N#ifndef BLE_DIS_ENABLED
N#define BLE_DIS_ENABLED 0
N#endif
N
N// <q> BLE_GLS_ENABLED  - ble_gls - Glucose Service
N 
N
N#ifndef BLE_GLS_ENABLED
N#define BLE_GLS_ENABLED 0
N#endif
N
N// <q> BLE_HIDS_ENABLED  - ble_hids - Human Interface Device Service
N 
N
N#ifndef BLE_HIDS_ENABLED
N#define BLE_HIDS_ENABLED 0
N#endif
N
N// <q> BLE_HRS_C_ENABLED  - ble_hrs_c - Heart Rate Service Client
N 
N
N#ifndef BLE_HRS_C_ENABLED
N#define BLE_HRS_C_ENABLED 0
N#endif
N
N// <q> BLE_HRS_ENABLED  - ble_hrs - Heart Rate Service
N 
N
N#ifndef BLE_HRS_ENABLED
N#define BLE_HRS_ENABLED 1
N#endif
N
N// <q> BLE_HTS_ENABLED  - ble_hts - Health Thermometer Service
N 
N
N#ifndef BLE_HTS_ENABLED
N#define BLE_HTS_ENABLED 0
N#endif
N
N// <q> BLE_IAS_C_ENABLED  - ble_ias_c - Immediate Alert Service Client
N 
N
N#ifndef BLE_IAS_C_ENABLED
N#define BLE_IAS_C_ENABLED 0
N#endif
N
N// <q> BLE_IAS_ENABLED  - ble_ias - Immediate Alert Service
N 
N
N#ifndef BLE_IAS_ENABLED
N#define BLE_IAS_ENABLED 0
N#endif
N
N// <q> BLE_LBS_C_ENABLED  - ble_lbs_c - Nordic LED Button Service Client
N 
N
N#ifndef BLE_LBS_C_ENABLED
N#define BLE_LBS_C_ENABLED 0
N#endif
N
N// <q> BLE_LBS_ENABLED  - ble_lbs - LED Button Service
N 
N
N#ifndef BLE_LBS_ENABLED
N#define BLE_LBS_ENABLED 0
N#endif
N
N// <q> BLE_LLS_ENABLED  - ble_lls - Link Loss Service
N 
N
N#ifndef BLE_LLS_ENABLED
N#define BLE_LLS_ENABLED 0
N#endif
N
N// <q> BLE_NUS_C_ENABLED  - ble_nus_c - Nordic UART Central Service
N 
N
N#ifndef BLE_NUS_C_ENABLED
N#define BLE_NUS_C_ENABLED 0
N#endif
N
N// <q> BLE_NUS_ENABLED  - ble_nus - Nordic UART Service
N 
N
N#ifndef BLE_NUS_ENABLED
N#define BLE_NUS_ENABLED 0
N#endif
N
N// <q> BLE_RSCS_C_ENABLED  - ble_rscs_c - Running Speed and Cadence Client
N 
N
N#ifndef BLE_RSCS_C_ENABLED
N#define BLE_RSCS_C_ENABLED 0
N#endif
N
N// <q> BLE_RSCS_ENABLED  - ble_rscs - Running Speed and Cadence Service
N 
N
N#ifndef BLE_RSCS_ENABLED
N#define BLE_RSCS_ENABLED 0
N#endif
N
N// <q> BLE_TPS_ENABLED  - ble_tps - TX Power Service
N 
N
N#ifndef BLE_TPS_ENABLED
N#define BLE_TPS_ENABLED 0
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Drivers 
N
N//==========================================================
N// <e> ADC_ENABLED - nrf_drv_adc - Driver for ADC peripheral (nRF51)
N//==========================================================
N#ifndef ADC_ENABLED
N#define ADC_ENABLED 0
N#endif
N#if  ADC_ENABLED
X#if  0
S// <o> ADC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef ADC_CONFIG_IRQ_PRIORITY
S#define ADC_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //ADC_ENABLED
N// </e>
N
N// <e> CLOCK_ENABLED - nrf_drv_clock - CLOCK peripheral driver
N//==========================================================
N#ifndef CLOCK_ENABLED
N#define CLOCK_ENABLED 1
N#endif
N#if  CLOCK_ENABLED
X#if  1
N// <o> CLOCK_CONFIG_XTAL_FREQ  - HF XTAL Frequency
N 
N// <0=> Default (64 MHz) 
N
N#ifndef CLOCK_CONFIG_XTAL_FREQ
N#define CLOCK_CONFIG_XTAL_FREQ 0
N#endif
N
N// <o> CLOCK_CONFIG_LF_SRC  - LF Clock Source
N 
N// <0=> RC 
N// <1=> XTAL 
N// <2=> Synth 
N
N#ifndef CLOCK_CONFIG_LF_SRC
N#define CLOCK_CONFIG_LF_SRC 1
N#endif
N
N// <o> CLOCK_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef CLOCK_CONFIG_IRQ_PRIORITY
N#define CLOCK_CONFIG_IRQ_PRIORITY 6
N#endif
N
N#endif //CLOCK_ENABLED
N// </e>
N
N// <e> COMP_ENABLED - nrf_drv_comp - COMP peripheral driver
N//==========================================================
N#ifndef COMP_ENABLED
N#define COMP_ENABLED 0
N#endif
N#if  COMP_ENABLED
X#if  0
S// <o> COMP_CONFIG_REF  - Reference voltage
S 
S// <0=> Internal 1.2V 
S// <1=> Internal 1.8V 
S// <2=> Internal 2.4V 
S// <4=> VDD 
S// <7=> ARef 
S
S#ifndef COMP_CONFIG_REF
S#define COMP_CONFIG_REF 1
S#endif
S
S// <o> COMP_CONFIG_MAIN_MODE  - Main mode
S 
S// <0=> Single ended 
S// <1=> Differential 
S
S#ifndef COMP_CONFIG_MAIN_MODE
S#define COMP_CONFIG_MAIN_MODE 0
S#endif
S
S// <o> COMP_CONFIG_SPEED_MODE  - Speed mode
S 
S// <0=> Low power 
S// <1=> Normal 
S// <2=> High speed 
S
S#ifndef COMP_CONFIG_SPEED_MODE
S#define COMP_CONFIG_SPEED_MODE 2
S#endif
S
S// <o> COMP_CONFIG_HYST  - Hystheresis
S 
S// <0=> No 
S// <1=> 50mV 
S
S#ifndef COMP_CONFIG_HYST
S#define COMP_CONFIG_HYST 0
S#endif
S
S// <o> COMP_CONFIG_ISOURCE  - Current Source
S 
S// <0=> Off 
S// <1=> 2.5 uA 
S// <2=> 5 uA 
S// <3=> 10 uA 
S
S#ifndef COMP_CONFIG_ISOURCE
S#define COMP_CONFIG_ISOURCE 0
S#endif
S
S// <o> COMP_CONFIG_INPUT  - Analog input
S 
S// <0=> 0 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef COMP_CONFIG_INPUT
S#define COMP_CONFIG_INPUT 0
S#endif
S
S// <o> COMP_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef COMP_CONFIG_IRQ_PRIORITY
S#define COMP_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //COMP_ENABLED
N// </e>
N
N// <q> EGU_ENABLED  - nrf_drv_swi - SWI(EGU) peripheral driver
N 
N
N#ifndef EGU_ENABLED
N#define EGU_ENABLED 0
N#endif
N
N// <e> GPIOTE_ENABLED - nrf_drv_gpiote - GPIOTE peripheral driver
N//==========================================================
N#ifndef GPIOTE_ENABLED
N#define GPIOTE_ENABLED 1
N#endif
N#if  GPIOTE_ENABLED
X#if  1
N// <o> GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS - Number of lower power input pins 
N#ifndef GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS
N#define GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS 4
N#endif
N
N// <o> GPIOTE_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef GPIOTE_CONFIG_IRQ_PRIORITY
N#define GPIOTE_CONFIG_IRQ_PRIORITY 6
N#endif
N
N#endif //GPIOTE_ENABLED
N// </e>
N
N// <e> I2S_ENABLED - nrf_drv_i2s - I2S peripheral driver
N//==========================================================
N#ifndef I2S_ENABLED
N#define I2S_ENABLED 0
N#endif
N#if  I2S_ENABLED
X#if  0
S// <o> I2S_CONFIG_SCK_PIN - SCK pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SCK_PIN
S#define I2S_CONFIG_SCK_PIN 31
S#endif
S
S// <o> I2S_CONFIG_LRCK_PIN - LRCK pin  <1-31> 
S
S
S#ifndef I2S_CONFIG_LRCK_PIN
S#define I2S_CONFIG_LRCK_PIN 30
S#endif
S
S// <o> I2S_CONFIG_MCK_PIN - MCK pin 
S#ifndef I2S_CONFIG_MCK_PIN
S#define I2S_CONFIG_MCK_PIN 255
S#endif
S
S// <o> I2S_CONFIG_SDOUT_PIN - SDOUT pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SDOUT_PIN
S#define I2S_CONFIG_SDOUT_PIN 29
S#endif
S
S// <o> I2S_CONFIG_SDIN_PIN - SDIN pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SDIN_PIN
S#define I2S_CONFIG_SDIN_PIN 28
S#endif
S
S// <o> I2S_CONFIG_MASTER  - Mode
S 
S// <0=> Master 
S// <1=> Slave 
S
S#ifndef I2S_CONFIG_MASTER
S#define I2S_CONFIG_MASTER 0
S#endif
S
S// <o> I2S_CONFIG_FORMAT  - Format
S 
S// <0=> I2S 
S// <1=> Aligned 
S
S#ifndef I2S_CONFIG_FORMAT
S#define I2S_CONFIG_FORMAT 0
S#endif
S
S// <o> I2S_CONFIG_ALIGN  - Alignment
S 
S// <0=> Left 
S// <1=> Right 
S
S#ifndef I2S_CONFIG_ALIGN
S#define I2S_CONFIG_ALIGN 0
S#endif
S
S// <o> I2S_CONFIG_SWIDTH  - Sample width (bits)
S 
S// <0=> 8 
S// <1=> 16 
S// <2=> 24 
S
S#ifndef I2S_CONFIG_SWIDTH
S#define I2S_CONFIG_SWIDTH 1
S#endif
S
S// <o> I2S_CONFIG_CHANNELS  - Channels
S 
S// <0=> Stereo 
S// <1=> Left 
S// <2=> Right 
S
S#ifndef I2S_CONFIG_CHANNELS
S#define I2S_CONFIG_CHANNELS 1
S#endif
S
S// <o> I2S_CONFIG_MCK_SETUP  - MCK behavior
S 
S// <0=> Disabled 
S// <2147483648=> 32MHz/2 
S// <1342177280=> 32MHz/3 
S// <1073741824=> 32MHz/4 
S// <805306368=> 32MHz/5 
S// <671088640=> 32MHz/6 
S// <536870912=> 32MHz/8 
S// <402653184=> 32MHz/10 
S// <369098752=> 32MHz/11 
S// <285212672=> 32MHz/15 
S// <268435456=> 32MHz/16 
S// <201326592=> 32MHz/21 
S// <184549376=> 32MHz/23 
S// <142606336=> 32MHz/30 
S// <138412032=> 32MHz/31 
S// <134217728=> 32MHz/32 
S// <100663296=> 32MHz/42 
S// <68157440=> 32MHz/63 
S// <34340864=> 32MHz/125 
S
S#ifndef I2S_CONFIG_MCK_SETUP
S#define I2S_CONFIG_MCK_SETUP 536870912
S#endif
S
S// <o> I2S_CONFIG_RATIO  - MCK/LRCK ratio
S 
S// <0=> 32x 
S// <1=> 48x 
S// <2=> 64x 
S// <3=> 96x 
S// <4=> 128x 
S// <5=> 192x 
S// <6=> 256x 
S// <7=> 384x 
S// <8=> 512x 
S
S#ifndef I2S_CONFIG_RATIO
S#define I2S_CONFIG_RATIO 2000
S#endif
S
S// <o> I2S_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef I2S_CONFIG_IRQ_PRIORITY
S#define I2S_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //I2S_ENABLED
N// </e>
N
N// <e> LPCOMP_ENABLED - nrf_drv_lpcomp - LPCOMP peripheral driver
N//==========================================================
N#ifndef LPCOMP_ENABLED
N#define LPCOMP_ENABLED 0
N#endif
N#if  LPCOMP_ENABLED
X#if  0
S// <o> LPCOMP_CONFIG_REFERENCE  - Reference voltage
S 
S// <0=> Supply 1/8 
S// <1=> Supply 2/8 
S// <2=> Supply 3/8 
S// <3=> Supply 4/8 
S// <4=> Supply 5/8 
S// <5=> Supply 6/8 
S// <6=> Supply 7/8 
S// <8=> Supply 1/16 (nRF52) 
S// <9=> Supply 3/16 (nRF52) 
S// <10=> Supply 5/16 (nRF52) 
S// <11=> Supply 7/16 (nRF52) 
S// <12=> Supply 9/16 (nRF52) 
S// <13=> Supply 11/16 (nRF52) 
S// <14=> Supply 13/16 (nRF52) 
S// <15=> Supply 15/16 (nRF52) 
S// <7=> External Ref 0 
S// <65543=> External Ref 1 
S
S#ifndef LPCOMP_CONFIG_REFERENCE
S#define LPCOMP_CONFIG_REFERENCE 3
S#endif
S
S// <o> LPCOMP_CONFIG_DETECTION  - Detection
S 
S// <0=> Crossing 
S// <1=> Up 
S// <2=> Down 
S
S#ifndef LPCOMP_CONFIG_DETECTION
S#define LPCOMP_CONFIG_DETECTION 2
S#endif
S
S// <o> LPCOMP_CONFIG_INPUT  - Analog input
S 
S// <0=> 0 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef LPCOMP_CONFIG_INPUT
S#define LPCOMP_CONFIG_INPUT 0
S#endif
S
S// <o> LPCOMP_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef LPCOMP_CONFIG_IRQ_PRIORITY
S#define LPCOMP_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //LPCOMP_ENABLED
N// </e>
N
N// <e> PDM_ENABLED - nrf_drv_pdm - PDM peripheral driver
N//==========================================================
N#ifndef PDM_ENABLED
N#define PDM_ENABLED 0
N#endif
N#if  PDM_ENABLED
X#if  0
S// <o> PDM_CONFIG_MODE  - Mode
S 
S// <0=> Stereo 
S// <1=> Mono 
S
S#ifndef PDM_CONFIG_MODE
S#define PDM_CONFIG_MODE 1
S#endif
S
S// <o> PDM_CONFIG_EDGE  - Edge
S 
S// <0=> Left falling 
S// <1=> Left rising 
S
S#ifndef PDM_CONFIG_EDGE
S#define PDM_CONFIG_EDGE 0
S#endif
S
S// <o> PDM_CONFIG_CLOCK_FREQ  - Clock frequency
S 
S// <134217728=> 1000k 
S// <138412032=> 1032k (default) 
S// <142606336=> 1067k 
S
S#ifndef PDM_CONFIG_CLOCK_FREQ
S#define PDM_CONFIG_CLOCK_FREQ 138412032
S#endif
S
S// <o> PDM_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef PDM_CONFIG_IRQ_PRIORITY
S#define PDM_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //PDM_ENABLED
N// </e>
N
N// <q> PERIPHERAL_RESOURCE_SHARING_ENABLED  - nrf_drv_common - Peripheral drivers common module
N 
N
N#ifndef PERIPHERAL_RESOURCE_SHARING_ENABLED
N#define PERIPHERAL_RESOURCE_SHARING_ENABLED 0
N#endif
N
N// <q> PPI_ENABLED  - nrf_drv_ppi - PPI peripheral driver
N 
N
N#ifndef PPI_ENABLED
N#define PPI_ENABLED 0
N#endif
N
N// <e> PWM_ENABLED - nrf_drv_pwm - PWM peripheral driver
N//==========================================================
N#ifndef PWM_ENABLED
N#define PWM_ENABLED 0
N#endif
N#if  PWM_ENABLED
X#if  0
S// <o> PWM_DEFAULT_CONFIG_OUT0_PIN - Out0 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT0_PIN
S#define PWM_DEFAULT_CONFIG_OUT0_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT1_PIN - Out1 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT1_PIN
S#define PWM_DEFAULT_CONFIG_OUT1_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT2_PIN - Out2 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT2_PIN
S#define PWM_DEFAULT_CONFIG_OUT2_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT3_PIN - Out3 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT3_PIN
S#define PWM_DEFAULT_CONFIG_OUT3_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_BASE_CLOCK  - Base clock
S 
S// <0=> 16 MHz 
S// <1=> 8 MHz 
S// <2=> 4 MHz 
S// <3=> 2 MHz 
S// <4=> 1 MHz 
S// <5=> 500 kHz 
S// <6=> 250 kHz 
S// <7=> 125 MHz 
S
S#ifndef PWM_DEFAULT_CONFIG_BASE_CLOCK
S#define PWM_DEFAULT_CONFIG_BASE_CLOCK 4
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_COUNT_MODE  - Count mode
S 
S// <0=> Up 
S// <1=> Up and Down 
S
S#ifndef PWM_DEFAULT_CONFIG_COUNT_MODE
S#define PWM_DEFAULT_CONFIG_COUNT_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_TOP_VALUE - Top value 
S#ifndef PWM_DEFAULT_CONFIG_TOP_VALUE
S#define PWM_DEFAULT_CONFIG_TOP_VALUE 1000
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_LOAD_MODE  - Load mode
S 
S// <0=> Common 
S// <1=> Grouped 
S// <2=> Individual 
S// <3=> Waveform 
S
S#ifndef PWM_DEFAULT_CONFIG_LOAD_MODE
S#define PWM_DEFAULT_CONFIG_LOAD_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_STEP_MODE  - Step mode
S 
S// <0=> Auto 
S// <1=> Triggered 
S
S#ifndef PWM_DEFAULT_CONFIG_STEP_MODE
S#define PWM_DEFAULT_CONFIG_STEP_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef PWM_DEFAULT_CONFIG_IRQ_PRIORITY
S#define PWM_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> PWM0_ENABLED  - Enable PWM0 instance
S 
S
S#ifndef PWM0_ENABLED
S#define PWM0_ENABLED 0
S#endif
S
S// <q> PWM1_ENABLED  - Enable PWM1 instance
S 
S
S#ifndef PWM1_ENABLED
S#define PWM1_ENABLED 0
S#endif
S
S// <q> PWM2_ENABLED  - Enable PWM2 instance
S 
S
S#ifndef PWM2_ENABLED
S#define PWM2_ENABLED 0
S#endif
S
N#endif //PWM_ENABLED
N// </e>
N
N// <e> QDEC_ENABLED - nrf_drv_qdec - QDEC peripheral driver
N//==========================================================
N#ifndef QDEC_ENABLED
N#define QDEC_ENABLED 0
N#endif
N#if  QDEC_ENABLED
X#if  0
S// <o> QDEC_CONFIG_REPORTPER  - Report period
S 
S// <0=> 10 Samples 
S// <1=> 40 Samples 
S// <2=> 80 Samples 
S// <3=> 120 Samples 
S// <4=> 160 Samples 
S// <5=> 200 Samples 
S// <6=> 240 Samples 
S// <7=> 280 Samples 
S
S#ifndef QDEC_CONFIG_REPORTPER
S#define QDEC_CONFIG_REPORTPER 0
S#endif
S
S// <o> QDEC_CONFIG_SAMPLEPER  - Sample period
S 
S// <0=> 128 us 
S// <1=> 256 us 
S// <2=> 512 us 
S// <3=> 1024 us 
S// <4=> 2048 us 
S// <5=> 4096 us 
S// <6=> 8192 us 
S// <7=> 16384 us 
S
S#ifndef QDEC_CONFIG_SAMPLEPER
S#define QDEC_CONFIG_SAMPLEPER 7
S#endif
S
S// <o> QDEC_CONFIG_PIO_A - A pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_A
S#define QDEC_CONFIG_PIO_A 31
S#endif
S
S// <o> QDEC_CONFIG_PIO_B - B pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_B
S#define QDEC_CONFIG_PIO_B 31
S#endif
S
S// <o> QDEC_CONFIG_PIO_LED - LED pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_LED
S#define QDEC_CONFIG_PIO_LED 31
S#endif
S
S// <o> QDEC_CONFIG_LEDPRE - LED pre 
S#ifndef QDEC_CONFIG_LEDPRE
S#define QDEC_CONFIG_LEDPRE 511
S#endif
S
S// <o> QDEC_CONFIG_LEDPOL  - LED polarity
S 
S// <0=> Active low 
S// <1=> Active high 
S
S#ifndef QDEC_CONFIG_LEDPOL
S#define QDEC_CONFIG_LEDPOL 1
S#endif
S
S// <q> QDEC_CONFIG_DBFEN  - Debouncing enable
S 
S
S#ifndef QDEC_CONFIG_DBFEN
S#define QDEC_CONFIG_DBFEN 0
S#endif
S
S// <q> QDEC_CONFIG_SAMPLE_INTEN  - Sample ready interrupt enable
S 
S
S#ifndef QDEC_CONFIG_SAMPLE_INTEN
S#define QDEC_CONFIG_SAMPLE_INTEN 0
S#endif
S
S// <o> QDEC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef QDEC_CONFIG_IRQ_PRIORITY
S#define QDEC_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //QDEC_ENABLED
N// </e>
N
N// <e> RNG_ENABLED - nrf_drv_rng - RNG peripheral driver
N//==========================================================
N#ifndef RNG_ENABLED
N#define RNG_ENABLED 0
N#endif
N#if  RNG_ENABLED
X#if  0
S// <q> RNG_CONFIG_ERROR_CORRECTION  - Error correction
S 
S
S#ifndef RNG_CONFIG_ERROR_CORRECTION
S#define RNG_CONFIG_ERROR_CORRECTION 0
S#endif
S
S// <o> RNG_CONFIG_POOL_SIZE - Pool size 
S#ifndef RNG_CONFIG_POOL_SIZE
S#define RNG_CONFIG_POOL_SIZE 8
S#endif
S
S// <o> RNG_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef RNG_CONFIG_IRQ_PRIORITY
S#define RNG_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //RNG_ENABLED
N// </e>
N
N// <e> RTC_ENABLED - nrf_drv_rtc - RTC peripheral driver
N//==========================================================
N#ifndef RTC_ENABLED
N#define RTC_ENABLED 0
N#endif
N#if  RTC_ENABLED
X#if  0
S// <o> RTC_DEFAULT_CONFIG_FREQUENCY - Frequency  <16-32768> 
S
S
S#ifndef RTC_DEFAULT_CONFIG_FREQUENCY
S#define RTC_DEFAULT_CONFIG_FREQUENCY 32768
S#endif
S
S// <q> RTC_DEFAULT_CONFIG_RELIABLE  - Ensures safe compare event triggering
S 
S
S#ifndef RTC_DEFAULT_CONFIG_RELIABLE
S#define RTC_DEFAULT_CONFIG_RELIABLE 0
S#endif
S
S// <o> RTC_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef RTC_DEFAULT_CONFIG_IRQ_PRIORITY
S#define RTC_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> RTC0_ENABLED  - Enable RTC0 instance
S 
S
S#ifndef RTC0_ENABLED
S#define RTC0_ENABLED 0
S#endif
S
S// <q> RTC1_ENABLED  - Enable RTC1 instance
S 
S
S#ifndef RTC1_ENABLED
S#define RTC1_ENABLED 0
S#endif
S
S// <q> RTC2_ENABLED  - Enable RTC2 instance
S 
S
S#ifndef RTC2_ENABLED
S#define RTC2_ENABLED 0
S#endif
S
S// <o> NRF_MAXIMUM_LATENCY_US - Maximum possible time[us] in highest priority interrupt 
S#ifndef NRF_MAXIMUM_LATENCY_US
S#define NRF_MAXIMUM_LATENCY_US 2000
S#endif
S
N#endif //RTC_ENABLED
N// </e>
N
N// <e> SAADC_ENABLED - nrf_drv_saadc - SAADC peripheral driver
N//==========================================================
N#ifndef SAADC_ENABLED
N#define SAADC_ENABLED 0
N#endif
N#if  SAADC_ENABLED
X#if  0
S// <o> SAADC_CONFIG_RESOLUTION  - Resolution
S 
S// <0=> 8 bit 
S// <1=> 10 bit 
S// <2=> 12 bit 
S// <3=> 14 bit 
S
S#ifndef SAADC_CONFIG_RESOLUTION
S#define SAADC_CONFIG_RESOLUTION 1
S#endif
S
S// <o> SAADC_CONFIG_OVERSAMPLE  - Sample period
S 
S// <0=> Disabled 
S// <1=> 2x 
S// <2=> 4x 
S// <3=> 8x 
S// <4=> 16x 
S// <5=> 32x 
S// <6=> 64x 
S// <7=> 128x 
S// <8=> 256x 
S
S#ifndef SAADC_CONFIG_OVERSAMPLE
S#define SAADC_CONFIG_OVERSAMPLE 0
S#endif
S
S// <q> SAADC_CONFIG_LP_MODE  - Enabling low power mode
S 
S
S#ifndef SAADC_CONFIG_LP_MODE
S#define SAADC_CONFIG_LP_MODE 0
S#endif
S
S// <o> SAADC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef SAADC_CONFIG_IRQ_PRIORITY
S#define SAADC_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //SAADC_ENABLED
N// </e>
N
N// <e> SPIS_ENABLED - nrf_drv_spis - SPI Slave driver
N//==========================================================
N#ifndef SPIS_ENABLED
N#define SPIS_ENABLED 0
N#endif
N#if  SPIS_ENABLED
X#if  0
S// <o> SPIS_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef SPIS_DEFAULT_CONFIG_IRQ_PRIORITY
S#define SPIS_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <o> SPIS_DEFAULT_MODE  - Mode
S 
S// <0=> MODE_0 
S// <1=> MODE_1 
S// <2=> MODE_2 
S// <3=> MODE_3 
S
S#ifndef SPIS_DEFAULT_MODE
S#define SPIS_DEFAULT_MODE 0
S#endif
S
S// <o> SPIS_DEFAULT_BIT_ORDER  - SPIS default bit order
S 
S// <0=> MSB first 
S// <1=> LSB first 
S
S#ifndef SPIS_DEFAULT_BIT_ORDER
S#define SPIS_DEFAULT_BIT_ORDER 0
S#endif
S
S// <o> SPIS_DEFAULT_DEF - SPIS default DEF character  <0-255> 
S
S
S#ifndef SPIS_DEFAULT_DEF
S#define SPIS_DEFAULT_DEF 255
S#endif
S
S// <o> SPIS_DEFAULT_ORC - SPIS default ORC character  <0-255> 
S
S
S#ifndef SPIS_DEFAULT_ORC
S#define SPIS_DEFAULT_ORC 255
S#endif
S
S// <q> SPIS0_ENABLED  - Enable SPIS0 instance
S 
S
S#ifndef SPIS0_ENABLED
S#define SPIS0_ENABLED 0
S#endif
S
S// <q> SPIS1_ENABLED  - Enable SPIS1 instance
S 
S
S#ifndef SPIS1_ENABLED
S#define SPIS1_ENABLED 0
S#endif
S
S// <q> SPIS2_ENABLED  - Enable SPIS2 instance
S 
S
S#ifndef SPIS2_ENABLED
S#define SPIS2_ENABLED 0
S#endif
S
N#endif //SPIS_ENABLED
N// </e>
N
N// <e> SPI_ENABLED - nrf_drv_spi - SPI/SPIM peripheral driver
N//==========================================================
N#ifndef SPI_ENABLED
N#define SPI_ENABLED 1
N#endif
N#if  SPI_ENABLED
X#if  1
N// <e> SPI_CONFIG_LOG_ENABLED - Enables logging in the module.
N//==========================================================
N#ifndef SPI_CONFIG_LOG_ENABLED
N#define SPI_CONFIG_LOG_ENABLED 0
N#endif
N#if  SPI_CONFIG_LOG_ENABLED
X#if  0
S// <o> SPI_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef SPI_CONFIG_LOG_LEVEL
S#define SPI_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> SPI_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SPI_CONFIG_INFO_COLOR
S#define SPI_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> SPI_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SPI_CONFIG_DEBUG_COLOR
S#define SPI_CONFIG_DEBUG_COLOR 0
S#endif
S
N#endif //SPI_CONFIG_LOG_ENABLED
N// </e>
N
N// <o> SPI_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef SPI_DEFAULT_CONFIG_IRQ_PRIORITY
N#define SPI_DEFAULT_CONFIG_IRQ_PRIORITY 6
N#endif
N
N// <e> SPI0_ENABLED - Enable SPI0 instance
N//==========================================================
N#ifndef SPI0_ENABLED
N#define SPI0_ENABLED 1
N#endif
N#if  SPI0_ENABLED
X#if  1
N// <q> SPI0_USE_EASY_DMA  - Use EasyDMA
N 
N
N#ifndef SPI0_USE_EASY_DMA
N#define SPI0_USE_EASY_DMA 0
N#endif
N
N// <o> SPI_SCK_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_SCK_PIN
N#define SPI0_SCK_PIN 25
N#endif
N
N// <o> SPI_MISO_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_MISO_PIN
N#define SPI0_MISO_PIN 26
N#endif
N
N// <o> SPI_MOSI_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_MOSI_PIN
N#define SPI0_MOSI_PIN 23
N#endif
N
N// <o> SPI_SS_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_SS_PIN
N#define SPI0_SS_PIN 24
N#endif
N#endif //SPI0_ENABLED
N// </e>
N
N// <e> SPI1_ENABLED - Enable SPI1 instance
N//==========================================================
N#ifndef SPI1_ENABLED
N#define SPI1_ENABLED 0
N#endif
N#if  SPI1_ENABLED
X#if  0
S// <q> SPI1_USE_EASY_DMA  - Use EasyDMA
S 
S
S#ifndef SPI1_USE_EASY_DMA
S#define SPI1_USE_EASY_DMA 1
S#endif
S
N#endif //SPI1_ENABLED
N// </e>
N
N// <e> SPI2_ENABLED - Enable SPI2 instance
N//==========================================================
N#ifndef SPI2_ENABLED
N#define SPI2_ENABLED 0
N#endif
N#if  SPI2_ENABLED
X#if  0
S// <q> SPI2_USE_EASY_DMA  - Use EasyDMA
S 
S
S#ifndef SPI2_USE_EASY_DMA
S#define SPI2_USE_EASY_DMA 1
S#endif
S
N#endif //SPI2_ENABLED
N// </e>
N
N#endif //SPI_ENABLED
N// </e>
N
N// <e> TIMER_ENABLED - nrf_drv_timer - TIMER periperal driver
N//==========================================================
N#ifndef TIMER_ENABLED
N#define TIMER_ENABLED 0
N#endif
N#if  TIMER_ENABLED
X#if  0
S// <o> TIMER_DEFAULT_CONFIG_FREQUENCY  - Timer frequency if in Timer mode
S 
S// <0=> 16 MHz 
S// <1=> 8 MHz 
S// <2=> 4 MHz 
S// <3=> 2 MHz 
S// <4=> 1 MHz 
S// <5=> 500 kHz 
S// <6=> 250 kHz 
S// <7=> 125 kHz 
S// <8=> 62.5 kHz 
S// <9=> 31.25 kHz 
S
S#ifndef TIMER_DEFAULT_CONFIG_FREQUENCY
S#define TIMER_DEFAULT_CONFIG_FREQUENCY 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_MODE  - Timer mode or operation
S 
S// <0=> Timer 
S// <1=> Counter 
S
S#ifndef TIMER_DEFAULT_CONFIG_MODE
S#define TIMER_DEFAULT_CONFIG_MODE 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_BIT_WIDTH  - Timer counter bit width
S 
S// <0=> 16 bit 
S// <1=> 8 bit 
S// <2=> 24 bit 
S// <3=> 32 bit 
S
S#ifndef TIMER_DEFAULT_CONFIG_BIT_WIDTH
S#define TIMER_DEFAULT_CONFIG_BIT_WIDTH 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef TIMER_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TIMER_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> TIMER0_ENABLED  - Enable TIMER0 instance
S 
S
S#ifndef TIMER0_ENABLED
S#define TIMER0_ENABLED 0
S#endif
S
S// <q> TIMER1_ENABLED  - Enable TIMER1 instance
S 
S
S#ifndef TIMER1_ENABLED
S#define TIMER1_ENABLED 0
S#endif
S
S// <q> TIMER2_ENABLED  - Enable TIMER2 instance
S 
S
S#ifndef TIMER2_ENABLED
S#define TIMER2_ENABLED 0
S#endif
S
S// <q> TIMER3_ENABLED  - Enable TIMER3 instance
S 
S
S#ifndef TIMER3_ENABLED
S#define TIMER3_ENABLED 0
S#endif
S
S// <q> TIMER4_ENABLED  - Enable TIMER4 instance
S 
S
S#ifndef TIMER4_ENABLED
S#define TIMER4_ENABLED 0
S#endif
S
N#endif //TIMER_ENABLED
N// </e>
N
N// <e> TWIS_ENABLED - nrf_drv_twis - TWIS peripheral driver
N//==========================================================
N#ifndef TWIS_ENABLED
N#define TWIS_ENABLED 0
N#endif
N#if  TWIS_ENABLED
X#if  0
S// <o> TWIS_DEFAULT_CONFIG_ADDR0 - Address0 
S#ifndef TWIS_DEFAULT_CONFIG_ADDR0
S#define TWIS_DEFAULT_CONFIG_ADDR0 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_ADDR1 - Address1 
S#ifndef TWIS_DEFAULT_CONFIG_ADDR1
S#define TWIS_DEFAULT_CONFIG_ADDR1 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_SCL_PULL  - SCL pin pull configuration
S 
S// <0=> Disabled 
S// <1=> Pull down 
S// <3=> Pull up 
S
S#ifndef TWIS_DEFAULT_CONFIG_SCL_PULL
S#define TWIS_DEFAULT_CONFIG_SCL_PULL 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_SDA_PULL  - SDA pin pull configuration
S 
S// <0=> Disabled 
S// <1=> Pull down 
S// <3=> Pull up 
S
S#ifndef TWIS_DEFAULT_CONFIG_SDA_PULL
S#define TWIS_DEFAULT_CONFIG_SDA_PULL 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef TWIS_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TWIS_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> TWIS0_ENABLED  - Enable TWIS0 instance
S 
S
S#ifndef TWIS0_ENABLED
S#define TWIS0_ENABLED 0
S#endif
S
S// <q> TWIS1_ENABLED  - Enable TWIS1 instance
S 
S
S#ifndef TWIS1_ENABLED
S#define TWIS1_ENABLED 0
S#endif
S
S// <q> TWIS_ASSUME_INIT_AFTER_RESET_ONLY  - Assume that any instance would be initialized only once
S 
S
S// <i> Optimization flag. Registers used by TWIS are shared by other peripherals. Normally, during initialization driver tries to clear all registers to known state before doing the initialization itself. This gives initialization safe procedure, no matter when it would be called. If you activate TWIS only once and do never uninitialize it - set this flag to 1 what gives more optimal code.
S
S#ifndef TWIS_ASSUME_INIT_AFTER_RESET_ONLY
S#define TWIS_ASSUME_INIT_AFTER_RESET_ONLY 0
S#endif
S
S// <q> TWIS_NO_SYNC_MODE  - Remove support for synchronous mode
S 
S
S// <i> Synchronous mode would be used in specific situations. And it uses some additional code and data memory to safely process state machine by polling it in status functions. If this functionality is not required it may be disabled to free some resources.
S
S#ifndef TWIS_NO_SYNC_MODE
S#define TWIS_NO_SYNC_MODE 0
S#endif
S
N#endif //TWIS_ENABLED
N// </e>
N
N// <e> TWI_ENABLED - nrf_drv_twi - TWI/TWIM peripheral driver
N//==========================================================
N#ifndef TWI_ENABLED
N#define TWI_ENABLED 0
N#endif
N#if  TWI_ENABLED
X#if  0
S// <o> TWI_DEFAULT_CONFIG_FREQUENCY  - Frequency
S 
S// <26738688=> 100k 
S// <67108864=> 250k 
S// <104857600=> 400k 
S
S#ifndef TWI_DEFAULT_CONFIG_FREQUENCY
S#define TWI_DEFAULT_CONFIG_FREQUENCY 26738688
S#endif
S
S// <q> TWI_DEFAULT_CONFIG_CLR_BUS_INIT  - Enables bus clearing procedure during init
S 
S
S#ifndef TWI_DEFAULT_CONFIG_CLR_BUS_INIT
S#define TWI_DEFAULT_CONFIG_CLR_BUS_INIT 0
S#endif
S
S// <q> TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT  - Enables bus holding after uninit
S 
S
S#ifndef TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT
S#define TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT 0
S#endif
S
S// <o> TWI_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef TWI_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TWI_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <e> TWI0_ENABLED - Enable TWI0 instance
S//==========================================================
S#ifndef TWI0_ENABLED
S#define TWI0_ENABLED 0
S#endif
S#if  TWI0_ENABLED
S// <q> TWI0_USE_EASY_DMA  - Use EasyDMA (if present)
S 
S
S#ifndef TWI0_USE_EASY_DMA
S#define TWI0_USE_EASY_DMA 0
S#endif
S
S#endif //TWI0_ENABLED
S// </e>
S
S// <e> TWI1_ENABLED - Enable TWI1 instance
S//==========================================================
S#ifndef TWI1_ENABLED
S#define TWI1_ENABLED 0
S#endif
S#if  TWI1_ENABLED
S// <q> TWI1_USE_EASY_DMA  - Use EasyDMA (if present)
S 
S
S#ifndef TWI1_USE_EASY_DMA
S#define TWI1_USE_EASY_DMA 0
S#endif
S
S#endif //TWI1_ENABLED
S// </e>
S
N#endif //TWI_ENABLED
N// </e>
N
N// <e> UART_ENABLED - nrf_drv_uart - UART/UARTE peripheral driver
N//==========================================================
N#ifndef UART_ENABLED
N#define UART_ENABLED 1
N#endif
N#if  UART_ENABLED
X#if  1
N// <o> UART_DEFAULT_CONFIG_HWFC  - Hardware Flow Control
N 
N// <0=> Disabled 
N// <1=> Enabled 
N
N#ifndef UART_DEFAULT_CONFIG_HWFC
N#define UART_DEFAULT_CONFIG_HWFC 0
N#endif
N
N// <o> UART_DEFAULT_CONFIG_PARITY  - Parity
N 
N// <0=> Excluded 
N// <14=> Included 
N
N#ifndef UART_DEFAULT_CONFIG_PARITY
N#define UART_DEFAULT_CONFIG_PARITY 0
N#endif
N
N// <o> UART_DEFAULT_CONFIG_BAUDRATE  - Default Baudrate
N 
N// <323584=> 1200 baud 
N// <643072=> 2400 baud 
N// <1290240=> 4800 baud 
N// <2576384=> 9600 baud 
N// <3862528=> 14400 baud 
N// <5152768=> 19200 baud 
N// <7716864=> 28800 baud 
N// <10289152=> 38400 baud 
N// <15400960=> 57600 baud 
N// <20615168=> 76800 baud 
N// <30801920=> 115200 baud 
N// <61865984=> 230400 baud 
N// <67108864=> 250000 baud 
N// <121634816=> 460800 baud 
N// <251658240=> 921600 baud 
N// <268435456=> 57600 baud 
N
N#ifndef UART_DEFAULT_CONFIG_BAUDRATE
N#define UART_DEFAULT_CONFIG_BAUDRATE 30801920
N#endif
N
N// <o> UART_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef UART_DEFAULT_CONFIG_IRQ_PRIORITY
N#define UART_DEFAULT_CONFIG_IRQ_PRIORITY 6
N#endif
N
N// <q> UART0_CONFIG_USE_EASY_DMA  - Default setting for using EasyDMA
N 
N
N#ifndef UART0_CONFIG_USE_EASY_DMA
N#define UART0_CONFIG_USE_EASY_DMA 1
N#endif
N
N// <q> UART_EASY_DMA_SUPPORT  - Driver supporting EasyDMA
N 
N
N#ifndef UART_EASY_DMA_SUPPORT
N#define UART_EASY_DMA_SUPPORT 1
N#endif
N
N// <q> UART_LEGACY_SUPPORT  - Driver supporting Legacy mode
N 
N
N#ifndef UART_LEGACY_SUPPORT
N#define UART_LEGACY_SUPPORT 1
N#endif
N
N#endif //UART_ENABLED
N// </e>
N
N// <e> WDT_ENABLED - nrf_drv_wdt - WDT peripheral driver
N//==========================================================
N#ifndef WDT_ENABLED
N#define WDT_ENABLED 0
N#endif
N#if  WDT_ENABLED
X#if  0
S// <o> WDT_CONFIG_BEHAVIOUR  - WDT behavior in CPU SLEEP or HALT mode
S 
S// <1=> Run in SLEEP, Pause in HALT 
S// <8=> Pause in SLEEP, Run in HALT 
S// <9=> Run in SLEEP and HALT 
S// <0=> Pause in SLEEP and HALT 
S
S#ifndef WDT_CONFIG_BEHAVIOUR
S#define WDT_CONFIG_BEHAVIOUR 1
S#endif
S
S// <o> WDT_CONFIG_RELOAD_VALUE - Reload value  <15-4294967295> 
S
S
S#ifndef WDT_CONFIG_RELOAD_VALUE
S#define WDT_CONFIG_RELOAD_VALUE 2000
S#endif
S
S// <o> WDT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef WDT_CONFIG_IRQ_PRIORITY
S#define WDT_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //WDT_ENABLED
N// </e>
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Libraries 
N
N//==========================================================
N// <q> APP_FIFO_ENABLED  - app_fifo - Software FIFO implementation
N 
N 
N#define APPL_LOG app_trace_log  
N
N#ifndef APP_FIFO_ENABLED
N#define APP_FIFO_ENABLED 1
N#endif
N
N// <q> APP_MAILBOX_ENABLED  - app_mailbox - Thread safe mailbox
N 
N
N#ifndef APP_MAILBOX_ENABLED
N#define APP_MAILBOX_ENABLED 0
N#endif
N
N// <q> APP_PWM_ENABLED  - app_pwm - PWM functionality
N 
N
N#ifndef APP_PWM_ENABLED
N#define APP_PWM_ENABLED 0
N#endif
N
N// <e> APP_SCHEDULER_ENABLED - app_scheduler - Events scheduler
N//==========================================================
N#ifndef APP_SCHEDULER_ENABLED
N#define APP_SCHEDULER_ENABLED 0
N#endif
N#if  APP_SCHEDULER_ENABLED
X#if  0
S// <q> APP_SCHEDULER_WITH_PAUSE  - Enabling pause feature
S 
S
S#ifndef APP_SCHEDULER_WITH_PAUSE
S#define APP_SCHEDULER_WITH_PAUSE 0
S#endif
S
S// <q> APP_SCHEDULER_WITH_PROFILER  - Enabling scheduler profiling
S 
S
S#ifndef APP_SCHEDULER_WITH_PROFILER
S#define APP_SCHEDULER_WITH_PROFILER 0
S#endif
S
N#endif //APP_SCHEDULER_ENABLED
N// </e>
N
N// <e> APP_TIMER_ENABLED - app_timer - Application timer functionality
N//==========================================================
N#ifndef APP_TIMER_ENABLED
N#define APP_TIMER_ENABLED 1
N#endif
N#if  APP_TIMER_ENABLED
X#if  1
N// <q> APP_TIMER_WITH_PROFILER  - Enable app_timer profiling
N 
N
N#ifndef APP_TIMER_WITH_PROFILER
N#define APP_TIMER_WITH_PROFILER 0
N#endif
N
N// <q> APP_TIMER_KEEPS_RTC_ACTIVE  - Enable RTC always on
N 
N
N// <i> If option is enabled RTC is kept running even if there is no active timers.
N// <i> This option can be used when app_timer is used for timestamping.
N
N#ifndef APP_TIMER_KEEPS_RTC_ACTIVE
N#define APP_TIMER_KEEPS_RTC_ACTIVE 0
N#endif
N
N#endif //APP_TIMER_ENABLED
N// </e>
N
N// <q> APP_TWI_ENABLED  - app_twi - TWI transaction manager
N 
N
N#ifndef APP_TWI_ENABLED
N#define APP_TWI_ENABLED 0
N#endif
N
N// <e> APP_UART_ENABLED - app_uart - UART driver
N//==========================================================
N#ifndef APP_UART_ENABLED
N#define APP_UART_ENABLED 0
N#endif
N#if  APP_UART_ENABLED
X#if  0
S// <o> APP_UART_DRIVER_INSTANCE  - UART instance used
S 
S// <0=> 0 
S
S#ifndef APP_UART_DRIVER_INSTANCE
S#define APP_UART_DRIVER_INSTANCE 0
S#endif
S
N#endif //APP_UART_ENABLED
N// </e>
N
N// <q> BUTTON_ENABLED  - app_button - buttons handling module
N 
N
N#ifndef BUTTON_ENABLED
N#define BUTTON_ENABLED 1
N#endif
N
N// <q> CRC16_ENABLED  - crc16 - CRC16 calculation routines
N 
N
N#ifndef CRC16_ENABLED
N#define CRC16_ENABLED 1
N#endif
N
N// <q> CRC32_ENABLED  - crc32 - CRC32 calculation routines
N 
N
N#ifndef CRC32_ENABLED
N#define CRC32_ENABLED 0
N#endif
N
N// <q> ECC_ENABLED  - ecc - Elliptic Curve Cryptography Library
N 
N
N#ifndef ECC_ENABLED
N#define ECC_ENABLED 0
N#endif
N
N// <e> FDS_ENABLED - fds - Flash data storage module
N//==========================================================
N#ifndef FDS_ENABLED
N#define FDS_ENABLED 1
N#endif
N#if  FDS_ENABLED
X#if  1
N// <o> FDS_OP_QUEUE_SIZE - Size of the internal queue. 
N#ifndef FDS_OP_QUEUE_SIZE
N#define FDS_OP_QUEUE_SIZE 4
N#endif
N
N// <o> FDS_CHUNK_QUEUE_SIZE - Determines how many @ref fds_record_chunk_t structures can be buffered at any time. 
N#ifndef FDS_CHUNK_QUEUE_SIZE
N#define FDS_CHUNK_QUEUE_SIZE 8
N#endif
N
N// <o> FDS_MAX_USERS - Maximum number of callbacks that can be registered. 
N#ifndef FDS_MAX_USERS
N#define FDS_MAX_USERS 8
N#endif
N
N// <o> FDS_VIRTUAL_PAGES - Number of virtual flash pages to use. 
N// <i> One of the virtual pages is reserved by the system for garbage collection.
N// <i> Therefore, the minimum is two virtual pages: one page to store data and
N// <i> one page to be used by the system for garbage collection. The total amount
N// <i> of flash memory that is used by FDS amounts to @ref FDS_VIRTUAL_PAGES
N// <i> @ref FDS_VIRTUAL_PAGE_SIZE * 4 bytes.
N
N#ifndef FDS_VIRTUAL_PAGES
N#define FDS_VIRTUAL_PAGES 3
N#endif
N
N// <o> FDS_VIRTUAL_PAGE_SIZE  - The size of a virtual page of flash memory, expressed in number of 4-byte words.
N 
N
N// <i> By default, a virtual page is the same size as a physical page.
N// <i> The size of a virtual page must be a multiple of the size of a physical page.
N// <1024=> 1024 
N// <2048=> 2048 
N
N#ifndef FDS_VIRTUAL_PAGE_SIZE
N#define FDS_VIRTUAL_PAGE_SIZE 1024
N#endif
N
N#endif //FDS_ENABLED
N// </e>
N
N// <e> FSTORAGE_ENABLED - fstorage - Flash storage module
N//==========================================================
N#ifndef FSTORAGE_ENABLED
N#define FSTORAGE_ENABLED 1
N#endif
N#if  FSTORAGE_ENABLED
X#if  1
N// <o> FS_QUEUE_SIZE - Configures the size of the internal queue. 
N// <i> Increase this if there are many users, or if it is likely that many
N// <i> operation will be queued at once without waiting for the previous operations
N// <i> to complete. In general, increase the queue size if you frequently receive
N// <i> @ref FS_ERR_QUEUE_FULL errors when calling @ref fs_store or @ref fs_erase.
N
N#ifndef FS_QUEUE_SIZE
N#define FS_QUEUE_SIZE 4
N#endif
N
N// <o> FS_OP_MAX_RETRIES - Number attempts to execute an operation if the SoftDevice fails. 
N// <i> Increase this value if events return the @ref FS_ERR_OPERATION_TIMEOUT
N// <i> error often. The SoftDevice may fail to schedule flash access due to high BLE activity.
N
N#ifndef FS_OP_MAX_RETRIES
N#define FS_OP_MAX_RETRIES 3
N#endif
N
N// <o> FS_MAX_WRITE_SIZE_WORDS - Maximum number of words to be written to flash in a single operation. 
N// <i> Tweaking this value can increase the chances of the SoftDevice being
N// <i> able to fit flash operations in between radio activity. This value is bound by the
N// <i> maximum number of words which the SoftDevice can write to flash in a single call to
N// <i> @ref sd_flash_write, which is 256 words for nRF51 ICs and 1024 words for nRF52 ICs.
N
N#ifndef FS_MAX_WRITE_SIZE_WORDS
N#define FS_MAX_WRITE_SIZE_WORDS 1024
N#endif
N
N#endif //FSTORAGE_ENABLED
N// </e>
N
N// <q> HARDFAULT_HANDLER_ENABLED  - hardfault_default - HardFault default handler for debugging and release
N 
N
N#ifndef HARDFAULT_HANDLER_ENABLED
N#define HARDFAULT_HANDLER_ENABLED 0
N#endif
N
N// <e> HCI_MEM_POOL_ENABLED - hci_mem_pool - memory pool implementation used by HCI
N//==========================================================
N#ifndef HCI_MEM_POOL_ENABLED
N#define HCI_MEM_POOL_ENABLED 0
N#endif
N#if  HCI_MEM_POOL_ENABLED
X#if  0
S// <o> HCI_TX_BUF_SIZE - TX buffer size in bytes. 
S#ifndef HCI_TX_BUF_SIZE
S#define HCI_TX_BUF_SIZE 600
S#endif
S
S// <o> HCI_RX_BUF_SIZE - RX buffer size in bytes. 
S#ifndef HCI_RX_BUF_SIZE
S#define HCI_RX_BUF_SIZE 600
S#endif
S
S// <o> HCI_RX_BUF_QUEUE_SIZE - RX buffer queue size. 
S#ifndef HCI_RX_BUF_QUEUE_SIZE
S#define HCI_RX_BUF_QUEUE_SIZE 4
S#endif
S
N#endif //HCI_MEM_POOL_ENABLED
N// </e>
N
N// <e> HCI_SLIP_ENABLED - hci_slip - SLIP protocol implementation used by HCI
N//==========================================================
N#ifndef HCI_SLIP_ENABLED
N#define HCI_SLIP_ENABLED 0
N#endif
N#if  HCI_SLIP_ENABLED
X#if  0
S// <o> HCI_UART_BAUDRATE  - Default Baudrate
S 
S// <323584=> 1200 baud 
S// <643072=> 2400 baud 
S// <1290240=> 4800 baud 
S// <2576384=> 9600 baud 
S// <3862528=> 14400 baud 
S// <5152768=> 19200 baud 
S// <7716864=> 28800 baud 
S// <10289152=> 38400 baud 
S// <15400960=> 57600 baud 
S// <20615168=> 76800 baud 
S// <30801920=> 115200 baud 
S// <61865984=> 230400 baud 
S// <67108864=> 250000 baud 
S// <121634816=> 460800 baud 
S// <251658240=> 921600 baud 
S// <268435456=> 57600 baud 
S
S#ifndef HCI_UART_BAUDRATE
S#define HCI_UART_BAUDRATE 30801920
S#endif
S
S// <o> HCI_UART_FLOW_CONTROL  - Hardware Flow Control
S 
S// <0=> Disabled 
S// <1=> Enabled 
S
S#ifndef HCI_UART_FLOW_CONTROL
S#define HCI_UART_FLOW_CONTROL 0
S#endif
S
S// <o> HCI_UART_RX_PIN - UART RX pin 
S#ifndef HCI_UART_RX_PIN
S#define HCI_UART_RX_PIN 8
S#endif
S
S// <o> HCI_UART_TX_PIN - UART TX pin 
S#ifndef HCI_UART_TX_PIN
S#define HCI_UART_TX_PIN 6
S#endif
S
S// <o> HCI_UART_RTS_PIN - UART RTS pin 
S#ifndef HCI_UART_RTS_PIN
S#define HCI_UART_RTS_PIN 5
S#endif
S
S// <o> HCI_UART_CTS_PIN - UART CTS pin 
S#ifndef HCI_UART_CTS_PIN
S#define HCI_UART_CTS_PIN 7
S#endif
S
N#endif //HCI_SLIP_ENABLED
N// </e>
N
N// <e> HCI_TRANSPORT_ENABLED - hci_transport - HCI transport
N//==========================================================
N#ifndef HCI_TRANSPORT_ENABLED
N#define HCI_TRANSPORT_ENABLED 0
N#endif
N#if  HCI_TRANSPORT_ENABLED
X#if  0
S// <o> HCI_MAX_PACKET_SIZE_IN_BITS - Maximum size of a single application packet in bits. 
S#ifndef HCI_MAX_PACKET_SIZE_IN_BITS
S#define HCI_MAX_PACKET_SIZE_IN_BITS 8000
S#endif
S
N#endif //HCI_TRANSPORT_ENABLED
N// </e>
N
N// <q> LED_SOFTBLINK_ENABLED  - led_softblink - led_softblink module
N 
N
N#ifndef LED_SOFTBLINK_ENABLED
N#define LED_SOFTBLINK_ENABLED 0
N#endif
N
N// <q> LOW_POWER_PWM_ENABLED  - low_power_pwm - low_power_pwm module
N 
N
N#ifndef LOW_POWER_PWM_ENABLED
N#define LOW_POWER_PWM_ENABLED 0
N#endif
N
N// <e> MEM_MANAGER_ENABLED - mem_manager - Dynamic memory allocator
N//==========================================================
N#ifndef MEM_MANAGER_ENABLED
N#define MEM_MANAGER_ENABLED 0
N#endif
N#if  MEM_MANAGER_ENABLED
X#if  0
S// <o> MEMORY_MANAGER_SMALL_BLOCK_COUNT - Size of each memory blocks identified as 'small' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_SMALL_BLOCK_COUNT
S#define MEMORY_MANAGER_SMALL_BLOCK_COUNT 1
S#endif
S
S// <o> MEMORY_MANAGER_SMALL_BLOCK_SIZE -  Size of each memory blocks identified as 'small' block. 
S// <i>  Size of each memory blocks identified as 'small' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_SMALL_BLOCK_SIZE
S#define MEMORY_MANAGER_SMALL_BLOCK_SIZE 32
S#endif
S
S// <o> MEMORY_MANAGER_MEDIUM_BLOCK_COUNT - Size of each memory blocks identified as 'medium' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_MEDIUM_BLOCK_COUNT
S#define MEMORY_MANAGER_MEDIUM_BLOCK_COUNT 0
S#endif
S
S// <o> MEMORY_MANAGER_MEDIUM_BLOCK_SIZE -  Size of each memory blocks identified as 'medium' block. 
S// <i>  Size of each memory blocks identified as 'medium' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_MEDIUM_BLOCK_SIZE
S#define MEMORY_MANAGER_MEDIUM_BLOCK_SIZE 256
S#endif
S
S// <o> MEMORY_MANAGER_LARGE_BLOCK_COUNT - Size of each memory blocks identified as 'large' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_LARGE_BLOCK_COUNT
S#define MEMORY_MANAGER_LARGE_BLOCK_COUNT 0
S#endif
S
S// <o> MEMORY_MANAGER_LARGE_BLOCK_SIZE -  Size of each memory blocks identified as 'large' block. 
S// <i>  Size of each memory blocks identified as 'large' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_LARGE_BLOCK_SIZE
S#define MEMORY_MANAGER_LARGE_BLOCK_SIZE 256
S#endif
S
S// <q> MEM_MANAGER_ENABLE_LOGS  - Enable debug trace in the module.
S 
S
S#ifndef MEM_MANAGER_ENABLE_LOGS
S#define MEM_MANAGER_ENABLE_LOGS 0
S#endif
S
S// <q> MEM_MANAGER_DISABLE_API_PARAM_CHECK  - Disable API parameter checks in the module.
S 
S
S#ifndef MEM_MANAGER_DISABLE_API_PARAM_CHECK
S#define MEM_MANAGER_DISABLE_API_PARAM_CHECK 0
S#endif
S
N#endif //MEM_MANAGER_ENABLED
N// </e>
N
N// <e> NRF_CSENSE_ENABLED - nrf_csense - nrf_csense module
N//==========================================================
N#ifndef NRF_CSENSE_ENABLED
N#define NRF_CSENSE_ENABLED 0
N#endif
N#if  NRF_CSENSE_ENABLED
X#if  0
S// <o> NRF_CSENSE_PAD_HYSTERESIS - Minimal value of change to decide that pad was touched. 
S#ifndef NRF_CSENSE_PAD_HYSTERESIS
S#define NRF_CSENSE_PAD_HYSTERESIS 15
S#endif
S
S// <o> NRF_CSENSE_PAD_DEVIATION - Minimal value measured on pad to take its value while calculating step. 
S#ifndef NRF_CSENSE_PAD_DEVIATION
S#define NRF_CSENSE_PAD_DEVIATION 70
S#endif
S
S// <o> NRF_CSENSE_MIN_PAD_VALUE - Minimum normalized value on pad to take its value into account. 
S#ifndef NRF_CSENSE_MIN_PAD_VALUE
S#define NRF_CSENSE_MIN_PAD_VALUE 20
S#endif
S
S// <o> NRF_CSENSE_MAX_PADS_NUMBER - Maximum number of pads used for one instance. 
S#ifndef NRF_CSENSE_MAX_PADS_NUMBER
S#define NRF_CSENSE_MAX_PADS_NUMBER 20
S#endif
S
S// <o> NRF_CSENSE_MAX_VALUE - Maximum normalized value got from measurement. 
S#ifndef NRF_CSENSE_MAX_VALUE
S#define NRF_CSENSE_MAX_VALUE 1000
S#endif
S
S// <o> NRF_CSENSE_OUTPUT_PIN - Output pin used by lower module. 
S// <i> This is only used when running on NRF51.
S
S#ifndef NRF_CSENSE_OUTPUT_PIN
S#define NRF_CSENSE_OUTPUT_PIN 30
S#endif
S
N#endif //NRF_CSENSE_ENABLED
N// </e>
N
N// <e> NRF_DRV_CSENSE_ENABLED - nrf_drv_csense - Capacitive sensor module
N//==========================================================
N#ifndef NRF_DRV_CSENSE_ENABLED
N#define NRF_DRV_CSENSE_ENABLED 0
N#endif
N#if  NRF_DRV_CSENSE_ENABLED
X#if  0
S// <o> TIMER0_FOR_CSENSE - First TIMER instance used by the driver (except nRF51) 
S#ifndef TIMER0_FOR_CSENSE
S#define TIMER0_FOR_CSENSE 1
S#endif
S
S// <o> TIMER1_FOR_CSENSE - Second TIMER instance used by the driver (except nRF51) 
S#ifndef TIMER1_FOR_CSENSE
S#define TIMER1_FOR_CSENSE 2
S#endif
S
S// <o> MEASUREMENT_PERIOD - Single measurement period. 
S// <i> Time of single measurement can be calculated as T = (1/2)*MEASUREMENT_PERIOD*(1/f_OSC) where f_OSC = I_SOURCE / (2C*(VUP-VDOWN) ). I_SOURCE, VUP and VDOWN are values used to initialize COMP and C is capacitance of used pad.
S
S#ifndef MEASUREMENT_PERIOD
S#define MEASUREMENT_PERIOD 20
S#endif
S
N#endif //NRF_DRV_CSENSE_ENABLED
N// </e>
N
N// <q> SLIP_ENABLED  - slip - SLIP encoding decoding
N 
N
N#ifndef SLIP_ENABLED
N#define SLIP_ENABLED 0
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Log 
N
N//==========================================================
N// <e> NRF_LOG_ENABLED - nrf_log - Logging
N//==========================================================
N#ifndef NRF_LOG_ENABLED
N#define NRF_LOG_ENABLED 0
N#endif
N#if  NRF_LOG_ENABLED
X#if  0
S// <e> NRF_LOG_USES_COLORS - If enabled then ANSI escape code for colors is prefixed to every string
S//==========================================================
S#ifndef NRF_LOG_USES_COLORS
S#define NRF_LOG_USES_COLORS 0
S#endif
S#if  NRF_LOG_USES_COLORS
S// <o> NRF_LOG_COLOR_DEFAULT  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef NRF_LOG_COLOR_DEFAULT
S#define NRF_LOG_COLOR_DEFAULT 0
S#endif
S
S// <o> NRF_LOG_ERROR_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef NRF_LOG_ERROR_COLOR
S#define NRF_LOG_ERROR_COLOR 0
S#endif
S
S// <o> NRF_LOG_WARNING_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef NRF_LOG_WARNING_COLOR
S#define NRF_LOG_WARNING_COLOR 0
S#endif
S
S#endif //NRF_LOG_USES_COLORS
S// </e>
S
S// <o> NRF_LOG_DEFAULT_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef NRF_LOG_DEFAULT_LEVEL
S#define NRF_LOG_DEFAULT_LEVEL 3
S#endif
S
S// <e> NRF_LOG_DEFERRED - Enable deffered logger.
S
S// <i> Log data is buffered and can be processed in idle.
S//==========================================================
S#ifndef NRF_LOG_DEFERRED
S#define NRF_LOG_DEFERRED 1
S#endif
S#if  NRF_LOG_DEFERRED
S// <o> NRF_LOG_DEFERRED_BUFSIZE - Size of the buffer for logs in words. 
S// <i> Must be power of 2
S
S#ifndef NRF_LOG_DEFERRED_BUFSIZE
S#define NRF_LOG_DEFERRED_BUFSIZE 256
S#endif
S
S#endif //NRF_LOG_DEFERRED
S// </e>
S
S// <q> NRF_LOG_USES_TIMESTAMP  - Enable timestamping
S 
S
S// <i> Function for getting the timestamp is provided by the user
S
S#ifndef NRF_LOG_USES_TIMESTAMP
S#define NRF_LOG_USES_TIMESTAMP 0
S#endif
S
N#endif //NRF_LOG_ENABLED
N// </e>
N
N// <h> nrf_log_backend - Logging sink
N
N//==========================================================
N// <o> NRF_LOG_BACKEND_MAX_STRING_LENGTH - Buffer for storing single output string 
N// <i> Logger backend RAM usage is determined by this value.
N
N#ifndef NRF_LOG_BACKEND_MAX_STRING_LENGTH
N#define NRF_LOG_BACKEND_MAX_STRING_LENGTH 256
N#endif
N
N// <o> NRF_LOG_TIMESTAMP_DIGITS - Number of digits for timestamp 
N// <i> If higher resolution timestamp source is used it might be needed to increase that
N
N#ifndef NRF_LOG_TIMESTAMP_DIGITS
N#define NRF_LOG_TIMESTAMP_DIGITS 8
N#endif
N
N// <e> NRF_LOG_BACKEND_SERIAL_USES_UART - If enabled data is printed over UART
N//==========================================================
N#ifndef NRF_LOG_BACKEND_SERIAL_USES_UART
N#define NRF_LOG_BACKEND_SERIAL_USES_UART 1
N#endif
N#if  NRF_LOG_BACKEND_SERIAL_USES_UART
X#if  1
N// <o> NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE  - Default Baudrate
N 
N// <323584=> 1200 baud 
N// <643072=> 2400 baud 
N// <1290240=> 4800 baud 
N// <2576384=> 9600 baud 
N// <3862528=> 14400 baud 
N// <5152768=> 19200 baud 
N// <7716864=> 28800 baud 
N// <10289152=> 38400 baud 
N// <15400960=> 57600 baud 
N// <20615168=> 76800 baud 
N// <30801920=> 115200 baud 
N// <61865984=> 230400 baud 
N// <67108864=> 250000 baud 
N// <121634816=> 460800 baud 
N// <251658240=> 921600 baud 
N// <268435456=> 57600 baud 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE
N#define NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE 30801920
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_TX_PIN - UART TX pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_TX_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_TX_PIN 6
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_RX_PIN - UART RX pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_RX_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_RX_PIN 8
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN - UART RTS pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN 5
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN - UART CTS pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN 7
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL  - Hardware Flow Control
N 
N// <0=> Disabled 
N// <1=> Enabled 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL
N#define NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL 0
N#endif
N
N// <o> NRF_LOG_BACKEND_UART_INSTANCE  - UART instance used
N 
N// <0=> 0 
N
N#ifndef NRF_LOG_BACKEND_UART_INSTANCE
N#define NRF_LOG_BACKEND_UART_INSTANCE 0
N#endif
N
N#endif //NRF_LOG_BACKEND_SERIAL_USES_UART
N// </e>
N
N// <q> NRF_LOG_BACKEND_SERIAL_USES_RTT  - If enabled data is printed using RTT
N 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_USES_RTT
N#define NRF_LOG_BACKEND_SERIAL_USES_RTT 0
N#endif
N
N// </h> 
N//==========================================================
N
N// </h> 
N//==========================================================
N
N// <<< end of configuration section >>>
N#endif //SDK_CONFIG_H
N
L 13 "..\..\..\..\..\..\components\libraries\log\src\nrf_log_backend_serial.c" 2
N#if NRF_LOG_ENABLED
X#if 0
S#include "nrf_log_backend.h"
S#include "nrf_error.h"
S#include "nordic_common.h"
S#include <stdarg.h>
S#include <string.h>
S#include <stdio.h>
S
S#if NRF_LOG_BACKEND_SERIAL_USES_RTT
S#include <SEGGER_RTT_Conf.h>
S#include <SEGGER_RTT.h>
S#endif
S
S#if NRF_LOG_BACKEND_SERIAL_USES_UART
S#include "nrf_drv_uart.h"
S#endif
S
S#if NRF_LOG_BACKEND_SERIAL_USES_RTT
Sstatic char m_rtt_buffer[NRF_LOG_BACKEND_MAX_STRING_LENGTH];
S#endif
S
S#if NRF_LOG_BACKEND_SERIAL_USES_UART
Sstatic char m_uart_buffer[NRF_LOG_BACKEND_MAX_STRING_LENGTH];
Sstatic nrf_drv_uart_t m_uart = NRF_DRV_UART_INSTANCE(NRF_LOG_BACKEND_UART_INSTANCE);
S
S#if (UART_ENABLED == 0)
S#error "UART driver must be enabled to use UART in nrf_log."
S#endif
S
S#endif //NRF_LOG_BACKEND_SERIAL_USES_UART
S
S#define HEXDUMP_BYTES_PER_LINE               16
S#define HEXDUMP_HEXBYTE_AREA                 3 // Two bytes for hexbyte and space to separate
S#define TIMESTAMP_STR(val) "[%0" NUM_TO_STR(val) "d]"
S
S#define RTT_RETRY_COUNTER 10 //Number of retries before skipping processing
S
S#define HEXDUMP_MAX_STR_LEN (NRF_LOG_BACKEND_MAX_STRING_LENGTH -          \
S                            (HEXDUMP_HEXBYTE_AREA*HEXDUMP_BYTES_PER_LINE +\
S                             NRF_LOG_TIMESTAMP_DIGITS +                   \
S                             4 +/* Color ANSI Escape Code */              \
S                             2)) /* Separators */
X#define HEXDUMP_MAX_STR_LEN (NRF_LOG_BACKEND_MAX_STRING_LENGTH -                                      (HEXDUMP_HEXBYTE_AREA*HEXDUMP_BYTES_PER_LINE +                             NRF_LOG_TIMESTAMP_DIGITS +                                                4 +                                            2))  
S
Sstatic bool m_initialized   = false;
Sstatic bool m_blocking_mode = false;
S
S#if (NRF_LOG_BACKEND_SERIAL_USES_UART)
Sstatic volatile bool m_rx_done = false;
S#endif
S
S#if (NRF_LOG_BACKEND_SERIAL_USES_UART)
Sstatic void uart_event_handler(nrf_drv_uart_event_t * p_event, void * p_context)
S{
S    // Dummy handler since is_busy feature is used for determining readiness.
S    if (p_event->type == NRF_DRV_UART_EVT_RX_DONE)
S    {
S        m_rx_done = true;
S    }
S}
S#endif //NRF_LOG_BACKEND_SERIAL_USES_UART
S
S
Sret_code_t nrf_log_backend_init(bool blocking)
S{
S    uint32_t              ret_code;
S
S    if (m_initialized && (blocking == m_blocking_mode))
S    {
S        return NRF_SUCCESS;
S    }
S
S#if NRF_LOG_BACKEND_SERIAL_USES_RTT
S    ret_code = SEGGER_RTT_ConfigUpBuffer(
S        0,
S        "Normal",
S        m_rtt_buffer,
S        NRF_LOG_BACKEND_MAX_STRING_LENGTH,
S        SEGGER_RTT_MODE_NO_BLOCK_TRIM);
S    if ( ret_code != 0)
S    {
S        return NRF_ERROR_INVALID_STATE;
S    }
S#endif //NRF_LOG_BACKEND_SERIAL_USES_RTT
S
S#if (NRF_LOG_BACKEND_SERIAL_USES_UART)
S    nrf_drv_uart_config_t uart_config = NRF_DRV_UART_DEFAULT_CONFIG;
S    uart_config.hwfc     =
S            (nrf_uart_hwfc_t)NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL;
S    uart_config.pseltxd  = NRF_LOG_BACKEND_SERIAL_UART_TX_PIN;
S    uart_config.pselrxd  = NRF_LOG_BACKEND_SERIAL_UART_RX_PIN;
S    uart_config.pselrts  = NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN;
S    uart_config.pselcts  = NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN;
S    uart_config.baudrate =
S        (nrf_uart_baudrate_t)NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE;
S    nrf_drv_uart_uninit(&m_uart);
S    ret_code = nrf_drv_uart_init(&m_uart, &uart_config,
S                                 blocking ? NULL : uart_event_handler);
S    if (ret_code != NRF_SUCCESS)
S    {
S        return ret_code;
S    }
S#endif //NRF_LOG_BACKEND_SERIAL_USES_UART
S
S    m_initialized   = true;
S    m_blocking_mode = blocking;
S    return NRF_SUCCESS;
S}
S
S
Sstatic bool serial_is_busy(void)
S{
S    bool res = false;
S
S#if (NRF_LOG_BACKEND_SERIAL_USES_UART)
S    res = nrf_drv_uart_tx_in_progress(&m_uart);
S#endif
S
S#if (NRF_LOG_BACKEND_SERIAL_USES_RTT)
S
S#endif
S
S    return res;
S}
S
S
Sstatic bool serial_tx(uint8_t * p_buf, uint32_t len)
S{
S    bool ret = true;
S
S#if NRF_LOG_BACKEND_SERIAL_USES_UART
S    memcpy(m_uart_buffer, p_buf, len);
S    uint32_t ret_code = nrf_drv_uart_tx(&m_uart, (uint8_t *)m_uart_buffer, len);
S    if (ret_code != NRF_SUCCESS)
S    {
S        ret = false;
S    }
S#endif //NRF_LOG_BACKEND_SERIAL_USES_UART
S
S#if NRF_LOG_BACKEND_SERIAL_USES_RTT
S    uint32_t idx    = 0;
S    uint32_t length = len;
S    uint32_t processed;
S    uint32_t watchdog_counter = RTT_RETRY_COUNTER;
S    do
S    {
S        processed = SEGGER_RTT_WriteNoLock(0, &p_buf[idx], length);
S        idx += processed;
S        length -= processed;
S        if (processed == 0)
S        {
S            // If RTT is not connected then ensure that logger does not block
S            watchdog_counter--;
S            if (watchdog_counter == 0)
S            {
S                break;
S            }
S        }
S    } while (length);
S#endif //NRF_LOG_BACKEND_SERIAL_USES_RTT
S    return ret;
S}
S
S
Sstatic uint8_t serial_get_byte(void)
S{
S    uint8_t data;
S#if NRF_LOG_BACKEND_SERIAL_USES_UART
S    if (m_blocking_mode)
S    {
S        (void)nrf_drv_uart_rx(&m_uart, &data, 1);
S    }
S    else
S    {
S        m_rx_done = false;
S        (void)nrf_drv_uart_rx(&m_uart, &data, 1);
S        while(!m_rx_done);
S    }
S#elif NRF_LOG_BACKEND_SERIAL_USES_RTT
S    data = (uint8_t)SEGGER_RTT_WaitKey();
S#endif //NRF_LOG_BACKEND_SERIAL_USES_RTT
S    return data;
S}
S
S
Sstatic bool buf_len_update(uint32_t * p_buf_len, int32_t new_len)
S{
S    bool ret;
S    if (new_len < 0)
S    {
S        ret = false;
S    }
S    else
S    {
S        *p_buf_len += (uint32_t)new_len;
S        ret = true;
S    }
S    return ret;
S}
S
S
Sstatic bool timestamp_process(const uint32_t * const p_timestamp, char * p_str, uint32_t * p_len)
S{
S    int32_t len = 0;
S    bool    ret = true;
S    if (p_timestamp)
S    {
S#if NRF_LOG_USES_COLORS
S        char color[] = "\x1B[0m";
S        len = sizeof(color) - 1;
S        memcpy(p_str, color, len);
S        *p_len += len;
S#endif //NRF_LOG_USES_COLORS
S        len = sprintf(&p_str[len], TIMESTAMP_STR(NRF_LOG_TIMESTAMP_DIGITS), (int)*p_timestamp);
S        ret = buf_len_update(p_len, len);
S    }
S    else
S    {
S        *p_len = 0;
S    }
S    return ret;
S}
S
S
Sstatic bool nrf_log_backend_serial_std_handler(
S    uint8_t                severity_level,
S    const uint32_t * const p_timestamp,
S    const char * const     p_str,
S    uint32_t             * p_args,
S    uint32_t               nargs)
S{
S    char     str[NRF_LOG_BACKEND_MAX_STRING_LENGTH];
S    int32_t  tmp_str_len     = 0;
S    uint32_t buffer_len      = 0;
S    bool     status          = true;
S
S    if (serial_is_busy())
S    {
S        return false;
S    }
S
S    if (!timestamp_process(p_timestamp, &str[buffer_len], &buffer_len))
S    {
S        return false;
S    }
S
S    switch (nargs)
S    {
S        case 0:
S        {
S            tmp_str_len = strlen(p_str);
S            if ((tmp_str_len + buffer_len) < NRF_LOG_BACKEND_MAX_STRING_LENGTH)
S            {
S                memcpy(&str[buffer_len], p_str, tmp_str_len);
S            }
S            break;
S        }
S
S        case 1:
S            tmp_str_len = sprintf(&str[buffer_len], p_str, p_args[0]);
S
S            break;
S
S        case 2:
S            tmp_str_len = sprintf(&str[buffer_len], p_str, p_args[0], p_args[1]);
S            break;
S
S        case 3:
S            tmp_str_len = sprintf(&str[buffer_len], p_str, p_args[0], p_args[1], p_args[2]);
S            break;
S
S        case 4:
S            tmp_str_len =
S                sprintf(&str[buffer_len], p_str, p_args[0], p_args[1], p_args[2], p_args[3]);
S            break;
S
S        case 5:
S            tmp_str_len =
S                sprintf(&str[buffer_len],
S                        p_str,
S                        p_args[0],
S                        p_args[1],
S                        p_args[2],
S                        p_args[3],
S                        p_args[4]);
S            break;
S
S        case 6:
S            tmp_str_len =
S                sprintf(&str[buffer_len],
S                        p_str,
S                        p_args[0],
S                        p_args[1],
S                        p_args[2],
S                        p_args[3],
S                        p_args[4],
S                        p_args[5]);
S            break;
S
S        default:
S            break;
S    }
S    status = buf_len_update(&buffer_len, tmp_str_len);
S    if (!status || buffer_len > NRF_LOG_BACKEND_MAX_STRING_LENGTH)
S    {
S        // error, sprintf failed.
S        return false;
S    }
S    else
S    {
S        return serial_tx((uint8_t *)str, buffer_len);
S    }
S}
S
S
Sstatic void byte2hex(const uint8_t c, char * p_out)
S{
S    uint8_t  nibble;
S    uint32_t i = 2;
S
S    while (i-- != 0)
S    {
S        nibble       = (c >> (4 * i)) & 0x0F;
S        p_out[1 - i] = (nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble);
S    }
S}
S
S
Sstatic char char2readablechar(char c)
S{
S    if ((c >= 32) && (c <= 126))
S    {
S        return c;
S    }
S    else
S    {
S        return '.';
S    }
S}
S
S
Sstatic uint32_t nrf_log_backend_serial_hexdump_handler(
S    uint8_t                severity_level,
S    const uint32_t * const p_timestamp,
S    const char * const     p_str,
S    uint32_t               offset,
S    const uint8_t * const  p_buf0,
S    uint32_t               buf0_length,
S    const uint8_t * const  p_buf1,
S    uint32_t               buf1_length)
S{
S    char     str[NRF_LOG_BACKEND_MAX_STRING_LENGTH];
S    uint32_t slen;
S    char   * p_hex_part;
S    char   * p_char_part;
S    uint8_t  c;
S    uint32_t byte_in_line;
S    uint32_t buffer_len    = 0;
S    uint32_t byte_cnt      = offset;
S    uint32_t length        = buf0_length + buf1_length;
S    uint32_t timestamp_len = p_timestamp ?
S            NRF_LOG_TIMESTAMP_DIGITS+2 : 0; //+2 since timestamp is in brackets
S
S    if (serial_is_busy())
S    {
S        return offset;
S    }
S
S    // If it is the first part of hexdump print the header
S    if (offset == 0)
S    {
S        if (!timestamp_process(p_timestamp, &str[buffer_len], &buffer_len))
S        {
S            return offset;
S        }
S        slen = strlen(p_str);
S        // Saturate string if it's too long.
S        slen = (slen > HEXDUMP_MAX_STR_LEN) ? HEXDUMP_MAX_STR_LEN : slen;
S        memcpy(&str[buffer_len], p_str, slen);
S        buffer_len += slen;
S    }
S
S    do
S    {
S
S        uint32_t  i;
S        uint32_t hex_part_offset  = buffer_len;
S        uint32_t char_part_offset = hex_part_offset +
S                                    (HEXDUMP_BYTES_PER_LINE * HEXDUMP_HEXBYTE_AREA + 1) + // +1 - separator between hexdump and characters.
S                                    timestamp_len;
S
S        p_hex_part  = &str[hex_part_offset];
S        p_char_part = &str[char_part_offset];
S
S        // Fill the blanks to align to timestamp print
S        for (i = 0; i < timestamp_len; i++)
S        {
S            *p_hex_part = ' ';
S            ++p_hex_part;
S        }
S
S        for (byte_in_line = 0; byte_in_line < HEXDUMP_BYTES_PER_LINE; byte_in_line++)
S        {
S            if (byte_cnt >= length)
S            {
S                // file the blanks
S                *p_hex_part++  = ' ';
S                *p_hex_part++  = ' ';
S                *p_hex_part++  = ' ';
S                *p_char_part++ = ' ';
S            }
S            else
S            {
S                if (byte_cnt < buf0_length)
S                {
S                    c = p_buf0[byte_cnt];
S                }
S                else
S                {
S                    c = p_buf1[byte_cnt - buf0_length];
S                }
S                byte2hex(c, p_hex_part);
S                p_hex_part    += 2; // move the pointer since byte in hex was added.
S                *p_hex_part++  = ' ';
S                *p_char_part++ = char2readablechar(c);
S                byte_cnt++;
S            }
S        }
S        *p_char_part++ = '\r';
S        *p_char_part++ = '\n';
S        *p_hex_part++  = ' ';
S        buffer_len    += timestamp_len +
S                         (HEXDUMP_BYTES_PER_LINE * HEXDUMP_HEXBYTE_AREA + 1) + // space for hex dump and separator between hexdump and string
S                         HEXDUMP_BYTES_PER_LINE +                              // space for stringS dump
S                         2;                                                    // space for new line
S        if (!serial_tx((uint8_t *)str, buffer_len))
S        {
S            return byte_cnt;
S        }
S
S        if (serial_is_busy())
S        {
S            return byte_cnt;
S        }
S        buffer_len = 0;
S    }
S    while (byte_cnt < length);
S    return byte_cnt;
S}
S
S
Snrf_log_std_handler_t nrf_log_backend_std_handler_get(void)
S{
S    return nrf_log_backend_serial_std_handler;
S}
S
S
Snrf_log_hexdump_handler_t nrf_log_backend_hexdump_handler_get(void)
S{
S    return nrf_log_backend_serial_hexdump_handler;
S}
S
S
Suint8_t nrf_log_backend_getchar(void)
S{
S    return serial_get_byte();
S}
S
N#endif // NRF_LOG_ENABLED
