; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\segger_rtt.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\segger_rtt.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\segger_rtt.crf ..\..\..\..\..\..\external\segger_rtt\SEGGER_RTT.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_ConfigDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigDownBuffer PROC
;;;859    */
;;;860    int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;861      int r;
;;;862      volatile unsigned SavedState;
;;;863    
;;;864      INIT();
000010  bf00              NOP      
000012  481f              LDR      r0,|L1.144|
000014  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000016  b908              CBNZ     r0,|L1.28|
000018  f7fffffe          BL       _DoInit
                  |L1.28|
00001c  bf00              NOP      
;;;865      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
00001e  481c              LDR      r0,|L1.144|
000020  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000022  42a0              CMP      r0,r4
000024  d92e              BLS      |L1.132|
;;;866        SEGGER_RTT_LOCK(SavedState);
000026  bf00              NOP      
;;;867        if (BufferIndex > 0u) {
000028  b30c              CBZ      r4,|L1.110|
;;;868          _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
00002a  eb040144          ADD      r1,r4,r4,LSL #1
00002e  4818              LDR      r0,|L1.144|
000030  3048              ADDS     r0,r0,#0x48
000032  f8406031          STR      r6,[r0,r1,LSL #3]
;;;869          _SEGGER_RTT.aDown[BufferIndex].pBuffer      = pBuffer;
000036  eb040144          ADD      r1,r4,r4,LSL #1
00003a  eb0000c1          ADD      r0,r0,r1,LSL #3
00003e  6047              STR      r7,[r0,#4]
;;;870          _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
000040  eb040144          ADD      r1,r4,r4,LSL #1
000044  4812              LDR      r0,|L1.144|
000046  3048              ADDS     r0,r0,#0x48
000048  eb0000c1          ADD      r0,r0,r1,LSL #3
00004c  f8c08008          STR      r8,[r0,#8]
;;;871          _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
000050  2100              MOVS     r1,#0
000052  eb040244          ADD      r2,r4,r4,LSL #1
000056  480e              LDR      r0,|L1.144|
000058  3048              ADDS     r0,r0,#0x48
00005a  eb0000c2          ADD      r0,r0,r2,LSL #3
00005e  6101              STR      r1,[r0,#0x10]
;;;872          _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
000060  eb040244          ADD      r2,r4,r4,LSL #1
000064  480a              LDR      r0,|L1.144|
000066  3048              ADDS     r0,r0,#0x48
000068  eb0000c2          ADD      r0,r0,r2,LSL #3
00006c  60c1              STR      r1,[r0,#0xc]
                  |L1.110|
;;;873        }
;;;874        _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
00006e  eb040144          ADD      r1,r4,r4,LSL #1
000072  4807              LDR      r0,|L1.144|
000074  3048              ADDS     r0,r0,#0x48
000076  eb0000c1          ADD      r0,r0,r1,LSL #3
00007a  f8c09014          STR      r9,[r0,#0x14]
;;;875        SEGGER_RTT_UNLOCK(SavedState);
00007e  bf00              NOP      
;;;876        r =  0;
000080  2500              MOVS     r5,#0
000082  e001              B        |L1.136|
                  |L1.132|
;;;877      } else {
;;;878        r = -1;
000084  f04f35ff          MOV      r5,#0xffffffff
                  |L1.136|
;;;879      }
;;;880      return r;
000088  4628              MOV      r0,r5
;;;881    }
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;882    
                          ENDP

00008e  0000              DCW      0x0000
                  |L1.144|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigUpBuffer PROC
;;;816    */
;;;817    int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;818      int r;
;;;819      volatile unsigned SavedState;
;;;820    
;;;821      INIT();
000010  bf00              NOP      
000012  481f              LDR      r0,|L2.144|
000014  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000016  b908              CBNZ     r0,|L2.28|
000018  f7fffffe          BL       _DoInit
                  |L2.28|
00001c  bf00              NOP      
;;;822      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
00001e  481c              LDR      r0,|L2.144|
000020  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000022  42a0              CMP      r0,r4
000024  d92e              BLS      |L2.132|
;;;823        SEGGER_RTT_LOCK(SavedState);
000026  bf00              NOP      
;;;824        if (BufferIndex > 0u) {
000028  b30c              CBZ      r4,|L2.110|
;;;825          _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
00002a  eb040144          ADD      r1,r4,r4,LSL #1
00002e  4818              LDR      r0,|L2.144|
000030  3018              ADDS     r0,r0,#0x18
000032  f8406031          STR      r6,[r0,r1,LSL #3]
;;;826          _SEGGER_RTT.aUp[BufferIndex].pBuffer      = pBuffer;
000036  eb040144          ADD      r1,r4,r4,LSL #1
00003a  eb0000c1          ADD      r0,r0,r1,LSL #3
00003e  6047              STR      r7,[r0,#4]
;;;827          _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
000040  eb040144          ADD      r1,r4,r4,LSL #1
000044  4812              LDR      r0,|L2.144|
000046  3018              ADDS     r0,r0,#0x18
000048  eb0000c1          ADD      r0,r0,r1,LSL #3
00004c  f8c08008          STR      r8,[r0,#8]
;;;828          _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
000050  2100              MOVS     r1,#0
000052  eb040244          ADD      r2,r4,r4,LSL #1
000056  480e              LDR      r0,|L2.144|
000058  3018              ADDS     r0,r0,#0x18
00005a  eb0000c2          ADD      r0,r0,r2,LSL #3
00005e  6101              STR      r1,[r0,#0x10]
;;;829          _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
000060  eb040244          ADD      r2,r4,r4,LSL #1
000064  480a              LDR      r0,|L2.144|
000066  3018              ADDS     r0,r0,#0x18
000068  eb0000c2          ADD      r0,r0,r2,LSL #3
00006c  60c1              STR      r1,[r0,#0xc]
                  |L2.110|
;;;830        }
;;;831        _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
00006e  eb040144          ADD      r1,r4,r4,LSL #1
000072  4807              LDR      r0,|L2.144|
000074  3018              ADDS     r0,r0,#0x18
000076  eb0000c1          ADD      r0,r0,r1,LSL #3
00007a  f8c09014          STR      r9,[r0,#0x14]
;;;832        SEGGER_RTT_UNLOCK(SavedState);
00007e  bf00              NOP      
;;;833        r =  0;
000080  2500              MOVS     r5,#0
000082  e001              B        |L2.136|
                  |L2.132|
;;;834      } else {
;;;835        r = -1;
000084  f04f35ff          MOV      r5,#0xffffffff
                  |L2.136|
;;;836      }
;;;837      return r;
000088  4628              MOV      r0,r5
;;;838    }
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;839    
                          ENDP

00008e  0000              DCW      0x0000
                  |L2.144|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_GetKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_GetKey PROC
;;;709    */
;;;710    int SEGGER_RTT_GetKey(void) {
000000  b538              PUSH     {r3-r5,lr}
;;;711      char c;
;;;712      int r;
;;;713    
;;;714      r = (int)SEGGER_RTT_Read(0u, &c, 1u);
000002  2201              MOVS     r2,#1
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SEGGER_RTT_Read
00000c  4604              MOV      r4,r0
;;;715      if (r == 1) {
00000e  2c01              CMP      r4,#1
000010  d102              BNE      |L3.24|
;;;716        r = (int)(unsigned char)c;
000012  f89d4000          LDRB     r4,[sp,#0]
000016  e001              B        |L3.28|
                  |L3.24|
;;;717      } else {
;;;718        r = -1;
000018  f04f34ff          MOV      r4,#0xffffffff
                  |L3.28|
;;;719      }
;;;720      return r;
00001c  4620              MOV      r0,r4
;;;721    }
00001e  bd38              POP      {r3-r5,pc}
;;;722    
                          ENDP


                          AREA ||i.SEGGER_RTT_HasData||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasData PROC
;;;786    */
;;;787    unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;788      SEGGER_RTT_RING_BUFFER *pRing;
;;;789      unsigned v;
;;;790    
;;;791      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000004  eb010441          ADD      r4,r1,r1,LSL #1
000008  4803              LDR      r0,|L4.24|
00000a  eb0002c4          ADD      r2,r0,r4,LSL #3
;;;792      v = pRing->WrOff;
00000e  68d3              LDR      r3,[r2,#0xc]
;;;793      return v - pRing->RdOff;
000010  6910              LDR      r0,[r2,#0x10]
000012  1a18              SUBS     r0,r3,r0
;;;794    }
000014  bd10              POP      {r4,pc}
;;;795    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      _SEGGER_RTT+0x48

                          AREA ||i.SEGGER_RTT_HasKey||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasKey PROC
;;;760    */
;;;761    int SEGGER_RTT_HasKey(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;762      unsigned RdOff;
;;;763      int r;
;;;764    
;;;765      INIT();
000002  bf00              NOP      
000004  4807              LDR      r0,|L5.36|
000006  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000008  b908              CBNZ     r0,|L5.14|
00000a  f7fffffe          BL       _DoInit
                  |L5.14|
00000e  bf00              NOP      
;;;766      RdOff = _SEGGER_RTT.aDown[0].RdOff;
000010  4804              LDR      r0,|L5.36|
000012  6d85              LDR      r5,[r0,#0x58]
;;;767      if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
000014  6d40              LDR      r0,[r0,#0x54]
000016  42a8              CMP      r0,r5
000018  d001              BEQ      |L5.30|
;;;768        r = 1;
00001a  2401              MOVS     r4,#1
00001c  e000              B        |L5.32|
                  |L5.30|
;;;769      } else {
;;;770        r = 0;
00001e  2400              MOVS     r4,#0
                  |L5.32|
;;;771      }
;;;772      return r;
000020  4620              MOV      r0,r4
;;;773    }
000022  bd70              POP      {r4-r6,pc}
;;;774    
                          ENDP

                  |L5.36|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Init||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Init PROC
;;;955    */
;;;956    void SEGGER_RTT_Init (void) {
000000  b510              PUSH     {r4,lr}
;;;957      INIT();
000002  bf00              NOP      
000004  4803              LDR      r0,|L6.20|
000006  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000008  b908              CBNZ     r0,|L6.14|
00000a  f7fffffe          BL       _DoInit
                  |L6.14|
00000e  bf00              NOP      
;;;958    }
000010  bd10              POP      {r4,pc}
;;;959    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Read||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Read PROC
;;;436    */
;;;437    unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;438      unsigned NumBytesRead;
;;;439      volatile unsigned SavedState;
;;;440      //
;;;441      SEGGER_RTT_LOCK(SavedState);
00000a  bf00              NOP      
;;;442      //
;;;443      // Call the non-locking read function
;;;444      //
;;;445      NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SEGGER_RTT_ReadNoLock
000016  4607              MOV      r7,r0
;;;446      //
;;;447      // Finish up.
;;;448      //
;;;449      SEGGER_RTT_UNLOCK(SavedState);
000018  bf00              NOP      
;;;450      //
;;;451      return NumBytesRead;
00001a  4638              MOV      r0,r7
;;;452    }
00001c  e8bd81f0          POP      {r4-r8,pc}
;;;453    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadNoLock PROC
;;;369    */
;;;370    unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  4683              MOV      r11,r0
000006  4617              MOV      r7,r2
;;;371      unsigned NumBytesRem;
;;;372      unsigned NumBytesRead;
;;;373      unsigned RdOff;
;;;374      unsigned WrOff;
;;;375      unsigned char* pBuffer;
;;;376      SEGGER_RTT_RING_BUFFER* pRing;
;;;377      //
;;;378      INIT();
000008  bf00              NOP      
00000a  4822              LDR      r0,|L8.148|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L8.20|
000010  f7fffffe          BL       _DoInit
                  |L8.20|
000014  bf00              NOP      
;;;379      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000016  eb0b014b          ADD      r1,r11,r11,LSL #1
00001a  481e              LDR      r0,|L8.148|
00001c  3048              ADDS     r0,r0,#0x48
00001e  eb0006c1          ADD      r6,r0,r1,LSL #3
;;;380      pBuffer = (unsigned char*)pData;
000022  f8dd9004          LDR      r9,[sp,#4]
;;;381      RdOff = pRing->RdOff;
000026  6935              LDR      r5,[r6,#0x10]
;;;382      WrOff = pRing->WrOff;
000028  f8d6a00c          LDR      r10,[r6,#0xc]
;;;383      NumBytesRead = 0u;
00002c  f04f0800          MOV      r8,#0
;;;384      //
;;;385      // Read from current read position to wrap-around of buffer, first
;;;386      //
;;;387      if (RdOff > WrOff) {
000030  4555              CMP      r5,r10
000032  d915              BLS      |L8.96|
;;;388        NumBytesRem = pRing->SizeOfBuffer - RdOff;
000034  68b0              LDR      r0,[r6,#8]
000036  1b44              SUBS     r4,r0,r5
;;;389        NumBytesRem = MIN(NumBytesRem, BufferSize);
000038  42bc              CMP      r4,r7
00003a  d201              BCS      |L8.64|
00003c  4620              MOV      r0,r4
00003e  e000              B        |L8.66|
                  |L8.64|
000040  4638              MOV      r0,r7
                  |L8.66|
000042  4604              MOV      r4,r0
;;;390        memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000044  6870              LDR      r0,[r6,#4]
000046  1941              ADDS     r1,r0,r5
000048  4622              MOV      r2,r4
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       __aeabi_memcpy
;;;391        NumBytesRead += NumBytesRem;
000050  44a0              ADD      r8,r8,r4
;;;392        pBuffer      += NumBytesRem;
000052  44a1              ADD      r9,r9,r4
;;;393        BufferSize   -= NumBytesRem;
000054  1b3f              SUBS     r7,r7,r4
;;;394        RdOff        += NumBytesRem;
000056  4425              ADD      r5,r5,r4
;;;395        //
;;;396        // Handle wrap-around of buffer
;;;397        //
;;;398        if (RdOff == pRing->SizeOfBuffer) {
000058  68b0              LDR      r0,[r6,#8]
00005a  42a8              CMP      r0,r5
00005c  d100              BNE      |L8.96|
;;;399          RdOff = 0u;
00005e  2500              MOVS     r5,#0
                  |L8.96|
;;;400        }
;;;401      }
;;;402      //
;;;403      // Read remaining items of buffer
;;;404      //
;;;405      NumBytesRem = WrOff - RdOff;
000060  ebaa0405          SUB      r4,r10,r5
;;;406      NumBytesRem = MIN(NumBytesRem, BufferSize);
000064  42bc              CMP      r4,r7
000066  d201              BCS      |L8.108|
000068  4620              MOV      r0,r4
00006a  e000              B        |L8.110|
                  |L8.108|
00006c  4638              MOV      r0,r7
                  |L8.110|
00006e  4604              MOV      r4,r0
;;;407      if (NumBytesRem > 0u) {
000070  b14c              CBZ      r4,|L8.134|
;;;408        memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000072  6870              LDR      r0,[r6,#4]
000074  1941              ADDS     r1,r0,r5
000076  4622              MOV      r2,r4
000078  4648              MOV      r0,r9
00007a  f7fffffe          BL       __aeabi_memcpy
;;;409        NumBytesRead += NumBytesRem;
00007e  44a0              ADD      r8,r8,r4
;;;410        pBuffer      += NumBytesRem;
000080  44a1              ADD      r9,r9,r4
;;;411        BufferSize   -= NumBytesRem;
000082  1b3f              SUBS     r7,r7,r4
;;;412        RdOff        += NumBytesRem;
000084  4425              ADD      r5,r5,r4
                  |L8.134|
;;;413      }
;;;414      if (NumBytesRead) {
000086  f1b80f00          CMP      r8,#0
00008a  d000              BEQ      |L8.142|
;;;415        pRing->RdOff = RdOff;
00008c  6135              STR      r5,[r6,#0x10]
                  |L8.142|
;;;416      }
;;;417      //
;;;418      return NumBytesRead;
00008e  4640              MOV      r0,r8
;;;419    }
000090  e8bd8ffe          POP      {r1-r11,pc}
;;;420    
                          ENDP

                  |L8.148|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameDownBuffer PROC
;;;930    */
;;;931    int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;932      int r;
;;;933      volatile unsigned SavedState;
;;;934    
;;;935      INIT();
000006  bf00              NOP      
000008  480b              LDR      r0,|L9.56|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L9.18|
00000e  f7fffffe          BL       _DoInit
                  |L9.18|
000012  bf00              NOP      
;;;936      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000014  4808              LDR      r0,|L9.56|
000016  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d909              BLS      |L9.48|
;;;937        SEGGER_RTT_LOCK(SavedState);
00001c  bf00              NOP      
;;;938        _SEGGER_RTT.aDown[BufferIndex].sName = sName;
00001e  eb040144          ADD      r1,r4,r4,LSL #1
000022  4805              LDR      r0,|L9.56|
000024  3048              ADDS     r0,r0,#0x48
000026  f8406031          STR      r6,[r0,r1,LSL #3]
;;;939        SEGGER_RTT_UNLOCK(SavedState);
00002a  bf00              NOP      
;;;940        r =  0;
00002c  2500              MOVS     r5,#0
00002e  e001              B        |L9.52|
                  |L9.48|
;;;941      } else {
;;;942        r = -1;
000030  f04f35ff          MOV      r5,#0xffffffff
                  |L9.52|
;;;943      }
;;;944      return r;
000034  4628              MOV      r0,r5
;;;945    }
000036  bd70              POP      {r4-r6,pc}
;;;946    
                          ENDP

                  |L9.56|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameUpBuffer PROC
;;;898    */
;;;899    int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;900      int r;
;;;901      volatile unsigned SavedState;
;;;902    
;;;903      INIT();
000006  bf00              NOP      
000008  480b              LDR      r0,|L10.56|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L10.18|
00000e  f7fffffe          BL       _DoInit
                  |L10.18|
000012  bf00              NOP      
;;;904      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000014  4808              LDR      r0,|L10.56|
000016  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d909              BLS      |L10.48|
;;;905        SEGGER_RTT_LOCK(SavedState);
00001c  bf00              NOP      
;;;906        _SEGGER_RTT.aUp[BufferIndex].sName = sName;
00001e  eb040144          ADD      r1,r4,r4,LSL #1
000022  4805              LDR      r0,|L10.56|
000024  3018              ADDS     r0,r0,#0x18
000026  f8406031          STR      r6,[r0,r1,LSL #3]
;;;907        SEGGER_RTT_UNLOCK(SavedState);
00002a  bf00              NOP      
;;;908        r =  0;
00002c  2500              MOVS     r5,#0
00002e  e001              B        |L10.52|
                  |L10.48|
;;;909      } else {
;;;910        r = -1;
000030  f04f35ff          MOV      r5,#0xffffffff
                  |L10.52|
;;;911      }
;;;912      return r;
000034  4628              MOV      r0,r5
;;;913    }
000036  bd70              POP      {r4-r6,pc}
;;;914    
                          ENDP

                  |L10.56|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetTerminal||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetTerminal PROC
;;;973    */
;;;974    int SEGGER_RTT_SetTerminal (char TerminalId) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
;;;975      char ac[2];
;;;976      SEGGER_RTT_RING_BUFFER *pRing;
;;;977      volatile unsigned SavedState;
;;;978      unsigned Avail;
;;;979      int r;
;;;980      //
;;;981      INIT();
000004  bf00              NOP      
000006  481a              LDR      r0,|L11.112|
000008  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000a  b908              CBNZ     r0,|L11.16|
00000c  f7fffffe          BL       _DoInit
                  |L11.16|
000010  bf00              NOP      
;;;982      //
;;;983      r = 0;
000012  2700              MOVS     r7,#0
;;;984      ac[0] = 0xFFU;
000014  20ff              MOVS     r0,#0xff
000016  f88d0000          STRB     r0,[sp,#0]
;;;985      if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
00001a  2c10              CMP      r4,#0x10
00001c  da24              BGE      |L11.104|
;;;986        ac[1] = _aTerminalId[(unsigned char)TerminalId];
00001e  4815              LDR      r0,|L11.116|
000020  5d00              LDRB     r0,[r0,r4]
000022  f88d0001          STRB     r0,[sp,#1]
;;;987        pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
000026  4d12              LDR      r5,|L11.112|
000028  3518              ADDS     r5,r5,#0x18
;;;988        SEGGER_RTT_LOCK(SavedState);    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
00002a  bf00              NOP      
;;;989        if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00002c  7d28              LDRB     r0,[r5,#0x14]
00002e  f0000003          AND      r0,r0,#3
000032  2802              CMP      r0,#2
000034  d107              BNE      |L11.70|
;;;990          _ActiveTerminal = TerminalId;
000036  4810              LDR      r0,|L11.120|
000038  7004              STRB     r4,[r0,#0]
;;;991          _WriteBlocking(pRing, ac, 2u);
00003a  2202              MOVS     r2,#2
00003c  4669              MOV      r1,sp
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       _WriteBlocking
000044  e00f              B        |L11.102|
                  |L11.70|
;;;992        } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
;;;993          Avail = _GetAvailWriteSpace(pRing);
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       _GetAvailWriteSpace
00004c  4606              MOV      r6,r0
;;;994          if (Avail >= 2) {
00004e  2e02              CMP      r6,#2
000050  d307              BCC      |L11.98|
;;;995            _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
000052  4809              LDR      r0,|L11.120|
000054  7004              STRB     r4,[r0,#0]
;;;996            _WriteNoCheck(pRing, ac, 2u);
000056  2202              MOVS     r2,#2
000058  4669              MOV      r1,sp
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       _WriteNoCheck
000060  e001              B        |L11.102|
                  |L11.98|
;;;997          } else {
;;;998            r = -1;
000062  f04f37ff          MOV      r7,#0xffffffff
                  |L11.102|
;;;999          }
;;;1000       }
;;;1001       SEGGER_RTT_UNLOCK(SavedState);
000066  e001              B        |L11.108|
                  |L11.104|
;;;1002     } else {
;;;1003       r = -1;
000068  f04f37ff          MOV      r7,#0xffffffff
                  |L11.108|
;;;1004     }
;;;1005     return r;
00006c  4638              MOV      r0,r7
;;;1006   }
00006e  bdf8              POP      {r3-r7,pc}
;;;1007   
                          ENDP

                  |L11.112|
                          DCD      _SEGGER_RTT
                  |L11.116|
                          DCD      _aTerminalId
                  |L11.120|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_TerminalOut||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_TerminalOut PROC
;;;1024   */
;;;1025   int SEGGER_RTT_TerminalOut (char TerminalId, const char* s) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4689              MOV      r9,r1
;;;1026     int  Status;
;;;1027     unsigned  FragLen;
;;;1028     unsigned  Avail;
;;;1029     SEGGER_RTT_RING_BUFFER *pRing;
;;;1030     volatile unsigned SavedState;
;;;1031     //
;;;1032     INIT();
000008  bf00              NOP      
00000a  4834              LDR      r0,|L12.220|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L12.20|
000010  f7fffffe          BL       _DoInit
                  |L12.20|
000014  bf00              NOP      
;;;1033     //
;;;1034     // Validate terminal ID.
;;;1035     //
;;;1036     if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
000016  2f10              CMP      r7,#0x10
000018  da5b              BGE      |L12.210|
;;;1037       //
;;;1038       // Get "to-host" ring buffer.
;;;1039       //
;;;1040       pRing = &_SEGGER_RTT.aUp[0];
00001a  f8df80c0          LDR      r8,|L12.220|
00001e  f1080818          ADD      r8,r8,#0x18
;;;1041       //
;;;1042       // Need to be able to change terminal, write data, change back.
;;;1043       // Compute the fixed and variable sizes.
;;;1044       //
;;;1045       FragLen = strlen(s);
000022  4648              MOV      r0,r9
000024  f7fffffe          BL       strlen
000028  4606              MOV      r6,r0
;;;1046       //
;;;1047       // How we output depends upon the mode...
;;;1048       //
;;;1049       SEGGER_RTT_LOCK(SavedState);
00002a  bf00              NOP      
;;;1050       Avail = _GetAvailWriteSpace(pRing);
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       _GetAvailWriteSpace
000032  4605              MOV      r5,r0
;;;1051       switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
000034  f8980014          LDRB     r0,[r8,#0x14]
000038  f0000003          AND      r0,r0,#3
00003c  b120              CBZ      r0,|L12.72|
00003e  2801              CMP      r0,#1
000040  d017              BEQ      |L12.114|
000042  2802              CMP      r0,#2
000044  d140              BNE      |L12.200|
000046  e02f              B        |L12.168|
                  |L12.72|
;;;1052       case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1053         //
;;;1054         // If we are in skip mode and there is no space for the whole
;;;1055         // of this output, don't bother switching terminals at all.
;;;1056         //
;;;1057         if (Avail < (FragLen + 4u)) {
000048  1d30              ADDS     r0,r6,#4
00004a  4285              CMP      r5,r0
00004c  d201              BCS      |L12.82|
;;;1058           Status = 0;
00004e  2400              MOVS     r4,#0
000050  e00e              B        |L12.112|
                  |L12.82|
;;;1059         } else {
;;;1060           _PostTerminalSwitch(pRing, TerminalId);
000052  4639              MOV      r1,r7
000054  4640              MOV      r0,r8
000056  f7fffffe          BL       _PostTerminalSwitch
;;;1061           Status = (int)_WriteBlocking(pRing, s, FragLen);
00005a  4632              MOV      r2,r6
00005c  4649              MOV      r1,r9
00005e  4640              MOV      r0,r8
000060  f7fffffe          BL       _WriteBlocking
000064  4604              MOV      r4,r0
;;;1062           _PostTerminalSwitch(pRing, _ActiveTerminal);
000066  481e              LDR      r0,|L12.224|
000068  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
00006a  4640              MOV      r0,r8
00006c  f7fffffe          BL       _PostTerminalSwitch
                  |L12.112|
;;;1063         }
;;;1064         break;
000070  e02d              B        |L12.206|
                  |L12.114|
;;;1065       case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1066         //
;;;1067         // If we are in trim mode and there is not enough space for everything,
;;;1068         // trim the output but always include the terminal switch.  If no room
;;;1069         // for terminal switch, skip that totally.
;;;1070         //
;;;1071         if (Avail < 4u) {
000072  2d04              CMP      r5,#4
000074  d202              BCS      |L12.124|
;;;1072           Status = -1;
000076  f04f34ff          MOV      r4,#0xffffffff
00007a  e014              B        |L12.166|
                  |L12.124|
;;;1073         } else {
;;;1074           _PostTerminalSwitch(pRing, TerminalId);
00007c  4639              MOV      r1,r7
00007e  4640              MOV      r0,r8
000080  f7fffffe          BL       _PostTerminalSwitch
;;;1075           Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
000084  1f28              SUBS     r0,r5,#4
000086  42b0              CMP      r0,r6
000088  d901              BLS      |L12.142|
00008a  4630              MOV      r0,r6
00008c  e000              B        |L12.144|
                  |L12.142|
00008e  1f28              SUBS     r0,r5,#4
                  |L12.144|
000090  4602              MOV      r2,r0
000092  4649              MOV      r1,r9
000094  4640              MOV      r0,r8
000096  f7fffffe          BL       _WriteBlocking
00009a  4604              MOV      r4,r0
;;;1076           _PostTerminalSwitch(pRing, _ActiveTerminal);
00009c  4810              LDR      r0,|L12.224|
00009e  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000a0  4640              MOV      r0,r8
0000a2  f7fffffe          BL       _PostTerminalSwitch
                  |L12.166|
;;;1077         }
;;;1078         break;
0000a6  e012              B        |L12.206|
                  |L12.168|
;;;1079       case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1080         //
;;;1081         // If we are in blocking mode, output everything.
;;;1082         //
;;;1083         _PostTerminalSwitch(pRing, TerminalId);
0000a8  4639              MOV      r1,r7
0000aa  4640              MOV      r0,r8
0000ac  f7fffffe          BL       _PostTerminalSwitch
;;;1084         Status = (int)_WriteBlocking(pRing, s, FragLen);
0000b0  4632              MOV      r2,r6
0000b2  4649              MOV      r1,r9
0000b4  4640              MOV      r0,r8
0000b6  f7fffffe          BL       _WriteBlocking
0000ba  4604              MOV      r4,r0
;;;1085         _PostTerminalSwitch(pRing, _ActiveTerminal);
0000bc  4808              LDR      r0,|L12.224|
0000be  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000c0  4640              MOV      r0,r8
0000c2  f7fffffe          BL       _PostTerminalSwitch
;;;1086         break;
0000c6  e002              B        |L12.206|
                  |L12.200|
;;;1087       default:
;;;1088         Status = -1;
0000c8  f04f34ff          MOV      r4,#0xffffffff
;;;1089         break;
0000cc  bf00              NOP      
                  |L12.206|
0000ce  bf00              NOP                            ;1064
;;;1090       }
;;;1091       //
;;;1092       // Finish up.
;;;1093       //
;;;1094       SEGGER_RTT_UNLOCK(SavedState);
0000d0  e001              B        |L12.214|
                  |L12.210|
;;;1095     } else {
;;;1096       Status = -1;
0000d2  f04f34ff          MOV      r4,#0xffffffff
                  |L12.214|
;;;1097     }
;;;1098     return Status;
0000d6  4620              MOV      r0,r4
;;;1099   }
0000d8  e8bd87f0          POP      {r4-r10,pc}
;;;1100   
                          ENDP

                  |L12.220|
                          DCD      _SEGGER_RTT
                  |L12.224|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_WaitKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WaitKey PROC
;;;737    */
;;;738    int SEGGER_RTT_WaitKey(void) {
000000  b510              PUSH     {r4,lr}
;;;739      int r;
;;;740    
;;;741      do {
000002  bf00              NOP      
                  |L13.4|
;;;742        r = SEGGER_RTT_GetKey();
000004  f7fffffe          BL       SEGGER_RTT_GetKey
;;;743      } while (r < 0);
000008  2800              CMP      r0,#0
00000a  dbfb              BLT      |L13.4|
;;;744      return r;
;;;745    }
00000c  bd10              POP      {r4,pc}
;;;746    
                          ENDP


                          AREA ||i.SEGGER_RTT_Write||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Write PROC
;;;648    */
;;;649    unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;650      unsigned Status;
;;;651      volatile unsigned SavedState;
;;;652      //
;;;653      INIT();
00000a  bf00              NOP      
00000c  4808              LDR      r0,|L14.48|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  b908              CBNZ     r0,|L14.22|
000012  f7fffffe          BL       _DoInit
                  |L14.22|
000016  bf00              NOP      
;;;654      SEGGER_RTT_LOCK(SavedState);
000018  bf00              NOP      
;;;655      //
;;;656      // Call the non-locking write function
;;;657      //
;;;658      Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SEGGER_RTT_WriteNoLock
000024  4607              MOV      r7,r0
;;;659      //
;;;660      // Finish up.
;;;661      //
;;;662      SEGGER_RTT_UNLOCK(SavedState);
000026  bf00              NOP      
;;;663      //
;;;664      return Status;
000028  4638              MOV      r0,r7
;;;665    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;666    
                          ENDP

00002e  0000              DCW      0x0000
                  |L14.48|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_WriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteNoLock PROC
;;;577    */
;;;578    unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;579      unsigned Status;
;;;580      unsigned Avail;
;;;581      const char*  pData;
;;;582      SEGGER_RTT_RING_BUFFER *pRing;
;;;583    
;;;584      pData = (const char *)pBuffer;
00000a  46c2              MOV      r10,r8
;;;585      //
;;;586      // Get "to-host" ring buffer.
;;;587      //
;;;588      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  eb070147          ADD      r1,r7,r7,LSL #1
000010  481b              LDR      r0,|L15.128|
000012  eb0009c1          ADD      r9,r0,r1,LSL #3
;;;589      //
;;;590      // How we output depends upon the mode...
;;;591      //
;;;592      switch (pRing->Flags) {
000016  f8d90014          LDR      r0,[r9,#0x14]
00001a  b120              CBZ      r0,|L15.38|
00001c  2801              CMP      r0,#1
00001e  d011              BEQ      |L15.68|
000020  2802              CMP      r0,#2
000022  d126              BNE      |L15.114|
000024  e01e              B        |L15.100|
                  |L15.38|
;;;593      case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;594        //
;;;595        // If we are in skip mode and there is no space for the whole
;;;596        // of this output, don't bother.
;;;597        //
;;;598        Avail = _GetAvailWriteSpace(pRing);
000026  4648              MOV      r0,r9
000028  f7fffffe          BL       _GetAvailWriteSpace
00002c  4605              MOV      r5,r0
;;;599        if (Avail < NumBytes) {
00002e  42b5              CMP      r5,r6
000030  d201              BCS      |L15.54|
;;;600          Status = 0u;
000032  2400              MOVS     r4,#0
000034  e005              B        |L15.66|
                  |L15.54|
;;;601        } else {
;;;602          Status = NumBytes;
000036  4634              MOV      r4,r6
;;;603          _WriteNoCheck(pRing, pData, NumBytes);
000038  4632              MOV      r2,r6
00003a  4651              MOV      r1,r10
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       _WriteNoCheck
                  |L15.66|
;;;604        }
;;;605        break;
000042  e018              B        |L15.118|
                  |L15.68|
;;;606      case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;607        //
;;;608        // If we are in trim mode, trim to what we can output without blocking.
;;;609        //
;;;610        Avail = _GetAvailWriteSpace(pRing);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       _GetAvailWriteSpace
00004a  4605              MOV      r5,r0
;;;611        Status = Avail < NumBytes ? Avail : NumBytes;
00004c  42b5              CMP      r5,r6
00004e  d201              BCS      |L15.84|
000050  4628              MOV      r0,r5
000052  e000              B        |L15.86|
                  |L15.84|
000054  4630              MOV      r0,r6
                  |L15.86|
000056  4604              MOV      r4,r0
;;;612        _WriteNoCheck(pRing, pData, Status);
000058  4622              MOV      r2,r4
00005a  4651              MOV      r1,r10
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       _WriteNoCheck
;;;613        break;
000062  e008              B        |L15.118|
                  |L15.100|
;;;614      case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;615        //
;;;616        // If we are in blocking mode, output everything.
;;;617        //
;;;618        Status = _WriteBlocking(pRing, pData, NumBytes);
000064  4632              MOV      r2,r6
000066  4651              MOV      r1,r10
000068  4648              MOV      r0,r9
00006a  f7fffffe          BL       _WriteBlocking
00006e  4604              MOV      r4,r0
;;;619        break;
000070  e001              B        |L15.118|
                  |L15.114|
;;;620      default:
;;;621        Status = 0u;
000072  2400              MOVS     r4,#0
;;;622        break;
000074  bf00              NOP      
                  |L15.118|
000076  bf00              NOP                            ;605
;;;623      }
;;;624      //
;;;625      // Finish up.
;;;626      //
;;;627      return Status;
000078  4620              MOV      r0,r4
;;;628    }
00007a  e8bd87f0          POP      {r4-r10,pc}
;;;629    
                          ENDP

00007e  0000              DCW      0x0000
                  |L15.128|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteSkipNoLock PROC
;;;477    */
;;;478    unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4682              MOV      r10,r0
000006  468b              MOV      r11,r1
000008  4616              MOV      r6,r2
;;;479      const char*  pData;
;;;480      SEGGER_RTT_RING_BUFFER* pRing;
;;;481      unsigned     Avail;
;;;482      unsigned     RdOff;
;;;483      unsigned     WrOff;
;;;484      unsigned     Rem;
;;;485    
;;;486      pData = (const char *)pBuffer;
00000a  f8cdb000          STR      r11,[sp,#0]
;;;487      //
;;;488      // Get "to-host" ring buffer and copy some elements into local variables.
;;;489      //
;;;490      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000e  eb0a014a          ADD      r1,r10,r10,LSL #1
000012  4826              LDR      r0,|L16.172|
000014  eb0004c1          ADD      r4,r0,r1,LSL #3
;;;491      RdOff = pRing->RdOff;
000018  f8d49010          LDR      r9,[r4,#0x10]
;;;492      WrOff = pRing->WrOff;
00001c  68e5              LDR      r5,[r4,#0xc]
;;;493      //
;;;494      // Handle the most common cases fastest.
;;;495      // Which is:
;;;496      //    RdOff <= WrOff -> Space until wrap around is free.
;;;497      //  AND
;;;498      //    WrOff + NumBytes < SizeOfBuffer -> No Wrap around necessary.
;;;499      //
;;;500      //  OR
;;;501      //
;;;502      //    RdOff > WrOff -> Space until RdOff - 1 is free.
;;;503      //  AND
;;;504      //    WrOff + NumBytes < RdOff -> Data fits into buffer
;;;505      //
;;;506      if (RdOff <= WrOff) {
00001e  45a9              CMP      r9,r5
000020  d833              BHI      |L16.138|
;;;507        //
;;;508        // Get space until WrOff will be at wrap around.
;;;509        //
;;;510        Avail = pRing->SizeOfBuffer - 1u - WrOff ;
000022  68a0              LDR      r0,[r4,#8]
000024  1e40              SUBS     r0,r0,#1
000026  1b47              SUBS     r7,r0,r5
;;;511        if (Avail >= NumBytes) {
000028  42b7              CMP      r7,r6
00002a  d30a              BCC      |L16.66|
;;;512          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
00002c  6861              LDR      r1,[r4,#4]
00002e  1948              ADDS     r0,r1,r5
000030  4632              MOV      r2,r6
000032  9900              LDR      r1,[sp,#0]
000034  f7fffffe          BL       __aeabi_memcpy
;;;513          pRing->WrOff = WrOff + NumBytes;
000038  19a8              ADDS     r0,r5,r6
00003a  60e0              STR      r0,[r4,#0xc]
;;;514          return 1;
00003c  2001              MOVS     r0,#1
                  |L16.62|
;;;515        }
;;;516        //
;;;517        // If data did not fit into space until wrap around calculate complete space in buffer.
;;;518        //
;;;519        Avail += RdOff;
;;;520        //
;;;521        // If there is still no space for the whole of this output, don't bother.
;;;522        //
;;;523        if (Avail >= NumBytes) {
;;;524          //
;;;525          //  OK, we have enough space in buffer. Copy in one or 2 chunks
;;;526          //
;;;527          Rem = pRing->SizeOfBuffer - WrOff;      // Space until end of buffer
;;;528          if (Rem > NumBytes) {
;;;529            memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;530            pRing->WrOff = WrOff + NumBytes;
;;;531          } else {
;;;532            //
;;;533            // We reach the end of the buffer, so need to wrap around
;;;534            //
;;;535            memcpy(pRing->pBuffer + WrOff, pData, Rem);
;;;536            memcpy(pRing->pBuffer, pData + Rem, NumBytes - Rem);
;;;537            pRing->WrOff = NumBytes - Rem;
;;;538          }
;;;539          return 1;
;;;540        }
;;;541      } else {
;;;542        Avail = RdOff - WrOff - 1u;
;;;543        if (Avail >= NumBytes) {
;;;544          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;545          pRing->WrOff = WrOff + NumBytes;
;;;546          return 1;
;;;547        }
;;;548      }
;;;549      //
;;;550      // If we reach this point no data has been written
;;;551      //
;;;552      return 0;
;;;553    }
00003e  e8bd8ff8          POP      {r3-r11,pc}
                  |L16.66|
000042  444f              ADD      r7,r7,r9              ;519
000044  42b7              CMP      r7,r6                 ;523
000046  d32f              BCC      |L16.168|
000048  68a0              LDR      r0,[r4,#8]            ;527
00004a  eba00805          SUB      r8,r0,r5              ;527
00004e  45b0              CMP      r8,r6                 ;528
000050  d908              BLS      |L16.100|
000052  6861              LDR      r1,[r4,#4]            ;529
000054  1948              ADDS     r0,r1,r5              ;529
000056  4632              MOV      r2,r6                 ;529
000058  9900              LDR      r1,[sp,#0]            ;529
00005a  f7fffffe          BL       __aeabi_memcpy
00005e  19a8              ADDS     r0,r5,r6              ;530
000060  60e0              STR      r0,[r4,#0xc]          ;530
000062  e010              B        |L16.134|
                  |L16.100|
000064  6861              LDR      r1,[r4,#4]            ;535
000066  1948              ADDS     r0,r1,r5              ;535
000068  4642              MOV      r2,r8                 ;535
00006a  9900              LDR      r1,[sp,#0]            ;535
00006c  f7fffffe          BL       __aeabi_memcpy
000070  eba60208          SUB      r2,r6,r8              ;536
000074  9b00              LDR      r3,[sp,#0]            ;536
000076  eb030108          ADD      r1,r3,r8              ;536
00007a  6860              LDR      r0,[r4,#4]            ;536
00007c  f7fffffe          BL       __aeabi_memcpy
000080  eba60008          SUB      r0,r6,r8              ;537
000084  60e0              STR      r0,[r4,#0xc]          ;537
                  |L16.134|
000086  2001              MOVS     r0,#1                 ;539
000088  e7d9              B        |L16.62|
                  |L16.138|
00008a  eba90005          SUB      r0,r9,r5              ;542
00008e  1e47              SUBS     r7,r0,#1              ;542
000090  42b7              CMP      r7,r6                 ;543
000092  d309              BCC      |L16.168|
000094  6861              LDR      r1,[r4,#4]            ;544
000096  1948              ADDS     r0,r1,r5              ;544
000098  4632              MOV      r2,r6                 ;544
00009a  9900              LDR      r1,[sp,#0]            ;544
00009c  f7fffffe          BL       __aeabi_memcpy
0000a0  19a8              ADDS     r0,r5,r6              ;545
0000a2  60e0              STR      r0,[r4,#0xc]          ;545
0000a4  2001              MOVS     r0,#1                 ;546
0000a6  e7ca              B        |L16.62|
                  |L16.168|
0000a8  2000              MOVS     r0,#0                 ;552
0000aa  e7c8              B        |L16.62|
;;;554    
                          ENDP

                  |L16.172|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteString||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WriteString PROC
;;;687    */
;;;688    unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;689      unsigned Len;
;;;690    
;;;691      Len = STRLEN(s);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
;;;692      return SEGGER_RTT_Write(BufferIndex, s, Len);
00000e  4632              MOV      r2,r6
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SEGGER_RTT_Write
;;;693    }
000018  bd70              POP      {r4-r6,pc}
;;;694    
                          ENDP


                          AREA ||i._DoInit||, CODE, READONLY, ALIGN=2

                  _DoInit PROC
;;;162                    } while (0)
;;;163    static void _DoInit(void) {
000000  b510              PUSH     {r4,lr}
;;;164      SEGGER_RTT_CB* p;
;;;165      //
;;;166      // Initialize control block
;;;167      //
;;;168      p = &_SEGGER_RTT;
000002  4c12              LDR      r4,|L18.76|
;;;169      p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
000004  2002              MOVS     r0,#2
000006  6120              STR      r0,[r4,#0x10]
;;;170      p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
000008  6160              STR      r0,[r4,#0x14]
;;;171      //
;;;172      // Initialize up buffer 0
;;;173      //
;;;174      p->aUp[0].sName         = "Terminal";
00000a  a011              ADR      r0,|L18.80|
00000c  61a0              STR      r0,[r4,#0x18]
;;;175      p->aUp[0].pBuffer       = _acUpBuffer;
00000e  4913              LDR      r1,|L18.92|
000010  61e1              STR      r1,[r4,#0x1c]
;;;176      p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
000012  f44f6180          MOV      r1,#0x400
000016  6221              STR      r1,[r4,#0x20]
;;;177      p->aUp[0].RdOff         = 0u;
000018  2100              MOVS     r1,#0
00001a  62a1              STR      r1,[r4,#0x28]
;;;178      p->aUp[0].WrOff         = 0u;
00001c  6261              STR      r1,[r4,#0x24]
;;;179      p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
00001e  62e1              STR      r1,[r4,#0x2c]
;;;180      //
;;;181      // Initialize down buffer 0
;;;182      //
;;;183      p->aDown[0].sName         = "Terminal";
000020  a00b              ADR      r0,|L18.80|
000022  64a0              STR      r0,[r4,#0x48]
;;;184      p->aDown[0].pBuffer       = _acDownBuffer;
000024  490e              LDR      r1,|L18.96|
000026  64e1              STR      r1,[r4,#0x4c]
;;;185      p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
000028  2110              MOVS     r1,#0x10
00002a  6521              STR      r1,[r4,#0x50]
;;;186      p->aDown[0].RdOff         = 0u;
00002c  2100              MOVS     r1,#0
00002e  65a1              STR      r1,[r4,#0x58]
;;;187      p->aDown[0].WrOff         = 0u;
000030  6561              STR      r1,[r4,#0x54]
;;;188      p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
000032  65e1              STR      r1,[r4,#0x5c]
;;;189      //
;;;190      // Finish initialization of the control block.
;;;191      // Copy Id string in three steps to make sure "SEGGER RTT" is not found
;;;192      // in initializer memory (usually flash) by J-Link
;;;193      //
;;;194      strcpy(&p->acID[7], "RTT");
000034  a10b              ADR      r1,|L18.100|
000036  1de0              ADDS     r0,r4,#7
000038  f7fffffe          BL       strcpy
;;;195      strcpy(&p->acID[0], "SEGGER");
00003c  a10a              ADR      r1,|L18.104|
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       strcpy
;;;196      p->acID[6] = ' ';
000044  2020              MOVS     r0,#0x20
000046  71a0              STRB     r0,[r4,#6]
;;;197    }
000048  bd10              POP      {r4,pc}
;;;198    
                          ENDP

00004a  0000              DCW      0x0000
                  |L18.76|
                          DCD      _SEGGER_RTT
                  |L18.80|
000050  5465726d          DCB      "Terminal",0
000054  696e616c
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L18.92|
                          DCD      _acUpBuffer
                  |L18.96|
                          DCD      _acDownBuffer
                  |L18.100|
000064  52545400          DCB      "RTT",0
                  |L18.104|
000068  53454747          DCB      "SEGGER",0
00006c  455200  
00006f  00                DCB      0

                          AREA ||i._GetAvailWriteSpace||, CODE, READONLY, ALIGN=1

                  _GetAvailWriteSpace PROC
;;;328    */
;;;329    static unsigned _GetAvailWriteSpace(SEGGER_RTT_RING_BUFFER *pRing) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;330      unsigned RdOff;
;;;331      unsigned WrOff;
;;;332      unsigned r;
;;;333      //
;;;334      // Avoid warnings regarding volatile access order.  It's not a problem
;;;335      // in this case, but dampen compiler enthusiasm.
;;;336      //
;;;337      RdOff = pRing->RdOff;
000004  690a              LDR      r2,[r1,#0x10]
;;;338      WrOff = pRing->WrOff;
000006  68cb              LDR      r3,[r1,#0xc]
;;;339      if (RdOff <= WrOff) {
000008  429a              CMP      r2,r3
00000a  d804              BHI      |L19.22|
;;;340        r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
00000c  688c              LDR      r4,[r1,#8]
00000e  1e64              SUBS     r4,r4,#1
000010  1ae4              SUBS     r4,r4,r3
000012  18a0              ADDS     r0,r4,r2
000014  e001              B        |L19.26|
                  |L19.22|
;;;341      } else {
;;;342        r = RdOff - WrOff - 1u;
000016  1ad4              SUBS     r4,r2,r3
000018  1e60              SUBS     r0,r4,#1
                  |L19.26|
;;;343      }
;;;344      return r;
;;;345    }
00001a  bd10              POP      {r4,pc}
;;;346    
                          ENDP


                          AREA ||i._PostTerminalSwitch||, CODE, READONLY, ALIGN=2

                  _PostTerminalSwitch PROC
;;;306    */
;;;307    static void _PostTerminalSwitch(SEGGER_RTT_RING_BUFFER *pRing, char TerminalId) {
000000  b538              PUSH     {r3-r5,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;308      char ac[2];
;;;309    
;;;310      ac[0] = 0xFFu;
000006  20ff              MOVS     r0,#0xff
000008  f88d0000          STRB     r0,[sp,#0]
;;;311      ac[1] = _aTerminalId[(unsigned char)TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
00000c  4804              LDR      r0,|L20.32|
00000e  5d00              LDRB     r0,[r0,r4]
000010  f88d0001          STRB     r0,[sp,#1]
;;;312      _WriteBlocking(pRing, ac, 2u);
000014  2202              MOVS     r2,#2
000016  4669              MOV      r1,sp
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       _WriteBlocking
;;;313    }
00001e  bd38              POP      {r3-r5,pc}
;;;314    
                          ENDP

                  |L20.32|
                          DCD      _aTerminalId

                          AREA ||i._WriteBlocking||, CODE, READONLY, ALIGN=1

                  _WriteBlocking PROC
;;;217    */
;;;218    static unsigned _WriteBlocking(SEGGER_RTT_RING_BUFFER *pRing, const char* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;219      unsigned NumBytesToWrite;
;;;220      unsigned NumBytesWritten;
;;;221      unsigned RdOff;
;;;222      unsigned WrOff;
;;;223      //
;;;224      // Write data to buffer and handle wrap-around if necessary
;;;225      //
;;;226      NumBytesWritten = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;227      WrOff = pRing->WrOff;
00000e  68e5              LDR      r5,[r4,#0xc]
;;;228      do {
000010  bf00              NOP      
                  |L21.18|
;;;229        RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
000012  f8d48010          LDR      r8,[r4,#0x10]
;;;230        if (RdOff > WrOff) {
000016  45a8              CMP      r8,r5
000018  d903              BLS      |L21.34|
;;;231          NumBytesToWrite = RdOff - WrOff - 1u;
00001a  eba80005          SUB      r0,r8,r5
00001e  1e46              SUBS     r6,r0,#1
000020  e004              B        |L21.44|
                  |L21.34|
;;;232        } else {
;;;233          NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
000022  eba50008          SUB      r0,r5,r8
000026  1c40              ADDS     r0,r0,#1
000028  68a1              LDR      r1,[r4,#8]
00002a  1a0e              SUBS     r6,r1,r0
                  |L21.44|
;;;234        }
;;;235        NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
00002c  68a0              LDR      r0,[r4,#8]
00002e  1b40              SUBS     r0,r0,r5
000030  42b0              CMP      r0,r6
000032  d901              BLS      |L21.56|
000034  4630              MOV      r0,r6
000036  e001              B        |L21.60|
                  |L21.56|
000038  68a0              LDR      r0,[r4,#8]
00003a  1b40              SUBS     r0,r0,r5
                  |L21.60|
00003c  4606              MOV      r6,r0
;;;236        NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
00003e  42be              CMP      r6,r7
000040  d201              BCS      |L21.70|
000042  4630              MOV      r0,r6
000044  e000              B        |L21.72|
                  |L21.70|
000046  4638              MOV      r0,r7
                  |L21.72|
000048  4606              MOV      r6,r0
;;;237        memcpy(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
00004a  6861              LDR      r1,[r4,#4]
00004c  1948              ADDS     r0,r1,r5
00004e  4632              MOV      r2,r6
000050  4649              MOV      r1,r9
000052  f7fffffe          BL       __aeabi_memcpy
;;;238        NumBytesWritten += NumBytesToWrite;
000056  44b2              ADD      r10,r10,r6
;;;239        pBuffer         += NumBytesToWrite;
000058  44b1              ADD      r9,r9,r6
;;;240        NumBytes        -= NumBytesToWrite;
00005a  1bbf              SUBS     r7,r7,r6
;;;241        WrOff           += NumBytesToWrite;
00005c  4435              ADD      r5,r5,r6
;;;242        if (WrOff == pRing->SizeOfBuffer) {
00005e  68a0              LDR      r0,[r4,#8]
000060  42a8              CMP      r0,r5
000062  d100              BNE      |L21.102|
;;;243          WrOff = 0u;
000064  2500              MOVS     r5,#0
                  |L21.102|
;;;244        }
;;;245        pRing->WrOff = WrOff;
000066  60e5              STR      r5,[r4,#0xc]
;;;246      } while (NumBytes);
000068  2f00              CMP      r7,#0
00006a  d1d2              BNE      |L21.18|
;;;247      //
;;;248      return NumBytesWritten;
00006c  4650              MOV      r0,r10
;;;249    }
00006e  e8bd87f0          POP      {r4-r10,pc}
;;;250    
                          ENDP


                          AREA ||i._WriteNoCheck||, CODE, READONLY, ALIGN=1

                  _WriteNoCheck PROC
;;;268    */
;;;269    static void _WriteNoCheck(SEGGER_RTT_RING_BUFFER *pRing, const char* pData, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;270      unsigned NumBytesAtOnce;
;;;271      unsigned WrOff;
;;;272      unsigned Rem;
;;;273    
;;;274      WrOff = pRing->WrOff;
00000a  68e6              LDR      r6,[r4,#0xc]
;;;275      Rem = pRing->SizeOfBuffer - WrOff;
00000c  68a0              LDR      r0,[r4,#8]
00000e  1b87              SUBS     r7,r0,r6
;;;276      if (Rem > NumBytes) {
000010  42af              CMP      r7,r5
000012  d908              BLS      |L22.38|
;;;277        //
;;;278        // All data fits before wrap around
;;;279        //
;;;280        memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
000014  6861              LDR      r1,[r4,#4]
000016  1988              ADDS     r0,r1,r6
000018  462a              MOV      r2,r5
00001a  4649              MOV      r1,r9
00001c  f7fffffe          BL       __aeabi_memcpy
;;;281        pRing->WrOff = WrOff + NumBytes;
000020  1970              ADDS     r0,r6,r5
000022  60e0              STR      r0,[r4,#0xc]
000024  e010              B        |L22.72|
                  |L22.38|
;;;282      } else {
;;;283        //
;;;284        // We reach the end of the buffer, so need to wrap around
;;;285        //
;;;286        NumBytesAtOnce = Rem;
000026  46b8              MOV      r8,r7
;;;287        memcpy(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
000028  6861              LDR      r1,[r4,#4]
00002a  1988              ADDS     r0,r1,r6
00002c  4642              MOV      r2,r8
00002e  4649              MOV      r1,r9
000030  f7fffffe          BL       __aeabi_memcpy
;;;288        NumBytesAtOnce = NumBytes - Rem;
000034  eba50807          SUB      r8,r5,r7
;;;289        memcpy(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
000038  eb090107          ADD      r1,r9,r7
00003c  4642              MOV      r2,r8
00003e  6860              LDR      r0,[r4,#4]
000040  f7fffffe          BL       __aeabi_memcpy
;;;290        pRing->WrOff = NumBytesAtOnce;
000044  f8c4800c          STR      r8,[r4,#0xc]
                  |L22.72|
;;;291      }
;;;292    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;293    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _acUpBuffer
                          %        1024
                  _acDownBuffer
                          %        16
                  _SEGGER_RTT
                          %        120

                          AREA ||.data||, DATA, ALIGN=0

                  _aTerminalId
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46
                  _ActiveTerminal
000010  00                DCB      0x00
