L 1 "..\..\..\..\..\..\components\libraries\crc16\crc16.c"
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N#include "sdk_config.h"
L 1 "..\config\sdk_config.h" 1
N
N
N#ifndef SDK_CONFIG_H
N#define SDK_CONFIG_H
N// <<< Use Configuration Wizard in Context Menu >>>\n
N#ifdef USE_APP_CONFIG
S#include "app_config.h"
N#endif
N// <h> nRF_BLE 
N
N//==========================================================
N// <q> BLE_ADVERTISING_ENABLED  - ble_advertising - Advertising module
N 
N
N#ifndef BLE_ADVERTISING_ENABLED
N#define BLE_ADVERTISING_ENABLED 1
N#endif
N
N// <q> BLE_DTM_ENABLED  - ble_dtm - Module for testing RF/PHY using DTM commands
N 
N
N#ifndef BLE_DTM_ENABLED
N#define BLE_DTM_ENABLED 0
N#endif
N
N// <q> BLE_RACP_ENABLED  - ble_racp - Record Access Control Point library
N 
N
N#ifndef BLE_RACP_ENABLED
N#define BLE_RACP_ENABLED 0
N#endif
N
N// <q> NRF_BLE_QWR_ENABLED  - nrf_ble_qwr - Queued writes support module (prepare/execute write)
N 
N
N#ifndef NRF_BLE_QWR_ENABLED
N#define NRF_BLE_QWR_ENABLED 1
N#endif
N
N// <q> PEER_MANAGER_ENABLED  - peer_manager - Peer Manager
N 
N
N#ifndef PEER_MANAGER_ENABLED
N#define PEER_MANAGER_ENABLED 1
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_BLE_Services 
N
N//==========================================================
N// <q> BLE_ANCS_C_ENABLED  - ble_ancs_c - Apple Notification Service Client
N 
N
N#ifndef BLE_ANCS_C_ENABLED
N#define BLE_ANCS_C_ENABLED 0
N#endif
N
N// <q> BLE_ANS_C_ENABLED  - ble_ans_c - Alert Notification Service Client
N 
N
N#ifndef BLE_ANS_C_ENABLED
N#define BLE_ANS_C_ENABLED 0
N#endif
N
N// <q> BLE_BAS_C_ENABLED  - ble_bas_c - Battery Service Client
N 
N
N#ifndef BLE_BAS_C_ENABLED
N#define BLE_BAS_C_ENABLED 0
N#endif
N
N// <q> BLE_BAS_ENABLED  - ble_bas - Battery Service
N 
N
N#ifndef BLE_BAS_ENABLED
N#define BLE_BAS_ENABLED 1
N#endif
N
N// <q> BLE_CSCS_ENABLED  - ble_cscs - Cycling Speed and Cadence Service
N 
N
N#ifndef BLE_CSCS_ENABLED
N#define BLE_CSCS_ENABLED 0
N#endif
N
N// <q> BLE_CTS_C_ENABLED  - ble_cts_c - Current Time Service Client
N 
N
N#ifndef BLE_CTS_C_ENABLED
N#define BLE_CTS_C_ENABLED 0
N#endif
N
N// <q> BLE_DIS_ENABLED  - ble_dis - Device Information Service
N 
N
N#ifndef BLE_DIS_ENABLED
N#define BLE_DIS_ENABLED 0
N#endif
N
N// <q> BLE_GLS_ENABLED  - ble_gls - Glucose Service
N 
N
N#ifndef BLE_GLS_ENABLED
N#define BLE_GLS_ENABLED 0
N#endif
N
N// <q> BLE_HIDS_ENABLED  - ble_hids - Human Interface Device Service
N 
N
N#ifndef BLE_HIDS_ENABLED
N#define BLE_HIDS_ENABLED 0
N#endif
N
N// <q> BLE_HRS_C_ENABLED  - ble_hrs_c - Heart Rate Service Client
N 
N
N#ifndef BLE_HRS_C_ENABLED
N#define BLE_HRS_C_ENABLED 0
N#endif
N
N// <q> BLE_HRS_ENABLED  - ble_hrs - Heart Rate Service
N 
N
N#ifndef BLE_HRS_ENABLED
N#define BLE_HRS_ENABLED 1
N#endif
N
N// <q> BLE_HTS_ENABLED  - ble_hts - Health Thermometer Service
N 
N
N#ifndef BLE_HTS_ENABLED
N#define BLE_HTS_ENABLED 0
N#endif
N
N// <q> BLE_IAS_C_ENABLED  - ble_ias_c - Immediate Alert Service Client
N 
N
N#ifndef BLE_IAS_C_ENABLED
N#define BLE_IAS_C_ENABLED 0
N#endif
N
N// <q> BLE_IAS_ENABLED  - ble_ias - Immediate Alert Service
N 
N
N#ifndef BLE_IAS_ENABLED
N#define BLE_IAS_ENABLED 0
N#endif
N
N// <q> BLE_LBS_C_ENABLED  - ble_lbs_c - Nordic LED Button Service Client
N 
N
N#ifndef BLE_LBS_C_ENABLED
N#define BLE_LBS_C_ENABLED 0
N#endif
N
N// <q> BLE_LBS_ENABLED  - ble_lbs - LED Button Service
N 
N
N#ifndef BLE_LBS_ENABLED
N#define BLE_LBS_ENABLED 0
N#endif
N
N// <q> BLE_LLS_ENABLED  - ble_lls - Link Loss Service
N 
N
N#ifndef BLE_LLS_ENABLED
N#define BLE_LLS_ENABLED 0
N#endif
N
N// <q> BLE_NUS_C_ENABLED  - ble_nus_c - Nordic UART Central Service
N 
N
N#ifndef BLE_NUS_C_ENABLED
N#define BLE_NUS_C_ENABLED 0
N#endif
N
N// <q> BLE_NUS_ENABLED  - ble_nus - Nordic UART Service
N 
N
N#ifndef BLE_NUS_ENABLED
N#define BLE_NUS_ENABLED 0
N#endif
N
N// <q> BLE_RSCS_C_ENABLED  - ble_rscs_c - Running Speed and Cadence Client
N 
N
N#ifndef BLE_RSCS_C_ENABLED
N#define BLE_RSCS_C_ENABLED 0
N#endif
N
N// <q> BLE_RSCS_ENABLED  - ble_rscs - Running Speed and Cadence Service
N 
N
N#ifndef BLE_RSCS_ENABLED
N#define BLE_RSCS_ENABLED 0
N#endif
N
N// <q> BLE_TPS_ENABLED  - ble_tps - TX Power Service
N 
N
N#ifndef BLE_TPS_ENABLED
N#define BLE_TPS_ENABLED 0
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Drivers 
N
N//==========================================================
N// <e> ADC_ENABLED - nrf_drv_adc - Driver for ADC peripheral (nRF51)
N//==========================================================
N#ifndef ADC_ENABLED
N#define ADC_ENABLED 0
N#endif
N#if  ADC_ENABLED
X#if  0
S// <o> ADC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef ADC_CONFIG_IRQ_PRIORITY
S#define ADC_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //ADC_ENABLED
N// </e>
N
N// <e> CLOCK_ENABLED - nrf_drv_clock - CLOCK peripheral driver
N//==========================================================
N#ifndef CLOCK_ENABLED
N#define CLOCK_ENABLED 1
N#endif
N#if  CLOCK_ENABLED
X#if  1
N// <o> CLOCK_CONFIG_XTAL_FREQ  - HF XTAL Frequency
N 
N// <0=> Default (64 MHz) 
N
N#ifndef CLOCK_CONFIG_XTAL_FREQ
N#define CLOCK_CONFIG_XTAL_FREQ 0
N#endif
N
N// <o> CLOCK_CONFIG_LF_SRC  - LF Clock Source
N 
N// <0=> RC 
N// <1=> XTAL 
N// <2=> Synth 
N
N#ifndef CLOCK_CONFIG_LF_SRC
N#define CLOCK_CONFIG_LF_SRC 1
N#endif
N
N// <o> CLOCK_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef CLOCK_CONFIG_IRQ_PRIORITY
N#define CLOCK_CONFIG_IRQ_PRIORITY 6
N#endif
N
N#endif //CLOCK_ENABLED
N// </e>
N
N// <e> COMP_ENABLED - nrf_drv_comp - COMP peripheral driver
N//==========================================================
N#ifndef COMP_ENABLED
N#define COMP_ENABLED 0
N#endif
N#if  COMP_ENABLED
X#if  0
S// <o> COMP_CONFIG_REF  - Reference voltage
S 
S// <0=> Internal 1.2V 
S// <1=> Internal 1.8V 
S// <2=> Internal 2.4V 
S// <4=> VDD 
S// <7=> ARef 
S
S#ifndef COMP_CONFIG_REF
S#define COMP_CONFIG_REF 1
S#endif
S
S// <o> COMP_CONFIG_MAIN_MODE  - Main mode
S 
S// <0=> Single ended 
S// <1=> Differential 
S
S#ifndef COMP_CONFIG_MAIN_MODE
S#define COMP_CONFIG_MAIN_MODE 0
S#endif
S
S// <o> COMP_CONFIG_SPEED_MODE  - Speed mode
S 
S// <0=> Low power 
S// <1=> Normal 
S// <2=> High speed 
S
S#ifndef COMP_CONFIG_SPEED_MODE
S#define COMP_CONFIG_SPEED_MODE 2
S#endif
S
S// <o> COMP_CONFIG_HYST  - Hystheresis
S 
S// <0=> No 
S// <1=> 50mV 
S
S#ifndef COMP_CONFIG_HYST
S#define COMP_CONFIG_HYST 0
S#endif
S
S// <o> COMP_CONFIG_ISOURCE  - Current Source
S 
S// <0=> Off 
S// <1=> 2.5 uA 
S// <2=> 5 uA 
S// <3=> 10 uA 
S
S#ifndef COMP_CONFIG_ISOURCE
S#define COMP_CONFIG_ISOURCE 0
S#endif
S
S// <o> COMP_CONFIG_INPUT  - Analog input
S 
S// <0=> 0 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef COMP_CONFIG_INPUT
S#define COMP_CONFIG_INPUT 0
S#endif
S
S// <o> COMP_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef COMP_CONFIG_IRQ_PRIORITY
S#define COMP_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //COMP_ENABLED
N// </e>
N
N// <q> EGU_ENABLED  - nrf_drv_swi - SWI(EGU) peripheral driver
N 
N
N#ifndef EGU_ENABLED
N#define EGU_ENABLED 0
N#endif
N
N// <e> GPIOTE_ENABLED - nrf_drv_gpiote - GPIOTE peripheral driver
N//==========================================================
N#ifndef GPIOTE_ENABLED
N#define GPIOTE_ENABLED 1
N#endif
N#if  GPIOTE_ENABLED
X#if  1
N// <o> GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS - Number of lower power input pins 
N#ifndef GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS
N#define GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS 4
N#endif
N
N// <o> GPIOTE_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef GPIOTE_CONFIG_IRQ_PRIORITY
N#define GPIOTE_CONFIG_IRQ_PRIORITY 6
N#endif
N
N#endif //GPIOTE_ENABLED
N// </e>
N
N// <e> I2S_ENABLED - nrf_drv_i2s - I2S peripheral driver
N//==========================================================
N#ifndef I2S_ENABLED
N#define I2S_ENABLED 0
N#endif
N#if  I2S_ENABLED
X#if  0
S// <o> I2S_CONFIG_SCK_PIN - SCK pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SCK_PIN
S#define I2S_CONFIG_SCK_PIN 31
S#endif
S
S// <o> I2S_CONFIG_LRCK_PIN - LRCK pin  <1-31> 
S
S
S#ifndef I2S_CONFIG_LRCK_PIN
S#define I2S_CONFIG_LRCK_PIN 30
S#endif
S
S// <o> I2S_CONFIG_MCK_PIN - MCK pin 
S#ifndef I2S_CONFIG_MCK_PIN
S#define I2S_CONFIG_MCK_PIN 255
S#endif
S
S// <o> I2S_CONFIG_SDOUT_PIN - SDOUT pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SDOUT_PIN
S#define I2S_CONFIG_SDOUT_PIN 29
S#endif
S
S// <o> I2S_CONFIG_SDIN_PIN - SDIN pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SDIN_PIN
S#define I2S_CONFIG_SDIN_PIN 28
S#endif
S
S// <o> I2S_CONFIG_MASTER  - Mode
S 
S// <0=> Master 
S// <1=> Slave 
S
S#ifndef I2S_CONFIG_MASTER
S#define I2S_CONFIG_MASTER 0
S#endif
S
S// <o> I2S_CONFIG_FORMAT  - Format
S 
S// <0=> I2S 
S// <1=> Aligned 
S
S#ifndef I2S_CONFIG_FORMAT
S#define I2S_CONFIG_FORMAT 0
S#endif
S
S// <o> I2S_CONFIG_ALIGN  - Alignment
S 
S// <0=> Left 
S// <1=> Right 
S
S#ifndef I2S_CONFIG_ALIGN
S#define I2S_CONFIG_ALIGN 0
S#endif
S
S// <o> I2S_CONFIG_SWIDTH  - Sample width (bits)
S 
S// <0=> 8 
S// <1=> 16 
S// <2=> 24 
S
S#ifndef I2S_CONFIG_SWIDTH
S#define I2S_CONFIG_SWIDTH 1
S#endif
S
S// <o> I2S_CONFIG_CHANNELS  - Channels
S 
S// <0=> Stereo 
S// <1=> Left 
S// <2=> Right 
S
S#ifndef I2S_CONFIG_CHANNELS
S#define I2S_CONFIG_CHANNELS 1
S#endif
S
S// <o> I2S_CONFIG_MCK_SETUP  - MCK behavior
S 
S// <0=> Disabled 
S// <2147483648=> 32MHz/2 
S// <1342177280=> 32MHz/3 
S// <1073741824=> 32MHz/4 
S// <805306368=> 32MHz/5 
S// <671088640=> 32MHz/6 
S// <536870912=> 32MHz/8 
S// <402653184=> 32MHz/10 
S// <369098752=> 32MHz/11 
S// <285212672=> 32MHz/15 
S// <268435456=> 32MHz/16 
S// <201326592=> 32MHz/21 
S// <184549376=> 32MHz/23 
S// <142606336=> 32MHz/30 
S// <138412032=> 32MHz/31 
S// <134217728=> 32MHz/32 
S// <100663296=> 32MHz/42 
S// <68157440=> 32MHz/63 
S// <34340864=> 32MHz/125 
S
S#ifndef I2S_CONFIG_MCK_SETUP
S#define I2S_CONFIG_MCK_SETUP 536870912
S#endif
S
S// <o> I2S_CONFIG_RATIO  - MCK/LRCK ratio
S 
S// <0=> 32x 
S// <1=> 48x 
S// <2=> 64x 
S// <3=> 96x 
S// <4=> 128x 
S// <5=> 192x 
S// <6=> 256x 
S// <7=> 384x 
S// <8=> 512x 
S
S#ifndef I2S_CONFIG_RATIO
S#define I2S_CONFIG_RATIO 2000
S#endif
S
S// <o> I2S_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef I2S_CONFIG_IRQ_PRIORITY
S#define I2S_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //I2S_ENABLED
N// </e>
N
N// <e> LPCOMP_ENABLED - nrf_drv_lpcomp - LPCOMP peripheral driver
N//==========================================================
N#ifndef LPCOMP_ENABLED
N#define LPCOMP_ENABLED 0
N#endif
N#if  LPCOMP_ENABLED
X#if  0
S// <o> LPCOMP_CONFIG_REFERENCE  - Reference voltage
S 
S// <0=> Supply 1/8 
S// <1=> Supply 2/8 
S// <2=> Supply 3/8 
S// <3=> Supply 4/8 
S// <4=> Supply 5/8 
S// <5=> Supply 6/8 
S// <6=> Supply 7/8 
S// <8=> Supply 1/16 (nRF52) 
S// <9=> Supply 3/16 (nRF52) 
S// <10=> Supply 5/16 (nRF52) 
S// <11=> Supply 7/16 (nRF52) 
S// <12=> Supply 9/16 (nRF52) 
S// <13=> Supply 11/16 (nRF52) 
S// <14=> Supply 13/16 (nRF52) 
S// <15=> Supply 15/16 (nRF52) 
S// <7=> External Ref 0 
S// <65543=> External Ref 1 
S
S#ifndef LPCOMP_CONFIG_REFERENCE
S#define LPCOMP_CONFIG_REFERENCE 3
S#endif
S
S// <o> LPCOMP_CONFIG_DETECTION  - Detection
S 
S// <0=> Crossing 
S// <1=> Up 
S// <2=> Down 
S
S#ifndef LPCOMP_CONFIG_DETECTION
S#define LPCOMP_CONFIG_DETECTION 2
S#endif
S
S// <o> LPCOMP_CONFIG_INPUT  - Analog input
S 
S// <0=> 0 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef LPCOMP_CONFIG_INPUT
S#define LPCOMP_CONFIG_INPUT 0
S#endif
S
S// <o> LPCOMP_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef LPCOMP_CONFIG_IRQ_PRIORITY
S#define LPCOMP_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //LPCOMP_ENABLED
N// </e>
N
N// <e> PDM_ENABLED - nrf_drv_pdm - PDM peripheral driver
N//==========================================================
N#ifndef PDM_ENABLED
N#define PDM_ENABLED 0
N#endif
N#if  PDM_ENABLED
X#if  0
S// <o> PDM_CONFIG_MODE  - Mode
S 
S// <0=> Stereo 
S// <1=> Mono 
S
S#ifndef PDM_CONFIG_MODE
S#define PDM_CONFIG_MODE 1
S#endif
S
S// <o> PDM_CONFIG_EDGE  - Edge
S 
S// <0=> Left falling 
S// <1=> Left rising 
S
S#ifndef PDM_CONFIG_EDGE
S#define PDM_CONFIG_EDGE 0
S#endif
S
S// <o> PDM_CONFIG_CLOCK_FREQ  - Clock frequency
S 
S// <134217728=> 1000k 
S// <138412032=> 1032k (default) 
S// <142606336=> 1067k 
S
S#ifndef PDM_CONFIG_CLOCK_FREQ
S#define PDM_CONFIG_CLOCK_FREQ 138412032
S#endif
S
S// <o> PDM_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef PDM_CONFIG_IRQ_PRIORITY
S#define PDM_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //PDM_ENABLED
N// </e>
N
N// <q> PERIPHERAL_RESOURCE_SHARING_ENABLED  - nrf_drv_common - Peripheral drivers common module
N 
N
N#ifndef PERIPHERAL_RESOURCE_SHARING_ENABLED
N#define PERIPHERAL_RESOURCE_SHARING_ENABLED 0
N#endif
N
N// <q> PPI_ENABLED  - nrf_drv_ppi - PPI peripheral driver
N 
N
N#ifndef PPI_ENABLED
N#define PPI_ENABLED 0
N#endif
N
N// <e> PWM_ENABLED - nrf_drv_pwm - PWM peripheral driver
N//==========================================================
N#ifndef PWM_ENABLED
N#define PWM_ENABLED 0
N#endif
N#if  PWM_ENABLED
X#if  0
S// <o> PWM_DEFAULT_CONFIG_OUT0_PIN - Out0 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT0_PIN
S#define PWM_DEFAULT_CONFIG_OUT0_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT1_PIN - Out1 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT1_PIN
S#define PWM_DEFAULT_CONFIG_OUT1_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT2_PIN - Out2 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT2_PIN
S#define PWM_DEFAULT_CONFIG_OUT2_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT3_PIN - Out3 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT3_PIN
S#define PWM_DEFAULT_CONFIG_OUT3_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_BASE_CLOCK  - Base clock
S 
S// <0=> 16 MHz 
S// <1=> 8 MHz 
S// <2=> 4 MHz 
S// <3=> 2 MHz 
S// <4=> 1 MHz 
S// <5=> 500 kHz 
S// <6=> 250 kHz 
S// <7=> 125 MHz 
S
S#ifndef PWM_DEFAULT_CONFIG_BASE_CLOCK
S#define PWM_DEFAULT_CONFIG_BASE_CLOCK 4
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_COUNT_MODE  - Count mode
S 
S// <0=> Up 
S// <1=> Up and Down 
S
S#ifndef PWM_DEFAULT_CONFIG_COUNT_MODE
S#define PWM_DEFAULT_CONFIG_COUNT_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_TOP_VALUE - Top value 
S#ifndef PWM_DEFAULT_CONFIG_TOP_VALUE
S#define PWM_DEFAULT_CONFIG_TOP_VALUE 1000
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_LOAD_MODE  - Load mode
S 
S// <0=> Common 
S// <1=> Grouped 
S// <2=> Individual 
S// <3=> Waveform 
S
S#ifndef PWM_DEFAULT_CONFIG_LOAD_MODE
S#define PWM_DEFAULT_CONFIG_LOAD_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_STEP_MODE  - Step mode
S 
S// <0=> Auto 
S// <1=> Triggered 
S
S#ifndef PWM_DEFAULT_CONFIG_STEP_MODE
S#define PWM_DEFAULT_CONFIG_STEP_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef PWM_DEFAULT_CONFIG_IRQ_PRIORITY
S#define PWM_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> PWM0_ENABLED  - Enable PWM0 instance
S 
S
S#ifndef PWM0_ENABLED
S#define PWM0_ENABLED 0
S#endif
S
S// <q> PWM1_ENABLED  - Enable PWM1 instance
S 
S
S#ifndef PWM1_ENABLED
S#define PWM1_ENABLED 0
S#endif
S
S// <q> PWM2_ENABLED  - Enable PWM2 instance
S 
S
S#ifndef PWM2_ENABLED
S#define PWM2_ENABLED 0
S#endif
S
N#endif //PWM_ENABLED
N// </e>
N
N// <e> QDEC_ENABLED - nrf_drv_qdec - QDEC peripheral driver
N//==========================================================
N#ifndef QDEC_ENABLED
N#define QDEC_ENABLED 0
N#endif
N#if  QDEC_ENABLED
X#if  0
S// <o> QDEC_CONFIG_REPORTPER  - Report period
S 
S// <0=> 10 Samples 
S// <1=> 40 Samples 
S// <2=> 80 Samples 
S// <3=> 120 Samples 
S// <4=> 160 Samples 
S// <5=> 200 Samples 
S// <6=> 240 Samples 
S// <7=> 280 Samples 
S
S#ifndef QDEC_CONFIG_REPORTPER
S#define QDEC_CONFIG_REPORTPER 0
S#endif
S
S// <o> QDEC_CONFIG_SAMPLEPER  - Sample period
S 
S// <0=> 128 us 
S// <1=> 256 us 
S// <2=> 512 us 
S// <3=> 1024 us 
S// <4=> 2048 us 
S// <5=> 4096 us 
S// <6=> 8192 us 
S// <7=> 16384 us 
S
S#ifndef QDEC_CONFIG_SAMPLEPER
S#define QDEC_CONFIG_SAMPLEPER 7
S#endif
S
S// <o> QDEC_CONFIG_PIO_A - A pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_A
S#define QDEC_CONFIG_PIO_A 31
S#endif
S
S// <o> QDEC_CONFIG_PIO_B - B pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_B
S#define QDEC_CONFIG_PIO_B 31
S#endif
S
S// <o> QDEC_CONFIG_PIO_LED - LED pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_LED
S#define QDEC_CONFIG_PIO_LED 31
S#endif
S
S// <o> QDEC_CONFIG_LEDPRE - LED pre 
S#ifndef QDEC_CONFIG_LEDPRE
S#define QDEC_CONFIG_LEDPRE 511
S#endif
S
S// <o> QDEC_CONFIG_LEDPOL  - LED polarity
S 
S// <0=> Active low 
S// <1=> Active high 
S
S#ifndef QDEC_CONFIG_LEDPOL
S#define QDEC_CONFIG_LEDPOL 1
S#endif
S
S// <q> QDEC_CONFIG_DBFEN  - Debouncing enable
S 
S
S#ifndef QDEC_CONFIG_DBFEN
S#define QDEC_CONFIG_DBFEN 0
S#endif
S
S// <q> QDEC_CONFIG_SAMPLE_INTEN  - Sample ready interrupt enable
S 
S
S#ifndef QDEC_CONFIG_SAMPLE_INTEN
S#define QDEC_CONFIG_SAMPLE_INTEN 0
S#endif
S
S// <o> QDEC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef QDEC_CONFIG_IRQ_PRIORITY
S#define QDEC_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //QDEC_ENABLED
N// </e>
N
N// <e> RNG_ENABLED - nrf_drv_rng - RNG peripheral driver
N//==========================================================
N#ifndef RNG_ENABLED
N#define RNG_ENABLED 0
N#endif
N#if  RNG_ENABLED
X#if  0
S// <q> RNG_CONFIG_ERROR_CORRECTION  - Error correction
S 
S
S#ifndef RNG_CONFIG_ERROR_CORRECTION
S#define RNG_CONFIG_ERROR_CORRECTION 0
S#endif
S
S// <o> RNG_CONFIG_POOL_SIZE - Pool size 
S#ifndef RNG_CONFIG_POOL_SIZE
S#define RNG_CONFIG_POOL_SIZE 8
S#endif
S
S// <o> RNG_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef RNG_CONFIG_IRQ_PRIORITY
S#define RNG_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //RNG_ENABLED
N// </e>
N
N// <e> RTC_ENABLED - nrf_drv_rtc - RTC peripheral driver
N//==========================================================
N#ifndef RTC_ENABLED
N#define RTC_ENABLED 0
N#endif
N#if  RTC_ENABLED
X#if  0
S// <o> RTC_DEFAULT_CONFIG_FREQUENCY - Frequency  <16-32768> 
S
S
S#ifndef RTC_DEFAULT_CONFIG_FREQUENCY
S#define RTC_DEFAULT_CONFIG_FREQUENCY 32768
S#endif
S
S// <q> RTC_DEFAULT_CONFIG_RELIABLE  - Ensures safe compare event triggering
S 
S
S#ifndef RTC_DEFAULT_CONFIG_RELIABLE
S#define RTC_DEFAULT_CONFIG_RELIABLE 0
S#endif
S
S// <o> RTC_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef RTC_DEFAULT_CONFIG_IRQ_PRIORITY
S#define RTC_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> RTC0_ENABLED  - Enable RTC0 instance
S 
S
S#ifndef RTC0_ENABLED
S#define RTC0_ENABLED 0
S#endif
S
S// <q> RTC1_ENABLED  - Enable RTC1 instance
S 
S
S#ifndef RTC1_ENABLED
S#define RTC1_ENABLED 0
S#endif
S
S// <q> RTC2_ENABLED  - Enable RTC2 instance
S 
S
S#ifndef RTC2_ENABLED
S#define RTC2_ENABLED 0
S#endif
S
S// <o> NRF_MAXIMUM_LATENCY_US - Maximum possible time[us] in highest priority interrupt 
S#ifndef NRF_MAXIMUM_LATENCY_US
S#define NRF_MAXIMUM_LATENCY_US 2000
S#endif
S
N#endif //RTC_ENABLED
N// </e>
N
N// <e> SAADC_ENABLED - nrf_drv_saadc - SAADC peripheral driver
N//==========================================================
N#ifndef SAADC_ENABLED
N#define SAADC_ENABLED 0
N#endif
N#if  SAADC_ENABLED
X#if  0
S// <o> SAADC_CONFIG_RESOLUTION  - Resolution
S 
S// <0=> 8 bit 
S// <1=> 10 bit 
S// <2=> 12 bit 
S// <3=> 14 bit 
S
S#ifndef SAADC_CONFIG_RESOLUTION
S#define SAADC_CONFIG_RESOLUTION 1
S#endif
S
S// <o> SAADC_CONFIG_OVERSAMPLE  - Sample period
S 
S// <0=> Disabled 
S// <1=> 2x 
S// <2=> 4x 
S// <3=> 8x 
S// <4=> 16x 
S// <5=> 32x 
S// <6=> 64x 
S// <7=> 128x 
S// <8=> 256x 
S
S#ifndef SAADC_CONFIG_OVERSAMPLE
S#define SAADC_CONFIG_OVERSAMPLE 0
S#endif
S
S// <q> SAADC_CONFIG_LP_MODE  - Enabling low power mode
S 
S
S#ifndef SAADC_CONFIG_LP_MODE
S#define SAADC_CONFIG_LP_MODE 0
S#endif
S
S// <o> SAADC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef SAADC_CONFIG_IRQ_PRIORITY
S#define SAADC_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //SAADC_ENABLED
N// </e>
N
N// <e> SPIS_ENABLED - nrf_drv_spis - SPI Slave driver
N//==========================================================
N#ifndef SPIS_ENABLED
N#define SPIS_ENABLED 0
N#endif
N#if  SPIS_ENABLED
X#if  0
S// <o> SPIS_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef SPIS_DEFAULT_CONFIG_IRQ_PRIORITY
S#define SPIS_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <o> SPIS_DEFAULT_MODE  - Mode
S 
S// <0=> MODE_0 
S// <1=> MODE_1 
S// <2=> MODE_2 
S// <3=> MODE_3 
S
S#ifndef SPIS_DEFAULT_MODE
S#define SPIS_DEFAULT_MODE 0
S#endif
S
S// <o> SPIS_DEFAULT_BIT_ORDER  - SPIS default bit order
S 
S// <0=> MSB first 
S// <1=> LSB first 
S
S#ifndef SPIS_DEFAULT_BIT_ORDER
S#define SPIS_DEFAULT_BIT_ORDER 0
S#endif
S
S// <o> SPIS_DEFAULT_DEF - SPIS default DEF character  <0-255> 
S
S
S#ifndef SPIS_DEFAULT_DEF
S#define SPIS_DEFAULT_DEF 255
S#endif
S
S// <o> SPIS_DEFAULT_ORC - SPIS default ORC character  <0-255> 
S
S
S#ifndef SPIS_DEFAULT_ORC
S#define SPIS_DEFAULT_ORC 255
S#endif
S
S// <q> SPIS0_ENABLED  - Enable SPIS0 instance
S 
S
S#ifndef SPIS0_ENABLED
S#define SPIS0_ENABLED 0
S#endif
S
S// <q> SPIS1_ENABLED  - Enable SPIS1 instance
S 
S
S#ifndef SPIS1_ENABLED
S#define SPIS1_ENABLED 0
S#endif
S
S// <q> SPIS2_ENABLED  - Enable SPIS2 instance
S 
S
S#ifndef SPIS2_ENABLED
S#define SPIS2_ENABLED 0
S#endif
S
N#endif //SPIS_ENABLED
N// </e>
N
N// <e> SPI_ENABLED - nrf_drv_spi - SPI/SPIM peripheral driver
N//==========================================================
N#ifndef SPI_ENABLED
N#define SPI_ENABLED 1
N#endif
N#if  SPI_ENABLED
X#if  1
N// <e> SPI_CONFIG_LOG_ENABLED - Enables logging in the module.
N//==========================================================
N#ifndef SPI_CONFIG_LOG_ENABLED
N#define SPI_CONFIG_LOG_ENABLED 0
N#endif
N#if  SPI_CONFIG_LOG_ENABLED
X#if  0
S// <o> SPI_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef SPI_CONFIG_LOG_LEVEL
S#define SPI_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> SPI_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SPI_CONFIG_INFO_COLOR
S#define SPI_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> SPI_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SPI_CONFIG_DEBUG_COLOR
S#define SPI_CONFIG_DEBUG_COLOR 0
S#endif
S
N#endif //SPI_CONFIG_LOG_ENABLED
N// </e>
N
N// <o> SPI_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef SPI_DEFAULT_CONFIG_IRQ_PRIORITY
N#define SPI_DEFAULT_CONFIG_IRQ_PRIORITY 6
N#endif
N
N// <e> SPI0_ENABLED - Enable SPI0 instance
N//==========================================================
N#ifndef SPI0_ENABLED
N#define SPI0_ENABLED 1
N#endif
N#if  SPI0_ENABLED
X#if  1
N// <q> SPI0_USE_EASY_DMA  - Use EasyDMA
N 
N
N#ifndef SPI0_USE_EASY_DMA
N#define SPI0_USE_EASY_DMA 0
N#endif
N
N// <o> SPI_SCK_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_SCK_PIN
N#define SPI0_SCK_PIN 25
N#endif
N
N// <o> SPI_MISO_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_MISO_PIN
N#define SPI0_MISO_PIN 26
N#endif
N
N// <o> SPI_MOSI_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_MOSI_PIN
N#define SPI0_MOSI_PIN 23
N#endif
N
N// <o> SPI_SS_PIN - Pin number  <0-31> 
N
N
N#ifndef SPI0_SS_PIN
N#define SPI0_SS_PIN 24
N#endif
N#endif //SPI0_ENABLED
N// </e>
N
N// <e> SPI1_ENABLED - Enable SPI1 instance
N//==========================================================
N#ifndef SPI1_ENABLED
N#define SPI1_ENABLED 0
N#endif
N#if  SPI1_ENABLED
X#if  0
S// <q> SPI1_USE_EASY_DMA  - Use EasyDMA
S 
S
S#ifndef SPI1_USE_EASY_DMA
S#define SPI1_USE_EASY_DMA 1
S#endif
S
N#endif //SPI1_ENABLED
N// </e>
N
N// <e> SPI2_ENABLED - Enable SPI2 instance
N//==========================================================
N#ifndef SPI2_ENABLED
N#define SPI2_ENABLED 0
N#endif
N#if  SPI2_ENABLED
X#if  0
S// <q> SPI2_USE_EASY_DMA  - Use EasyDMA
S 
S
S#ifndef SPI2_USE_EASY_DMA
S#define SPI2_USE_EASY_DMA 1
S#endif
S
N#endif //SPI2_ENABLED
N// </e>
N
N#endif //SPI_ENABLED
N// </e>
N
N// <e> TIMER_ENABLED - nrf_drv_timer - TIMER periperal driver
N//==========================================================
N#ifndef TIMER_ENABLED
N#define TIMER_ENABLED 0
N#endif
N#if  TIMER_ENABLED
X#if  0
S// <o> TIMER_DEFAULT_CONFIG_FREQUENCY  - Timer frequency if in Timer mode
S 
S// <0=> 16 MHz 
S// <1=> 8 MHz 
S// <2=> 4 MHz 
S// <3=> 2 MHz 
S// <4=> 1 MHz 
S// <5=> 500 kHz 
S// <6=> 250 kHz 
S// <7=> 125 kHz 
S// <8=> 62.5 kHz 
S// <9=> 31.25 kHz 
S
S#ifndef TIMER_DEFAULT_CONFIG_FREQUENCY
S#define TIMER_DEFAULT_CONFIG_FREQUENCY 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_MODE  - Timer mode or operation
S 
S// <0=> Timer 
S// <1=> Counter 
S
S#ifndef TIMER_DEFAULT_CONFIG_MODE
S#define TIMER_DEFAULT_CONFIG_MODE 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_BIT_WIDTH  - Timer counter bit width
S 
S// <0=> 16 bit 
S// <1=> 8 bit 
S// <2=> 24 bit 
S// <3=> 32 bit 
S
S#ifndef TIMER_DEFAULT_CONFIG_BIT_WIDTH
S#define TIMER_DEFAULT_CONFIG_BIT_WIDTH 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef TIMER_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TIMER_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> TIMER0_ENABLED  - Enable TIMER0 instance
S 
S
S#ifndef TIMER0_ENABLED
S#define TIMER0_ENABLED 0
S#endif
S
S// <q> TIMER1_ENABLED  - Enable TIMER1 instance
S 
S
S#ifndef TIMER1_ENABLED
S#define TIMER1_ENABLED 0
S#endif
S
S// <q> TIMER2_ENABLED  - Enable TIMER2 instance
S 
S
S#ifndef TIMER2_ENABLED
S#define TIMER2_ENABLED 0
S#endif
S
S// <q> TIMER3_ENABLED  - Enable TIMER3 instance
S 
S
S#ifndef TIMER3_ENABLED
S#define TIMER3_ENABLED 0
S#endif
S
S// <q> TIMER4_ENABLED  - Enable TIMER4 instance
S 
S
S#ifndef TIMER4_ENABLED
S#define TIMER4_ENABLED 0
S#endif
S
N#endif //TIMER_ENABLED
N// </e>
N
N// <e> TWIS_ENABLED - nrf_drv_twis - TWIS peripheral driver
N//==========================================================
N#ifndef TWIS_ENABLED
N#define TWIS_ENABLED 0
N#endif
N#if  TWIS_ENABLED
X#if  0
S// <o> TWIS_DEFAULT_CONFIG_ADDR0 - Address0 
S#ifndef TWIS_DEFAULT_CONFIG_ADDR0
S#define TWIS_DEFAULT_CONFIG_ADDR0 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_ADDR1 - Address1 
S#ifndef TWIS_DEFAULT_CONFIG_ADDR1
S#define TWIS_DEFAULT_CONFIG_ADDR1 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_SCL_PULL  - SCL pin pull configuration
S 
S// <0=> Disabled 
S// <1=> Pull down 
S// <3=> Pull up 
S
S#ifndef TWIS_DEFAULT_CONFIG_SCL_PULL
S#define TWIS_DEFAULT_CONFIG_SCL_PULL 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_SDA_PULL  - SDA pin pull configuration
S 
S// <0=> Disabled 
S// <1=> Pull down 
S// <3=> Pull up 
S
S#ifndef TWIS_DEFAULT_CONFIG_SDA_PULL
S#define TWIS_DEFAULT_CONFIG_SDA_PULL 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef TWIS_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TWIS_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <q> TWIS0_ENABLED  - Enable TWIS0 instance
S 
S
S#ifndef TWIS0_ENABLED
S#define TWIS0_ENABLED 0
S#endif
S
S// <q> TWIS1_ENABLED  - Enable TWIS1 instance
S 
S
S#ifndef TWIS1_ENABLED
S#define TWIS1_ENABLED 0
S#endif
S
S// <q> TWIS_ASSUME_INIT_AFTER_RESET_ONLY  - Assume that any instance would be initialized only once
S 
S
S// <i> Optimization flag. Registers used by TWIS are shared by other peripherals. Normally, during initialization driver tries to clear all registers to known state before doing the initialization itself. This gives initialization safe procedure, no matter when it would be called. If you activate TWIS only once and do never uninitialize it - set this flag to 1 what gives more optimal code.
S
S#ifndef TWIS_ASSUME_INIT_AFTER_RESET_ONLY
S#define TWIS_ASSUME_INIT_AFTER_RESET_ONLY 0
S#endif
S
S// <q> TWIS_NO_SYNC_MODE  - Remove support for synchronous mode
S 
S
S// <i> Synchronous mode would be used in specific situations. And it uses some additional code and data memory to safely process state machine by polling it in status functions. If this functionality is not required it may be disabled to free some resources.
S
S#ifndef TWIS_NO_SYNC_MODE
S#define TWIS_NO_SYNC_MODE 0
S#endif
S
N#endif //TWIS_ENABLED
N// </e>
N
N// <e> TWI_ENABLED - nrf_drv_twi - TWI/TWIM peripheral driver
N//==========================================================
N#ifndef TWI_ENABLED
N#define TWI_ENABLED 0
N#endif
N#if  TWI_ENABLED
X#if  0
S// <o> TWI_DEFAULT_CONFIG_FREQUENCY  - Frequency
S 
S// <26738688=> 100k 
S// <67108864=> 250k 
S// <104857600=> 400k 
S
S#ifndef TWI_DEFAULT_CONFIG_FREQUENCY
S#define TWI_DEFAULT_CONFIG_FREQUENCY 26738688
S#endif
S
S// <q> TWI_DEFAULT_CONFIG_CLR_BUS_INIT  - Enables bus clearing procedure during init
S 
S
S#ifndef TWI_DEFAULT_CONFIG_CLR_BUS_INIT
S#define TWI_DEFAULT_CONFIG_CLR_BUS_INIT 0
S#endif
S
S// <q> TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT  - Enables bus holding after uninit
S 
S
S#ifndef TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT
S#define TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT 0
S#endif
S
S// <o> TWI_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef TWI_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TWI_DEFAULT_CONFIG_IRQ_PRIORITY 6
S#endif
S
S// <e> TWI0_ENABLED - Enable TWI0 instance
S//==========================================================
S#ifndef TWI0_ENABLED
S#define TWI0_ENABLED 0
S#endif
S#if  TWI0_ENABLED
S// <q> TWI0_USE_EASY_DMA  - Use EasyDMA (if present)
S 
S
S#ifndef TWI0_USE_EASY_DMA
S#define TWI0_USE_EASY_DMA 0
S#endif
S
S#endif //TWI0_ENABLED
S// </e>
S
S// <e> TWI1_ENABLED - Enable TWI1 instance
S//==========================================================
S#ifndef TWI1_ENABLED
S#define TWI1_ENABLED 0
S#endif
S#if  TWI1_ENABLED
S// <q> TWI1_USE_EASY_DMA  - Use EasyDMA (if present)
S 
S
S#ifndef TWI1_USE_EASY_DMA
S#define TWI1_USE_EASY_DMA 0
S#endif
S
S#endif //TWI1_ENABLED
S// </e>
S
N#endif //TWI_ENABLED
N// </e>
N
N// <e> UART_ENABLED - nrf_drv_uart - UART/UARTE peripheral driver
N//==========================================================
N#ifndef UART_ENABLED
N#define UART_ENABLED 1
N#endif
N#if  UART_ENABLED
X#if  1
N// <o> UART_DEFAULT_CONFIG_HWFC  - Hardware Flow Control
N 
N// <0=> Disabled 
N// <1=> Enabled 
N
N#ifndef UART_DEFAULT_CONFIG_HWFC
N#define UART_DEFAULT_CONFIG_HWFC 0
N#endif
N
N// <o> UART_DEFAULT_CONFIG_PARITY  - Parity
N 
N// <0=> Excluded 
N// <14=> Included 
N
N#ifndef UART_DEFAULT_CONFIG_PARITY
N#define UART_DEFAULT_CONFIG_PARITY 0
N#endif
N
N// <o> UART_DEFAULT_CONFIG_BAUDRATE  - Default Baudrate
N 
N// <323584=> 1200 baud 
N// <643072=> 2400 baud 
N// <1290240=> 4800 baud 
N// <2576384=> 9600 baud 
N// <3862528=> 14400 baud 
N// <5152768=> 19200 baud 
N// <7716864=> 28800 baud 
N// <10289152=> 38400 baud 
N// <15400960=> 57600 baud 
N// <20615168=> 76800 baud 
N// <30801920=> 115200 baud 
N// <61865984=> 230400 baud 
N// <67108864=> 250000 baud 
N// <121634816=> 460800 baud 
N// <251658240=> 921600 baud 
N// <268435456=> 57600 baud 
N
N#ifndef UART_DEFAULT_CONFIG_BAUDRATE
N#define UART_DEFAULT_CONFIG_BAUDRATE 30801920
N#endif
N
N// <o> UART_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N// <4=> 4 
N// <5=> 5 
N// <6=> 6 
N// <7=> 7 
N
N#ifndef UART_DEFAULT_CONFIG_IRQ_PRIORITY
N#define UART_DEFAULT_CONFIG_IRQ_PRIORITY 6
N#endif
N
N// <q> UART0_CONFIG_USE_EASY_DMA  - Default setting for using EasyDMA
N 
N
N#ifndef UART0_CONFIG_USE_EASY_DMA
N#define UART0_CONFIG_USE_EASY_DMA 1
N#endif
N
N// <q> UART_EASY_DMA_SUPPORT  - Driver supporting EasyDMA
N 
N
N#ifndef UART_EASY_DMA_SUPPORT
N#define UART_EASY_DMA_SUPPORT 1
N#endif
N
N// <q> UART_LEGACY_SUPPORT  - Driver supporting Legacy mode
N 
N
N#ifndef UART_LEGACY_SUPPORT
N#define UART_LEGACY_SUPPORT 1
N#endif
N
N#endif //UART_ENABLED
N// </e>
N
N// <e> WDT_ENABLED - nrf_drv_wdt - WDT peripheral driver
N//==========================================================
N#ifndef WDT_ENABLED
N#define WDT_ENABLED 0
N#endif
N#if  WDT_ENABLED
X#if  0
S// <o> WDT_CONFIG_BEHAVIOUR  - WDT behavior in CPU SLEEP or HALT mode
S 
S// <1=> Run in SLEEP, Pause in HALT 
S// <8=> Pause in SLEEP, Run in HALT 
S// <9=> Run in SLEEP and HALT 
S// <0=> Pause in SLEEP and HALT 
S
S#ifndef WDT_CONFIG_BEHAVIOUR
S#define WDT_CONFIG_BEHAVIOUR 1
S#endif
S
S// <o> WDT_CONFIG_RELOAD_VALUE - Reload value  <15-4294967295> 
S
S
S#ifndef WDT_CONFIG_RELOAD_VALUE
S#define WDT_CONFIG_RELOAD_VALUE 2000
S#endif
S
S// <o> WDT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef WDT_CONFIG_IRQ_PRIORITY
S#define WDT_CONFIG_IRQ_PRIORITY 6
S#endif
S
N#endif //WDT_ENABLED
N// </e>
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Libraries 
N
N//==========================================================
N// <q> APP_FIFO_ENABLED  - app_fifo - Software FIFO implementation
N 
N 
N#define APPL_LOG app_trace_log  
N
N#ifndef APP_FIFO_ENABLED
N#define APP_FIFO_ENABLED 1
N#endif
N
N// <q> APP_MAILBOX_ENABLED  - app_mailbox - Thread safe mailbox
N 
N
N#ifndef APP_MAILBOX_ENABLED
N#define APP_MAILBOX_ENABLED 0
N#endif
N
N// <q> APP_PWM_ENABLED  - app_pwm - PWM functionality
N 
N
N#ifndef APP_PWM_ENABLED
N#define APP_PWM_ENABLED 0
N#endif
N
N// <e> APP_SCHEDULER_ENABLED - app_scheduler - Events scheduler
N//==========================================================
N#ifndef APP_SCHEDULER_ENABLED
N#define APP_SCHEDULER_ENABLED 0
N#endif
N#if  APP_SCHEDULER_ENABLED
X#if  0
S// <q> APP_SCHEDULER_WITH_PAUSE  - Enabling pause feature
S 
S
S#ifndef APP_SCHEDULER_WITH_PAUSE
S#define APP_SCHEDULER_WITH_PAUSE 0
S#endif
S
S// <q> APP_SCHEDULER_WITH_PROFILER  - Enabling scheduler profiling
S 
S
S#ifndef APP_SCHEDULER_WITH_PROFILER
S#define APP_SCHEDULER_WITH_PROFILER 0
S#endif
S
N#endif //APP_SCHEDULER_ENABLED
N// </e>
N
N// <e> APP_TIMER_ENABLED - app_timer - Application timer functionality
N//==========================================================
N#ifndef APP_TIMER_ENABLED
N#define APP_TIMER_ENABLED 1
N#endif
N#if  APP_TIMER_ENABLED
X#if  1
N// <q> APP_TIMER_WITH_PROFILER  - Enable app_timer profiling
N 
N
N#ifndef APP_TIMER_WITH_PROFILER
N#define APP_TIMER_WITH_PROFILER 0
N#endif
N
N// <q> APP_TIMER_KEEPS_RTC_ACTIVE  - Enable RTC always on
N 
N
N// <i> If option is enabled RTC is kept running even if there is no active timers.
N// <i> This option can be used when app_timer is used for timestamping.
N
N#ifndef APP_TIMER_KEEPS_RTC_ACTIVE
N#define APP_TIMER_KEEPS_RTC_ACTIVE 0
N#endif
N
N#endif //APP_TIMER_ENABLED
N// </e>
N
N// <q> APP_TWI_ENABLED  - app_twi - TWI transaction manager
N 
N
N#ifndef APP_TWI_ENABLED
N#define APP_TWI_ENABLED 0
N#endif
N
N// <e> APP_UART_ENABLED - app_uart - UART driver
N//==========================================================
N#ifndef APP_UART_ENABLED
N#define APP_UART_ENABLED 0
N#endif
N#if  APP_UART_ENABLED
X#if  0
S// <o> APP_UART_DRIVER_INSTANCE  - UART instance used
S 
S// <0=> 0 
S
S#ifndef APP_UART_DRIVER_INSTANCE
S#define APP_UART_DRIVER_INSTANCE 0
S#endif
S
N#endif //APP_UART_ENABLED
N// </e>
N
N// <q> BUTTON_ENABLED  - app_button - buttons handling module
N 
N
N#ifndef BUTTON_ENABLED
N#define BUTTON_ENABLED 1
N#endif
N
N// <q> CRC16_ENABLED  - crc16 - CRC16 calculation routines
N 
N
N#ifndef CRC16_ENABLED
N#define CRC16_ENABLED 1
N#endif
N
N// <q> CRC32_ENABLED  - crc32 - CRC32 calculation routines
N 
N
N#ifndef CRC32_ENABLED
N#define CRC32_ENABLED 0
N#endif
N
N// <q> ECC_ENABLED  - ecc - Elliptic Curve Cryptography Library
N 
N
N#ifndef ECC_ENABLED
N#define ECC_ENABLED 0
N#endif
N
N// <e> FDS_ENABLED - fds - Flash data storage module
N//==========================================================
N#ifndef FDS_ENABLED
N#define FDS_ENABLED 1
N#endif
N#if  FDS_ENABLED
X#if  1
N// <o> FDS_OP_QUEUE_SIZE - Size of the internal queue. 
N#ifndef FDS_OP_QUEUE_SIZE
N#define FDS_OP_QUEUE_SIZE 4
N#endif
N
N// <o> FDS_CHUNK_QUEUE_SIZE - Determines how many @ref fds_record_chunk_t structures can be buffered at any time. 
N#ifndef FDS_CHUNK_QUEUE_SIZE
N#define FDS_CHUNK_QUEUE_SIZE 8
N#endif
N
N// <o> FDS_MAX_USERS - Maximum number of callbacks that can be registered. 
N#ifndef FDS_MAX_USERS
N#define FDS_MAX_USERS 8
N#endif
N
N// <o> FDS_VIRTUAL_PAGES - Number of virtual flash pages to use. 
N// <i> One of the virtual pages is reserved by the system for garbage collection.
N// <i> Therefore, the minimum is two virtual pages: one page to store data and
N// <i> one page to be used by the system for garbage collection. The total amount
N// <i> of flash memory that is used by FDS amounts to @ref FDS_VIRTUAL_PAGES
N// <i> @ref FDS_VIRTUAL_PAGE_SIZE * 4 bytes.
N
N#ifndef FDS_VIRTUAL_PAGES
N#define FDS_VIRTUAL_PAGES 3
N#endif
N
N// <o> FDS_VIRTUAL_PAGE_SIZE  - The size of a virtual page of flash memory, expressed in number of 4-byte words.
N 
N
N// <i> By default, a virtual page is the same size as a physical page.
N// <i> The size of a virtual page must be a multiple of the size of a physical page.
N// <1024=> 1024 
N// <2048=> 2048 
N
N#ifndef FDS_VIRTUAL_PAGE_SIZE
N#define FDS_VIRTUAL_PAGE_SIZE 1024
N#endif
N
N#endif //FDS_ENABLED
N// </e>
N
N// <e> FSTORAGE_ENABLED - fstorage - Flash storage module
N//==========================================================
N#ifndef FSTORAGE_ENABLED
N#define FSTORAGE_ENABLED 1
N#endif
N#if  FSTORAGE_ENABLED
X#if  1
N// <o> FS_QUEUE_SIZE - Configures the size of the internal queue. 
N// <i> Increase this if there are many users, or if it is likely that many
N// <i> operation will be queued at once without waiting for the previous operations
N// <i> to complete. In general, increase the queue size if you frequently receive
N// <i> @ref FS_ERR_QUEUE_FULL errors when calling @ref fs_store or @ref fs_erase.
N
N#ifndef FS_QUEUE_SIZE
N#define FS_QUEUE_SIZE 4
N#endif
N
N// <o> FS_OP_MAX_RETRIES - Number attempts to execute an operation if the SoftDevice fails. 
N// <i> Increase this value if events return the @ref FS_ERR_OPERATION_TIMEOUT
N// <i> error often. The SoftDevice may fail to schedule flash access due to high BLE activity.
N
N#ifndef FS_OP_MAX_RETRIES
N#define FS_OP_MAX_RETRIES 3
N#endif
N
N// <o> FS_MAX_WRITE_SIZE_WORDS - Maximum number of words to be written to flash in a single operation. 
N// <i> Tweaking this value can increase the chances of the SoftDevice being
N// <i> able to fit flash operations in between radio activity. This value is bound by the
N// <i> maximum number of words which the SoftDevice can write to flash in a single call to
N// <i> @ref sd_flash_write, which is 256 words for nRF51 ICs and 1024 words for nRF52 ICs.
N
N#ifndef FS_MAX_WRITE_SIZE_WORDS
N#define FS_MAX_WRITE_SIZE_WORDS 1024
N#endif
N
N#endif //FSTORAGE_ENABLED
N// </e>
N
N// <q> HARDFAULT_HANDLER_ENABLED  - hardfault_default - HardFault default handler for debugging and release
N 
N
N#ifndef HARDFAULT_HANDLER_ENABLED
N#define HARDFAULT_HANDLER_ENABLED 0
N#endif
N
N// <e> HCI_MEM_POOL_ENABLED - hci_mem_pool - memory pool implementation used by HCI
N//==========================================================
N#ifndef HCI_MEM_POOL_ENABLED
N#define HCI_MEM_POOL_ENABLED 0
N#endif
N#if  HCI_MEM_POOL_ENABLED
X#if  0
S// <o> HCI_TX_BUF_SIZE - TX buffer size in bytes. 
S#ifndef HCI_TX_BUF_SIZE
S#define HCI_TX_BUF_SIZE 600
S#endif
S
S// <o> HCI_RX_BUF_SIZE - RX buffer size in bytes. 
S#ifndef HCI_RX_BUF_SIZE
S#define HCI_RX_BUF_SIZE 600
S#endif
S
S// <o> HCI_RX_BUF_QUEUE_SIZE - RX buffer queue size. 
S#ifndef HCI_RX_BUF_QUEUE_SIZE
S#define HCI_RX_BUF_QUEUE_SIZE 4
S#endif
S
N#endif //HCI_MEM_POOL_ENABLED
N// </e>
N
N// <e> HCI_SLIP_ENABLED - hci_slip - SLIP protocol implementation used by HCI
N//==========================================================
N#ifndef HCI_SLIP_ENABLED
N#define HCI_SLIP_ENABLED 0
N#endif
N#if  HCI_SLIP_ENABLED
X#if  0
S// <o> HCI_UART_BAUDRATE  - Default Baudrate
S 
S// <323584=> 1200 baud 
S// <643072=> 2400 baud 
S// <1290240=> 4800 baud 
S// <2576384=> 9600 baud 
S// <3862528=> 14400 baud 
S// <5152768=> 19200 baud 
S// <7716864=> 28800 baud 
S// <10289152=> 38400 baud 
S// <15400960=> 57600 baud 
S// <20615168=> 76800 baud 
S// <30801920=> 115200 baud 
S// <61865984=> 230400 baud 
S// <67108864=> 250000 baud 
S// <121634816=> 460800 baud 
S// <251658240=> 921600 baud 
S// <268435456=> 57600 baud 
S
S#ifndef HCI_UART_BAUDRATE
S#define HCI_UART_BAUDRATE 30801920
S#endif
S
S// <o> HCI_UART_FLOW_CONTROL  - Hardware Flow Control
S 
S// <0=> Disabled 
S// <1=> Enabled 
S
S#ifndef HCI_UART_FLOW_CONTROL
S#define HCI_UART_FLOW_CONTROL 0
S#endif
S
S// <o> HCI_UART_RX_PIN - UART RX pin 
S#ifndef HCI_UART_RX_PIN
S#define HCI_UART_RX_PIN 8
S#endif
S
S// <o> HCI_UART_TX_PIN - UART TX pin 
S#ifndef HCI_UART_TX_PIN
S#define HCI_UART_TX_PIN 6
S#endif
S
S// <o> HCI_UART_RTS_PIN - UART RTS pin 
S#ifndef HCI_UART_RTS_PIN
S#define HCI_UART_RTS_PIN 5
S#endif
S
S// <o> HCI_UART_CTS_PIN - UART CTS pin 
S#ifndef HCI_UART_CTS_PIN
S#define HCI_UART_CTS_PIN 7
S#endif
S
N#endif //HCI_SLIP_ENABLED
N// </e>
N
N// <e> HCI_TRANSPORT_ENABLED - hci_transport - HCI transport
N//==========================================================
N#ifndef HCI_TRANSPORT_ENABLED
N#define HCI_TRANSPORT_ENABLED 0
N#endif
N#if  HCI_TRANSPORT_ENABLED
X#if  0
S// <o> HCI_MAX_PACKET_SIZE_IN_BITS - Maximum size of a single application packet in bits. 
S#ifndef HCI_MAX_PACKET_SIZE_IN_BITS
S#define HCI_MAX_PACKET_SIZE_IN_BITS 8000
S#endif
S
N#endif //HCI_TRANSPORT_ENABLED
N// </e>
N
N// <q> LED_SOFTBLINK_ENABLED  - led_softblink - led_softblink module
N 
N
N#ifndef LED_SOFTBLINK_ENABLED
N#define LED_SOFTBLINK_ENABLED 0
N#endif
N
N// <q> LOW_POWER_PWM_ENABLED  - low_power_pwm - low_power_pwm module
N 
N
N#ifndef LOW_POWER_PWM_ENABLED
N#define LOW_POWER_PWM_ENABLED 0
N#endif
N
N// <e> MEM_MANAGER_ENABLED - mem_manager - Dynamic memory allocator
N//==========================================================
N#ifndef MEM_MANAGER_ENABLED
N#define MEM_MANAGER_ENABLED 0
N#endif
N#if  MEM_MANAGER_ENABLED
X#if  0
S// <o> MEMORY_MANAGER_SMALL_BLOCK_COUNT - Size of each memory blocks identified as 'small' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_SMALL_BLOCK_COUNT
S#define MEMORY_MANAGER_SMALL_BLOCK_COUNT 1
S#endif
S
S// <o> MEMORY_MANAGER_SMALL_BLOCK_SIZE -  Size of each memory blocks identified as 'small' block. 
S// <i>  Size of each memory blocks identified as 'small' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_SMALL_BLOCK_SIZE
S#define MEMORY_MANAGER_SMALL_BLOCK_SIZE 32
S#endif
S
S// <o> MEMORY_MANAGER_MEDIUM_BLOCK_COUNT - Size of each memory blocks identified as 'medium' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_MEDIUM_BLOCK_COUNT
S#define MEMORY_MANAGER_MEDIUM_BLOCK_COUNT 0
S#endif
S
S// <o> MEMORY_MANAGER_MEDIUM_BLOCK_SIZE -  Size of each memory blocks identified as 'medium' block. 
S// <i>  Size of each memory blocks identified as 'medium' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_MEDIUM_BLOCK_SIZE
S#define MEMORY_MANAGER_MEDIUM_BLOCK_SIZE 256
S#endif
S
S// <o> MEMORY_MANAGER_LARGE_BLOCK_COUNT - Size of each memory blocks identified as 'large' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_LARGE_BLOCK_COUNT
S#define MEMORY_MANAGER_LARGE_BLOCK_COUNT 0
S#endif
S
S// <o> MEMORY_MANAGER_LARGE_BLOCK_SIZE -  Size of each memory blocks identified as 'large' block. 
S// <i>  Size of each memory blocks identified as 'large' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_LARGE_BLOCK_SIZE
S#define MEMORY_MANAGER_LARGE_BLOCK_SIZE 256
S#endif
S
S// <q> MEM_MANAGER_ENABLE_LOGS  - Enable debug trace in the module.
S 
S
S#ifndef MEM_MANAGER_ENABLE_LOGS
S#define MEM_MANAGER_ENABLE_LOGS 0
S#endif
S
S// <q> MEM_MANAGER_DISABLE_API_PARAM_CHECK  - Disable API parameter checks in the module.
S 
S
S#ifndef MEM_MANAGER_DISABLE_API_PARAM_CHECK
S#define MEM_MANAGER_DISABLE_API_PARAM_CHECK 0
S#endif
S
N#endif //MEM_MANAGER_ENABLED
N// </e>
N
N// <e> NRF_CSENSE_ENABLED - nrf_csense - nrf_csense module
N//==========================================================
N#ifndef NRF_CSENSE_ENABLED
N#define NRF_CSENSE_ENABLED 0
N#endif
N#if  NRF_CSENSE_ENABLED
X#if  0
S// <o> NRF_CSENSE_PAD_HYSTERESIS - Minimal value of change to decide that pad was touched. 
S#ifndef NRF_CSENSE_PAD_HYSTERESIS
S#define NRF_CSENSE_PAD_HYSTERESIS 15
S#endif
S
S// <o> NRF_CSENSE_PAD_DEVIATION - Minimal value measured on pad to take its value while calculating step. 
S#ifndef NRF_CSENSE_PAD_DEVIATION
S#define NRF_CSENSE_PAD_DEVIATION 70
S#endif
S
S// <o> NRF_CSENSE_MIN_PAD_VALUE - Minimum normalized value on pad to take its value into account. 
S#ifndef NRF_CSENSE_MIN_PAD_VALUE
S#define NRF_CSENSE_MIN_PAD_VALUE 20
S#endif
S
S// <o> NRF_CSENSE_MAX_PADS_NUMBER - Maximum number of pads used for one instance. 
S#ifndef NRF_CSENSE_MAX_PADS_NUMBER
S#define NRF_CSENSE_MAX_PADS_NUMBER 20
S#endif
S
S// <o> NRF_CSENSE_MAX_VALUE - Maximum normalized value got from measurement. 
S#ifndef NRF_CSENSE_MAX_VALUE
S#define NRF_CSENSE_MAX_VALUE 1000
S#endif
S
S// <o> NRF_CSENSE_OUTPUT_PIN - Output pin used by lower module. 
S// <i> This is only used when running on NRF51.
S
S#ifndef NRF_CSENSE_OUTPUT_PIN
S#define NRF_CSENSE_OUTPUT_PIN 30
S#endif
S
N#endif //NRF_CSENSE_ENABLED
N// </e>
N
N// <e> NRF_DRV_CSENSE_ENABLED - nrf_drv_csense - Capacitive sensor module
N//==========================================================
N#ifndef NRF_DRV_CSENSE_ENABLED
N#define NRF_DRV_CSENSE_ENABLED 0
N#endif
N#if  NRF_DRV_CSENSE_ENABLED
X#if  0
S// <o> TIMER0_FOR_CSENSE - First TIMER instance used by the driver (except nRF51) 
S#ifndef TIMER0_FOR_CSENSE
S#define TIMER0_FOR_CSENSE 1
S#endif
S
S// <o> TIMER1_FOR_CSENSE - Second TIMER instance used by the driver (except nRF51) 
S#ifndef TIMER1_FOR_CSENSE
S#define TIMER1_FOR_CSENSE 2
S#endif
S
S// <o> MEASUREMENT_PERIOD - Single measurement period. 
S// <i> Time of single measurement can be calculated as T = (1/2)*MEASUREMENT_PERIOD*(1/f_OSC) where f_OSC = I_SOURCE / (2C*(VUP-VDOWN) ). I_SOURCE, VUP and VDOWN are values used to initialize COMP and C is capacitance of used pad.
S
S#ifndef MEASUREMENT_PERIOD
S#define MEASUREMENT_PERIOD 20
S#endif
S
N#endif //NRF_DRV_CSENSE_ENABLED
N// </e>
N
N// <q> SLIP_ENABLED  - slip - SLIP encoding decoding
N 
N
N#ifndef SLIP_ENABLED
N#define SLIP_ENABLED 0
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Log 
N
N//==========================================================
N// <e> NRF_LOG_ENABLED - nrf_log - Logging
N//==========================================================
N#ifndef NRF_LOG_ENABLED
N#define NRF_LOG_ENABLED 0
N#endif
N#if  NRF_LOG_ENABLED
X#if  0
S// <e> NRF_LOG_USES_COLORS - If enabled then ANSI escape code for colors is prefixed to every string
S//==========================================================
S#ifndef NRF_LOG_USES_COLORS
S#define NRF_LOG_USES_COLORS 0
S#endif
S#if  NRF_LOG_USES_COLORS
S// <o> NRF_LOG_COLOR_DEFAULT  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef NRF_LOG_COLOR_DEFAULT
S#define NRF_LOG_COLOR_DEFAULT 0
S#endif
S
S// <o> NRF_LOG_ERROR_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef NRF_LOG_ERROR_COLOR
S#define NRF_LOG_ERROR_COLOR 0
S#endif
S
S// <o> NRF_LOG_WARNING_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef NRF_LOG_WARNING_COLOR
S#define NRF_LOG_WARNING_COLOR 0
S#endif
S
S#endif //NRF_LOG_USES_COLORS
S// </e>
S
S// <o> NRF_LOG_DEFAULT_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef NRF_LOG_DEFAULT_LEVEL
S#define NRF_LOG_DEFAULT_LEVEL 3
S#endif
S
S// <e> NRF_LOG_DEFERRED - Enable deffered logger.
S
S// <i> Log data is buffered and can be processed in idle.
S//==========================================================
S#ifndef NRF_LOG_DEFERRED
S#define NRF_LOG_DEFERRED 1
S#endif
S#if  NRF_LOG_DEFERRED
S// <o> NRF_LOG_DEFERRED_BUFSIZE - Size of the buffer for logs in words. 
S// <i> Must be power of 2
S
S#ifndef NRF_LOG_DEFERRED_BUFSIZE
S#define NRF_LOG_DEFERRED_BUFSIZE 256
S#endif
S
S#endif //NRF_LOG_DEFERRED
S// </e>
S
S// <q> NRF_LOG_USES_TIMESTAMP  - Enable timestamping
S 
S
S// <i> Function for getting the timestamp is provided by the user
S
S#ifndef NRF_LOG_USES_TIMESTAMP
S#define NRF_LOG_USES_TIMESTAMP 0
S#endif
S
N#endif //NRF_LOG_ENABLED
N// </e>
N
N// <h> nrf_log_backend - Logging sink
N
N//==========================================================
N// <o> NRF_LOG_BACKEND_MAX_STRING_LENGTH - Buffer for storing single output string 
N// <i> Logger backend RAM usage is determined by this value.
N
N#ifndef NRF_LOG_BACKEND_MAX_STRING_LENGTH
N#define NRF_LOG_BACKEND_MAX_STRING_LENGTH 256
N#endif
N
N// <o> NRF_LOG_TIMESTAMP_DIGITS - Number of digits for timestamp 
N// <i> If higher resolution timestamp source is used it might be needed to increase that
N
N#ifndef NRF_LOG_TIMESTAMP_DIGITS
N#define NRF_LOG_TIMESTAMP_DIGITS 8
N#endif
N
N// <e> NRF_LOG_BACKEND_SERIAL_USES_UART - If enabled data is printed over UART
N//==========================================================
N#ifndef NRF_LOG_BACKEND_SERIAL_USES_UART
N#define NRF_LOG_BACKEND_SERIAL_USES_UART 1
N#endif
N#if  NRF_LOG_BACKEND_SERIAL_USES_UART
X#if  1
N// <o> NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE  - Default Baudrate
N 
N// <323584=> 1200 baud 
N// <643072=> 2400 baud 
N// <1290240=> 4800 baud 
N// <2576384=> 9600 baud 
N// <3862528=> 14400 baud 
N// <5152768=> 19200 baud 
N// <7716864=> 28800 baud 
N// <10289152=> 38400 baud 
N// <15400960=> 57600 baud 
N// <20615168=> 76800 baud 
N// <30801920=> 115200 baud 
N// <61865984=> 230400 baud 
N// <67108864=> 250000 baud 
N// <121634816=> 460800 baud 
N// <251658240=> 921600 baud 
N// <268435456=> 57600 baud 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE
N#define NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE 30801920
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_TX_PIN - UART TX pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_TX_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_TX_PIN 6
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_RX_PIN - UART RX pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_RX_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_RX_PIN 8
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN - UART RTS pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN 5
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN - UART CTS pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN 7
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL  - Hardware Flow Control
N 
N// <0=> Disabled 
N// <1=> Enabled 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL
N#define NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL 0
N#endif
N
N// <o> NRF_LOG_BACKEND_UART_INSTANCE  - UART instance used
N 
N// <0=> 0 
N
N#ifndef NRF_LOG_BACKEND_UART_INSTANCE
N#define NRF_LOG_BACKEND_UART_INSTANCE 0
N#endif
N
N#endif //NRF_LOG_BACKEND_SERIAL_USES_UART
N// </e>
N
N// <q> NRF_LOG_BACKEND_SERIAL_USES_RTT  - If enabled data is printed using RTT
N 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_USES_RTT
N#define NRF_LOG_BACKEND_SERIAL_USES_RTT 0
N#endif
N
N// </h> 
N//==========================================================
N
N// </h> 
N//==========================================================
N
N// <<< end of configuration section >>>
N#endif //SDK_CONFIG_H
N
L 13 "..\..\..\..\..\..\components\libraries\crc16\crc16.c" 2
N#if CRC16_ENABLED
X#if 1
N#include "crc16.h"
L 1 "..\..\..\..\..\..\components\libraries\crc16\crc16.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup crc16 CRC16 compute
N * @{
N * @ingroup hci_transport
N *
N * @brief    This module implements CRC-16-CCITT (polynomial 0x1021) with 0xFFFF initial value.
N *           The data can be passed in multiple blocks.
N */
N
N#ifndef CRC16_H__
N#define CRC16_H__
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060016
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 27 "..\..\..\..\..\..\components\libraries\crc16\crc16.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**@brief Function for calculating CRC-16 in blocks.
N *
N * Feed each consecutive data block into this function, along with the current value of p_crc as
N * returned by the previous call of this function. The first call of this function should pass NULL
N * as the initial value of the crc in p_crc.
N *
N * @param[in] p_data The input data block for computation.
N * @param[in] size   The size of the input data block in bytes.
N * @param[in] p_crc  The previous calculated CRC-16 value or NULL if first call.
N *
N * @return The updated CRC-16 value, based on the input supplied.
N */
Nuint16_t crc16_compute(uint8_t const * p_data, uint32_t size, uint16_t const * p_crc);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // CRC16_H__
N
N/** @} */
L 15 "..\..\..\..\..\..\components\libraries\crc16\crc16.c" 2
N
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060016
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 17 "..\..\..\..\..\..\components\libraries\crc16\crc16.c" 2
N
Nuint16_t crc16_compute(uint8_t const * p_data, uint32_t size, uint16_t const * p_crc)
N{
N    uint16_t crc = (p_crc == NULL) ? 0xFFFF : *p_crc;
X    uint16_t crc = (p_crc == 0) ? 0xFFFF : *p_crc;
N
N    for (uint32_t i = 0; i < size; i++)
N    {
N        crc  = (uint8_t)(crc >> 8) | (crc << 8);
N        crc ^= p_data[i];
N        crc ^= (uint8_t)(crc & 0xFF) >> 4;
N        crc ^= (crc << 8) << 4;
N        crc ^= ((crc & 0xFF) << 4) << 1;
N    }
N
N    return crc;
N}
N#endif //CRC16_ENABLED
