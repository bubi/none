; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\nrf_drv_uart.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\nrf_drv_uart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\nrf_drv_uart.crf ..\..\..\..\..\..\components\drivers_nrf\uart\nrf_drv_uart.c]
                          THUMB

                          AREA ||i.UARTE0_UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UARTE0_UART0_IRQHandler PROC
;;;843    
;;;844    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;845    {
;;;846        CODE_FOR_UARTE_INT
000002  4806              LDR      r0,|L1.28|
000004  7f00              LDRB     r0,[r0,#0x1c]  ; m_cb
000006  b120              CBZ      r0,|L1.18|
000008  4904              LDR      r1,|L1.28|
00000a  4805              LDR      r0,|L1.32|
00000c  f7fffffe          BL       uarte_irq_handler
000010  e003              B        |L1.26|
                  |L1.18|
;;;847        (
;;;848            UART0_INSTANCE_INDEX,
;;;849            uarte_irq_handler(NRF_UARTE0, &m_cb[UART0_INSTANCE_INDEX]);
;;;850        )
;;;851        CODE_FOR_UART
000012  4902              LDR      r1,|L1.28|
000014  4802              LDR      r0,|L1.32|
000016  f7fffffe          BL       uart_irq_handler
                  |L1.26|
;;;852        (
;;;853            uart_irq_handler(NRF_UART0, &m_cb[UART0_INSTANCE_INDEX]);
;;;854        )
;;;855    }
00001a  bd10              POP      {r4,pc}
;;;856    #endif //UART_ENABLED
                          ENDP

                  |L1.28|
                          DCD      m_cb
                  |L1.32|
                          DCD      0x40002000

                          AREA ||i.apply_config||, CODE, READONLY, ALIGN=2

                  apply_config PROC
;;;66     
;;;67     __STATIC_INLINE void apply_config(nrf_drv_uart_t const * p_instance, nrf_drv_uart_config_t const * p_config)
000000  b570              PUSH     {r4-r6,lr}
;;;68     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;69         nrf_gpio_pin_set(p_config->pseltxd);
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       nrf_gpio_pin_set
;;;70         nrf_gpio_cfg_output(p_config->pseltxd);
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       nrf_gpio_cfg_output
;;;71         nrf_gpio_cfg_input(p_config->pselrxd, NRF_GPIO_PIN_NOPULL);
000012  2100              MOVS     r1,#0
000014  6860              LDR      r0,[r4,#4]
000016  f7fffffe          BL       nrf_gpio_cfg_input
;;;72     
;;;73         CODE_FOR_UARTE
00001a  7928              LDRB     r0,[r5,#4]
00001c  4927              LDR      r1,|L2.188|
00001e  eb011040          ADD      r0,r1,r0,LSL #5
000022  7f00              LDRB     r0,[r0,#0x1c]
000024  b320              CBZ      r0,|L2.112|
000026  6828              LDR      r0,[r5,#0]
000028  69a1              LDR      r1,[r4,#0x18]
00002a  f8c01524          STR      r1,[r0,#0x524]
00002e  bf00              NOP      
000030  7d61              LDRB     r1,[r4,#0x15]
000032  7d22              LDRB     r2,[r4,#0x14]
000034  6828              LDR      r0,[r5,#0]
000036  ea410302          ORR      r3,r1,r2
00003a  f8c0356c          STR      r3,[r0,#0x56c]
00003e  bf00              NOP      
000040  e9d41200          LDRD     r1,r2,[r4,#0]
000044  6828              LDR      r0,[r5,#0]
000046  f7fffffe          BL       nrf_uarte_txrx_pins_set
00004a  7d20              LDRB     r0,[r4,#0x14]
00004c  2801              CMP      r0,#1
00004e  d133              BNE      |L2.184|
000050  2100              MOVS     r1,#0
000052  68a0              LDR      r0,[r4,#8]
000054  f7fffffe          BL       nrf_gpio_cfg_input
000058  68e0              LDR      r0,[r4,#0xc]
00005a  f7fffffe          BL       nrf_gpio_pin_set
00005e  68e0              LDR      r0,[r4,#0xc]
000060  f7fffffe          BL       nrf_gpio_cfg_output
000064  e9d42102          LDRD     r2,r1,[r4,#8]
000068  6828              LDR      r0,[r5,#0]
00006a  f7fffffe          BL       nrf_uarte_hwfc_pins_set
00006e  e023              B        |L2.184|
                  |L2.112|
;;;74         (
;;;75             nrf_uarte_baudrate_set(p_instance->reg.p_uarte, (nrf_uarte_baudrate_t)p_config->baudrate);
;;;76             nrf_uarte_configure(p_instance->reg.p_uarte, (nrf_uarte_parity_t)p_config->parity,
;;;77                                 (nrf_uarte_hwfc_t)p_config->hwfc);
;;;78             nrf_uarte_txrx_pins_set(p_instance->reg.p_uarte, p_config->pseltxd, p_config->pselrxd);
;;;79             if (p_config->hwfc == NRF_UART_HWFC_ENABLED)
;;;80             {
;;;81                 nrf_gpio_cfg_input(p_config->pselcts, NRF_GPIO_PIN_NOPULL);
;;;82                 nrf_gpio_pin_set(p_config->pselrts);
;;;83                 nrf_gpio_cfg_output(p_config->pselrts);
;;;84                 nrf_uarte_hwfc_pins_set(p_instance->reg.p_uarte, p_config->pselrts, p_config->pselcts);
;;;85             }
;;;86         )
;;;87         CODE_FOR_UART
000070  6828              LDR      r0,[r5,#0]
000072  69a1              LDR      r1,[r4,#0x18]
000074  f8c01524          STR      r1,[r0,#0x524]
000078  bf00              NOP      
00007a  7d61              LDRB     r1,[r4,#0x15]
00007c  7d22              LDRB     r2,[r4,#0x14]
00007e  6828              LDR      r0,[r5,#0]
000080  ea410302          ORR      r3,r1,r2
000084  f8c0356c          STR      r3,[r0,#0x56c]
000088  bf00              NOP      
00008a  e9d41200          LDRD     r1,r2,[r4,#0]
00008e  6828              LDR      r0,[r5,#0]
000090  f7fffffe          BL       nrf_uart_txrx_pins_set
000094  7d20              LDRB     r0,[r4,#0x14]
000096  2801              CMP      r0,#1
000098  d10e              BNE      |L2.184|
00009a  2100              MOVS     r1,#0
00009c  68a0              LDR      r0,[r4,#8]
00009e  f7fffffe          BL       nrf_gpio_cfg_input
0000a2  68e0              LDR      r0,[r4,#0xc]
0000a4  f7fffffe          BL       nrf_gpio_pin_set
0000a8  68e0              LDR      r0,[r4,#0xc]
0000aa  f7fffffe          BL       nrf_gpio_cfg_output
0000ae  e9d42102          LDRD     r2,r1,[r4,#8]
0000b2  6828              LDR      r0,[r5,#0]
0000b4  f7fffffe          BL       nrf_uart_hwfc_pins_set
                  |L2.184|
;;;88         (
;;;89             nrf_uart_baudrate_set(p_instance->reg.p_uart, p_config->baudrate);
;;;90             nrf_uart_configure(p_instance->reg.p_uart, p_config->parity, p_config->hwfc);
;;;91             nrf_uart_txrx_pins_set(p_instance->reg.p_uart, p_config->pseltxd, p_config->pselrxd);
;;;92             if (p_config->hwfc == NRF_UART_HWFC_ENABLED)
;;;93             {
;;;94                 nrf_gpio_cfg_input(p_config->pselcts, NRF_GPIO_PIN_NOPULL);
;;;95                 nrf_gpio_pin_set(p_config->pselrts);
;;;96                 nrf_gpio_cfg_output(p_config->pselrts);
;;;97                 nrf_uart_hwfc_pins_set(p_instance->reg.p_uart, p_config->pselrts, p_config->pselcts);
;;;98             }
;;;99         )
;;;100    }
0000b8  bd70              POP      {r4-r6,pc}
;;;101    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L2.188|
                          DCD      m_cb

                          AREA ||i.interrupts_enable||, CODE, READONLY, ALIGN=2

                  interrupts_enable PROC
;;;101    
;;;102    __STATIC_INLINE void interrupts_enable(const nrf_drv_uart_t * p_instance, uint8_t interrupt_priority)
000000  b570              PUSH     {r4-r6,lr}
;;;103    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;104        CODE_FOR_UARTE
000006  7920              LDRB     r0,[r4,#4]
000008  491d              LDR      r1,|L3.128|
00000a  eb011040          ADD      r0,r1,r0,LSL #5
00000e  7f00              LDRB     r0,[r0,#0x1c]
000010  b1f8              CBZ      r0,|L3.82|
000012  f44f7188          MOV      r1,#0x110
000016  6820              LDR      r0,[r4,#0]
000018  f7fffffe          BL       nrf_uarte_event_clear
00001c  f44f7190          MOV      r1,#0x120
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       nrf_uarte_event_clear
000026  f44f7192          MOV      r1,#0x124
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       nrf_uarte_event_clear
000030  f44f71a2          MOV      r1,#0x144
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       nrf_uarte_event_clear
00003a  4912              LDR      r1,|L3.132|
00003c  6820              LDR      r0,[r4,#0]
00003e  f7fffffe          BL       nrf_uarte_int_enable
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       nrf_drv_get_IRQn
000048  4606              MOV      r6,r0
00004a  4629              MOV      r1,r5
00004c  f7fffffe          BL       nrf_drv_common_irq_enable
000050  e014              B        |L3.124|
                  |L3.82|
;;;105        (
;;;106            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDRX);
;;;107            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDTX);
;;;108            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ERROR);
;;;109            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_RXTO);
;;;110            nrf_uarte_int_enable(p_instance->reg.p_uarte, NRF_UARTE_INT_ENDRX_MASK |
;;;111                                             NRF_UARTE_INT_ENDTX_MASK |
;;;112                                             NRF_UARTE_INT_ERROR_MASK |
;;;113                                             NRF_UARTE_INT_RXTO_MASK);
;;;114            nrf_drv_common_irq_enable(nrf_drv_get_IRQn((void *)p_instance->reg.p_uarte), interrupt_priority);
;;;115        )
;;;116        CODE_FOR_UART
000052  f44f718e          MOV      r1,#0x11c
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       nrf_uart_event_clear
00005c  f44f71a2          MOV      r1,#0x144
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       nrf_uart_event_clear
000066  4908              LDR      r1,|L3.136|
000068  6820              LDR      r0,[r4,#0]
00006a  f7fffffe          BL       nrf_uart_int_enable
00006e  6820              LDR      r0,[r4,#0]
000070  f7fffffe          BL       nrf_drv_get_IRQn
000074  4606              MOV      r6,r0
000076  4629              MOV      r1,r5
000078  f7fffffe          BL       nrf_drv_common_irq_enable
                  |L3.124|
;;;117        (
;;;118            nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY);
;;;119            nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_RXTO);
;;;120            nrf_uart_int_enable(p_instance->reg.p_uart, NRF_UART_INT_MASK_TXDRDY |
;;;121                                           NRF_UART_INT_MASK_RXTO);
;;;122            nrf_drv_common_irq_enable(nrf_drv_get_IRQn((void *)p_instance->reg.p_uart), interrupt_priority);
;;;123        )
;;;124    }
00007c  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP

00007e  0000              DCW      0x0000
                  |L3.128|
                          DCD      m_cb
                  |L3.132|
                          DCD      0x00020310
                  |L3.136|
                          DCD      0x00020080

                          AREA ||i.nrf_drv_common_irq_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_common_irq_disable PROC
;;;184    
;;;185    __STATIC_INLINE void nrf_drv_common_irq_disable(IRQn_Type IRQn)
000000  bf00              NOP      
000002  f000021f          AND      r2,r0,#0x1f
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  4a03              LDR      r2,|L4.24|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
;;;186    {
;;;187        NVIC_DisableIRQ(IRQn);
;;;188    }
000014  4770              BX       lr
;;;189    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0xe000e180

                          AREA ||i.nrf_drv_get_IRQn||, CODE, READONLY, ALIGN=1

                  nrf_drv_get_IRQn PROC
;;;199    
;;;200    __STATIC_INLINE IRQn_Type nrf_drv_get_IRQn(void const * const pinst)
000000  4601              MOV      r1,r0
;;;201    {
;;;202        uint8_t ret = (uint8_t)((uint32_t)pinst>>12U);
000002  f3c13207          UBFX     r2,r1,#12,#8
;;;203        return (IRQn_Type) ret;
000006  b250              SXTB     r0,r2
;;;204    }
000008  4770              BX       lr
;;;205    
                          ENDP


                          AREA ||i.nrf_drv_uart_errorsrc_get||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_errorsrc_get PROC
;;;607    
;;;608    uint32_t nrf_drv_uart_errorsrc_get(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;609    {
000002  4604              MOV      r4,r0
;;;610        uint32_t errsrc;
;;;611        CODE_FOR_UARTE
000004  7920              LDRB     r0,[r4,#4]
000006  490d              LDR      r1,|L6.60|
000008  eb011040          ADD      r0,r1,r0,LSL #5
00000c  7f00              LDRB     r0,[r0,#0x1c]
00000e  b148              CBZ      r0,|L6.36|
000010  f44f7192          MOV      r1,#0x124
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       nrf_uarte_event_clear
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       nrf_uarte_errorsrc_get_and_clear
000020  4605              MOV      r5,r0
000022  e008              B        |L6.54|
                  |L6.36|
;;;612        (
;;;613            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ERROR);
;;;614            errsrc = nrf_uarte_errorsrc_get_and_clear(p_instance->reg.p_uarte);
;;;615        )
;;;616        CODE_FOR_UART
000024  f44f7192          MOV      r1,#0x124
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       nrf_uart_event_clear
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       nrf_uart_errorsrc_get_and_clear
000034  4605              MOV      r5,r0
                  |L6.54|
;;;617        (
;;;618            nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_ERROR);
;;;619            errsrc = nrf_uart_errorsrc_get_and_clear(p_instance->reg.p_uart);
;;;620        )
;;;621        return errsrc;
000036  4628              MOV      r0,r5
;;;622    }
000038  bd70              POP      {r4-r6,pc}
;;;623    
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_init PROC
;;;200    
;;;201    ret_code_t nrf_drv_uart_init(const nrf_drv_uart_t * p_instance, nrf_drv_uart_config_t const * p_config,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;202                                 nrf_uart_event_handler_t event_handler)
;;;203    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;204        ASSERT(p_config);
;;;205        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
00000a  7928              LDRB     r0,[r5,#4]
00000c  491a              LDR      r1,|L7.120|
00000e  eb011440          ADD      r4,r1,r0,LSL #5
;;;206    
;;;207        if (p_cb->state != NRF_DRV_STATE_UNINITIALIZED)
000012  7ee0              LDRB     r0,[r4,#0x1b]
000014  b110              CBZ      r0,|L7.28|
;;;208        {
;;;209            return NRF_ERROR_INVALID_STATE;
000016  2008              MOVS     r0,#8
                  |L7.24|
;;;210        }
;;;211    
;;;212    #if (defined(UARTE_IN_USE) && defined(UART_IN_USE))
;;;213        p_cb->use_easy_dma = p_config->use_easy_dma;
;;;214    #endif
;;;215        apply_config(p_instance, p_config);
;;;216    
;;;217        p_cb->handler = event_handler;
;;;218        p_cb->p_context = p_config->p_context;
;;;219    
;;;220        if (p_cb->handler)
;;;221        {
;;;222            interrupts_enable(p_instance, p_config->interrupt_priority);
;;;223        }
;;;224    
;;;225        uart_enable(p_instance);
;;;226        p_cb->rx_buffer_length = 0;
;;;227        p_cb->rx_secondary_buffer_length = 0;
;;;228        p_cb->tx_buffer_length = 0;
;;;229        p_cb->state = NRF_DRV_STATE_INITIALIZED;
;;;230        p_cb->rx_enabled = false;
;;;231        return NRF_SUCCESS;
;;;232    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L7.28|
00001c  7f70              LDRB     r0,[r6,#0x1d]         ;213
00001e  7720              STRB     r0,[r4,#0x1c]         ;213
000020  4631              MOV      r1,r6                 ;215
000022  4628              MOV      r0,r5                 ;215
000024  f7fffffe          BL       apply_config
000028  6067              STR      r7,[r4,#4]            ;217
00002a  6930              LDR      r0,[r6,#0x10]         ;218
00002c  6020              STR      r0,[r4,#0]            ;218
00002e  6860              LDR      r0,[r4,#4]            ;220
000030  b118              CBZ      r0,|L7.58|
000032  7f31              LDRB     r1,[r6,#0x1c]         ;222
000034  4628              MOV      r0,r5                 ;222
000036  f7fffffe          BL       interrupts_enable
                  |L7.58|
00003a  bf00              NOP                            ;225
00003c  7928              LDRB     r0,[r5,#4]            ;225
00003e  490e              LDR      r1,|L7.120|
000040  eb011040          ADD      r0,r1,r0,LSL #5       ;225
000044  7f00              LDRB     r0,[r0,#0x1c]         ;225
000046  b128              CBZ      r0,|L7.84|
000048  6828              LDR      r0,[r5,#0]            ;225
00004a  2108              MOVS     r1,#8                 ;225
00004c  f8c01500          STR      r1,[r0,#0x500]        ;225
000050  bf00              NOP                            ;225
000052  e005              B        |L7.96|
                  |L7.84|
000054  6828              LDR      r0,[r5,#0]            ;225
000056  2104              MOVS     r1,#4                 ;225
000058  f8c01500          STR      r1,[r0,#0x500]        ;225
00005c  bf00              NOP                            ;225
00005e  bf00              NOP                            ;225
                  |L7.96|
000060  bf00              NOP                            ;225
000062  2000              MOVS     r0,#0                 ;226
000064  75e0              STRB     r0,[r4,#0x17]         ;226
000066  7620              STRB     r0,[r4,#0x18]         ;227
000068  75a0              STRB     r0,[r4,#0x16]         ;228
00006a  2001              MOVS     r0,#1                 ;229
00006c  76e0              STRB     r0,[r4,#0x1b]         ;229
00006e  2000              MOVS     r0,#0                 ;230
000070  76a0              STRB     r0,[r4,#0x1a]         ;230
000072  bf00              NOP                            ;231
000074  e7d0              B        |L7.24|
;;;233    
                          ENDP

000076  0000              DCW      0x0000
                  |L7.120|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx PROC
;;;503    
;;;504    ret_code_t nrf_drv_uart_rx(const nrf_drv_uart_t * p_instance, uint8_t * p_data, uint8_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;505    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;506        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
00000a  7920              LDRB     r0,[r4,#4]
00000c  492f              LDR      r1,|L8.204|
00000e  eb011540          ADD      r5,r1,r0,LSL #5
;;;507    
;;;508        ASSERT(m_cb[p_instance->drv_inst_idx].state == NRF_DRV_STATE_INITIALIZED);
;;;509        ASSERT(length>0);
;;;510    
;;;511        CODE_FOR_UARTE
000012  7920              LDRB     r0,[r4,#4]
000014  eb011040          ADD      r0,r1,r0,LSL #5
000018  7f00              LDRB     r0,[r0,#0x1c]
00001a  b138              CBZ      r0,|L8.44|
00001c  0c30              LSRS     r0,r6,#16
00001e  0400              LSLS     r0,r0,#16
000020  f1b05f00          CMP      r0,#0x20000000
000024  d002              BEQ      |L8.44|
000026  2010              MOVS     r0,#0x10
                  |L8.40|
;;;512        (
;;;513            // EasyDMA requires that transfer buffers are placed in DataRAM,
;;;514            // signal error if the are not.
;;;515            if (!IS_EASY_DMA_RAM_ADDRESS(p_data))
;;;516            {
;;;517                return NRF_ERROR_INVALID_ADDR;
;;;518            }
;;;519        )
;;;520    
;;;521        bool second_buffer = false;
;;;522    
;;;523        if (p_cb->handler)
;;;524        {
;;;525            CODE_FOR_UARTE
;;;526            (
;;;527                nrf_uarte_int_disable(p_instance->reg.p_uarte, NRF_UARTE_INT_ERROR_MASK | NRF_UARTE_INT_ENDRX_MASK);
;;;528            )
;;;529            CODE_FOR_UART
;;;530            (
;;;531                nrf_uart_int_disable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;532            )
;;;533        }
;;;534        if (p_cb->rx_buffer_length != 0)
;;;535        {
;;;536            if (p_cb->rx_secondary_buffer_length != 0)
;;;537            {
;;;538                if (p_cb->handler)
;;;539                {
;;;540                    CODE_FOR_UARTE
;;;541                    (
;;;542                        nrf_uarte_int_enable(p_instance->reg.p_uarte, NRF_UARTE_INT_ERROR_MASK | NRF_UARTE_INT_ENDRX_MASK);
;;;543                    )
;;;544                    CODE_FOR_UART
;;;545                    (
;;;546                        nrf_uart_int_enable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;547                    )
;;;548                }
;;;549                return NRF_ERROR_BUSY;
;;;550            }
;;;551            second_buffer = true;
;;;552        }
;;;553    
;;;554        if (!second_buffer)
;;;555        {
;;;556            p_cb->rx_buffer_length = length;
;;;557            p_cb->p_rx_buffer      = p_data;
;;;558            p_cb->rx_counter       = 0;
;;;559            p_cb->rx_secondary_buffer_length = 0;
;;;560        }
;;;561        else
;;;562        {
;;;563            p_cb->p_rx_secondary_buffer = p_data;
;;;564            p_cb->rx_secondary_buffer_length = length;
;;;565        }
;;;566    
;;;567        CODE_FOR_UARTE
;;;568        (
;;;569            return nrf_drv_uart_rx_for_uarte(p_instance, p_data, length, second_buffer);
;;;570        )
;;;571        CODE_FOR_UART
;;;572        (
;;;573            return nrf_drv_uart_rx_for_uart(p_instance, p_data, length, second_buffer);
;;;574        )
;;;575    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L8.44|
00002c  f04f0800          MOV      r8,#0                 ;521
000030  6868              LDR      r0,[r5,#4]            ;523
000032  b180              CBZ      r0,|L8.86|
000034  7920              LDRB     r0,[r4,#4]            ;525
000036  4925              LDR      r1,|L8.204|
000038  eb011040          ADD      r0,r1,r0,LSL #5       ;525
00003c  7f00              LDRB     r0,[r0,#0x1c]         ;525
00003e  b128              CBZ      r0,|L8.76|
000040  f44f7104          MOV      r1,#0x210             ;525
000044  6820              LDR      r0,[r4,#0]            ;525
000046  f7fffffe          BL       nrf_uarte_int_disable
00004a  e004              B        |L8.86|
                  |L8.76|
00004c  f44f7101          MOV      r1,#0x204             ;529
000050  6820              LDR      r0,[r4,#0]            ;529
000052  f7fffffe          BL       nrf_uart_int_disable
                  |L8.86|
000056  7de8              LDRB     r0,[r5,#0x17]         ;534
000058  b1c0              CBZ      r0,|L8.140|
00005a  7e28              LDRB     r0,[r5,#0x18]         ;536
00005c  b1a0              CBZ      r0,|L8.136|
00005e  6868              LDR      r0,[r5,#4]            ;538
000060  b180              CBZ      r0,|L8.132|
000062  7920              LDRB     r0,[r4,#4]            ;540
000064  4919              LDR      r1,|L8.204|
000066  eb011040          ADD      r0,r1,r0,LSL #5       ;540
00006a  7f00              LDRB     r0,[r0,#0x1c]         ;540
00006c  b128              CBZ      r0,|L8.122|
00006e  f44f7104          MOV      r1,#0x210             ;540
000072  6820              LDR      r0,[r4,#0]            ;540
000074  f7fffffe          BL       nrf_uarte_int_enable
000078  e004              B        |L8.132|
                  |L8.122|
00007a  f44f7101          MOV      r1,#0x204             ;544
00007e  6820              LDR      r0,[r4,#0]            ;544
000080  f7fffffe          BL       nrf_uart_int_enable
                  |L8.132|
000084  2011              MOVS     r0,#0x11              ;549
000086  e7cf              B        |L8.40|
                  |L8.136|
000088  f04f0801          MOV      r8,#1                 ;551
                  |L8.140|
00008c  f1b80f00          CMP      r8,#0                 ;554
000090  d105              BNE      |L8.158|
000092  75ef              STRB     r7,[r5,#0x17]         ;556
000094  60ee              STR      r6,[r5,#0xc]          ;557
000096  2000              MOVS     r0,#0                 ;558
000098  7668              STRB     r0,[r5,#0x19]         ;558
00009a  7628              STRB     r0,[r5,#0x18]         ;559
00009c  e001              B        |L8.162|
                  |L8.158|
00009e  612e              STR      r6,[r5,#0x10]         ;563
0000a0  762f              STRB     r7,[r5,#0x18]         ;564
                  |L8.162|
0000a2  7920              LDRB     r0,[r4,#4]            ;567
0000a4  4909              LDR      r1,|L8.204|
0000a6  eb011040          ADD      r0,r1,r0,LSL #5       ;567
0000aa  7f00              LDRB     r0,[r0,#0x1c]         ;567
0000ac  b130              CBZ      r0,|L8.188|
0000ae  4643              MOV      r3,r8                 ;567
0000b0  463a              MOV      r2,r7                 ;567
0000b2  4631              MOV      r1,r6                 ;567
0000b4  4620              MOV      r0,r4                 ;567
0000b6  f7fffffe          BL       nrf_drv_uart_rx_for_uarte
0000ba  e7b5              B        |L8.40|
                  |L8.188|
0000bc  4643              MOV      r3,r8                 ;571
0000be  463a              MOV      r2,r7                 ;571
0000c0  4631              MOV      r1,r6                 ;571
0000c2  4620              MOV      r0,r4                 ;571
0000c4  f7fffffe          BL       nrf_drv_uart_rx_for_uart
0000c8  e7ae              B        |L8.40|
;;;576    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L8.204|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_abort||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_abort PROC
;;;674    
;;;675    void nrf_drv_uart_rx_abort(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;676    {
000002  4604              MOV      r4,r0
;;;677        CODE_FOR_UARTE
000004  7920              LDRB     r0,[r4,#4]
000006  490a              LDR      r1,|L9.48|
000008  eb011040          ADD      r0,r1,r0,LSL #5
00000c  7f00              LDRB     r0,[r0,#0x1c]
00000e  b120              CBZ      r0,|L9.26|
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       nrf_uarte_task_trigger
000018  e008              B        |L9.44|
                  |L9.26|
;;;678        (
;;;679            nrf_uarte_task_trigger(p_instance->reg.p_uarte, NRF_UARTE_TASK_STOPRX);
;;;680        )
;;;681        CODE_FOR_UART
00001a  f44f7101          MOV      r1,#0x204
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       nrf_uart_int_disable
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       nrf_uart_task_trigger
                  |L9.44|
;;;682        (
;;;683            nrf_uart_int_disable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;684            nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPRX);
;;;685        )
;;;686    }
00002c  bd10              POP      {r4,pc}
;;;687    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_disable PROC
;;;593    
;;;594    void nrf_drv_uart_rx_disable(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;595    {
000002  4604              MOV      r4,r0
;;;596        //Easy dma mode does not support enabling receiver without setting up buffer.
;;;597        CODE_FOR_UARTE
000004  7920              LDRB     r0,[r4,#4]
000006  4908              LDR      r1,|L10.40|
000008  eb011040          ADD      r0,r1,r0,LSL #5
00000c  7f00              LDRB     r0,[r0,#0x1c]
00000e  b948              CBNZ     r0,|L10.36|
;;;598        (
;;;599            ASSERT(false);
;;;600        )
;;;601        CODE_FOR_UART
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       nrf_uart_task_trigger
000018  2000              MOVS     r0,#0
00001a  7921              LDRB     r1,[r4,#4]
00001c  4a02              LDR      r2,|L10.40|
00001e  eb021141          ADD      r1,r2,r1,LSL #5
000022  7688              STRB     r0,[r1,#0x1a]
                  |L10.36|
;;;602        (
;;;603            nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPRX);
;;;604            m_cb[p_instance->drv_inst_idx].rx_enabled = false;
;;;605        )
;;;606    }
000024  bd10              POP      {r4,pc}
;;;607    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_enable PROC
;;;576    
;;;577    void nrf_drv_uart_rx_enable(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;578    {
000002  4604              MOV      r4,r0
;;;579        //Easy dma mode does not support enabling receiver without setting up buffer.
;;;580        CODE_FOR_UARTE
000004  7920              LDRB     r0,[r4,#4]
000006  490a              LDR      r1,|L11.48|
000008  eb011040          ADD      r0,r1,r0,LSL #5
00000c  7f00              LDRB     r0,[r0,#0x1c]
00000e  b968              CBNZ     r0,|L11.44|
;;;581        (
;;;582            ASSERT(false);
;;;583        )
;;;584        CODE_FOR_UART
000010  7920              LDRB     r0,[r4,#4]
000012  eb011040          ADD      r0,r1,r0,LSL #5
000016  7e80              LDRB     r0,[r0,#0x1a]
000018  b940              CBNZ     r0,|L11.44|
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rx_enable
000020  2001              MOVS     r0,#1
000022  7921              LDRB     r1,[r4,#4]
000024  4a02              LDR      r2,|L11.48|
000026  eb021141          ADD      r1,r2,r1,LSL #5
00002a  7688              STRB     r0,[r1,#0x1a]
                  |L11.44|
;;;585        (
;;;586            if (!m_cb[p_instance->drv_inst_idx].rx_enabled)
;;;587            {
;;;588                rx_enable(p_instance);
;;;589                m_cb[p_instance->drv_inst_idx].rx_enabled = true;
;;;590            }
;;;591        )
;;;592    }
00002c  bd10              POP      {r4,pc}
;;;593    
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_for_uart||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_for_uart PROC
;;;396    
;;;397    __STATIC_INLINE ret_code_t nrf_drv_uart_rx_for_uart(const nrf_drv_uart_t * p_instance, uint8_t * p_data, uint8_t length, bool second_buffer)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;398    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
00000a  4698              MOV      r8,r3
;;;399        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
00000c  7920              LDRB     r0,[r4,#4]
00000e  492a              LDR      r1,|L12.184|
000010  eb011540          ADD      r5,r1,r0,LSL #5
;;;400    
;;;401        if ((!p_cb->rx_enabled) && (!second_buffer))
000014  7ea8              LDRB     r0,[r5,#0x1a]
000016  b928              CBNZ     r0,|L12.36|
000018  f1b80f00          CMP      r8,#0
00001c  d102              BNE      |L12.36|
;;;402        {
;;;403            rx_enable(p_instance);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       rx_enable
                  |L12.36|
;;;404        }
;;;405    
;;;406        if (p_cb->handler == NULL)
000024  6868              LDR      r0,[r5,#4]
000026  2800              CMP      r0,#0
000028  d13f              BNE      |L12.170|
;;;407        {
;;;408            nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_RXTO);
00002a  f44f71a2          MOV      r1,#0x144
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       nrf_uart_event_clear
;;;409    
;;;410            bool rxrdy;
;;;411            bool rxto;
;;;412            bool error;
;;;413            do
000034  bf00              NOP      
                  |L12.54|
;;;414            {
;;;415                do
000036  bf00              NOP      
                  |L12.56|
;;;416                {
;;;417                    error = nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_ERROR);
000038  f44f7192          MOV      r1,#0x124
00003c  6820              LDR      r0,[r4,#0]
00003e  f7fffffe          BL       nrf_uart_event_check
000042  4607              MOV      r7,r0
;;;418                    rxrdy = nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_RXDRDY);
000044  f44f7184          MOV      r1,#0x108
000048  6820              LDR      r0,[r4,#0]
00004a  f7fffffe          BL       nrf_uart_event_check
00004e  4681              MOV      r9,r0
;;;419                    rxto  = nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_RXTO);
000050  f44f71a2          MOV      r1,#0x144
000054  6820              LDR      r0,[r4,#0]
000056  f7fffffe          BL       nrf_uart_event_check
00005a  4606              MOV      r6,r0
;;;420                } while ((!rxrdy) && (!rxto) && (!error));
00005c  f1b90f00          CMP      r9,#0
000060  d102              BNE      |L12.104|
000062  b90e              CBNZ     r6,|L12.104|
000064  2f00              CMP      r7,#0
000066  d0e7              BEQ      |L12.56|
                  |L12.104|
;;;421    
;;;422                if (error || rxto)
000068  b907              CBNZ     r7,|L12.108|
00006a  b106              CBZ      r6,|L12.110|
                  |L12.108|
;;;423                {
;;;424                    break;
00006c  e007              B        |L12.126|
                  |L12.110|
;;;425                }
;;;426                rx_byte(p_instance->reg.p_uart, p_cb);
00006e  4629              MOV      r1,r5
000070  6820              LDR      r0,[r4,#0]
000072  f7fffffe          BL       rx_byte
;;;427            } while (p_cb->rx_buffer_length > p_cb->rx_counter);
000076  7de8              LDRB     r0,[r5,#0x17]
000078  7e69              LDRB     r1,[r5,#0x19]
00007a  4288              CMP      r0,r1
00007c  dcdb              BGT      |L12.54|
                  |L12.126|
00007e  bf00              NOP                            ;424
;;;428    
;;;429            p_cb->rx_buffer_length = 0;
000080  2000              MOVS     r0,#0
000082  75e8              STRB     r0,[r5,#0x17]
;;;430            if (error)
000084  b117              CBZ      r7,|L12.140|
;;;431            {
;;;432                return NRF_ERROR_INTERNAL;
000086  2003              MOVS     r0,#3
                  |L12.136|
;;;433            }
;;;434    
;;;435            if (rxto)
;;;436            {
;;;437                return NRF_ERROR_FORBIDDEN;
;;;438            }
;;;439    
;;;440            if (p_cb->rx_enabled)
;;;441            {
;;;442                nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STARTRX);
;;;443            }
;;;444            else
;;;445            {
;;;446                // Skip stopping RX if driver is forced to be enabled.
;;;447                nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPRX);
;;;448            }
;;;449        }
;;;450        else
;;;451        {
;;;452            nrf_uart_int_enable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;453        }
;;;454        return NRF_SUCCESS;
;;;455    }
000088  e8bd9ff0          POP      {r4-r12,pc}
                  |L12.140|
00008c  b10e              CBZ      r6,|L12.146|
00008e  200f              MOVS     r0,#0xf               ;437
000090  e7fa              B        |L12.136|
                  |L12.146|
000092  7ea8              LDRB     r0,[r5,#0x1a]         ;440
000094  b120              CBZ      r0,|L12.160|
000096  2100              MOVS     r1,#0                 ;442
000098  6820              LDR      r0,[r4,#0]            ;442
00009a  f7fffffe          BL       nrf_uart_task_trigger
00009e  e003              B        |L12.168|
                  |L12.160|
0000a0  2104              MOVS     r1,#4                 ;447
0000a2  6820              LDR      r0,[r4,#0]            ;447
0000a4  f7fffffe          BL       nrf_uart_task_trigger
                  |L12.168|
0000a8  e004              B        |L12.180|
                  |L12.170|
0000aa  f44f7101          MOV      r1,#0x204             ;452
0000ae  6820              LDR      r0,[r4,#0]            ;452
0000b0  f7fffffe          BL       nrf_uart_int_enable
                  |L12.180|
0000b4  2000              MOVS     r0,#0                 ;454
0000b6  e7e7              B        |L12.136|
;;;456    #endif
                          ENDP

                  |L12.184|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_for_uarte||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_for_uarte PROC
;;;458    #if defined(UARTE_IN_USE)
;;;459    __STATIC_INLINE ret_code_t nrf_drv_uart_rx_for_uarte(const nrf_drv_uart_t * p_instance, uint8_t * p_data, uint8_t length, bool second_buffer)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;460    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
;;;461        nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDRX);
00000c  f44f7188          MOV      r1,#0x110
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       nrf_uarte_event_clear
;;;462        nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_RXTO);
000016  f44f71a2          MOV      r1,#0x144
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       nrf_uarte_event_clear
;;;463        nrf_uarte_rx_buffer_set(p_instance->reg.p_uarte, p_data, length);
000020  6820              LDR      r0,[r4,#0]
000022  f8c05534          STR      r5,[r0,#0x534]
000026  f44f61a7          MOV      r1,#0x538
00002a  500e              STR      r6,[r1,r0]
00002c  bf00              NOP      
;;;464        if (!second_buffer)
00002e  f1b90f00          CMP      r9,#0
000032  d104              BNE      |L13.62|
;;;465        {
;;;466            nrf_uarte_task_trigger(p_instance->reg.p_uarte, NRF_UARTE_TASK_STARTRX);
000034  2100              MOVS     r1,#0
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       nrf_uarte_task_trigger
00003c  e008              B        |L13.80|
                  |L13.62|
;;;467        }
;;;468        else
;;;469        {
;;;470            nrf_uarte_shorts_enable(p_instance->reg.p_uarte, NRF_UARTE_SHORT_ENDRX_STARTRX);
00003e  2120              MOVS     r1,#0x20
000040  6820              LDR      r0,[r4,#0]
000042  f8d02200          LDR      r2,[r0,#0x200]
000046  430a              ORRS     r2,r2,r1
000048  f8c02200          STR      r2,[r0,#0x200]
00004c  bf00              NOP      
00004e  bf00              NOP      
                  |L13.80|
;;;471        }
;;;472    
;;;473        if (m_cb[p_instance->drv_inst_idx].handler == NULL)
000050  7920              LDRB     r0,[r4,#4]
000052  491b              LDR      r1,|L13.192|
000054  eb011040          ADD      r0,r1,r0,LSL #5
000058  6840              LDR      r0,[r0,#4]
00005a  bb50              CBNZ     r0,|L13.178|
;;;474        {
;;;475            bool endrx;
;;;476            bool rxto;
;;;477            bool error;
;;;478            do {
00005c  bf00              NOP      
                  |L13.94|
;;;479                endrx  = nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDRX);
00005e  f44f7188          MOV      r1,#0x110
000062  6820              LDR      r0,[r4,#0]
000064  f7fffffe          BL       nrf_uarte_event_check
000068  4682              MOV      r10,r0
;;;480                rxto   = nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_RXTO);
00006a  f44f71a2          MOV      r1,#0x144
00006e  6820              LDR      r0,[r4,#0]
000070  f7fffffe          BL       nrf_uarte_event_check
000074  4680              MOV      r8,r0
;;;481                error  = nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ERROR);
000076  f44f7192          MOV      r1,#0x124
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       nrf_uarte_event_check
000080  4607              MOV      r7,r0
;;;482            }while ((!endrx) && (!rxto) && (!error));
000082  f1ba0f00          CMP      r10,#0
000086  d104              BNE      |L13.146|
000088  f1b80f00          CMP      r8,#0
00008c  d101              BNE      |L13.146|
00008e  2f00              CMP      r7,#0
000090  d0e5              BEQ      |L13.94|
                  |L13.146|
;;;483    
;;;484            m_cb[p_instance->drv_inst_idx].rx_buffer_length = 0;
000092  2000              MOVS     r0,#0
000094  7921              LDRB     r1,[r4,#4]
000096  4a0a              LDR      r2,|L13.192|
000098  eb021141          ADD      r1,r2,r1,LSL #5
00009c  75c8              STRB     r0,[r1,#0x17]
;;;485    
;;;486            if (error)
00009e  b117              CBZ      r7,|L13.166|
;;;487            {
;;;488                return NRF_ERROR_INTERNAL;
0000a0  2003              MOVS     r0,#3
                  |L13.162|
;;;489            }
;;;490    
;;;491            if (rxto)
;;;492            {
;;;493                return NRF_ERROR_FORBIDDEN;
;;;494            }
;;;495        }
;;;496        else
;;;497        {
;;;498            nrf_uarte_int_enable(p_instance->reg.p_uarte, NRF_UARTE_INT_ERROR_MASK | NRF_UARTE_INT_ENDRX_MASK);
;;;499        }
;;;500        return NRF_SUCCESS;
;;;501    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
                  |L13.166|
0000a6  f1b80f00          CMP      r8,#0                 ;491
0000aa  d001              BEQ      |L13.176|
0000ac  200f              MOVS     r0,#0xf               ;493
0000ae  e7f8              B        |L13.162|
                  |L13.176|
0000b0  e004              B        |L13.188|
                  |L13.178|
0000b2  f44f7104          MOV      r1,#0x210             ;498
0000b6  6820              LDR      r0,[r4,#0]            ;498
0000b8  f7fffffe          BL       nrf_uarte_int_enable
                  |L13.188|
0000bc  2000              MOVS     r0,#0                 ;500
0000be  e7f0              B        |L13.162|
;;;502    #endif
                          ENDP

                  |L13.192|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx PROC
;;;334    
;;;335    ret_code_t nrf_drv_uart_tx(const nrf_drv_uart_t * p_instance, uint8_t const * const p_data, uint8_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;336    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;337        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
00000a  7920              LDRB     r0,[r4,#4]
00000c  4913              LDR      r1,|L14.92|
00000e  eb011640          ADD      r6,r1,r0,LSL #5
;;;338        ASSERT(p_cb->state == NRF_DRV_STATE_INITIALIZED);
;;;339        ASSERT(length>0);
;;;340        ASSERT(p_data);
;;;341    
;;;342        CODE_FOR_UARTE
000012  7920              LDRB     r0,[r4,#4]
000014  eb011040          ADD      r0,r1,r0,LSL #5
000018  7f00              LDRB     r0,[r0,#0x1c]
00001a  b138              CBZ      r0,|L14.44|
00001c  0c28              LSRS     r0,r5,#16
00001e  0400              LSLS     r0,r0,#16
000020  f1b05f00          CMP      r0,#0x20000000
000024  d002              BEQ      |L14.44|
000026  2010              MOVS     r0,#0x10
                  |L14.40|
;;;343        (
;;;344            // EasyDMA requires that transfer buffers are placed in DataRAM,
;;;345            // signal error if the are not.
;;;346            if (!IS_EASY_DMA_RAM_ADDRESS(p_data))
;;;347            {
;;;348                return NRF_ERROR_INVALID_ADDR;
;;;349            }
;;;350        )
;;;351    
;;;352        if (nrf_drv_uart_tx_in_progress(p_instance))
;;;353        {
;;;354            return NRF_ERROR_BUSY;
;;;355        }
;;;356        p_cb->tx_buffer_length = length;
;;;357        p_cb->p_tx_buffer      = p_data;
;;;358        p_cb->tx_counter       = 0;
;;;359    
;;;360        CODE_FOR_UARTE
;;;361        (
;;;362            return nrf_drv_uart_tx_for_uarte(p_instance);
;;;363        )
;;;364        CODE_FOR_UART
;;;365        (
;;;366            return nrf_drv_uart_tx_for_uart(p_instance);
;;;367        )
;;;368    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L14.44|
00002c  4620              MOV      r0,r4                 ;352
00002e  f7fffffe          BL       nrf_drv_uart_tx_in_progress
000032  b108              CBZ      r0,|L14.56|
000034  2011              MOVS     r0,#0x11              ;354
000036  e7f7              B        |L14.40|
                  |L14.56|
000038  75b7              STRB     r7,[r6,#0x16]         ;356
00003a  60b5              STR      r5,[r6,#8]            ;357
00003c  2000              MOVS     r0,#0                 ;358
00003e  82b0              STRH     r0,[r6,#0x14]         ;358
000040  7920              LDRB     r0,[r4,#4]            ;360
000042  4906              LDR      r1,|L14.92|
000044  eb011040          ADD      r0,r1,r0,LSL #5       ;360
000048  7f00              LDRB     r0,[r0,#0x1c]         ;360
00004a  b118              CBZ      r0,|L14.84|
00004c  4620              MOV      r0,r4                 ;360
00004e  f7fffffe          BL       nrf_drv_uart_tx_for_uarte
000052  e7e9              B        |L14.40|
                  |L14.84|
000054  4620              MOV      r0,r4                 ;364
000056  f7fffffe          BL       nrf_drv_uart_tx_for_uart
00005a  e7e5              B        |L14.40|
;;;369    
                          ENDP

                  |L14.92|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_abort||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_abort PROC
;;;647    
;;;648    void nrf_drv_uart_tx_abort(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;649    {
000002  4604              MOV      r4,r0
;;;650        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000004  7920              LDRB     r0,[r4,#4]
000006  4916              LDR      r1,|L15.96|
000008  eb011540          ADD      r5,r1,r0,LSL #5
;;;651    
;;;652        CODE_FOR_UARTE
00000c  7920              LDRB     r0,[r4,#4]
00000e  eb011040          ADD      r0,r1,r0,LSL #5
000012  7f00              LDRB     r0,[r0,#0x1c]
000014  b198              CBZ      r0,|L15.62|
000016  f44f71ac          MOV      r1,#0x158
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       nrf_uarte_event_clear
000020  210c              MOVS     r1,#0xc
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       nrf_uarte_task_trigger
000028  6868              LDR      r0,[r5,#4]
00002a  b9b8              CBNZ     r0,|L15.92|
00002c  bf00              NOP      
                  |L15.46|
00002e  f44f71ac          MOV      r1,#0x158
000032  6820              LDR      r0,[r4,#0]
000034  f7fffffe          BL       nrf_uarte_event_check
000038  2800              CMP      r0,#0
00003a  d0f8              BEQ      |L15.46|
00003c  e00e              B        |L15.92|
                  |L15.62|
;;;653        (
;;;654            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_TXSTOPPED);
;;;655            nrf_uarte_task_trigger(p_instance->reg.p_uarte, NRF_UARTE_TASK_STOPTX);
;;;656            if (p_cb->handler == NULL)
;;;657            {
;;;658                while (!nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_TXSTOPPED));
;;;659            }
;;;660        )
;;;661        CODE_FOR_UART
00003e  210c              MOVS     r1,#0xc
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       nrf_uart_task_trigger
000046  6868              LDR      r0,[r5,#4]
000048  b128              CBZ      r0,|L15.86|
00004a  8aa8              LDRH     r0,[r5,#0x14]
00004c  b2c1              UXTB     r1,r0
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       tx_done_event
000054  e002              B        |L15.92|
                  |L15.86|
000056  f44f7080          MOV      r0,#0x100
00005a  82a8              STRH     r0,[r5,#0x14]
                  |L15.92|
;;;662        (
;;;663            nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPTX);
;;;664            if (p_cb->handler)
;;;665            {
;;;666                tx_done_event(p_cb, p_cb->tx_counter);
;;;667            }
;;;668            else
;;;669            {
;;;670                p_cb->tx_counter       = TX_COUNTER_ABORT_REQ_VALUE;
;;;671            }
;;;672        )
;;;673    }
00005c  bd70              POP      {r4-r6,pc}
;;;674    
                          ENDP

00005e  0000              DCW      0x0000
                  |L15.96|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_for_uart||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_for_uart PROC
;;;259    
;;;260    __STATIC_INLINE ret_code_t nrf_drv_uart_tx_for_uart(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;261    {
000002  4604              MOV      r4,r0
;;;262        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000004  7920              LDRB     r0,[r4,#4]
000006  4920              LDR      r1,|L16.136|
000008  eb011540          ADD      r5,r1,r0,LSL #5
;;;263        ret_code_t err_code = NRF_SUCCESS;
00000c  2600              MOVS     r6,#0
;;;264    
;;;265        nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY);
00000e  f44f718e          MOV      r1,#0x11c
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       nrf_uart_event_clear
;;;266        nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STARTTX);
000018  2108              MOVS     r1,#8
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       nrf_uart_task_trigger
;;;267    
;;;268        tx_byte(p_instance->reg.p_uart, p_cb);
000020  4629              MOV      r1,r5
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       tx_byte
;;;269    
;;;270        if (p_cb->handler == NULL)
000028  6868              LDR      r0,[r5,#4]
00002a  bb58              CBNZ     r0,|L16.132|
;;;271        {
;;;272            while (p_cb->tx_counter < (uint16_t) p_cb->tx_buffer_length)
00002c  e012              B        |L16.84|
                  |L16.46|
;;;273            {
;;;274                while (!nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY) &&
00002e  bf00              NOP      
                  |L16.48|
000030  f44f718e          MOV      r1,#0x11c
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       nrf_uart_event_check
00003a  b918              CBNZ     r0,|L16.68|
;;;275                        p_cb->tx_counter != TX_COUNTER_ABORT_REQ_VALUE)
00003c  8aa8              LDRH     r0,[r5,#0x14]
00003e  f5b07f80          CMP      r0,#0x100
000042  d1f5              BNE      |L16.48|
                  |L16.68|
;;;276                {
;;;277                }
;;;278                if (p_cb->tx_counter != TX_COUNTER_ABORT_REQ_VALUE)
000044  8aa8              LDRH     r0,[r5,#0x14]
000046  f5b07f80          CMP      r0,#0x100
00004a  d003              BEQ      |L16.84|
;;;279                {
;;;280                    tx_byte(p_instance->reg.p_uart, p_cb);
00004c  4629              MOV      r1,r5
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       tx_byte
                  |L16.84|
000054  8aa8              LDRH     r0,[r5,#0x14]         ;272
000056  7da9              LDRB     r1,[r5,#0x16]         ;272
000058  4288              CMP      r0,r1                 ;272
00005a  dbe8              BLT      |L16.46|
;;;281                }
;;;282            }
;;;283    
;;;284            if (p_cb->tx_counter == TX_COUNTER_ABORT_REQ_VALUE)
00005c  8aa8              LDRH     r0,[r5,#0x14]
00005e  f5b07f80          CMP      r0,#0x100
000062  d101              BNE      |L16.104|
;;;285            {
;;;286                err_code = NRF_ERROR_FORBIDDEN;
000064  260f              MOVS     r6,#0xf
000066  e00b              B        |L16.128|
                  |L16.104|
;;;287            }
;;;288            else
;;;289            {
;;;290                while (!nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY))
000068  bf00              NOP      
                  |L16.106|
00006a  f44f718e          MOV      r1,#0x11c
00006e  6820              LDR      r0,[r4,#0]
000070  f7fffffe          BL       nrf_uart_event_check
000074  2800              CMP      r0,#0
000076  d0f8              BEQ      |L16.106|
;;;291                {
;;;292                }
;;;293                nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPTX);
000078  210c              MOVS     r1,#0xc
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       nrf_uart_task_trigger
                  |L16.128|
;;;294            }
;;;295            p_cb->tx_buffer_length = 0;
000080  2000              MOVS     r0,#0
000082  75a8              STRB     r0,[r5,#0x16]
                  |L16.132|
;;;296        }
;;;297    
;;;298        return err_code;
000084  4630              MOV      r0,r6
;;;299    }
000086  bd70              POP      {r4-r6,pc}
;;;300    #endif
                          ENDP

                  |L16.136|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_for_uarte||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_for_uarte PROC
;;;302    #if defined(UARTE_IN_USE)
;;;303    __STATIC_INLINE ret_code_t nrf_drv_uart_tx_for_uarte(const nrf_drv_uart_t * p_instance)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;304    {
000004  4604              MOV      r4,r0
;;;305        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000006  7920              LDRB     r0,[r4,#4]
000008  491b              LDR      r1,|L17.120|
00000a  eb011540          ADD      r5,r1,r0,LSL #5
;;;306        ret_code_t err_code = NRF_SUCCESS;
00000e  f04f0800          MOV      r8,#0
;;;307    
;;;308        nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDTX);
000012  f44f7190          MOV      r1,#0x120
000016  6820              LDR      r0,[r4,#0]
000018  f7fffffe          BL       nrf_uarte_event_clear
;;;309        nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_TXSTOPPED);
00001c  f44f71ac          MOV      r1,#0x158
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       nrf_uarte_event_clear
;;;310        nrf_uarte_tx_buffer_set(p_instance->reg.p_uarte, p_cb->p_tx_buffer, p_cb->tx_buffer_length);
000026  6820              LDR      r0,[r4,#0]
000028  7daa              LDRB     r2,[r5,#0x16]
00002a  68a9              LDR      r1,[r5,#8]
00002c  f8c01544          STR      r1,[r0,#0x544]
000030  f44f63a9          MOV      r3,#0x548
000034  501a              STR      r2,[r3,r0]
000036  bf00              NOP      
;;;311        nrf_uarte_task_trigger(p_instance->reg.p_uarte, NRF_UARTE_TASK_STARTTX);
000038  2108              MOVS     r1,#8
00003a  6820              LDR      r0,[r4,#0]
00003c  f7fffffe          BL       nrf_uarte_task_trigger
;;;312    
;;;313        if (p_cb->handler == NULL)
000040  6868              LDR      r0,[r5,#4]
000042  b9a8              CBNZ     r0,|L17.112|
;;;314        {
;;;315            bool endtx;
;;;316            bool txstopped;
;;;317            do
000044  bf00              NOP      
                  |L17.70|
;;;318            {
;;;319                endtx     = nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDTX);
000046  f44f7190          MOV      r1,#0x120
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       nrf_uarte_event_check
000050  4607              MOV      r7,r0
;;;320                txstopped = nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_TXSTOPPED);
000052  f44f71ac          MOV      r1,#0x158
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       nrf_uarte_event_check
00005c  4606              MOV      r6,r0
;;;321            }
;;;322            while ((!endtx) && (!txstopped));
00005e  b90f              CBNZ     r7,|L17.100|
000060  2e00              CMP      r6,#0
000062  d0f0              BEQ      |L17.70|
                  |L17.100|
;;;323    
;;;324            if (txstopped)
000064  b10e              CBZ      r6,|L17.106|
;;;325            {
;;;326                err_code = NRF_ERROR_FORBIDDEN;
000066  f04f080f          MOV      r8,#0xf
                  |L17.106|
;;;327            }
;;;328            p_cb->tx_buffer_length = 0;
00006a  2000              MOVS     r0,#0
00006c  75a8              STRB     r0,[r5,#0x16]
;;;329        }
00006e  bf00              NOP      
                  |L17.112|
;;;330    
;;;331        return err_code;
000070  4640              MOV      r0,r8
;;;332    }
000072  e8bd81f0          POP      {r4-r8,pc}
;;;333    #endif
                          ENDP

000076  0000              DCW      0x0000
                  |L17.120|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_in_progress||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_in_progress PROC
;;;369    
;;;370    bool nrf_drv_uart_tx_in_progress(const nrf_drv_uart_t * p_instance)
000000  4601              MOV      r1,r0
;;;371    {
;;;372        return (m_cb[p_instance->drv_inst_idx].tx_buffer_length != 0);
000002  7908              LDRB     r0,[r1,#4]
000004  4a04              LDR      r2,|L18.24|
000006  eb021040          ADD      r0,r2,r0,LSL #5
00000a  7d80              LDRB     r0,[r0,#0x16]
00000c  b108              CBZ      r0,|L18.18|
00000e  2001              MOVS     r0,#1
                  |L18.16|
;;;373    }
000010  4770              BX       lr
                  |L18.18|
000012  2000              MOVS     r0,#0                 ;372
000014  e7fc              B        |L18.16|
;;;374    
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_uninit||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_uninit PROC
;;;233    
;;;234    void nrf_drv_uart_uninit(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;235    {
000002  4604              MOV      r4,r0
;;;236        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000004  7920              LDRB     r0,[r4,#4]
000006  491f              LDR      r1,|L19.132|
000008  eb011540          ADD      r5,r1,r0,LSL #5
;;;237    
;;;238        uart_disable(p_instance);
00000c  bf00              NOP      
00000e  7920              LDRB     r0,[r4,#4]
000010  eb011040          ADD      r0,r1,r0,LSL #5
000014  7f00              LDRB     r0,[r0,#0x1c]
000016  b128              CBZ      r0,|L19.36|
000018  6820              LDR      r0,[r4,#0]
00001a  2100              MOVS     r1,#0
00001c  f8c01500          STR      r1,[r0,#0x500]
000020  bf00              NOP      
000022  e005              B        |L19.48|
                  |L19.36|
000024  6820              LDR      r0,[r4,#0]
000026  2100              MOVS     r1,#0
000028  f8c01500          STR      r1,[r0,#0x500]
00002c  bf00              NOP      
00002e  bf00              NOP      
                  |L19.48|
000030  bf00              NOP      
;;;239    
;;;240        if (p_cb->handler)
000032  6868              LDR      r0,[r5,#4]
000034  b1f0              CBZ      r0,|L19.116|
;;;241        {
;;;242            interrupts_disable(p_instance);
000036  bf00              NOP      
000038  7920              LDRB     r0,[r4,#4]
00003a  4912              LDR      r1,|L19.132|
00003c  eb011040          ADD      r0,r1,r0,LSL #5
000040  7f00              LDRB     r0,[r0,#0x1c]
000042  b150              CBZ      r0,|L19.90|
000044  4910              LDR      r1,|L19.136|
000046  6820              LDR      r0,[r4,#0]
000048  f7fffffe          BL       nrf_uarte_int_disable
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       nrf_drv_get_IRQn
000052  4606              MOV      r6,r0
000054  f7fffffe          BL       nrf_drv_common_irq_disable
000058  e00a              B        |L19.112|
                  |L19.90|
00005a  490b              LDR      r1,|L19.136|
00005c  398c              SUBS     r1,r1,#0x8c
00005e  6820              LDR      r0,[r4,#0]
000060  f7fffffe          BL       nrf_uart_int_disable
000064  6820              LDR      r0,[r4,#0]
000066  f7fffffe          BL       nrf_drv_get_IRQn
00006a  4606              MOV      r6,r0
00006c  f7fffffe          BL       nrf_drv_common_irq_disable
                  |L19.112|
000070  bf00              NOP      
000072  bf00              NOP      
                  |L19.116|
;;;243        }
;;;244    
;;;245        pins_to_default(p_instance);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       pins_to_default
;;;246    
;;;247        p_cb->state = NRF_DRV_STATE_UNINITIALIZED;
00007a  2000              MOVS     r0,#0
00007c  76e8              STRB     r0,[r5,#0x1b]
;;;248        p_cb->handler = NULL;
00007e  6068              STR      r0,[r5,#4]
;;;249    }
000080  bd70              POP      {r4-r6,pc}
;;;250    
                          ENDP

000082  0000              DCW      0x0000
                  |L19.132|
                          DCD      m_cb
                  |L19.136|
                          DCD      0x00020310

                          AREA ||i.nrf_gpio_cfg||, CODE, READONLY, ALIGN=2

                  nrf_gpio_cfg PROC
;;;453    
;;;454    __STATIC_INLINE void nrf_gpio_cfg(
000000  b5f0              PUSH     {r4-r7,lr}
;;;455            uint32_t             pin_number,
;;;456            nrf_gpio_pin_dir_t   dir,
;;;457            nrf_gpio_pin_input_t input,
;;;458            nrf_gpio_pin_pull_t  pull,
;;;459            nrf_gpio_pin_drive_t drive,
;;;460            nrf_gpio_pin_sense_t sense)
;;;461    {
000002  e9dd4505          LDRD     r4,r5,[sp,#0x14]
;;;462        NRF_GPIO->PIN_CNF[pin_number] = ((uint32_t)dir   << GPIO_PIN_CNF_DIR_Pos)
000006  ea410642          ORR      r6,r1,r2,LSL #1
00000a  ea460683          ORR      r6,r6,r3,LSL #2
00000e  ea462604          ORR      r6,r6,r4,LSL #8
000012  ea464705          ORR      r7,r6,r5,LSL #16
000016  4e02              LDR      r6,|L20.32|
000018  f8467020          STR      r7,[r6,r0,LSL #2]
;;;463                                      | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
;;;464                                      | ((uint32_t)pull  << GPIO_PIN_CNF_PULL_Pos)
;;;465                                      | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
;;;466                                      | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
;;;467    }
00001c  bdf0              POP      {r4-r7,pc}
;;;468    
                          ENDP

00001e  0000              DCW      0x0000
                  |L20.32|
                          DCD      0x50000700

                          AREA ||i.nrf_gpio_cfg_default||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_default PROC
;;;490    
;;;491    __STATIC_INLINE void nrf_gpio_cfg_default(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;492    {
000002  4604              MOV      r4,r0
;;;493        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4601              MOV      r1,r0
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;494                pin_number,
;;;495                NRF_GPIO_PIN_DIR_INPUT,
;;;496                NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;497                NRF_GPIO_PIN_NOPULL,
;;;498                NRF_GPIO_PIN_S0S1,
;;;499                NRF_GPIO_PIN_NOSENSE);
;;;500    }
000016  bd1c              POP      {r2-r4,pc}
;;;501    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_input||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_input PROC
;;;479    
;;;480    __STATIC_INLINE void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
000000  b57c              PUSH     {r2-r6,lr}
;;;481    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;482        nrf_gpio_cfg(
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  4623              MOV      r3,r4
00000c  4602              MOV      r2,r0
00000e  4601              MOV      r1,r0
000010  9001              STR      r0,[sp,#4]
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       nrf_gpio_cfg
;;;483                pin_number,
;;;484                NRF_GPIO_PIN_DIR_INPUT,
;;;485                NRF_GPIO_PIN_INPUT_CONNECT,
;;;486                pull_config,
;;;487                NRF_GPIO_PIN_S0S1,
;;;488                NRF_GPIO_PIN_NOSENSE);
;;;489    }
000018  bd7c              POP      {r2-r6,pc}
;;;490    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_output||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_output PROC
;;;468    
;;;469    __STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;470    {
000002  4604              MOV      r4,r0
;;;471        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4611              MOV      r1,r2
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;472                pin_number,
;;;473                NRF_GPIO_PIN_DIR_OUTPUT,
;;;474                NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;475                NRF_GPIO_PIN_NOPULL,
;;;476                NRF_GPIO_PIN_S0S1,
;;;477                NRF_GPIO_PIN_NOSENSE);
;;;478    }
000016  bd1c              POP      {r2-r4,pc}
;;;479    
                          ENDP


                          AREA ||i.nrf_gpio_pin_set||, CODE, READONLY, ALIGN=2

                  nrf_gpio_pin_set PROC
;;;552    
;;;553    __STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
000000  2101              MOVS     r1,#1
;;;554    {
;;;555        NRF_GPIO->OUTSET = (1UL << pin_number);
000002  4081              LSLS     r1,r1,r0
000004  4a01              LDR      r2,|L24.12|
000006  6011              STR      r1,[r2,#0]
;;;556    }
000008  4770              BX       lr
;;;557    
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      0x50000508

                          AREA ||i.nrf_uart_errorsrc_get_and_clear||, CODE, READONLY, ALIGN=1

                  nrf_uart_errorsrc_get_and_clear PROC
;;;387    
;;;388    __STATIC_INLINE uint32_t nrf_uart_errorsrc_get_and_clear(NRF_UART_Type * p_reg)
000000  4601              MOV      r1,r0
;;;389    {
;;;390        uint32_t errsrc_mask = p_reg->ERRORSRC;
000002  f8d10480          LDR      r0,[r1,#0x480]
;;;391        p_reg->ERRORSRC = errsrc_mask;
000006  f8c10480          STR      r0,[r1,#0x480]
;;;392        return errsrc_mask;
;;;393    }
00000a  4770              BX       lr
;;;394    
                          ENDP


                          AREA ||i.nrf_uart_event_check||, CODE, READONLY, ALIGN=1

                  nrf_uart_event_check PROC
;;;361    
;;;362    __STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type * p_reg, nrf_uart_event_t event)
000000  4602              MOV      r2,r0
;;;363    {
;;;364        return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
000002  5850              LDR      r0,[r2,r1]
000004  b108              CBZ      r0,|L26.10|
000006  2001              MOVS     r0,#1
                  |L26.8|
;;;365    }
000008  4770              BX       lr
                  |L26.10|
00000a  2000              MOVS     r0,#0                 ;364
00000c  e7fc              B        |L26.8|
;;;366    
                          ENDP


                          AREA ||i.nrf_uart_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_uart_event_clear PROC
;;;351    #ifndef SUPPRESS_INLINE_IMPLEMENTATION
;;;352    __STATIC_INLINE void nrf_uart_event_clear(NRF_UART_Type * p_reg, nrf_uart_event_t event)
000000  b508              PUSH     {r3,lr}
;;;353    {
;;;354        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
000002  2200              MOVS     r2,#0
000004  5042              STR      r2,[r0,r1]
;;;355    #if __CORTEX_M == 0x04
;;;356        volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
000006  5842              LDR      r2,[r0,r1]
000008  9200              STR      r2,[sp,#0]
;;;357        (void)dummy;
00000a  bf00              NOP      
;;;358    #endif
;;;359    
;;;360    }
00000c  bd08              POP      {r3,pc}
;;;361    
                          ENDP


                          AREA ||i.nrf_uart_hwfc_pins_set||, CODE, READONLY, ALIGN=1

                  nrf_uart_hwfc_pins_set PROC
;;;435    
;;;436    __STATIC_INLINE void nrf_uart_hwfc_pins_set(NRF_UART_Type * p_reg, uint32_t pselrts, uint32_t pselcts)
000000  f8c01508          STR      r1,[r0,#0x508]
;;;437    {
;;;438        p_reg->PSELRTS = pselrts;
;;;439        p_reg->PSELCTS = pselcts;
000004  f8c02510          STR      r2,[r0,#0x510]
;;;440    }
000008  4770              BX       lr
;;;441    
                          ENDP


                          AREA ||i.nrf_uart_int_disable||, CODE, READONLY, ALIGN=1

                  nrf_uart_int_disable PROC
;;;382    
;;;383    __STATIC_INLINE void nrf_uart_int_disable(NRF_UART_Type * p_reg, uint32_t int_mask)
000000  f8c01308          STR      r1,[r0,#0x308]
;;;384    {
;;;385        p_reg->INTENCLR = int_mask;
;;;386    }
000004  4770              BX       lr
;;;387    
                          ENDP


                          AREA ||i.nrf_uart_int_enable||, CODE, READONLY, ALIGN=1

                  nrf_uart_int_enable PROC
;;;372    
;;;373    __STATIC_INLINE void nrf_uart_int_enable(NRF_UART_Type * p_reg, uint32_t int_mask)
000000  f8c01304          STR      r1,[r0,#0x304]
;;;374    {
;;;375        p_reg->INTENSET = int_mask;
;;;376    }
000004  4770              BX       lr
;;;377    
                          ENDP


                          AREA ||i.nrf_uart_int_enable_check||, CODE, READONLY, ALIGN=1

                  nrf_uart_int_enable_check PROC
;;;377    
;;;378    __STATIC_INLINE bool nrf_uart_int_enable_check(NRF_UART_Type * p_reg, uint32_t int_mask)
000000  4602              MOV      r2,r0
;;;379    {
;;;380        return (bool)(p_reg->INTENSET & int_mask);
000002  f8d20304          LDR      r0,[r2,#0x304]
000006  4008              ANDS     r0,r0,r1
000008  b108              CBZ      r0,|L31.14|
00000a  2001              MOVS     r0,#1
                  |L31.12|
;;;381    }
00000c  4770              BX       lr
                  |L31.14|
00000e  2000              MOVS     r0,#0                 ;380
000010  e7fc              B        |L31.12|
;;;382    
                          ENDP


                          AREA ||i.nrf_uart_task_trigger||, CODE, READONLY, ALIGN=1

                  nrf_uart_task_trigger PROC
;;;456    
;;;457    __STATIC_INLINE void nrf_uart_task_trigger(NRF_UART_Type * p_reg, nrf_uart_task_t task)
000000  2201              MOVS     r2,#1
;;;458    {
;;;459        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
000002  5042              STR      r2,[r0,r1]
;;;460    }
000004  4770              BX       lr
;;;461    
                          ENDP


                          AREA ||i.nrf_uart_txrx_pins_set||, CODE, READONLY, ALIGN=1

                  nrf_uart_txrx_pins_set PROC
;;;404    
;;;405    __STATIC_INLINE void nrf_uart_txrx_pins_set(NRF_UART_Type * p_reg, uint32_t pseltxd, uint32_t pselrxd)
000000  f8c0150c          STR      r1,[r0,#0x50c]
;;;406    {
;;;407        p_reg->PSELTXD = pseltxd;
;;;408        p_reg->PSELRXD = pselrxd;
000004  f8c02514          STR      r2,[r0,#0x514]
;;;409    }
000008  4770              BX       lr
;;;410    
                          ENDP


                          AREA ||i.nrf_uarte_errorsrc_get_and_clear||, CODE, READONLY, ALIGN=1

                  nrf_uarte_errorsrc_get_and_clear PROC
;;;433    
;;;434    __STATIC_INLINE uint32_t nrf_uarte_errorsrc_get_and_clear(NRF_UARTE_Type * p_reg)
000000  4601              MOV      r1,r0
;;;435    {
;;;436        uint32_t errsrc_mask = p_reg->ERRORSRC;
000002  f8d10480          LDR      r0,[r1,#0x480]
;;;437        p_reg->ERRORSRC = errsrc_mask;
000006  f8c10480          STR      r0,[r1,#0x480]
;;;438        return errsrc_mask;
;;;439    }
00000a  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.nrf_uarte_event_check||, CODE, READONLY, ALIGN=1

                  nrf_uarte_event_check PROC
;;;397    
;;;398    __STATIC_INLINE bool nrf_uarte_event_check(NRF_UARTE_Type * p_reg, nrf_uarte_event_t event)
000000  4602              MOV      r2,r0
;;;399    {
;;;400        return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
000002  5850              LDR      r0,[r2,r1]
000004  b108              CBZ      r0,|L35.10|
000006  2001              MOVS     r0,#1
                  |L35.8|
;;;401    }
000008  4770              BX       lr
                  |L35.10|
00000a  2000              MOVS     r0,#0                 ;400
00000c  e7fc              B        |L35.8|
;;;402    
                          ENDP


                          AREA ||i.nrf_uarte_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_uarte_event_clear PROC
;;;387    #ifndef SUPPRESS_INLINE_IMPLEMENTATION
;;;388    __STATIC_INLINE void nrf_uarte_event_clear(NRF_UARTE_Type * p_reg, nrf_uarte_event_t event)
000000  b508              PUSH     {r3,lr}
;;;389    {
;;;390        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
000002  2200              MOVS     r2,#0
000004  5042              STR      r2,[r0,r1]
;;;391    #if __CORTEX_M == 0x04
;;;392        volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
000006  5842              LDR      r2,[r0,r1]
000008  9200              STR      r2,[sp,#0]
;;;393        (void)dummy;
00000a  bf00              NOP      
;;;394    #endif
;;;395    
;;;396    }
00000c  bd08              POP      {r3,pc}
;;;397    
                          ENDP


                          AREA ||i.nrf_uarte_hwfc_pins_set||, CODE, READONLY, ALIGN=1

                  nrf_uarte_hwfc_pins_set PROC
;;;481    
;;;482    __STATIC_INLINE void nrf_uarte_hwfc_pins_set(NRF_UARTE_Type * p_reg, uint32_t pselrts, uint32_t pselcts)
000000  f8c01508          STR      r1,[r0,#0x508]
;;;483    {
;;;484        p_reg->PSEL.RTS = pselrts;
;;;485        p_reg->PSEL.CTS = pselcts;
000004  f44f63a2          MOV      r3,#0x510
000008  501a              STR      r2,[r3,r0]
;;;486    }
00000a  4770              BX       lr
;;;487    
                          ENDP


                          AREA ||i.nrf_uarte_int_disable||, CODE, READONLY, ALIGN=1

                  nrf_uarte_int_disable PROC
;;;428    
;;;429    __STATIC_INLINE void nrf_uarte_int_disable(NRF_UARTE_Type * p_reg, uint32_t int_mask)
000000  f8c01308          STR      r1,[r0,#0x308]
;;;430    {
;;;431        p_reg->INTENCLR = int_mask;
;;;432    }
000004  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.nrf_uarte_int_enable||, CODE, READONLY, ALIGN=1

                  nrf_uarte_int_enable PROC
;;;418    
;;;419    __STATIC_INLINE void nrf_uarte_int_enable(NRF_UARTE_Type * p_reg, uint32_t int_mask)
000000  f8c01304          STR      r1,[r0,#0x304]
;;;420    {
;;;421        p_reg->INTENSET = int_mask;
;;;422    }
000004  4770              BX       lr
;;;423    
                          ENDP


                          AREA ||i.nrf_uarte_rx_amount_get||, CODE, READONLY, ALIGN=1

                  nrf_uarte_rx_amount_get PROC
;;;535    
;;;536    __STATIC_INLINE uint32_t nrf_uarte_rx_amount_get(NRF_UARTE_Type * p_reg)
000000  4601              MOV      r1,r0
;;;537    {
;;;538        return p_reg->RXD.AMOUNT;
000002  f240503c          MOV      r0,#0x53c
000006  5840              LDR      r0,[r0,r1]
;;;539    }
000008  4770              BX       lr
;;;540    #endif //SUPPRESS_INLINE_IMPLEMENTATION
                          ENDP


                          AREA ||i.nrf_uarte_task_trigger||, CODE, READONLY, ALIGN=1

                  nrf_uarte_task_trigger PROC
;;;492    
;;;493    __STATIC_INLINE void nrf_uarte_task_trigger(NRF_UARTE_Type * p_reg, nrf_uarte_task_t task)
000000  2201              MOVS     r2,#1
;;;494    {
;;;495        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
000002  5042              STR      r2,[r0,r1]
;;;496    }
000004  4770              BX       lr
;;;497    
                          ENDP


                          AREA ||i.nrf_uarte_txrx_pins_set||, CODE, READONLY, ALIGN=1

                  nrf_uarte_txrx_pins_set PROC
;;;450    
;;;451    __STATIC_INLINE void nrf_uarte_txrx_pins_set(NRF_UARTE_Type * p_reg, uint32_t pseltxd, uint32_t pselrxd)
000000  f240530c          MOV      r3,#0x50c
;;;452    {
;;;453        p_reg->PSEL.TXD = pseltxd;
000004  5019              STR      r1,[r3,r0]
;;;454        p_reg->PSEL.RXD = pselrxd;
000006  f2405314          MOV      r3,#0x514
00000a  501a              STR      r2,[r3,r0]
;;;455    }
00000c  4770              BX       lr
;;;456    
                          ENDP


                          AREA ||i.pins_to_default||, CODE, READONLY, ALIGN=2

                  pins_to_default PROC
;;;146    
;;;147    __STATIC_INLINE void pins_to_default(const nrf_drv_uart_t * p_instance)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;148    {
000004  4604              MOV      r4,r0
;;;149        /* Reset pins to default states */
;;;150        uint32_t txd;
;;;151        uint32_t rxd;
;;;152        uint32_t rts;
;;;153        uint32_t cts;
;;;154    
;;;155        CODE_FOR_UARTE
000006  7920              LDRB     r0,[r4,#4]
000008  492e              LDR      r1,|L43.196|
00000a  eb011040          ADD      r0,r1,r0,LSL #5
00000e  7f00              LDRB     r0,[r0,#0x1c]
000010  b318              CBZ      r0,|L43.90|
000012  6820              LDR      r0,[r4,#0]
000014  f240510c          MOV      r1,#0x50c
000018  580f              LDR      r7,[r1,r0]
00001a  bf00              NOP      
00001c  6820              LDR      r0,[r4,#0]
00001e  f8d08514          LDR      r8,[r0,#0x514]
000022  bf00              NOP      
000024  6820              LDR      r0,[r4,#0]
000026  f8d05508          LDR      r5,[r0,#0x508]
00002a  bf00              NOP      
00002c  6820              LDR      r0,[r4,#0]
00002e  1d09              ADDS     r1,r1,#4
000030  580e              LDR      r6,[r1,r0]
000032  bf00              NOP      
000034  f8d49000          LDR      r9,[r4,#0]
000038  f04f32ff          MOV      r2,#0xffffffff
00003c  4611              MOV      r1,r2
00003e  4648              MOV      r0,r9
000040  f7fffffe          BL       nrf_uarte_txrx_pins_set
000044  bf00              NOP      
000046  f8d49000          LDR      r9,[r4,#0]
00004a  f04f32ff          MOV      r2,#0xffffffff
00004e  4611              MOV      r1,r2
000050  4648              MOV      r0,r9
000052  f7fffffe          BL       nrf_uarte_hwfc_pins_set
000056  bf00              NOP      
000058  e022              B        |L43.160|
                  |L43.90|
;;;156        (
;;;157            txd = nrf_uarte_tx_pin_get(p_instance->reg.p_uarte);
;;;158            rxd = nrf_uarte_rx_pin_get(p_instance->reg.p_uarte);
;;;159            rts = nrf_uarte_rts_pin_get(p_instance->reg.p_uarte);
;;;160            cts = nrf_uarte_cts_pin_get(p_instance->reg.p_uarte);
;;;161            nrf_uarte_txrx_pins_disconnect(p_instance->reg.p_uarte);
;;;162            nrf_uarte_hwfc_pins_disconnect(p_instance->reg.p_uarte);
;;;163        )
;;;164        CODE_FOR_UART
00005a  6820              LDR      r0,[r4,#0]
00005c  f8d0750c          LDR      r7,[r0,#0x50c]
000060  bf00              NOP      
000062  6820              LDR      r0,[r4,#0]
000064  f8d08514          LDR      r8,[r0,#0x514]
000068  bf00              NOP      
00006a  6820              LDR      r0,[r4,#0]
00006c  f8d05508          LDR      r5,[r0,#0x508]
000070  bf00              NOP      
000072  6820              LDR      r0,[r4,#0]
000074  f8d06510          LDR      r6,[r0,#0x510]
000078  bf00              NOP      
00007a  f8d49000          LDR      r9,[r4,#0]
00007e  f04f32ff          MOV      r2,#0xffffffff
000082  4611              MOV      r1,r2
000084  4648              MOV      r0,r9
000086  f7fffffe          BL       nrf_uart_txrx_pins_set
00008a  bf00              NOP      
00008c  f8d49000          LDR      r9,[r4,#0]
000090  f04f32ff          MOV      r2,#0xffffffff
000094  4611              MOV      r1,r2
000096  4648              MOV      r0,r9
000098  f7fffffe          BL       nrf_uart_hwfc_pins_set
00009c  bf00              NOP      
00009e  bf00              NOP      
                  |L43.160|
;;;165        (
;;;166            txd = nrf_uart_tx_pin_get(p_instance->reg.p_uart);
;;;167            rxd = nrf_uart_rx_pin_get(p_instance->reg.p_uart);
;;;168            rts = nrf_uart_rts_pin_get(p_instance->reg.p_uart);
;;;169            cts = nrf_uart_cts_pin_get(p_instance->reg.p_uart);
;;;170            nrf_uart_txrx_pins_disconnect(p_instance->reg.p_uart);
;;;171            nrf_uart_hwfc_pins_disconnect(p_instance->reg.p_uart);
;;;172        )
;;;173    
;;;174        nrf_gpio_cfg_default(txd);
0000a0  4638              MOV      r0,r7
0000a2  f7fffffe          BL       nrf_gpio_cfg_default
;;;175        nrf_gpio_cfg_default(rxd);
0000a6  4640              MOV      r0,r8
0000a8  f7fffffe          BL       nrf_gpio_cfg_default
;;;176    
;;;177        if (cts != NRF_UART_PSEL_DISCONNECTED)
0000ac  1c70              ADDS     r0,r6,#1
0000ae  b110              CBZ      r0,|L43.182|
;;;178        {
;;;179            nrf_gpio_cfg_default(cts);
0000b0  4630              MOV      r0,r6
0000b2  f7fffffe          BL       nrf_gpio_cfg_default
                  |L43.182|
;;;180        }
;;;181    
;;;182        if (rts != NRF_UART_PSEL_DISCONNECTED)
0000b6  1c68              ADDS     r0,r5,#1
0000b8  b110              CBZ      r0,|L43.192|
;;;183        {
;;;184            nrf_gpio_cfg_default(rts);
0000ba  4628              MOV      r0,r5
0000bc  f7fffffe          BL       nrf_gpio_cfg_default
                  |L43.192|
;;;185        }
;;;186    
;;;187    }
0000c0  e8bd87f0          POP      {r4-r10,pc}
;;;188    
                          ENDP

                  |L43.196|
                          DCD      m_cb

                          AREA ||i.rx_byte||, CODE, READONLY, ALIGN=1

                  rx_byte PROC
;;;382    
;;;383    __STATIC_INLINE void rx_byte(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)
000000  b570              PUSH     {r4-r6,lr}
;;;384    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;385        if (!p_cb->rx_buffer_length)
000006  7de0              LDRB     r0,[r4,#0x17]
000008  b940              CBNZ     r0,|L44.28|
;;;386        {
;;;387            nrf_uart_event_clear(p_uart, NRF_UART_EVENT_RXDRDY);
00000a  f44f7184          MOV      r1,#0x108
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       nrf_uart_event_clear
;;;388            // Byte received when buffer is not set - data lost.
;;;389            (void) nrf_uart_rxd_get(p_uart);
000014  bf00              NOP      
000016  f8d50518          LDR      r0,[r5,#0x518]
                  |L44.26|
;;;390            return;
;;;391        }
;;;392        nrf_uart_event_clear(p_uart, NRF_UART_EVENT_RXDRDY);
;;;393        p_cb->p_rx_buffer[p_cb->rx_counter] = nrf_uart_rxd_get(p_uart);
;;;394        p_cb->rx_counter++;
;;;395    }
00001a  bd70              POP      {r4-r6,pc}
                  |L44.28|
00001c  f44f7184          MOV      r1,#0x108             ;392
000020  4628              MOV      r0,r5                 ;392
000022  f7fffffe          BL       nrf_uart_event_clear
000026  bf00              NOP                            ;393
000028  f8d50518          LDR      r0,[r5,#0x518]        ;393
00002c  b2c0              UXTB     r0,r0                 ;393
00002e  7e62              LDRB     r2,[r4,#0x19]         ;393
000030  68e1              LDR      r1,[r4,#0xc]          ;393
000032  5488              STRB     r0,[r1,r2]            ;393
000034  7e60              LDRB     r0,[r4,#0x19]         ;394
000036  1c40              ADDS     r0,r0,#1              ;394
000038  7660              STRB     r0,[r4,#0x19]         ;394
00003a  bf00              NOP      
00003c  e7ed              B        |L44.26|
;;;396    
                          ENDP


                          AREA ||i.rx_done_event||, CODE, READONLY, ALIGN=1

                  rx_done_event PROC
;;;623    
;;;624    __STATIC_INLINE void rx_done_event(uart_control_block_t * p_cb, uint8_t bytes, uint8_t * p_data)
000000  b57f              PUSH     {r0-r6,lr}
;;;625    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;626        nrf_drv_uart_event_t event;
;;;627    
;;;628        event.type             = NRF_DRV_UART_EVT_RX_DONE;
000008  2001              MOVS     r0,#1
00000a  f88d0000          STRB     r0,[sp,#0]
;;;629        event.data.rxtx.bytes  = bytes;
00000e  f88d5008          STRB     r5,[sp,#8]
;;;630        event.data.rxtx.p_data = p_data;
000012  9601              STR      r6,[sp,#4]
;;;631    
;;;632        p_cb->handler(&event, p_cb->p_context);
000014  4668              MOV      r0,sp
000016  e9d41200          LDRD     r1,r2,[r4,#0]
00001a  4790              BLX      r2
;;;633    }
00001c  bd7f              POP      {r0-r6,pc}
;;;634    
                          ENDP


                          AREA ||i.rx_enable||, CODE, READONLY, ALIGN=1

                  rx_enable PROC
;;;375    #if defined(UART_IN_USE)
;;;376    __STATIC_INLINE void rx_enable(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;377    {
000002  4604              MOV      r4,r0
;;;378        nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_ERROR);
000004  f44f7192          MOV      r1,#0x124
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       nrf_uart_event_clear
;;;379        nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_RXDRDY);
00000e  f44f7184          MOV      r1,#0x108
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       nrf_uart_event_clear
;;;380        nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STARTRX);
000018  2100              MOVS     r1,#0
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       nrf_uart_task_trigger
;;;381    }
000020  bd10              POP      {r4,pc}
;;;382    
                          ENDP


                          AREA ||i.tx_byte||, CODE, READONLY, ALIGN=1

                  tx_byte PROC
;;;251    #if defined(UART_IN_USE)
;;;252    __STATIC_INLINE void tx_byte(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)
000000  b570              PUSH     {r4-r6,lr}
;;;253    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;254        nrf_uart_event_clear(p_uart, NRF_UART_EVENT_TXDRDY);
000006  f44f718e          MOV      r1,#0x11c
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       nrf_uart_event_clear
;;;255        uint8_t txd = p_cb->p_tx_buffer[p_cb->tx_counter];
000010  8aa1              LDRH     r1,[r4,#0x14]
000012  68a0              LDR      r0,[r4,#8]
000014  5c46              LDRB     r6,[r0,r1]
;;;256        p_cb->tx_counter++;
000016  8aa0              LDRH     r0,[r4,#0x14]
000018  1c40              ADDS     r0,r0,#1
00001a  82a0              STRH     r0,[r4,#0x14]
;;;257        nrf_uart_txd_set(p_uart, txd);
00001c  4630              MOV      r0,r6
00001e  f8c5051c          STR      r0,[r5,#0x51c]
000022  bf00              NOP      
;;;258    }
000024  bd70              POP      {r4-r6,pc}
;;;259    
                          ENDP


                          AREA ||i.tx_done_event||, CODE, READONLY, ALIGN=1

                  tx_done_event PROC
;;;634    
;;;635    __STATIC_INLINE void tx_done_event(uart_control_block_t * p_cb, uint8_t bytes)
000000  b57f              PUSH     {r0-r6,lr}
;;;636    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;637        nrf_drv_uart_event_t event;
;;;638    
;;;639        event.type             = NRF_DRV_UART_EVT_TX_DONE;
000006  2000              MOVS     r0,#0
000008  f88d0000          STRB     r0,[sp,#0]
;;;640        event.data.rxtx.bytes  = bytes;
00000c  f88d5008          STRB     r5,[sp,#8]
;;;641        event.data.rxtx.p_data = (uint8_t *)p_cb->p_tx_buffer;
000010  68a0              LDR      r0,[r4,#8]
000012  9001              STR      r0,[sp,#4]
;;;642    
;;;643        p_cb->tx_buffer_length = 0;
000014  2000              MOVS     r0,#0
000016  75a0              STRB     r0,[r4,#0x16]
;;;644    
;;;645        p_cb->handler(&event, p_cb->p_context);
000018  4668              MOV      r0,sp
00001a  e9d41200          LDRD     r1,r2,[r4,#0]
00001e  4790              BLX      r2
;;;646    }
000020  bd7f              POP      {r0-r6,pc}
;;;647    
                          ENDP


                          AREA ||i.uart_irq_handler||, CODE, READONLY, ALIGN=1

                  uart_irq_handler PROC
;;;689    #if defined(UART_IN_USE)
;;;690    __STATIC_INLINE void uart_irq_handler(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;691    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;692        if (nrf_uart_int_enable_check(p_uart, NRF_UART_INT_MASK_ERROR) &&
000008  f44f7100          MOV      r1,#0x200
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       nrf_uart_int_enable_check
000012  b348              CBZ      r0,|L49.104|
;;;693            nrf_uart_event_check(p_uart, NRF_UART_EVENT_ERROR))
000014  f44f7192          MOV      r1,#0x124
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       nrf_uart_event_check
00001e  b318              CBZ      r0,|L49.104|
;;;694        {
;;;695            nrf_drv_uart_event_t event;
;;;696            nrf_uart_event_clear(p_uart, NRF_UART_EVENT_ERROR);
000020  f44f7192          MOV      r1,#0x124
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       nrf_uart_event_clear
;;;697            nrf_uart_int_disable(p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
00002a  f44f7101          MOV      r1,#0x204
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       nrf_uart_int_disable
;;;698            if (!p_cb->rx_enabled)
000034  7ea0              LDRB     r0,[r4,#0x1a]
000036  b918              CBNZ     r0,|L49.64|
;;;699            {
;;;700                nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STOPRX);
000038  2104              MOVS     r1,#4
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       nrf_uart_task_trigger
                  |L49.64|
;;;701            }
;;;702            event.type                   = NRF_DRV_UART_EVT_ERROR;
000040  2002              MOVS     r0,#2
000042  f88d0000          STRB     r0,[sp,#0]
;;;703            event.data.error.error_mask  = nrf_uart_errorsrc_get_and_clear(p_uart);
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       nrf_uart_errorsrc_get_and_clear
00004c  9003              STR      r0,[sp,#0xc]
;;;704            event.data.error.rxtx.bytes  = p_cb->rx_buffer_length;
00004e  7de1              LDRB     r1,[r4,#0x17]
000050  f88d1008          STRB     r1,[sp,#8]
;;;705            event.data.error.rxtx.p_data = p_cb->p_rx_buffer;
000054  68e0              LDR      r0,[r4,#0xc]
000056  9001              STR      r0,[sp,#4]
;;;706    
;;;707            //abort transfer
;;;708            p_cb->rx_buffer_length = 0;
000058  2000              MOVS     r0,#0
00005a  75e0              STRB     r0,[r4,#0x17]
;;;709            p_cb->rx_secondary_buffer_length = 0;
00005c  7620              STRB     r0,[r4,#0x18]
;;;710    
;;;711            p_cb->handler(&event,p_cb->p_context);
00005e  4668              MOV      r0,sp
000060  e9d41200          LDRD     r1,r2,[r4,#0]
000064  4790              BLX      r2
;;;712        }
000066  e036              B        |L49.214|
                  |L49.104|
;;;713        else if (nrf_uart_int_enable_check(p_uart, NRF_UART_INT_MASK_RXDRDY) &&
000068  2104              MOVS     r1,#4
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       nrf_uart_int_enable_check
000070  2800              CMP      r0,#0
000072  d030              BEQ      |L49.214|
;;;714                 nrf_uart_event_check(p_uart, NRF_UART_EVENT_RXDRDY))
000074  f44f7184          MOV      r1,#0x108
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       nrf_uart_event_check
00007e  b350              CBZ      r0,|L49.214|
;;;715        {
;;;716            rx_byte(p_uart, p_cb);
000080  4621              MOV      r1,r4
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       rx_byte
;;;717            if (p_cb->rx_buffer_length == p_cb->rx_counter)
000088  7de0              LDRB     r0,[r4,#0x17]
00008a  7e61              LDRB     r1,[r4,#0x19]
00008c  4288              CMP      r0,r1
00008e  d122              BNE      |L49.214|
;;;718            {
;;;719                if (p_cb->rx_secondary_buffer_length)
000090  7e20              LDRB     r0,[r4,#0x18]
000092  b170              CBZ      r0,|L49.178|
;;;720                {
;;;721                    uint8_t * p_data     = p_cb->p_rx_buffer;
000094  68e6              LDR      r6,[r4,#0xc]
;;;722                    uint8_t   rx_counter = p_cb->rx_counter;
000096  7e67              LDRB     r7,[r4,#0x19]
;;;723    
;;;724                    //Switch to secondary buffer.
;;;725                    p_cb->rx_buffer_length = p_cb->rx_secondary_buffer_length;
000098  7e20              LDRB     r0,[r4,#0x18]
00009a  75e0              STRB     r0,[r4,#0x17]
;;;726                    p_cb->p_rx_buffer = p_cb->p_rx_secondary_buffer;
00009c  6920              LDR      r0,[r4,#0x10]
00009e  60e0              STR      r0,[r4,#0xc]
;;;727                    p_cb->rx_secondary_buffer_length = 0;
0000a0  2000              MOVS     r0,#0
0000a2  7620              STRB     r0,[r4,#0x18]
;;;728                    p_cb->rx_counter = 0;
0000a4  7660              STRB     r0,[r4,#0x19]
;;;729                    rx_done_event(p_cb, rx_counter, p_data);
0000a6  4632              MOV      r2,r6
0000a8  4639              MOV      r1,r7
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       rx_done_event
;;;730                }
0000b0  e011              B        |L49.214|
                  |L49.178|
;;;731                else
;;;732                {
;;;733                    if (!p_cb->rx_enabled)
0000b2  7ea0              LDRB     r0,[r4,#0x1a]
0000b4  b918              CBNZ     r0,|L49.190|
;;;734                    {
;;;735                        nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STOPRX);
0000b6  2104              MOVS     r1,#4
0000b8  4628              MOV      r0,r5
0000ba  f7fffffe          BL       nrf_uart_task_trigger
                  |L49.190|
;;;736                    }
;;;737                    nrf_uart_int_disable(p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
0000be  f44f7101          MOV      r1,#0x204
0000c2  4628              MOV      r0,r5
0000c4  f7fffffe          BL       nrf_uart_int_disable
;;;738                    p_cb->rx_buffer_length = 0;
0000c8  2000              MOVS     r0,#0
0000ca  75e0              STRB     r0,[r4,#0x17]
;;;739                    rx_done_event(p_cb, p_cb->rx_counter, p_cb->p_rx_buffer);
0000cc  7e61              LDRB     r1,[r4,#0x19]
0000ce  68e2              LDR      r2,[r4,#0xc]
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       rx_done_event
                  |L49.214|
;;;740                }
;;;741            }
;;;742        }
;;;743    
;;;744        if (nrf_uart_event_check(p_uart, NRF_UART_EVENT_TXDRDY))
0000d6  f44f718e          MOV      r1,#0x11c
0000da  4628              MOV      r0,r5
0000dc  f7fffffe          BL       nrf_uart_event_check
0000e0  b198              CBZ      r0,|L49.266|
;;;745        {
;;;746            if (p_cb->tx_counter < (uint16_t) p_cb->tx_buffer_length)
0000e2  8aa0              LDRH     r0,[r4,#0x14]
0000e4  7da1              LDRB     r1,[r4,#0x16]
0000e6  4288              CMP      r0,r1
0000e8  da04              BGE      |L49.244|
;;;747            {
;;;748                tx_byte(p_uart, p_cb);
0000ea  4621              MOV      r1,r4
0000ec  4628              MOV      r0,r5
0000ee  f7fffffe          BL       tx_byte
0000f2  e00a              B        |L49.266|
                  |L49.244|
;;;749            }
;;;750            else
;;;751            {
;;;752                nrf_uart_event_clear(p_uart, NRF_UART_EVENT_TXDRDY);
0000f4  f44f718e          MOV      r1,#0x11c
0000f8  4628              MOV      r0,r5
0000fa  f7fffffe          BL       nrf_uart_event_clear
;;;753                if (p_cb->tx_buffer_length)
0000fe  7da0              LDRB     r0,[r4,#0x16]
000100  b118              CBZ      r0,|L49.266|
;;;754                {
;;;755                    tx_done_event(p_cb, p_cb->tx_buffer_length);
000102  7da1              LDRB     r1,[r4,#0x16]
000104  4620              MOV      r0,r4
000106  f7fffffe          BL       tx_done_event
                  |L49.266|
;;;756                }
;;;757            }
;;;758        }
;;;759    
;;;760        if (nrf_uart_event_check(p_uart, NRF_UART_EVENT_RXTO))
00010a  f44f71a2          MOV      r1,#0x144
00010e  4628              MOV      r0,r5
000110  f7fffffe          BL       nrf_uart_event_check
000114  b198              CBZ      r0,|L49.318|
;;;761        {
;;;762            nrf_uart_event_clear(p_uart, NRF_UART_EVENT_RXTO);
000116  f44f71a2          MOV      r1,#0x144
00011a  4628              MOV      r0,r5
00011c  f7fffffe          BL       nrf_uart_event_clear
;;;763    
;;;764            // RXTO event may be triggered as a result of abort call. In th
;;;765            if (p_cb->rx_enabled)
000120  7ea0              LDRB     r0,[r4,#0x1a]
000122  b118              CBZ      r0,|L49.300|
;;;766            {
;;;767                nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STARTRX);
000124  2100              MOVS     r1,#0
000126  4628              MOV      r0,r5
000128  f7fffffe          BL       nrf_uart_task_trigger
                  |L49.300|
;;;768            }
;;;769            if (p_cb->rx_buffer_length)
00012c  7de0              LDRB     r0,[r4,#0x17]
00012e  b130              CBZ      r0,|L49.318|
;;;770            {
;;;771                p_cb->rx_buffer_length = 0;
000130  2000              MOVS     r0,#0
000132  75e0              STRB     r0,[r4,#0x17]
;;;772                rx_done_event(p_cb, p_cb->rx_counter, p_cb->p_rx_buffer);
000134  7e61              LDRB     r1,[r4,#0x19]
000136  68e2              LDR      r2,[r4,#0xc]
000138  4620              MOV      r0,r4
00013a  f7fffffe          BL       rx_done_event
                  |L49.318|
;;;773            }
;;;774        }
;;;775    }
00013e  e8bd81ff          POP      {r0-r8,pc}
;;;776    #endif
                          ENDP


                          AREA ||i.uarte_irq_handler||, CODE, READONLY, ALIGN=1

                  uarte_irq_handler PROC
;;;778    #if defined(UARTE_IN_USE)
;;;779    __STATIC_INLINE void uarte_irq_handler(NRF_UARTE_Type * p_uarte, uart_control_block_t * p_cb)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;780    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;781        if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_ERROR))
000008  f44f7192          MOV      r1,#0x124
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       nrf_uarte_event_check
000012  b1d8              CBZ      r0,|L50.76|
;;;782        {
;;;783            nrf_drv_uart_event_t event;
;;;784    
;;;785            nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_ERROR);
000014  f44f7192          MOV      r1,#0x124
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       nrf_uarte_event_clear
;;;786    
;;;787            event.type                   = NRF_DRV_UART_EVT_ERROR;
00001e  2002              MOVS     r0,#2
000020  f88d0000          STRB     r0,[sp,#0]
;;;788            event.data.error.error_mask  = nrf_uarte_errorsrc_get_and_clear(p_uarte);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       nrf_uarte_errorsrc_get_and_clear
00002a  9003              STR      r0,[sp,#0xc]
;;;789            event.data.error.rxtx.bytes  = nrf_uarte_rx_amount_get(p_uarte);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       nrf_uarte_rx_amount_get
000032  b2c1              UXTB     r1,r0
000034  f88d1008          STRB     r1,[sp,#8]
;;;790            event.data.error.rxtx.p_data = p_cb->p_rx_buffer;
000038  68e0              LDR      r0,[r4,#0xc]
00003a  9001              STR      r0,[sp,#4]
;;;791    
;;;792            //abort transfer
;;;793            p_cb->rx_buffer_length = 0;
00003c  2000              MOVS     r0,#0
00003e  75e0              STRB     r0,[r4,#0x17]
;;;794            p_cb->rx_secondary_buffer_length = 0;
000040  7620              STRB     r0,[r4,#0x18]
;;;795    
;;;796            p_cb->handler(&event, p_cb->p_context);
000042  4668              MOV      r0,sp
000044  e9d41200          LDRD     r1,r2,[r4,#0]
000048  4790              BLX      r2
;;;797        }
00004a  e02f              B        |L50.172|
                  |L50.76|
;;;798        else if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_ENDRX))
00004c  f44f7188          MOV      r1,#0x110
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       nrf_uarte_event_check
000056  b348              CBZ      r0,|L50.172|
;;;799        {
;;;800            nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_ENDRX);
000058  f44f7188          MOV      r1,#0x110
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       nrf_uarte_event_clear
;;;801            uint8_t amount = nrf_uarte_rx_amount_get(p_uarte);
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       nrf_uarte_rx_amount_get
000068  b2c6              UXTB     r6,r0
;;;802            // If the transfer was stopped before completion, amount of transfered bytes
;;;803            // will not be equal to the buffer length. Interrupted trunsfer is ignored.
;;;804            if (amount == p_cb->rx_buffer_length)
00006a  7de0              LDRB     r0,[r4,#0x17]
00006c  42b0              CMP      r0,r6
00006e  d11c              BNE      |L50.170|
;;;805            {
;;;806                if (p_cb->rx_secondary_buffer_length)
000070  7e20              LDRB     r0,[r4,#0x18]
000072  b198              CBZ      r0,|L50.156|
;;;807                {
;;;808                    uint8_t * p_data = p_cb->p_rx_buffer;
000074  68e7              LDR      r7,[r4,#0xc]
;;;809                    nrf_uarte_shorts_disable(p_uarte, NRF_UARTE_SHORT_ENDRX_STARTRX);
000076  2020              MOVS     r0,#0x20
000078  f8d51200          LDR      r1,[r5,#0x200]
00007c  4381              BICS     r1,r1,r0
00007e  f8c51200          STR      r1,[r5,#0x200]
000082  bf00              NOP      
;;;810                    p_cb->rx_buffer_length = p_cb->rx_secondary_buffer_length;
000084  7e20              LDRB     r0,[r4,#0x18]
000086  75e0              STRB     r0,[r4,#0x17]
;;;811                    p_cb->p_rx_buffer = p_cb->p_rx_secondary_buffer;
000088  6920              LDR      r0,[r4,#0x10]
00008a  60e0              STR      r0,[r4,#0xc]
;;;812                    p_cb->rx_secondary_buffer_length = 0;
00008c  2000              MOVS     r0,#0
00008e  7620              STRB     r0,[r4,#0x18]
;;;813                    rx_done_event(p_cb, amount, p_data);
000090  463a              MOV      r2,r7
000092  4631              MOV      r1,r6
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       rx_done_event
;;;814                }
00009a  e006              B        |L50.170|
                  |L50.156|
;;;815                else
;;;816                {
;;;817                    p_cb->rx_buffer_length = 0;
00009c  2000              MOVS     r0,#0
00009e  75e0              STRB     r0,[r4,#0x17]
;;;818                    rx_done_event(p_cb, amount, p_cb->p_rx_buffer);
0000a0  4631              MOV      r1,r6
0000a2  4620              MOV      r0,r4
0000a4  68e2              LDR      r2,[r4,#0xc]
0000a6  f7fffffe          BL       rx_done_event
                  |L50.170|
;;;819                }
;;;820            }
;;;821        }
0000aa  bf00              NOP      
                  |L50.172|
;;;822    
;;;823        if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_RXTO))
0000ac  f44f71a2          MOV      r1,#0x144
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       nrf_uarte_event_check
0000b6  b188              CBZ      r0,|L50.220|
;;;824        {
;;;825            nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_RXTO);
0000b8  f44f71a2          MOV      r1,#0x144
0000bc  4628              MOV      r0,r5
0000be  f7fffffe          BL       nrf_uarte_event_clear
;;;826            if (p_cb->rx_buffer_length)
0000c2  7de0              LDRB     r0,[r4,#0x17]
0000c4  b150              CBZ      r0,|L50.220|
;;;827            {
;;;828                p_cb->rx_buffer_length = 0;
0000c6  2000              MOVS     r0,#0
0000c8  75e0              STRB     r0,[r4,#0x17]
;;;829                rx_done_event(p_cb, nrf_uarte_rx_amount_get(p_uarte), p_cb->p_rx_buffer);
0000ca  4628              MOV      r0,r5
0000cc  f7fffffe          BL       nrf_uarte_rx_amount_get
0000d0  b2c6              UXTB     r6,r0
0000d2  4631              MOV      r1,r6
0000d4  4620              MOV      r0,r4
0000d6  68e2              LDR      r2,[r4,#0xc]
0000d8  f7fffffe          BL       rx_done_event
                  |L50.220|
;;;830            }
;;;831        }
;;;832    
;;;833        if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_ENDTX))
0000dc  f44f7190          MOV      r1,#0x120
0000e0  4628              MOV      r0,r5
0000e2  f7fffffe          BL       nrf_uarte_event_check
0000e6  b178              CBZ      r0,|L50.264|
;;;834        {
;;;835            nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_ENDTX);
0000e8  f44f7190          MOV      r1,#0x120
0000ec  4628              MOV      r0,r5
0000ee  f7fffffe          BL       nrf_uarte_event_clear
;;;836            if (p_cb->tx_buffer_length)
0000f2  7da0              LDRB     r0,[r4,#0x16]
0000f4  b140              CBZ      r0,|L50.264|
;;;837            {
;;;838                tx_done_event(p_cb, nrf_uarte_tx_amount_get(p_uarte));
0000f6  bf00              NOP      
0000f8  f240504c          MOV      r0,#0x54c
0000fc  5940              LDR      r0,[r0,r5]
0000fe  b2c6              UXTB     r6,r0
000100  4631              MOV      r1,r6
000102  4620              MOV      r0,r4
000104  f7fffffe          BL       tx_done_event
                  |L50.264|
;;;839            }
;;;840        }
;;;841    }
000108  e8bd81ff          POP      {r0-r8,pc}
;;;842    #endif
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_cb
                          %        32

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\uart\\nrf_drv_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_nrf_drv_uart_c_fa4207eb____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_nrf_drv_uart_c_fa4207eb____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_nrf_drv_uart_c_fa4207eb____REVSH|
#line 402
|__asm___14_nrf_drv_uart_c_fa4207eb____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_nrf_drv_uart_c_fa4207eb____RRX|
#line 587
|__asm___14_nrf_drv_uart_c_fa4207eb____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
