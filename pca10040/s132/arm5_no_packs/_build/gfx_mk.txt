; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\gfx_mk.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\gfx_mk.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\gfx_mk.crf ..\..\..\..\..\..\external\ugfx\src\gfx_mk.c]
                          THUMB

                          AREA ||i.Qadd||, CODE, READONLY, ALIGN=1

                  Qadd PROC
;;;523    
;;;524    static void Qadd(threadQ * q, thread *t) {
000000  2200              MOVS     r2,#0
;;;525    	t->next = 0;
000002  600a              STR      r2,[r1,#0]
;;;526    	if (q->head) {
000004  6802              LDR      r2,[r0,#0]
000006  b11a              CBZ      r2,|L1.16|
;;;527    		q->tail->next = t;
000008  6842              LDR      r2,[r0,#4]
00000a  6011              STR      r1,[r2,#0]
;;;528    		q->tail = t;
00000c  6041              STR      r1,[r0,#4]
00000e  e001              B        |L1.20|
                  |L1.16|
;;;529    	} else
;;;530    		q->head = q->tail = t;
000010  6041              STR      r1,[r0,#4]
000012  6001              STR      r1,[r0,#0]
                  |L1.20|
;;;531    }
000014  4770              BX       lr
;;;532    
                          ENDP


                          AREA ||i.Qinit||, CODE, READONLY, ALIGN=1

                  Qinit PROC
;;;519    
;;;520    static void Qinit(threadQ * q) {
000000  2100              MOVS     r1,#0
;;;521    	q->head = q->tail = 0;
000002  6041              STR      r1,[r0,#4]
000004  6001              STR      r1,[r0,#0]
;;;522    }
000006  4770              BX       lr
;;;523    
                          ENDP


                          AREA ||i.Qpop||, CODE, READONLY, ALIGN=1

                  Qpop PROC
;;;532    
;;;533    static thread *Qpop(threadQ * q) {
000000  4601              MOV      r1,r0
;;;534    	struct thread * t;
;;;535    
;;;536    	if (!q->head)
000002  6808              LDR      r0,[r1,#0]
000004  b908              CBNZ     r0,|L3.10|
;;;537    		return 0;
000006  2000              MOVS     r0,#0
                  |L3.8|
;;;538    	t = q->head;
;;;539    	q->head = t->next;
;;;540    	return t;
;;;541    }
000008  4770              BX       lr
                  |L3.10|
00000a  680a              LDR      r2,[r1,#0]            ;538
00000c  6810              LDR      r0,[r2,#0]            ;539
00000e  6008              STR      r0,[r1,#0]            ;539
000010  4610              MOV      r0,r2                 ;540
000012  e7f9              B        |L3.8|
;;;542    
                          ENDP


                          AREA ||i.StartupLogoDisplay||, CODE, READONLY, ALIGN=2

                  StartupLogoDisplay PROC
;;;503    	static bool_t	gdispInitDone;
;;;504    	static void StartupLogoDisplay(GDisplay *g) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4606              MOV      r6,r0
;;;505    		coord_t			x, y, w;
;;;506    		const coord_t *	p;
;;;507    		static const coord_t blks[] = {
;;;508    				// u
;;;509    				2, 6, 1, 10,
;;;510    				3, 11, 4, 1,
;;;511    				6, 6, 1, 6,
;;;512    				// G
;;;513    				8, 0, 1, 12,
;;;514    				9, 0, 6, 1,
;;;515    				9, 11, 6, 1,
;;;516    				14, 6, 1, 5,
;;;517    				12, 6, 2, 1,
;;;518    				// F
;;;519    				16, 0, 1, 12,
;;;520    				17, 0, 6, 1,
;;;521    				17, 6, 3, 1,
;;;522    				// X
;;;523    				22, 6, 7, 1,
;;;524    				24, 0, 1, 6,
;;;525    				22, 7, 1, 5,
;;;526    				28, 0, 1, 6,
;;;527    				26, 7, 1, 5,
;;;528    		};
;;;529    
;;;530    		// Get a starting position and a scale
;;;531    		// Work on a 8x16 grid for each char, 4 chars (uGFX) in 1 line, using half the screen
;;;532    		w = g->g.Width/(8*4*2);
000006  f9b60008          LDRSH    r0,[r6,#8]
00000a  17c1              ASRS     r1,r0,#31
00000c  eb006191          ADD      r1,r0,r1,LSR #26
000010  118c              ASRS     r4,r1,#6
;;;533    		if (!w) w = 1;
000012  b904              CBNZ     r4,|L4.22|
000014  2401              MOVS     r4,#1
                  |L4.22|
;;;534    		x = (g->g.Width - (8*4)*w)/2;
000016  f9b61008          LDRSH    r1,[r6,#8]
00001a  2220              MOVS     r2,#0x20
00001c  fb021014          MLS      r0,r2,r4,r1
000020  eb0071d0          ADD      r1,r0,r0,LSR #31
000024  1049              ASRS     r1,r1,#1
000026  b20f              SXTH     r7,r1
;;;535    		y = (g->g.Height - (16*1)*w)/2;
000028  f9b6100a          LDRSH    r1,[r6,#0xa]
00002c  2210              MOVS     r2,#0x10
00002e  fb021014          MLS      r0,r2,r4,r1
000032  eb0071d0          ADD      r1,r0,r0,LSR #31
000036  1049              ASRS     r1,r1,#1
000038  fa0ff881          SXTH     r8,r1
;;;536    
;;;537    		// Simple but crude!
;;;538    		for(p = blks; p < blks+sizeof(blks)/sizeof(blks[0]); p+=4)
00003c  4d0f              LDR      r5,|L4.124|
00003e  e016              B        |L4.110|
                  |L4.64|
;;;539    			gdispGFillArea(g, x+p[0]*w, y+p[1]*w, p[2]*w, p[3]*w, GDISP_STARTUP_LOGO_COLOR);
000040  2107              MOVS     r1,#7
000042  88e8              LDRH     r0,[r5,#6]
000044  4360              MULS     r0,r4,r0
000046  b200              SXTH     r0,r0
000048  e9cd0100          STRD     r0,r1,[sp,#0]
00004c  88a8              LDRH     r0,[r5,#4]
00004e  4360              MULS     r0,r4,r0
000050  b203              SXTH     r3,r0
000052  f9b50002          LDRSH    r0,[r5,#2]
000056  fb008004          MLA      r0,r0,r4,r8
00005a  b202              SXTH     r2,r0
00005c  f9b50000          LDRSH    r0,[r5,#0]
000060  fb007004          MLA      r0,r0,r4,r7
000064  b201              SXTH     r1,r0
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       gdispGFillArea
00006c  3508              ADDS     r5,r5,#8              ;538
                  |L4.110|
00006e  4803              LDR      r0,|L4.124|
000070  3080              ADDS     r0,r0,#0x80           ;538
000072  4285              CMP      r5,r0                 ;538
000074  d3e4              BCC      |L4.64|
;;;540    	}
000076  e8bd81fc          POP      {r2-r8,pc}
;;;541    #endif
                          ENDP

00007a  0000              DCW      0x0000
                  |L4.124|
                          DCD      blks

                          AREA ||i._gdispDeInitDriver||, CODE, READONLY, ALIGN=2

                  _gdispDeInitDriver PROC
;;;677    
;;;678    void _gdispDeInitDriver(GDriver *g) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;679    	#define		gd		((GDisplay *)g)
;;;680    
;;;681    	if (GDISP == gd)
000004  4805              LDR      r0,|L5.28|
000006  6800              LDR      r0,[r0,#0]  ; GDISP
000008  42a0              CMP      r0,r4
00000a  d105              BNE      |L5.24|
;;;682    		GDISP = (GDisplay *)gdriverGetInstance(GDRIVER_TYPE_DISPLAY, 0);
00000c  2100              MOVS     r1,#0
00000e  2067              MOVS     r0,#0x67
000010  f7fffffe          BL       gdriverGetInstance
000014  4901              LDR      r1,|L5.28|
000016  6008              STR      r0,[r1,#0]  ; GDISP
                  |L5.24|
;;;683    
;;;684    	#if GDISP_HARDWARE_DEINIT
;;;685    		#if GDISP_HARDWARE_DEINIT == HARDWARE_AUTODETECT
;;;686    			if (gvmt(gd)->deinit)
;;;687    		#endif
;;;688    		{
;;;689    			MUTEX_ENTER(gd);
;;;690    			gdisp_lld_deinit(gd);
;;;691    			MUTEX_EXIT(gd);
;;;692    		}
;;;693    	#endif
;;;694    	MUTEX_DEINIT(gd);
;;;695    
;;;696    	#undef gd
;;;697    }
000018  bd10              POP      {r4,pc}
;;;698    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      GDISP

                          AREA ||i._gdispDeinit||, CODE, READONLY, ALIGN=1

                  _gdispDeinit PROC
;;;616    
;;;617    void _gdispDeinit(void)
000000  4770              BX       lr
;;;618    {
;;;619    	/* ToDo */
;;;620    }
;;;621    
                          ENDP


                          AREA ||i._gdispInit||, CODE, READONLY, ALIGN=2

                  _gdispInit PROC
;;;556    
;;;557    void _gdispInit(void)
000000  b510              PUSH     {r4,lr}
;;;558    {
;;;559    	// GDISP_DRIVER_LIST is defined - create each driver instance
;;;560    	#if defined(GDISP_DRIVER_LIST)
;;;561    		{
;;;562    			unsigned	i;
;;;563    			typedef const GDISPVMT const GDISPVMTLIST[1];
;;;564    
;;;565    			extern GDISPVMTLIST						  GDISP_DRIVER_LIST;
;;;566    			static const GDISPVMT * const dclist[] = {GDISP_DRIVER_LIST};
;;;567    
;;;568    			for(i = 0; i < sizeof(dclist)/sizeof(dclist[0]); i++) {
;;;569    				if (!(dclist[i]->d.flags & GDISP_VFLG_DYNAMICONLY))
;;;570    					gdriverRegister(&dclist[i]->d, 0);
;;;571    			}
;;;572    		}
;;;573    	#elif GDISP_TOTAL_DISPLAYS > 1
;;;574    		{
;;;575    			unsigned	i;
;;;576    			extern const GDISPVMT const		GDISPVMT_OnlyOne[1];
;;;577    
;;;578    			if (!(GDISPVMT_OnlyOne->d.flags & GDISP_VFLG_DYNAMICONLY)) {
;;;579    				for(i = 0; i < GDISP_TOTAL_DISPLAYS; i++)
;;;580    					gdriverRegister(&GDISPVMT_OnlyOne->d, 0);
;;;581    			}
;;;582    		}
;;;583    	#else
;;;584    		{
;;;585    			extern const GDISPVMT const		GDISPVMT_OnlyOne[1];
;;;586    
;;;587    			if (!(GDISPVMT_OnlyOne->d.flags & GDISP_VFLG_DYNAMICONLY))
000002  4812              LDR      r0,|L7.76|
000004  7880              LDRB     r0,[r0,#2]  ; GDISPVMT_OnlyOne
000006  f0000001          AND      r0,r0,#1
00000a  b918              CBNZ     r0,|L7.20|
;;;588    				gdriverRegister(&GDISPVMT_OnlyOne->d, 0);
00000c  2100              MOVS     r1,#0
00000e  480f              LDR      r0,|L7.76|
000010  f7fffffe          BL       gdriverRegister
                  |L7.20|
;;;589    		}
;;;590    	#endif
;;;591    
;;;592    	// Re-clear the display after the timeout if we added the logo
;;;593    	#if GDISP_STARTUP_LOGO_TIMEOUT > 0
;;;594    		{
;;;595    			GDisplay	*g;
;;;596    
;;;597    			gfxSleepMilliseconds(GDISP_STARTUP_LOGO_TIMEOUT);
000014  f44f707a          MOV      r0,#0x3e8
000018  f7fffffe          BL       gfxSleepMilliseconds
;;;598    
;;;599    			for(g = (GDisplay *)gdriverGetNext(GDRIVER_TYPE_DISPLAY, 0); g; g = (GDisplay *)gdriverGetNext(GDRIVER_TYPE_DISPLAY, (GDriver *)g)) {
00001c  2100              MOVS     r1,#0
00001e  2067              MOVS     r0,#0x67
000020  f7fffffe          BL       gdriverGetNext
000024  4604              MOV      r4,r0
000026  e00b              B        |L7.64|
                  |L7.40|
;;;600    				gdispGClear(g, GDISP_STARTUP_COLOR);
000028  2100              MOVS     r1,#0
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       gdispGClear
;;;601    				#if GDISP_HARDWARE_FLUSH
;;;602    					gdispGFlush(g);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       gdispGFlush
000036  4621              MOV      r1,r4                 ;599
000038  2067              MOVS     r0,#0x67              ;599
00003a  f7fffffe          BL       gdriverGetNext
00003e  4604              MOV      r4,r0                 ;599
                  |L7.64|
000040  2c00              CMP      r4,#0                 ;599
000042  d1f1              BNE      |L7.40|
;;;603    				#endif
;;;604    			}
;;;605    
;;;606    			gdispInitDone = TRUE;
000044  20ff              MOVS     r0,#0xff
000046  4902              LDR      r1,|L7.80|
000048  7008              STRB     r0,[r1,#0]
;;;607    		}
;;;608    	#endif
;;;609    
;;;610    	// Start the automatic timer flush (if required)
;;;611    	#if GDISP_NEED_TIMERFLUSH
;;;612    		gtimerInit(&FlushTimer);
;;;613    		gtimerStart(&FlushTimer, FlushTimerFn, 0, TRUE, GDISP_NEED_TIMERFLUSH);
;;;614    	#endif
;;;615    }
00004a  bd10              POP      {r4,pc}
;;;616    
                          ENDP

                  |L7.76|
                          DCD      GDISPVMT_OnlyOne
                  |L7.80|
                          DCD      gdispInitDone

                          AREA ||i._gdispInitDriver||, CODE, READONLY, ALIGN=1

                  _gdispInitDriver PROC
;;;621    
;;;622    bool_t _gdispInitDriver(GDriver *g, void *param, unsigned driverinstance, unsigned systeminstance) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;623    	#define		gd		((GDisplay *)g)
;;;624    	bool_t		ret;
;;;625    
;;;626    	// Intialise fields
;;;627    	gd->systemdisplay = systeminstance;
00000c  7727              STRB     r7,[r4,#0x1c]
;;;628    	gd->controllerdisplay = driverinstance;
00000e  7766              STRB     r6,[r4,#0x1d]
;;;629    	gd->flags = 0;
000010  2000              MOVS     r0,#0
000012  83e0              STRH     r0,[r4,#0x1e]
;;;630    	gd->priv = param;
000014  6165              STR      r5,[r4,#0x14]
;;;631    	MUTEX_INIT(gd);
;;;632    
;;;633    	// Call the driver init
;;;634    	MUTEX_ENTER(gd);
;;;635    	ret = gdisp_lld_init(gd);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gdisp_lld_init
00001c  4680              MOV      r8,r0
;;;636    	MUTEX_EXIT(gd);
;;;637    	return ret;
00001e  4640              MOV      r0,r8
;;;638    
;;;639    	#undef gd
;;;640    }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;641    
                          ENDP


                          AREA ||i._gdispPostInitDriver||, CODE, READONLY, ALIGN=2

                  _gdispPostInitDriver PROC
;;;641    
;;;642    void _gdispPostInitDriver(GDriver *g) {
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
;;;643    	#define		gd		((GDisplay *)g)
;;;644    
;;;645    	// Set orientation, clip
;;;646    	#if defined(GDISP_DEFAULT_ORIENTATION) && GDISP_NEED_CONTROL && GDISP_HARDWARE_CONTROL
;;;647    		#if GDISP_NEED_PIXMAP
;;;648    			// Pixmaps should stay in their created orientation (at least initially)
;;;649    			if (!(gvmt(gd)->d.flags & GDISP_VFLG_PIXMAP))
;;;650    		#endif
;;;651    			gdispGControl(gd, GDISP_CONTROL_ORIENTATION, (void *)GDISP_DEFAULT_ORIENTATION);
;;;652    	#endif
;;;653    	#if GDISP_NEED_VALIDATION || GDISP_NEED_CLIP
;;;654    		gdispGSetClip(gd, 0, 0, gd->g.Width, gd->g.Height);
000004  f9b4000a          LDRSH    r0,[r4,#0xa]
000008  9000              STR      r0,[sp,#0]
00000a  f9b43008          LDRSH    r3,[r4,#8]
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       gdispGSetClip
;;;655    	#endif
;;;656    
;;;657    	// Clear the Screen
;;;658    	gdispGClear(gd, GDISP_STARTUP_COLOR);
000018  2100              MOVS     r1,#0
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       gdispGClear
;;;659    
;;;660    	// Display the startup logo if this is a static initialised display
;;;661    	#if GDISP_STARTUP_LOGO_TIMEOUT > 0
;;;662    		if (!gdispInitDone)
000020  4807              LDR      r0,|L9.64|
000022  7800              LDRB     r0,[r0,#0]  ; gdispInitDone
000024  b910              CBNZ     r0,|L9.44|
;;;663    			StartupLogoDisplay(gd);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       StartupLogoDisplay
                  |L9.44|
;;;664    	#endif
;;;665    
;;;666    	// Flush
;;;667    	#if GDISP_HARDWARE_FLUSH
;;;668    		gdispGFlush(gd);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       gdispGFlush
;;;669    	#endif
;;;670    
;;;671    	// If this is the first driver set GDISP
;;;672    	if (!GDISP)
000032  4804              LDR      r0,|L9.68|
000034  6800              LDR      r0,[r0,#0]  ; GDISP
000036  b908              CBNZ     r0,|L9.60|
;;;673    		GDISP = gd;
000038  4802              LDR      r0,|L9.68|
00003a  6004              STR      r4,[r0,#0]  ; GDISP
                  |L9.60|
;;;674    
;;;675    	#undef gd
;;;676    }
00003c  bd38              POP      {r3-r5,pc}
;;;677    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      gdispInitDone
                  |L9.68|
                          DCD      GDISP

                          AREA ||i._gdriverDeinit||, CODE, READONLY, ALIGN=2

                  _gdriverDeinit PROC
;;;24     // The system de-initialization.
;;;25     void _gdriverDeinit(void) {
000000  b510              PUSH     {r4,lr}
;;;26     	while(dhead)
000002  e003              B        |L10.12|
                  |L10.4|
;;;27     		gdriverUnRegister(dhead);
000004  4804              LDR      r0,|L10.24|
000006  6800              LDR      r0,[r0,#0]  ; dhead
000008  f7fffffe          BL       gdriverUnRegister
                  |L10.12|
00000c  4802              LDR      r0,|L10.24|
00000e  6800              LDR      r0,[r0,#0]            ;26  ; dhead
000010  2800              CMP      r0,#0                 ;26
000012  d1f7              BNE      |L10.4|
;;;28     }
000014  bd10              POP      {r4,pc}
;;;29     
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      dhead

                          AREA ||i._gdriverInit||, CODE, READONLY, ALIGN=1

                  _gdriverInit PROC
;;;20     // The system initialization.
;;;21     void _gdriverInit(void) {
000000  4770              BX       lr
;;;22     }
;;;23     
                          ENDP


                          AREA ||i._gfxAdjustCxt||, CODE, READONLY, ALIGN=2

                  _gfxAdjustCxt PROC
;;;442    	// Move the stack frame and relocate the context data
;;;443    	static void _gfxAdjustCxt(thread *t) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
;;;444    		char **	s;
;;;445    		char *	nf;
;;;446    		int		diff;
;;;447    		uint32_t	i;
;;;448    
;;;449    		// Copy the stack frame
;;;450    		#if AUTO_DETECT_STACKFRAME
;;;451    			if (STACK_DIR_UP) {					// Stack grows up
000004  4825              LDR      r0,|L12.156|
000006  7800              LDRB     r0,[r0,#0]  ; stackdirup
000008  b180              CBZ      r0,|L12.44|
;;;452    				nf = (char *)(t) + sizeof(thread) + sizeof(jmp_buf) + STACK_BASE;
00000a  f10400b8          ADD      r0,r4,#0xb8
00000e  4924              LDR      r1,|L12.160|
000010  6809              LDR      r1,[r1,#0]  ; stackbase
000012  1846              ADDS     r6,r0,r1
;;;453    				memcpy(t+1, (char *)&s - STACK_BASE, STACK_BASE+sizeof(char *));
000014  4a22              LDR      r2,|L12.160|
000016  6812              LDR      r2,[r2,#0]  ; stackbase
000018  ebad0102          SUB      r1,sp,r2
00001c  4820              LDR      r0,|L12.160|
00001e  6802              LDR      r2,[r0,#0]  ; stackbase
000020  1d12              ADDS     r2,r2,#4
000022  f1040018          ADD      r0,r4,#0x18
000026  f7fffffe          BL       __aeabi_memcpy
00002a  e00c              B        |L12.70|
                  |L12.44|
;;;454    			} else {							// Stack grows down
;;;455    				nf = (char *)(t) + t->size - (STACK_BASE + sizeof(char *));
00002c  68a0              LDR      r0,[r4,#8]
00002e  1901              ADDS     r1,r0,r4
000030  481b              LDR      r0,|L12.160|
000032  6800              LDR      r0,[r0,#0]  ; stackbase
000034  1d00              ADDS     r0,r0,#4
000036  1a0e              SUBS     r6,r1,r0
;;;456    				memcpy(nf, &s, STACK_BASE+sizeof(char *));
000038  4819              LDR      r0,|L12.160|
00003a  6802              LDR      r2,[r0,#0]  ; stackbase
00003c  1d12              ADDS     r2,r2,#4
00003e  4669              MOV      r1,sp
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       __aeabi_memcpy
                  |L12.70|
;;;457    			}
;;;458    		#elif STACK_DIR_UP
;;;459    			// Stack grows up
;;;460    			nf = (char *)(t) + sizeof(thread) + sizeof(jmp_buf) + STACK_BASE;
;;;461    			memcpy(t+1, (char *)&s - STACK_BASE, STACK_BASE+sizeof(char *));
;;;462    		#else
;;;463    			// Stack grows down
;;;464    			nf = (char *)(t) + t->size - (STACK_BASE + sizeof(char *));
;;;465    			memcpy(nf, &s, STACK_BASE+sizeof(char *));
;;;466    		#endif
;;;467    
;;;468    		// Relocate the context data
;;;469    		s = (char **)(t->cxt);
000046  6960              LDR      r0,[r4,#0x14]
000048  9000              STR      r0,[sp,#0]
;;;470    		diff = nf - (char *)&s;
00004a  4668              MOV      r0,sp
00004c  1a37              SUBS     r7,r6,r0
;;;471    
;;;472    		// Relocate the elements we know need to be relocated
;;;473    		for (i = MASK1; i ; i >>= 1, s++) {
00004e  4815              LDR      r0,|L12.164|
000050  6805              LDR      r5,[r0,#0]  ; jmpmask1
000052  e00b              B        |L12.108|
                  |L12.84|
;;;474    			if ((i & 1))
000054  f0050001          AND      r0,r5,#1
000058  b120              CBZ      r0,|L12.100|
;;;475    				*s += diff;
00005a  9800              LDR      r0,[sp,#0]
00005c  6800              LDR      r0,[r0,#0]
00005e  4438              ADD      r0,r0,r7
000060  9900              LDR      r1,[sp,#0]
000062  6008              STR      r0,[r1,#0]
                  |L12.100|
000064  086d              LSRS     r5,r5,#1              ;473
000066  9800              LDR      r0,[sp,#0]            ;473
000068  1d00              ADDS     r0,r0,#4              ;473
00006a  9000              STR      r0,[sp,#0]            ;473
                  |L12.108|
00006c  2d00              CMP      r5,#0                 ;473
00006e  d1f1              BNE      |L12.84|
;;;476    		}
;;;477    		#ifdef MASK2
;;;478    			s = (char **)(t->cxt)+32;
000070  6960              LDR      r0,[r4,#0x14]
000072  3080              ADDS     r0,r0,#0x80
000074  9000              STR      r0,[sp,#0]
;;;479    			for (i = MASK2; i ; i >>= 1, s++) {
000076  480c              LDR      r0,|L12.168|
000078  6805              LDR      r5,[r0,#0]  ; jmpmask2
00007a  e00b              B        |L12.148|
                  |L12.124|
;;;480    				if ((i & 1))
00007c  f0050001          AND      r0,r5,#1
000080  b120              CBZ      r0,|L12.140|
;;;481    					*s += diff;
000082  9800              LDR      r0,[sp,#0]
000084  6800              LDR      r0,[r0,#0]
000086  4438              ADD      r0,r0,r7
000088  9900              LDR      r1,[sp,#0]
00008a  6008              STR      r0,[r1,#0]
                  |L12.140|
00008c  086d              LSRS     r5,r5,#1              ;479
00008e  9800              LDR      r0,[sp,#0]            ;479
000090  1d00              ADDS     r0,r0,#4              ;479
000092  9000              STR      r0,[sp,#0]            ;479
                  |L12.148|
000094  2d00              CMP      r5,#0                 ;479
000096  d1f1              BNE      |L12.124|
;;;482    			}
;;;483    		#endif
;;;484    	}
000098  bdf8              POP      {r3-r7,pc}
;;;485    	static void _gfxXSwitch(thread *oldt, thread *newt, bool_t doBuildFrame) {
                          ENDP

00009a  0000              DCW      0x0000
                  |L12.156|
                          DCD      stackdirup
                  |L12.160|
                          DCD      stackbase
                  |L12.164|
                          DCD      jmpmask1
                  |L12.168|
                          DCD      jmpmask2

                          AREA ||i._gfxGetStackState||, CODE, READONLY, ALIGN=2

                  _gfxGetStackState PROC
;;;383    		// These two functions are not static to prevent the compiler removing them as functions
;;;384    		void _gfxGetStackState(void) {
000000  b508              PUSH     {r3,lr}
;;;385    			char *c;
;;;386    			pframeinfo->localptr = (char *)&c;
000002  4905              LDR      r1,|L13.24|
000004  6809              LDR      r1,[r1,#0]  ; pframeinfo
000006  f8c1d000          STR      sp,[r1,#0]
;;;387    			CXT_SAVE(pframeinfo->cxt);
00000a  4803              LDR      r0,|L13.24|
00000c  6800              LDR      r0,[r0,#0]  ; pframeinfo
00000e  3008              ADDS     r0,r0,#8
000010  f7fffffe          BL       setjmp
;;;388    		}
000014  bd08              POP      {r3,pc}
;;;389    		void _gfxGetStackStateInFn(void) {
                          ENDP

000016  0000              DCW      0x0000
                  |L13.24|
                          DCD      pframeinfo

                          AREA ||i._gfxGetStackStateInFn||, CODE, READONLY, ALIGN=2

                  _gfxGetStackStateInFn PROC
;;;388    		}
;;;389    		void _gfxGetStackStateInFn(void) {
000000  b510              PUSH     {r4,lr}
;;;390    			pframeinfo++;
000002  4806              LDR      r0,|L14.28|
000004  6800              LDR      r0,[r0,#0]  ; pframeinfo
000006  30a8              ADDS     r0,r0,#0xa8
000008  4904              LDR      r1,|L14.28|
00000a  6008              STR      r0,[r1,#0]  ; pframeinfo
;;;391    			_gfxGetStackState();
00000c  f7fffffe          BL       _gfxGetStackState
;;;392    			pframeinfo--;
000010  4802              LDR      r0,|L14.28|
000012  6800              LDR      r0,[r0,#0]  ; pframeinfo
000014  38a8              SUBS     r0,r0,#0xa8
000016  4901              LDR      r1,|L14.28|
000018  6008              STR      r0,[r1,#0]  ; pframeinfo
;;;393    		}
00001a  bd10              POP      {r4,pc}
;;;394    		static void _gfxThreadsInit(void) {
                          ENDP

                  |L14.28|
                          DCD      pframeinfo

                          AREA ||i._gfxThreadsInit||, CODE, READONLY, ALIGN=2

                  _gfxThreadsInit PROC
;;;393    		}
;;;394    		static void _gfxThreadsInit(void) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  b0d4              SUB      sp,sp,#0x150
;;;395    			uint32_t	i;
;;;396    			char **		pout;
;;;397    			char **		pin;
;;;398    			size_t		diff;
;;;399    			char *		framebase;
;;;400    			saveloc		tmpsaveloc[2];
;;;401    
;;;402    			// Create the main thread context
;;;403    			mainthread.cxt = maincxt;
000006  4837              LDR      r0,|L15.228|
000008  4937              LDR      r1,|L15.232|
00000a  6148              STR      r0,[r1,#0x14]  ; mainthread
;;;404    
;;;405    			// Allocate a buffer to store our test data
;;;406    			pframeinfo = tmpsaveloc;
00000c  4937              LDR      r1,|L15.236|
00000e  f8c1d000          STR      sp,[r1,#0]  ; pframeinfo
;;;407    
;;;408    			// Get details of the stack frame from within a function
;;;409    			_gfxGetStackStateInFn();
000012  f7fffffe          BL       _gfxGetStackStateInFn
;;;410    
;;;411    			// Get details of the stack frame outside the function
;;;412    			_gfxGetStackState();
000016  f7fffffe          BL       _gfxGetStackState
;;;413    
;;;414    			/* Work out the frame entries to relocate by treating the jump buffer as an array of pointers */
;;;415    			stackdirup =  pframeinfo[1].localptr > pframeinfo[0].localptr;
00001a  4834              LDR      r0,|L15.236|
00001c  6800              LDR      r0,[r0,#0]  ; pframeinfo
00001e  f8d000a8          LDR      r0,[r0,#0xa8]
000022  4932              LDR      r1,|L15.236|
000024  6809              LDR      r1,[r1,#0]  ; pframeinfo
000026  6809              LDR      r1,[r1,#0]
000028  4288              CMP      r0,r1
00002a  d901              BLS      |L15.48|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L15.50|
                  |L15.48|
000030  2000              MOVS     r0,#0
                  |L15.50|
000032  492f              LDR      r1,|L15.240|
000034  7008              STRB     r0,[r1,#0]
;;;416    			pout = (char **)pframeinfo[0].cxt;
000036  482d              LDR      r0,|L15.236|
000038  6800              LDR      r0,[r0,#0]  ; pframeinfo
00003a  f1000408          ADD      r4,r0,#8
;;;417    			pin =  (char **)pframeinfo[1].cxt;
00003e  482b              LDR      r0,|L15.236|
000040  6800              LDR      r0,[r0,#0]  ; pframeinfo
000042  f10007b0          ADD      r7,r0,#0xb0
;;;418    			diff = pframeinfo[0].localptr - pframeinfo[1].localptr;
000046  4829              LDR      r0,|L15.236|
000048  6800              LDR      r0,[r0,#0]  ; pframeinfo
00004a  6800              LDR      r0,[r0,#0]
00004c  4927              LDR      r1,|L15.236|
00004e  6809              LDR      r1,[r1,#0]  ; pframeinfo
000050  f8d110a8          LDR      r1,[r1,#0xa8]
000054  eba00801          SUB      r8,r0,r1
;;;419    			framebase = pframeinfo[0].localptr;
000058  4824              LDR      r0,|L15.236|
00005a  6800              LDR      r0,[r0,#0]  ; pframeinfo
00005c  6806              LDR      r6,[r0,#0]
;;;420    			jmpmask1 = jmpmask2 = 0;
00005e  2000              MOVS     r0,#0
000060  4924              LDR      r1,|L15.244|
000062  6008              STR      r0,[r1,#0]  ; jmpmask2
000064  4924              LDR      r1,|L15.248|
000066  6008              STR      r0,[r1,#0]  ; jmpmask1
;;;421    			for (i = 0; i < sizeof(jmp_buf)/sizeof(char *); i++, pout++, pin++) {
000068  2500              MOVS     r5,#0
00006a  e027              B        |L15.188|
                  |L15.108|
;;;422    				if ((size_t)(*pout - *pin) == diff) {
00006c  6820              LDR      r0,[r4,#0]
00006e  6839              LDR      r1,[r7,#0]
000070  1a40              SUBS     r0,r0,r1
000072  4540              CMP      r0,r8
000074  d11f              BNE      |L15.182|
;;;423    					if (i < 32)
000076  2d20              CMP      r5,#0x20
000078  d207              BCS      |L15.138|
;;;424    						jmpmask1 |= 1 << i;
00007a  2001              MOVS     r0,#1
00007c  40a8              LSLS     r0,r0,r5
00007e  491e              LDR      r1,|L15.248|
000080  6809              LDR      r1,[r1,#0]  ; jmpmask1
000082  4308              ORRS     r0,r0,r1
000084  491c              LDR      r1,|L15.248|
000086  6008              STR      r0,[r1,#0]  ; jmpmask1
000088  e009              B        |L15.158|
                  |L15.138|
;;;425    					else
;;;426    						jmpmask2 |= 1 << (i-32);
00008a  f1a50020          SUB      r0,r5,#0x20
00008e  2101              MOVS     r1,#1
000090  fa01f000          LSL      r0,r1,r0
000094  4917              LDR      r1,|L15.244|
000096  6809              LDR      r1,[r1,#0]  ; jmpmask2
000098  4308              ORRS     r0,r0,r1
00009a  4916              LDR      r1,|L15.244|
00009c  6008              STR      r0,[r1,#0]  ; jmpmask2
                  |L15.158|
;;;427    
;;;428    					if (stackdirup) {
00009e  4814              LDR      r0,|L15.240|
0000a0  7800              LDRB     r0,[r0,#0]  ; stackdirup
0000a2  b120              CBZ      r0,|L15.174|
;;;429    						if (framebase > *pout)
0000a4  6820              LDR      r0,[r4,#0]
0000a6  42b0              CMP      r0,r6
0000a8  d205              BCS      |L15.182|
;;;430    							framebase = *pout;
0000aa  6826              LDR      r6,[r4,#0]
0000ac  e003              B        |L15.182|
                  |L15.174|
;;;431    					} else {
;;;432    						if (framebase < *pout)
0000ae  6820              LDR      r0,[r4,#0]
0000b0  42b0              CMP      r0,r6
0000b2  d900              BLS      |L15.182|
;;;433    							framebase = *pout;
0000b4  6826              LDR      r6,[r4,#0]
                  |L15.182|
0000b6  1c6d              ADDS     r5,r5,#1              ;421
0000b8  1d24              ADDS     r4,r4,#4              ;421
0000ba  1d3f              ADDS     r7,r7,#4              ;421
                  |L15.188|
0000bc  2d28              CMP      r5,#0x28              ;421
0000be  d3d5              BCC      |L15.108|
;;;434    					}
;;;435    				}
;;;436    			}
;;;437    			stackbase = stackdirup ? (pframeinfo[0].localptr - framebase) : (framebase - pframeinfo[0].localptr);
0000c0  480b              LDR      r0,|L15.240|
0000c2  7800              LDRB     r0,[r0,#0]  ; stackdirup
0000c4  b120              CBZ      r0,|L15.208|
0000c6  4809              LDR      r0,|L15.236|
0000c8  6800              LDR      r0,[r0,#0]  ; pframeinfo
0000ca  6800              LDR      r0,[r0,#0]
0000cc  1b80              SUBS     r0,r0,r6
0000ce  e003              B        |L15.216|
                  |L15.208|
0000d0  4806              LDR      r0,|L15.236|
0000d2  6800              LDR      r0,[r0,#0]  ; pframeinfo
0000d4  6800              LDR      r0,[r0,#0]
0000d6  1a30              SUBS     r0,r6,r0
                  |L15.216|
0000d8  4908              LDR      r1,|L15.252|
0000da  6008              STR      r0,[r1,#0]  ; stackbase
;;;438    		}
0000dc  b054              ADD      sp,sp,#0x150
0000de  e8bd81f0          POP      {r4-r8,pc}
;;;439    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L15.228|
                          DCD      maincxt
                  |L15.232|
                          DCD      mainthread
                  |L15.236|
                          DCD      pframeinfo
                  |L15.240|
                          DCD      stackdirup
                  |L15.244|
                          DCD      jmpmask2
                  |L15.248|
                          DCD      jmpmask1
                  |L15.252|
                          DCD      stackbase

                          AREA ||i._gfxXSwitch||, CODE, READONLY, ALIGN=2

                  _gfxXSwitch PROC
;;;484    	}
;;;485    	static void _gfxXSwitch(thread *oldt, thread *newt, bool_t doBuildFrame) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;486    
;;;487    		// Save the old context
;;;488    		if (CXT_SAVE(oldt->cxt)) return;
00000a  6968              LDR      r0,[r5,#0x14]
00000c  f7fffffe          BL       setjmp
000010  b108              CBZ      r0,|L16.22|
;;;489    
;;;490    		// Do we need to build a new context?
;;;491    		if (doBuildFrame) {
;;;492    
;;;493    			// Save our existing context as a starting point for the new context
;;;494    			newt->cxt = newt+1;
;;;495    			if (CXT_SAVE(newt->cxt)) {
;;;496    
;;;497    				// We are now running the new thread
;;;498    
;;;499    				// We can't use any of the above function parameters here
;;;500    				//	as we are on a different stack.
;;;501    
;;;502    				// Run the users function.
;;;503    				gfxThreadExit(current->fn(current->param));
;;;504    
;;;505    				// We never get here as gfxThreadExit() never returns
;;;506    			}
;;;507    
;;;508    			// Adjust the new context so the stack references are correct
;;;509    			_gfxAdjustCxt(newt);
;;;510    		}
;;;511    
;;;512    		// Start the new context
;;;513    		CXT_RESTORE(newt->cxt, 1);
;;;514    	}
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L16.22|
000016  b19e              CBZ      r6,|L16.64|
000018  f1040018          ADD      r0,r4,#0x18           ;494
00001c  6160              STR      r0,[r4,#0x14]         ;494
00001e  6960              LDR      r0,[r4,#0x14]         ;495
000020  f7fffffe          BL       setjmp
000024  b148              CBZ      r0,|L16.58|
000026  4a08              LDR      r2,|L16.72|
000028  6812              LDR      r2,[r2,#0]            ;503  ; current
00002a  6910              LDR      r0,[r2,#0x10]         ;503
00002c  4a06              LDR      r2,|L16.72|
00002e  6812              LDR      r2,[r2,#0]            ;503  ; current
000030  68d1              LDR      r1,[r2,#0xc]          ;503
000032  4788              BLX      r1                    ;503
000034  4607              MOV      r7,r0                 ;503
000036  f7fffffe          BL       gfxThreadExit
                  |L16.58|
00003a  4620              MOV      r0,r4                 ;509
00003c  f7fffffe          BL       _gfxAdjustCxt
                  |L16.64|
000040  2101              MOVS     r1,#1                 ;513
000042  6960              LDR      r0,[r4,#0x14]         ;513
000044  f7fffffe          BL       longjmp
;;;515    
                          ENDP

                  |L16.72|
                          DCD      current

                          AREA ||i._gosDeinit||, CODE, READONLY, ALIGN=1

                  _gosDeinit PROC
;;;38     
;;;39     void _gosDeinit(void)
000000  4770              BX       lr
;;;40     {
;;;41     	/* ToDo */
;;;42     }
;;;43     
                          ENDP


                          AREA ||i._gosHeapInit||, CODE, READONLY, ALIGN=1

                  _gosHeapInit PROC
;;;17     
;;;18     	void _gosHeapInit(void) {
000000  4770              BX       lr
;;;19     	}
;;;20     	void *gfxAlloc(size_t sz) {
                          ENDP


                          AREA ||i._gosInit||, CODE, READONLY, ALIGN=1

                  _gosInit PROC
;;;21     
;;;22     void _gosInit(void)
000000  b510              PUSH     {r4,lr}
;;;23     {
;;;24     	/* No initialization of the operating system itself is needed as there isn't one.
;;;25     	 * On the other hand the C runtime should still already be initialized before
;;;26     	 * getting here!
;;;27     	 */
;;;28     	#if !GFX_OS_INIT_NO_WARNING
;;;29     		#warning "GOS: Raw32 - Make sure you initialize your hardware and the C runtime before calling gfxInit() in your application!"
;;;30     	#endif
;;;31     
;;;32     	// Set up the heap allocator
;;;33     	_gosHeapInit();
000002  f7fffffe          BL       _gosHeapInit
;;;34     
;;;35     	// Start the scheduler
;;;36     	_gosThreadsInit();
000006  f7fffffe          BL       _gosThreadsInit
;;;37     }
00000a  bd10              POP      {r4,pc}
;;;38     
                          ENDP


                          AREA ||i._gosThreadsInit||, CODE, READONLY, ALIGN=2

                  _gosThreadsInit PROC
;;;542    
;;;543    void _gosThreadsInit(void) {
000000  b510              PUSH     {r4,lr}
;;;544    	Qinit(&readyQ);
000002  4809              LDR      r0,|L20.40|
000004  f7fffffe          BL       Qinit
;;;545    
;;;546    	mainthread.next = 0;
000008  2000              MOVS     r0,#0
00000a  4908              LDR      r1,|L20.44|
00000c  6008              STR      r0,[r1,#0]  ; mainthread
;;;547    	mainthread.size = sizeof(thread);
00000e  2018              MOVS     r0,#0x18
000010  6088              STR      r0,[r1,#8]  ; mainthread
;;;548    	mainthread.flags = FLG_THD_MAIN;
000012  2002              MOVS     r0,#2
000014  6048              STR      r0,[r1,#4]  ; mainthread
;;;549    	mainthread.fn = 0;
000016  2000              MOVS     r0,#0
000018  60c8              STR      r0,[r1,#0xc]  ; mainthread
;;;550    	mainthread.param = 0;
00001a  6108              STR      r0,[r1,#0x10]  ; mainthread
;;;551    
;;;552    	_gfxThreadsInit();
00001c  f7fffffe          BL       _gfxThreadsInit
;;;553    
;;;554    	current = &mainthread;
000020  4802              LDR      r0,|L20.44|
000022  4903              LDR      r1,|L20.48|
000024  6008              STR      r0,[r1,#0]  ; current
;;;555    }
000026  bd10              POP      {r4,pc}
;;;556    
                          ENDP

                  |L20.40|
                          DCD      readyQ
                  |L20.44|
                          DCD      mainthread
                  |L20.48|
                          DCD      current

                          AREA ||i.cleanUpDeadThreads||, CODE, READONLY, ALIGN=2

                  cleanUpDeadThreads PROC
;;;561    // Check if there are dead processes to deallocate
;;;562    static void cleanUpDeadThreads(void) {
000000  b510              PUSH     {r4,lr}
;;;563    	thread *p;
;;;564    
;;;565    	while ((p = Qpop(&deadQ)))
000002  e002              B        |L21.10|
                  |L21.4|
;;;566    		gfxFree(p);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       gfxFree
                  |L21.10|
00000a  4803              LDR      r0,|L21.24|
00000c  f7fffffe          BL       Qpop
000010  1e04              SUBS     r4,r0,#0              ;565
000012  d1f7              BNE      |L21.4|
;;;567    }
000014  bd10              POP      {r4,pc}
;;;568    
                          ENDP

000016  0000              DCW      0x0000
                  |L21.24|
                          DCD      deadQ

                          AREA ||i.drawpixel_clip||, CODE, READONLY, ALIGN=1

                  drawpixel_clip PROC
;;;165    #if NEED_CLIPPING
;;;166    	static GFXINLINE void drawpixel_clip(GDisplay *g) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;167    		#if GDISP_HARDWARE_CLIP == HARDWARE_AUTODETECT
;;;168    			if (!gvmt(g)->setclip)
;;;169    		#endif
;;;170    		{
;;;171    			if (g->p.x < g->clipx0 || g->p.x >= g->clipx1 || g->p.y < g->clipy0 || g->p.y >= g->clipy1)
000004  f9b40028          LDRSH    r0,[r4,#0x28]
000008  f9b41020          LDRSH    r1,[r4,#0x20]
00000c  4288              CMP      r0,r1
00000e  db11              BLT      |L22.52|
000010  f9b40028          LDRSH    r0,[r4,#0x28]
000014  f9b41024          LDRSH    r1,[r4,#0x24]
000018  4288              CMP      r0,r1
00001a  da0b              BGE      |L22.52|
00001c  f9b4002a          LDRSH    r0,[r4,#0x2a]
000020  f9b41022          LDRSH    r1,[r4,#0x22]
000024  4288              CMP      r0,r1
000026  db05              BLT      |L22.52|
000028  f9b4002a          LDRSH    r0,[r4,#0x2a]
00002c  f9b41026          LDRSH    r1,[r4,#0x26]
000030  4288              CMP      r0,r1
000032  db00              BLT      |L22.54|
                  |L22.52|
;;;172    				return;
;;;173    		}
;;;174    		drawpixel(g);
;;;175    	}
000034  bd10              POP      {r4,pc}
                  |L22.54|
000036  bf00              NOP                            ;174
000038  4620              MOV      r0,r4                 ;174
00003a  f7fffffe          BL       gdisp_lld_draw_pixel
00003e  bf00              NOP                            ;174
000040  bf00              NOP      
000042  e7f7              B        |L22.52|
;;;176    #else
                          ENDP


                          AREA ||i.fillarea||, CODE, READONLY, ALIGN=1

                  fillarea PROC
;;;184    // Resets the streaming area if GDISP_HARDWARE_STREAM_WRITE and GDISP_HARDWARE_STREAM_POS is set.
;;;185    static GFXINLINE void fillarea(GDisplay *g) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;186    
;;;187    	// Best is hardware accelerated area fill
;;;188    	#if GDISP_HARDWARE_FILLS
;;;189    		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
;;;190    			if (gvmt(g)->fill)
;;;191    		#endif
;;;192    		{
;;;193    			gdisp_lld_fill_area(g);
;;;194    			return;
;;;195    		}
;;;196    	#endif
;;;197    
;;;198    	// Next best is hardware streaming
;;;199    	#if GDISP_HARDWARE_FILLS != TRUE && GDISP_HARDWARE_STREAM_WRITE
;;;200    		#if GDISP_HARDWARE_STREAM_WRITE == HARDWARE_AUTODETECT
;;;201    			if (gvmt(g)->writestart)
;;;202    		#endif
;;;203    		{
;;;204    			uint32_t	area;
;;;205    
;;;206    			#if GDISP_HARDWARE_STREAM_POS
;;;207    				if ((g->flags & GDISP_FLG_SCRSTREAM)) {
;;;208    					gdisp_lld_write_stop(g);
;;;209    					g->flags &= ~GDISP_FLG_SCRSTREAM;
;;;210    				}
;;;211    			#endif
;;;212    
;;;213    			area = (uint32_t)g->p.cx * g->p.cy;
;;;214    			gdisp_lld_write_start(g);
;;;215    			#if GDISP_HARDWARE_STREAM_POS
;;;216    				#if GDISP_HARDWARE_STREAM_POS == HARDWARE_AUTODETECT
;;;217    					if (gvmt(g)->writepos)
;;;218    				#endif
;;;219    				gdisp_lld_write_pos(g);
;;;220    			#endif
;;;221    			for(; area; area--)
;;;222    				gdisp_lld_write_color(g);
;;;223    			gdisp_lld_write_stop(g);
;;;224    			return;
;;;225    		}
;;;226    	#endif
;;;227    
;;;228    	// Worst is pixel drawing
;;;229    	#if GDISP_HARDWARE_FILLS != TRUE && GDISP_HARDWARE_STREAM_WRITE != TRUE && GDISP_HARDWARE_DRAWPIXEL
;;;230    		// The following test is unneeded because we are guaranteed to have draw pixel if we don't have streaming
;;;231    		//#if GDISP_HARDWARE_DRAWPIXEL == HARDWARE_AUTODETECT
;;;232    		//	if (gvmt(g)->pixel)
;;;233    		//#endif
;;;234    		{
;;;235    			coord_t x0, y0, x1, y1;
;;;236    
;;;237    			x0 = g->p.x;
000006  f9b45028          LDRSH    r5,[r4,#0x28]
;;;238    			y0 = g->p.y;
00000a  f9b4602a          LDRSH    r6,[r4,#0x2a]
;;;239    			x1 = g->p.x + g->p.cx;
00000e  8d21              LDRH     r1,[r4,#0x28]
000010  8da0              LDRH     r0,[r4,#0x2c]
000012  4408              ADD      r0,r0,r1
000014  b207              SXTH     r7,r0
;;;240    			y1 = g->p.y + g->p.cy;
000016  8d61              LDRH     r1,[r4,#0x2a]
000018  8de0              LDRH     r0,[r4,#0x2e]
00001a  4408              ADD      r0,r0,r1
00001c  fa0ff880          SXTH     r8,r0
;;;241    			for(; g->p.y < y1; g->p.y++, g->p.x = x0)
000020  e010              B        |L23.68|
                  |L23.34|
;;;242    				for(; g->p.x < x1; g->p.x++)
000022  e006              B        |L23.50|
                  |L23.36|
;;;243    					gdisp_lld_draw_pixel(g);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       gdisp_lld_draw_pixel
00002a  8d20              LDRH     r0,[r4,#0x28]         ;242
00002c  1c40              ADDS     r0,r0,#1              ;242
00002e  b200              SXTH     r0,r0                 ;242
000030  8520              STRH     r0,[r4,#0x28]         ;242
                  |L23.50|
000032  f9b40028          LDRSH    r0,[r4,#0x28]         ;242
000036  42b8              CMP      r0,r7                 ;242
000038  dbf4              BLT      |L23.36|
00003a  8d60              LDRH     r0,[r4,#0x2a]         ;241
00003c  1c40              ADDS     r0,r0,#1              ;241
00003e  b201              SXTH     r1,r0                 ;241
000040  8561              STRH     r1,[r4,#0x2a]         ;241
000042  8525              STRH     r5,[r4,#0x28]         ;241
                  |L23.68|
000044  f9b4002a          LDRSH    r0,[r4,#0x2a]         ;241
000048  4540              CMP      r0,r8                 ;241
00004a  dbea              BLT      |L23.34|
;;;244    			g->p.y = y0;
00004c  8566              STRH     r6,[r4,#0x2a]
;;;245    			return;
;;;246    		}
;;;247    	#endif
;;;248    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;249    
                          ENDP


                          AREA ||i.gdispBlendColor||, CODE, READONLY, ALIGN=1

                  gdispBlendColor PROC
;;;3412   
;;;3413   color_t gdispBlendColor(color_t fg, color_t bg, uint8_t alpha)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3414   {
000004  4603              MOV      r3,r0
;;;3415   	uint16_t fg_ratio = alpha + 1;
000006  1c54              ADDS     r4,r2,#1
;;;3416   	uint16_t bg_ratio = 256 - alpha;
000008  f5c27580          RSB      r5,r2,#0x100
;;;3417   	uint16_t r, g, b;
;;;3418   
;;;3419   	r = RED_OF(fg) * fg_ratio;
00000c  f0030004          AND      r0,r3,#4
000010  0140              LSLS     r0,r0,#5
000012  4360              MULS     r0,r4,r0
000014  b286              UXTH     r6,r0
;;;3420   	g = GREEN_OF(fg) * fg_ratio;
000016  f0030002          AND      r0,r3,#2
00001a  0180              LSLS     r0,r0,#6
00001c  4360              MULS     r0,r4,r0
00001e  b287              UXTH     r7,r0
;;;3421   	b = BLUE_OF(fg) * fg_ratio;
000020  07d8              LSLS     r0,r3,#31
000022  0e00              LSRS     r0,r0,#24
000024  4360              MULS     r0,r4,r0
000026  fa1ffc80          UXTH     r12,r0
;;;3422   
;;;3423   	r += RED_OF(bg) * bg_ratio;
00002a  f0010004          AND      r0,r1,#4
00002e  0140              LSLS     r0,r0,#5
000030  fb006005          MLA      r0,r0,r5,r6
000034  b286              UXTH     r6,r0
;;;3424   	g += GREEN_OF(bg) * bg_ratio;
000036  f0010002          AND      r0,r1,#2
00003a  0180              LSLS     r0,r0,#6
00003c  fb007005          MLA      r0,r0,r5,r7
000040  b287              UXTH     r7,r0
;;;3425   	b += BLUE_OF(bg) * bg_ratio;
000042  07c8              LSLS     r0,r1,#31
000044  0e00              LSRS     r0,r0,#24
000046  fb00c005          MLA      r0,r0,r5,r12
00004a  fa1ffc80          UXTH     r12,r0
;;;3426   
;;;3427   	r >>= 8;
00004e  1236              ASRS     r6,r6,#8
;;;3428   	g >>= 8;
000050  123f              ASRS     r7,r7,#8
;;;3429   	b >>= 8;
000052  ea4f2c2c          ASR      r12,r12,#8
;;;3430   
;;;3431   	return RGB2COLOR(r, g, b);
000056  f0060080          AND      r0,r6,#0x80
00005a  1140              ASRS     r0,r0,#5
00005c  f0070880          AND      r8,r7,#0x80
000060  ea4010a8          ORR      r0,r0,r8,ASR #6
000064  ea4010dc          ORR      r0,r0,r12,LSR #7
;;;3432   }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;3433   
                          ENDP


                          AREA ||i.gdispContrastColor||, CODE, READONLY, ALIGN=1

                  gdispContrastColor PROC
;;;3433   
;;;3434   color_t gdispContrastColor(color_t color) {
000000  b530              PUSH     {r4,r5,lr}
000002  4601              MOV      r1,r0
;;;3435   	uint16_t r, g, b;
;;;3436   
;;;3437   	r = RED_OF(color) > 128 ? 0 : 255;
000004  f0010004          AND      r0,r1,#4
000008  2580              MOVS     r5,#0x80
00000a  ebb51f40          CMP      r5,r0,LSL #5
00000e  da01              BGE      |L25.20|
000010  2000              MOVS     r0,#0
000012  e000              B        |L25.22|
                  |L25.20|
000014  20ff              MOVS     r0,#0xff
                  |L25.22|
000016  4602              MOV      r2,r0
;;;3438   	g = GREEN_OF(color) > 128 ? 0 : 255;
000018  f0010002          AND      r0,r1,#2
00001c  2580              MOVS     r5,#0x80
00001e  ebb51f80          CMP      r5,r0,LSL #6
000022  da01              BGE      |L25.40|
000024  2000              MOVS     r0,#0
000026  e000              B        |L25.42|
                  |L25.40|
000028  20ff              MOVS     r0,#0xff
                  |L25.42|
00002a  4603              MOV      r3,r0
;;;3439   	b = BLUE_OF(color) > 128 ? 0 : 255;
00002c  f0010001          AND      r0,r1,#1
000030  2580              MOVS     r5,#0x80
000032  ebb51fc0          CMP      r5,r0,LSL #7
000036  da01              BGE      |L25.60|
000038  2000              MOVS     r0,#0
00003a  e000              B        |L25.62|
                  |L25.60|
00003c  20ff              MOVS     r0,#0xff
                  |L25.62|
00003e  4604              MOV      r4,r0
;;;3440   
;;;3441   	return RGB2COLOR(r, g, b);
000040  f0020080          AND      r0,r2,#0x80
000044  1140              ASRS     r0,r0,#5
000046  f0030580          AND      r5,r3,#0x80
00004a  ea4010a5          ORR      r0,r0,r5,ASR #6
00004e  f3c415c0          UBFX     r5,r4,#7,#1
000052  4328              ORRS     r0,r0,r5
;;;3442   }
000054  bd30              POP      {r4,r5,pc}
;;;3443   
                          ENDP


                          AREA ||i.gdispGBlitArea||, CODE, READONLY, ALIGN=1

                  gdispGBlitArea PROC
;;;1098   
;;;1099   void gdispGBlitArea(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, coord_t srcx, coord_t srcy, coord_t srccx, const pixel_t *buffer) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd9b0d          LDRD     r9,r11,[sp,#0x34]
000010  e9dda80a          LDRD     r10,r8,[sp,#0x28]
;;;1100   	MUTEX_ENTER(g);
;;;1101   
;;;1102   	#if NEED_CLIPPING
;;;1103   		#if GDISP_HARDWARE_CLIP == HARDWARE_AUTODETECT
;;;1104   			if (!gvmt(g)->setclip)
;;;1105   		#endif
;;;1106   		{
;;;1107   			// This is a different clipping to fillarea(g) as it needs to take into account srcx,srcy
;;;1108   			if (x < g->clipx0) { cx -= g->clipx0 - x; srcx += g->clipx0 - x; x = g->clipx0; }
000014  f9b40020          LDRSH    r0,[r4,#0x20]
000018  42a8              CMP      r0,r5
00001a  dd0a              BLE      |L26.50|
00001c  8c20              LDRH     r0,[r4,#0x20]
00001e  1b40              SUBS     r0,r0,r5
000020  1a38              SUBS     r0,r7,r0
000022  b207              SXTH     r7,r0
000024  8c20              LDRH     r0,[r4,#0x20]
000026  1b40              SUBS     r0,r0,r5
000028  4440              ADD      r0,r0,r8
00002a  fa0ff880          SXTH     r8,r0
00002e  f9b45020          LDRSH    r5,[r4,#0x20]
                  |L26.50|
;;;1109   			if (y < g->clipy0) { cy -= g->clipy0 - y; srcy += g->clipy0 - x; y = g->clipy0; }
000032  f9b40022          LDRSH    r0,[r4,#0x22]
000036  42b0              CMP      r0,r6
000038  dd0d              BLE      |L26.86|
00003a  8c60              LDRH     r0,[r4,#0x22]
00003c  1b80              SUBS     r0,r0,r6
00003e  ebaa0000          SUB      r0,r10,r0
000042  fa0ffa80          SXTH     r10,r0
000046  8c60              LDRH     r0,[r4,#0x22]
000048  1b41              SUBS     r1,r0,r5
00004a  980c              LDR      r0,[sp,#0x30]
00004c  4408              ADD      r0,r0,r1
00004e  b200              SXTH     r0,r0
000050  900c              STR      r0,[sp,#0x30]
000052  f9b46022          LDRSH    r6,[r4,#0x22]
                  |L26.86|
;;;1110   			if (x+cx > g->clipx1)	cx = g->clipx1 - x;
000056  19e8              ADDS     r0,r5,r7
000058  f9b41024          LDRSH    r1,[r4,#0x24]
00005c  4288              CMP      r0,r1
00005e  dd02              BLE      |L26.102|
000060  8ca0              LDRH     r0,[r4,#0x24]
000062  1b40              SUBS     r0,r0,r5
000064  b207              SXTH     r7,r0
                  |L26.102|
;;;1111   			if (y+cy > g->clipy1)	cy = g->clipy1 - y;
000066  eb06000a          ADD      r0,r6,r10
00006a  f9b41026          LDRSH    r1,[r4,#0x26]
00006e  4288              CMP      r0,r1
000070  dd03              BLE      |L26.122|
000072  8ce0              LDRH     r0,[r4,#0x26]
000074  1b80              SUBS     r0,r0,r6
000076  fa0ffa80          SXTH     r10,r0
                  |L26.122|
;;;1112   			if (srcx+cx > srccx) cx = srccx - srcx;
00007a  eb080007          ADD      r0,r8,r7
00007e  4548              CMP      r0,r9
000080  dd02              BLE      |L26.136|
000082  eba90008          SUB      r0,r9,r8
000086  b207              SXTH     r7,r0
                  |L26.136|
;;;1113   			if (cx <= 0 || cy <= 0) { MUTEX_EXIT(g); return; }
000088  2f00              CMP      r7,#0
00008a  dd02              BLE      |L26.146|
00008c  f1ba0f00          CMP      r10,#0
000090  dc01              BGT      |L26.150|
                  |L26.146|
;;;1114   		}
;;;1115   	#endif
;;;1116   
;;;1117   	// Best is hardware bitfills
;;;1118   	#if GDISP_HARDWARE_BITFILLS
;;;1119   		#if GDISP_HARDWARE_BITFILLS == HARDWARE_AUTODETECT
;;;1120   			if (gvmt(g)->blit)
;;;1121   		#endif
;;;1122   		{
;;;1123   			g->p.x = x;
;;;1124   			g->p.y = y;
;;;1125   			g->p.cx = cx;
;;;1126   			g->p.cy = cy;
;;;1127   			g->p.x1 = srcx;
;;;1128   			g->p.y1 = srcy;
;;;1129   			g->p.x2 = srccx;
;;;1130   			g->p.ptr = (void *)buffer;
;;;1131   			gdisp_lld_blit_area(g);
;;;1132   			autoflush_stopdone(g);
;;;1133   			MUTEX_EXIT(g);
;;;1134   			return;
;;;1135   		}
;;;1136   	#endif
;;;1137   
;;;1138   	// Next best is hardware streaming
;;;1139   	#if GDISP_HARDWARE_BITFILLS != TRUE && GDISP_HARDWARE_STREAM_WRITE
;;;1140   		#if GDISP_HARDWARE_STREAM_WRITE == HARDWARE_AUTODETECT
;;;1141   			if (gvmt(g)->writestart)
;;;1142   		#endif
;;;1143   		{
;;;1144   			// Translate buffer to the real image data, use srcx,srcy as the end point, srccx as the buffer line gap
;;;1145   			buffer += srcy*srccx+srcx;
;;;1146   			srcx = x + cx;
;;;1147   			srcy = y + cy;
;;;1148   			srccx -= cx;
;;;1149   
;;;1150   			g->p.x = x;
;;;1151   			g->p.y = y;
;;;1152   			g->p.cx = cx;
;;;1153   			g->p.cy = cy;
;;;1154   			gdisp_lld_write_start(g);
;;;1155   			#if GDISP_HARDWARE_STREAM_POS
;;;1156   				#if GDISP_HARDWARE_STREAM_POS == HARDWARE_AUTODETECT
;;;1157   					if (gvmt(g)->writepos)
;;;1158   				#endif
;;;1159   				gdisp_lld_write_pos(g);
;;;1160   			#endif
;;;1161   			for(g->p.y = y; g->p.y < srcy; g->p.y++, buffer += srccx) {
;;;1162   				for(g->p.x = x; g->p.x < srcx; g->p.x++) {
;;;1163   					g->p.color = *buffer++;
;;;1164   					gdisp_lld_write_color(g);
;;;1165   				}
;;;1166   			}
;;;1167   			gdisp_lld_write_stop(g);
;;;1168   			autoflush_stopdone(g);
;;;1169   			MUTEX_EXIT(g);
;;;1170   			return;
;;;1171   		}
;;;1172   	#endif
;;;1173   
;;;1174   	// Only slightly better than drawing pixels is to look for runs and use fill area
;;;1175   	#if GDISP_HARDWARE_BITFILLS != TRUE && GDISP_HARDWARE_STREAM_WRITE != TRUE && GDISP_HARDWARE_FILLS
;;;1176   		// We don't need to test for auto-detect on drawpixel as we know we have it because we don't have streaming.
;;;1177   		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
;;;1178   			if (gvmt(g)->fill)
;;;1179   		#endif
;;;1180   		{
;;;1181   			// Translate buffer to the real image data, use srcx,srcy as the end point, srccx as the buffer line gap
;;;1182   			buffer += srcy*srccx+srcx;
;;;1183   			srcx = x + cx;
;;;1184   			srcy = y + cy;
;;;1185   			srccx -= cx;
;;;1186   
;;;1187   			g->p.cy = 1;
;;;1188   			for(g->p.y = y; g->p.y < srcy; g->p.y++, buffer += srccx) {
;;;1189   				for(g->p.x=x; g->p.x < srcx; g->p.x += g->p.cx) {
;;;1190   					g->p.cx=1;
;;;1191   					g->p.color = *buffer++;
;;;1192   					while(g->p.x+g->p.cx < srcx && *buffer == g->p.color) {
;;;1193   						g->p.cx++;
;;;1194   						buffer++;
;;;1195   					}
;;;1196   					if (g->p.cx == 1) {
;;;1197   						gdisp_lld_draw_pixel(g);
;;;1198   					} else {
;;;1199   						gdisp_lld_fill_area(g);
;;;1200   					}
;;;1201   				}
;;;1202   			}
;;;1203   			autoflush_stopdone(g);
;;;1204   			MUTEX_EXIT(g);
;;;1205   			return;
;;;1206   		}
;;;1207   	#endif
;;;1208   
;;;1209   	// Worst is drawing pixels
;;;1210   	#if GDISP_HARDWARE_BITFILLS != TRUE && GDISP_HARDWARE_STREAM_WRITE != TRUE && GDISP_HARDWARE_FILLS != TRUE && GDISP_HARDWARE_DRAWPIXEL
;;;1211   		// The following test is unneeded because we are guaranteed to have draw pixel if we don't have streaming
;;;1212   		//#if GDISP_HARDWARE_DRAWPIXEL == HARDWARE_AUTODETECT
;;;1213   		//	if (gvmt(g)->pixel)
;;;1214   		//#endif
;;;1215   		{
;;;1216   			// Translate buffer to the real image data, use srcx,srcy as the end point, srccx as the buffer line gap
;;;1217   			buffer += srcy*srccx+srcx;
;;;1218   			srcx = x + cx;
;;;1219   			srcy = y + cy;
;;;1220   			srccx -= cx;
;;;1221   
;;;1222   			for(g->p.y = y; g->p.y < srcy; g->p.y++, buffer += srccx) {
;;;1223   				for(g->p.x=x; g->p.x < srcx; g->p.x++) {
;;;1224   					g->p.color = *buffer++;
;;;1225   					gdisp_lld_draw_pixel(g);
;;;1226   				}
;;;1227   			}
;;;1228   			autoflush_stopdone(g);
;;;1229   			MUTEX_EXIT(g);
;;;1230   			return;
;;;1231   		}
;;;1232   	#endif
;;;1233   }
000092  e8bd9ff0          POP      {r4-r12,pc}
                  |L26.150|
000096  980c              LDR      r0,[sp,#0x30]         ;1217
000098  fb008009          MLA      r0,r0,r9,r8           ;1217
00009c  4483              ADD      r11,r11,r0            ;1217
00009e  19e8              ADDS     r0,r5,r7              ;1218
0000a0  fa0ff880          SXTH     r8,r0                 ;1218
0000a4  eb06000a          ADD      r0,r6,r10             ;1219
0000a8  b200              SXTH     r0,r0                 ;1219
0000aa  900c              STR      r0,[sp,#0x30]         ;1219
0000ac  eba90007          SUB      r0,r9,r7              ;1220
0000b0  fa0ff980          SXTH     r9,r0                 ;1220
0000b4  8566              STRH     r6,[r4,#0x2a]         ;1222
0000b6  e015              B        |L26.228|
                  |L26.184|
0000b8  8525              STRH     r5,[r4,#0x28]         ;1223
0000ba  e00a              B        |L26.210|
                  |L26.188|
0000bc  f81b1b01          LDRB     r1,[r11],#1           ;1224
0000c0  2038              MOVS     r0,#0x38              ;1224
0000c2  5501              STRB     r1,[r0,r4]            ;1224
0000c4  4620              MOV      r0,r4                 ;1225
0000c6  f7fffffe          BL       gdisp_lld_draw_pixel
0000ca  8d20              LDRH     r0,[r4,#0x28]         ;1223
0000cc  1c40              ADDS     r0,r0,#1              ;1223
0000ce  b200              SXTH     r0,r0                 ;1223
0000d0  8520              STRH     r0,[r4,#0x28]         ;1223
                  |L26.210|
0000d2  f9b40028          LDRSH    r0,[r4,#0x28]         ;1223
0000d6  4540              CMP      r0,r8                 ;1223
0000d8  dbf0              BLT      |L26.188|
0000da  8d60              LDRH     r0,[r4,#0x2a]         ;1222
0000dc  1c40              ADDS     r0,r0,#1              ;1222
0000de  b201              SXTH     r1,r0                 ;1222
0000e0  8561              STRH     r1,[r4,#0x2a]         ;1222
0000e2  44cb              ADD      r11,r11,r9            ;1222
                  |L26.228|
0000e4  f9b4102a          LDRSH    r1,[r4,#0x2a]         ;1222
0000e8  980c              LDR      r0,[sp,#0x30]         ;1222
0000ea  4281              CMP      r1,r0                 ;1222
0000ec  dbe4              BLT      |L26.184|
0000ee  bf00              NOP                            ;1230
0000f0  e7cf              B        |L26.146|
;;;1234   
                          ENDP


                          AREA ||i.gdispGClear||, CODE, READONLY, ALIGN=1

                  gdispGClear PROC
;;;1001   
;;;1002   void gdispGClear(GDisplay *g, color_t color) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1003   	// Note - clear() ignores the clipping area. It clears the screen.
;;;1004   	MUTEX_ENTER(g);
;;;1005   
;;;1006   	// Best is hardware accelerated clear
;;;1007   	#if GDISP_HARDWARE_CLEARS
;;;1008   		#if GDISP_HARDWARE_CLEARS == HARDWARE_AUTODETECT
;;;1009   			if (gvmt(g)->clear)
;;;1010   		#endif
;;;1011   		{
;;;1012   			g->p.color = color;
;;;1013   			gdisp_lld_clear(g);
;;;1014   			autoflush_stopdone(g);
;;;1015   			MUTEX_EXIT(g);
;;;1016   			return;
;;;1017   		}
;;;1018   	#endif
;;;1019   
;;;1020   	// Next best is hardware accelerated area fill
;;;1021   	#if GDISP_HARDWARE_CLEARS != TRUE && GDISP_HARDWARE_FILLS
;;;1022   		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
;;;1023   			if (gvmt(g)->fill)
;;;1024   		#endif
;;;1025   		{
;;;1026   			g->p.x = g->p.y = 0;
;;;1027   			g->p.cx = g->g.Width;
;;;1028   			g->p.cy = g->g.Height;
;;;1029   			g->p.color = color;
;;;1030   			gdisp_lld_fill_area(g);
;;;1031   			autoflush_stopdone(g);
;;;1032   			MUTEX_EXIT(g);
;;;1033   			return;
;;;1034   		}
;;;1035   	#endif
;;;1036   
;;;1037   	// Next best is streaming
;;;1038   	#if GDISP_HARDWARE_CLEARS != TRUE && GDISP_HARDWARE_FILLS != TRUE && GDISP_HARDWARE_STREAM_WRITE
;;;1039   		#if GDISP_HARDWARE_STREAM_WRITE == HARDWARE_AUTODETECT
;;;1040   			if (gvmt(g)->writestart)
;;;1041   		#endif
;;;1042   		{
;;;1043   			uint32_t	area;
;;;1044   
;;;1045   			g->p.x = g->p.y = 0;
;;;1046   			g->p.cx = g->g.Width;
;;;1047   			g->p.cy = g->g.Height;
;;;1048   			g->p.color = color;
;;;1049   			area = (uint32_t)g->p.cx * g->p.cy;
;;;1050   
;;;1051   			gdisp_lld_write_start(g);
;;;1052   			#if GDISP_HARDWARE_STREAM_POS
;;;1053   				#if GDISP_HARDWARE_STREAM_POS == HARDWARE_AUTODETECT
;;;1054   					if (gvmt(g)->writepos)
;;;1055   				#endif
;;;1056   				gdisp_lld_write_pos(g);
;;;1057   			#endif
;;;1058   			for(; area; area--)
;;;1059   				gdisp_lld_write_color(g);
;;;1060   			gdisp_lld_write_stop(g);
;;;1061   			autoflush_stopdone(g);
;;;1062   			MUTEX_EXIT(g);
;;;1063   			return;
;;;1064   		}
;;;1065   	#endif
;;;1066   
;;;1067   	// Worst is drawing pixels
;;;1068   	#if GDISP_HARDWARE_CLEARS != TRUE && GDISP_HARDWARE_FILLS != TRUE && GDISP_HARDWARE_STREAM_WRITE != TRUE && GDISP_HARDWARE_DRAWPIXEL
;;;1069   		// The following test is unneeded because we are guaranteed to have draw pixel if we don't have streaming
;;;1070   		//#if GDISP_HARDWARE_DRAWPIXEL == HARDWARE_AUTODETECT
;;;1071   		//	if (gvmt(g)->pixel)
;;;1072   		//#endif
;;;1073   		{
;;;1074   			g->p.color = color;
000006  2038              MOVS     r0,#0x38
000008  5505              STRB     r5,[r0,r4]
;;;1075   			for(g->p.y = 0; g->p.y < g->g.Height; g->p.y++)
00000a  2100              MOVS     r1,#0
00000c  8561              STRH     r1,[r4,#0x2a]
00000e  e013              B        |L27.56|
                  |L27.16|
;;;1076   				for(g->p.x = 0; g->p.x < g->g.Width; g->p.x++)
000010  2000              MOVS     r0,#0
000012  8520              STRH     r0,[r4,#0x28]
000014  e006              B        |L27.36|
                  |L27.22|
;;;1077   					gdisp_lld_draw_pixel(g);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       gdisp_lld_draw_pixel
00001c  8d20              LDRH     r0,[r4,#0x28]         ;1076
00001e  1c40              ADDS     r0,r0,#1              ;1076
000020  b200              SXTH     r0,r0                 ;1076
000022  8520              STRH     r0,[r4,#0x28]         ;1076
                  |L27.36|
000024  f9b40028          LDRSH    r0,[r4,#0x28]         ;1076
000028  f9b41008          LDRSH    r1,[r4,#8]            ;1076
00002c  4288              CMP      r0,r1                 ;1076
00002e  dbf2              BLT      |L27.22|
000030  8d60              LDRH     r0,[r4,#0x2a]         ;1075
000032  1c40              ADDS     r0,r0,#1              ;1075
000034  b201              SXTH     r1,r0                 ;1075
000036  8561              STRH     r1,[r4,#0x2a]         ;1075
                  |L27.56|
000038  f9b4102a          LDRSH    r1,[r4,#0x2a]         ;1075
00003c  f9b4000a          LDRSH    r0,[r4,#0xa]          ;1075
000040  4281              CMP      r1,r0                 ;1075
000042  dbe5              BLT      |L27.16|
;;;1078   			autoflush_stopdone(g);
;;;1079   			MUTEX_EXIT(g);
;;;1080   			return;
;;;1081   		}
;;;1082   	#endif
;;;1083   }
000044  bd70              POP      {r4-r6,pc}
;;;1084   
                          ENDP


                          AREA ||i.gdispGDrawBox||, CODE, READONLY, ALIGN=1

                  gdispGDrawBox PROC
;;;2756   
;;;2757   void gdispGDrawBox(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, color_t color) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
00000c  e9dd6908          LDRD     r6,r9,[sp,#0x20]
;;;2758   	if (cx <= 0 || cy <= 0) return;
000010  2f00              CMP      r7,#0
000012  dd01              BLE      |L28.24|
000014  2e00              CMP      r6,#0
000016  dc01              BGT      |L28.28|
                  |L28.24|
;;;2759   	cx = x+cx-1; cy = y+cy-1;			// cx, cy are now the end point.
;;;2760   
;;;2761   	MUTEX_ENTER(g);
;;;2762   
;;;2763   	g->p.color = color;
;;;2764   
;;;2765   	if (cx - x > 2) {
;;;2766   		g->p.x = x; g->p.y = y; g->p.x1 = cx; hline_clip(g);
;;;2767   		if (y != cy) {
;;;2768   			g->p.x = x; g->p.y = cy; g->p.x1 = cx; hline_clip(g);
;;;2769   			if (cy - y > 2) {
;;;2770   				y++; cy--;
;;;2771   				g->p.x = x; g->p.y = y; g->p.y1 = cy; vline_clip(g);
;;;2772   				g->p.x = cx; g->p.y = y; g->p.y1 = cy; vline_clip(g);
;;;2773   			}
;;;2774   		}
;;;2775   	} else {
;;;2776   		g->p.x = x; g->p.y = y; g->p.y1 = cy; vline_clip(g);
;;;2777   		if (x != cx) {
;;;2778   			g->p.x = cx; g->p.y = y; g->p.y1 = cy; vline_clip(g);
;;;2779   		}
;;;2780   	}
;;;2781   
;;;2782   	autoflush(g);
;;;2783   	MUTEX_EXIT(g);
;;;2784   }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L28.28|
00001c  eb080007          ADD      r0,r8,r7              ;2759
000020  1e40              SUBS     r0,r0,#1              ;2759
000022  b207              SXTH     r7,r0                 ;2759
000024  19a8              ADDS     r0,r5,r6              ;2759
000026  1e40              SUBS     r0,r0,#1              ;2759
000028  b206              SXTH     r6,r0                 ;2759
00002a  f8849038          STRB     r9,[r4,#0x38]         ;2763
00002e  eba70008          SUB      r0,r7,r8              ;2765
000032  2802              CMP      r0,#2                 ;2765
000034  dd24              BLE      |L28.128|
000036  f8a48028          STRH     r8,[r4,#0x28]         ;2766
00003a  8565              STRH     r5,[r4,#0x2a]         ;2766
00003c  8627              STRH     r7,[r4,#0x30]         ;2766
00003e  4620              MOV      r0,r4                 ;2766
000040  f7fffffe          BL       hline_clip
000044  42b5              CMP      r5,r6                 ;2767
000046  d02a              BEQ      |L28.158|
000048  f8a48028          STRH     r8,[r4,#0x28]         ;2768
00004c  8566              STRH     r6,[r4,#0x2a]         ;2768
00004e  8627              STRH     r7,[r4,#0x30]         ;2768
000050  4620              MOV      r0,r4                 ;2768
000052  f7fffffe          BL       hline_clip
000056  1b70              SUBS     r0,r6,r5              ;2769
000058  2802              CMP      r0,#2                 ;2769
00005a  dd20              BLE      |L28.158|
00005c  1c68              ADDS     r0,r5,#1              ;2770
00005e  b205              SXTH     r5,r0                 ;2770
000060  1e70              SUBS     r0,r6,#1              ;2770
000062  b206              SXTH     r6,r0                 ;2770
000064  f8a48028          STRH     r8,[r4,#0x28]         ;2771
000068  8565              STRH     r5,[r4,#0x2a]         ;2771
00006a  8666              STRH     r6,[r4,#0x32]         ;2771
00006c  4620              MOV      r0,r4                 ;2771
00006e  f7fffffe          BL       vline_clip
000072  8527              STRH     r7,[r4,#0x28]         ;2772
000074  8565              STRH     r5,[r4,#0x2a]         ;2772
000076  8666              STRH     r6,[r4,#0x32]         ;2772
000078  4620              MOV      r0,r4                 ;2772
00007a  f7fffffe          BL       vline_clip
00007e  e00e              B        |L28.158|
                  |L28.128|
000080  f8a48028          STRH     r8,[r4,#0x28]         ;2776
000084  8565              STRH     r5,[r4,#0x2a]         ;2776
000086  8666              STRH     r6,[r4,#0x32]         ;2776
000088  4620              MOV      r0,r4                 ;2776
00008a  f7fffffe          BL       vline_clip
00008e  45b8              CMP      r8,r7                 ;2777
000090  d005              BEQ      |L28.158|
000092  8527              STRH     r7,[r4,#0x28]         ;2778
000094  8565              STRH     r5,[r4,#0x2a]         ;2778
000096  8666              STRH     r6,[r4,#0x32]         ;2778
000098  4620              MOV      r0,r4                 ;2778
00009a  f7fffffe          BL       vline_clip
                  |L28.158|
00009e  bf00              NOP      
0000a0  e7ba              B        |L28.24|
;;;2785   
                          ENDP


                          AREA ||i.gdispGDrawLine||, CODE, READONLY, ALIGN=1

                  gdispGDrawLine PROC
;;;989    
;;;990    void gdispGDrawLine(GDisplay *g, coord_t x0, coord_t y0, coord_t x1, coord_t y1, color_t color) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;991    	MUTEX_ENTER(g);
;;;992    	g->p.x = x0;
000010  8525              STRH     r5,[r4,#0x28]
;;;993    	g->p.y = y0;
000012  8566              STRH     r6,[r4,#0x2a]
;;;994    	g->p.x1 = x1;
000014  8627              STRH     r7,[r4,#0x30]
;;;995    	g->p.y1 = y1;
000016  f8a48032          STRH     r8,[r4,#0x32]
;;;996    	g->p.color = color;
00001a  f8849038          STRB     r9,[r4,#0x38]
;;;997    	line_clip(g);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       line_clip
;;;998    	autoflush(g);
;;;999    	MUTEX_EXIT(g);
;;;1000   }
000024  e8bd87f0          POP      {r4-r10,pc}
;;;1001   
                          ENDP


                          AREA ||i.gdispGDrawPixel||, CODE, READONLY, ALIGN=1

                  gdispGDrawPixel PROC
;;;979    
;;;980    void gdispGDrawPixel(GDisplay *g, coord_t x, coord_t y, color_t color) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;981    	MUTEX_ENTER(g);
;;;982    	g->p.x		= x;
00000c  8525              STRH     r5,[r4,#0x28]
;;;983    	g->p.y		= y;
00000e  8566              STRH     r6,[r4,#0x2a]
;;;984    	g->p.color	= color;
000010  2038              MOVS     r0,#0x38
000012  5507              STRB     r7,[r0,r4]
;;;985    	drawpixel_clip(g);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       drawpixel_clip
;;;986    	autoflush(g);
;;;987    	MUTEX_EXIT(g);
;;;988    }
00001a  e8bd81f0          POP      {r4-r8,pc}
;;;989    
                          ENDP


                          AREA ||i.gdispGFillArea||, CODE, READONLY, ALIGN=1

                  gdispGFillArea PROC
;;;1084   
;;;1085   void gdispGFillArea(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy, color_t color) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;1086   	MUTEX_ENTER(g);
;;;1087   	g->p.x = x;
000010  8525              STRH     r5,[r4,#0x28]
;;;1088   	g->p.y = y;
000012  8566              STRH     r6,[r4,#0x2a]
;;;1089   	g->p.cx = cx;
000014  85a7              STRH     r7,[r4,#0x2c]
;;;1090   	g->p.cy = cy;
000016  f8a4802e          STRH     r8,[r4,#0x2e]
;;;1091   	g->p.color = color;
00001a  f8849038          STRB     r9,[r4,#0x38]
;;;1092   	TEST_CLIP_AREA(g) {
00001e  f9b40028          LDRSH    r0,[r4,#0x28]
000022  f9b41020          LDRSH    r1,[r4,#0x20]
000026  4288              CMP      r0,r1
000028  da08              BGE      |L31.60|
00002a  8c20              LDRH     r0,[r4,#0x20]
00002c  8d21              LDRH     r1,[r4,#0x28]
00002e  1a41              SUBS     r1,r0,r1
000030  8da0              LDRH     r0,[r4,#0x2c]
000032  1a40              SUBS     r0,r0,r1
000034  b201              SXTH     r1,r0
000036  85a1              STRH     r1,[r4,#0x2c]
000038  8c20              LDRH     r0,[r4,#0x20]
00003a  8520              STRH     r0,[r4,#0x28]
                  |L31.60|
00003c  f9b4002a          LDRSH    r0,[r4,#0x2a]
000040  f9b41022          LDRSH    r1,[r4,#0x22]
000044  4288              CMP      r0,r1
000046  da08              BGE      |L31.90|
000048  8c61              LDRH     r1,[r4,#0x22]
00004a  8d60              LDRH     r0,[r4,#0x2a]
00004c  1a09              SUBS     r1,r1,r0
00004e  8de0              LDRH     r0,[r4,#0x2e]
000050  1a40              SUBS     r0,r0,r1
000052  b201              SXTH     r1,r0
000054  85e1              STRH     r1,[r4,#0x2e]
000056  8c61              LDRH     r1,[r4,#0x22]
000058  8561              STRH     r1,[r4,#0x2a]
                  |L31.90|
00005a  f9b41028          LDRSH    r1,[r4,#0x28]
00005e  f9b4002c          LDRSH    r0,[r4,#0x2c]
000062  4408              ADD      r0,r0,r1
000064  f9b41024          LDRSH    r1,[r4,#0x24]
000068  4288              CMP      r0,r1
00006a  dd04              BLE      |L31.118|
00006c  8ca0              LDRH     r0,[r4,#0x24]
00006e  8d21              LDRH     r1,[r4,#0x28]
000070  1a40              SUBS     r0,r0,r1
000072  b201              SXTH     r1,r0
000074  85a1              STRH     r1,[r4,#0x2c]
                  |L31.118|
000076  f9b4102a          LDRSH    r1,[r4,#0x2a]
00007a  f9b4002e          LDRSH    r0,[r4,#0x2e]
00007e  4408              ADD      r0,r0,r1
000080  f9b41026          LDRSH    r1,[r4,#0x26]
000084  4288              CMP      r0,r1
000086  dd04              BLE      |L31.146|
000088  8ce1              LDRH     r1,[r4,#0x26]
00008a  8d60              LDRH     r0,[r4,#0x2a]
00008c  1a08              SUBS     r0,r1,r0
00008e  b201              SXTH     r1,r0
000090  85e1              STRH     r1,[r4,#0x2e]
                  |L31.146|
000092  f9b4002c          LDRSH    r0,[r4,#0x2c]
000096  2800              CMP      r0,#0
000098  dd06              BLE      |L31.168|
00009a  f9b4002e          LDRSH    r0,[r4,#0x2e]
00009e  2800              CMP      r0,#0
0000a0  dd02              BLE      |L31.168|
;;;1093   		fillarea(g);
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       fillarea
                  |L31.168|
;;;1094   	}
;;;1095   	autoflush_stopdone(g);
;;;1096   	MUTEX_EXIT(g);
;;;1097   }
0000a8  e8bd87f0          POP      {r4-r10,pc}
;;;1098   
                          ENDP


                          AREA ||i.gdispGFlush||, CODE, READONLY, ALIGN=1

                  gdispGFlush PROC
;;;717    
;;;718    void gdispGFlush(GDisplay *g) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;719    	#if GDISP_HARDWARE_FLUSH
;;;720    		#if GDISP_HARDWARE_FLUSH == HARDWARE_AUTODETECT
;;;721    			if (gvmt(g)->flush)
;;;722    		#endif
;;;723    		{
;;;724    			MUTEX_ENTER(g);
;;;725    			gdisp_lld_flush(g);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       gdisp_lld_flush
;;;726    			MUTEX_EXIT(g);
;;;727    		}
;;;728    	#else
;;;729    		(void) g;
;;;730    	#endif
;;;731    }
00000a  bd10              POP      {r4,pc}
;;;732    
                          ENDP


                          AREA ||i.gdispGGetBacklight||, CODE, READONLY, ALIGN=1

                  gdispGGetBacklight PROC
;;;714    orientation_t gdispGGetOrientation(GDisplay *g)	{ return g->g.Orientation; }
;;;715    uint8_t gdispGGetBacklight(GDisplay *g)			{ return g->g.Backlight; }
000000  4601              MOV      r1,r0
000002  7bc8              LDRB     r0,[r1,#0xf]
000004  4770              BX       lr
;;;716    uint8_t gdispGGetContrast(GDisplay *g)			{ return g->g.Contrast; }
                          ENDP


                          AREA ||i.gdispGGetContrast||, CODE, READONLY, ALIGN=1

                  gdispGGetContrast PROC
;;;715    uint8_t gdispGGetBacklight(GDisplay *g)			{ return g->g.Backlight; }
;;;716    uint8_t gdispGGetContrast(GDisplay *g)			{ return g->g.Contrast; }
000000  4601              MOV      r1,r0
000002  7c08              LDRB     r0,[r1,#0x10]
000004  4770              BX       lr
;;;717    
                          ENDP


                          AREA ||i.gdispGGetHeight||, CODE, READONLY, ALIGN=1

                  gdispGGetHeight PROC
;;;711    coord_t gdispGGetWidth(GDisplay *g)				{ return g->g.Width; }
;;;712    coord_t gdispGGetHeight(GDisplay *g)			{ return g->g.Height; }
000000  4601              MOV      r1,r0
000002  f9b1000a          LDRSH    r0,[r1,#0xa]
000006  4770              BX       lr
;;;713    powermode_t gdispGGetPowerMode(GDisplay *g)		{ return g->g.Powermode; }
                          ENDP


                          AREA ||i.gdispGGetOrientation||, CODE, READONLY, ALIGN=1

                  gdispGGetOrientation PROC
;;;713    powermode_t gdispGGetPowerMode(GDisplay *g)		{ return g->g.Powermode; }
;;;714    orientation_t gdispGGetOrientation(GDisplay *g)	{ return g->g.Orientation; }
000000  4601              MOV      r1,r0
000002  8988              LDRH     r0,[r1,#0xc]
000004  4770              BX       lr
;;;715    uint8_t gdispGGetBacklight(GDisplay *g)			{ return g->g.Backlight; }
                          ENDP


                          AREA ||i.gdispGGetPowerMode||, CODE, READONLY, ALIGN=1

                  gdispGGetPowerMode PROC
;;;712    coord_t gdispGGetHeight(GDisplay *g)			{ return g->g.Height; }
;;;713    powermode_t gdispGGetPowerMode(GDisplay *g)		{ return g->g.Powermode; }
000000  4601              MOV      r1,r0
000002  7b88              LDRB     r0,[r1,#0xe]
000004  4770              BX       lr
;;;714    orientation_t gdispGGetOrientation(GDisplay *g)	{ return g->g.Orientation; }
                          ENDP


                          AREA ||i.gdispGGetWidth||, CODE, READONLY, ALIGN=1

                  gdispGGetWidth PROC
;;;710    
;;;711    coord_t gdispGGetWidth(GDisplay *g)				{ return g->g.Width; }
000000  4601              MOV      r1,r0
000002  f9b10008          LDRSH    r0,[r1,#8]
000006  4770              BX       lr
;;;712    coord_t gdispGGetHeight(GDisplay *g)			{ return g->g.Height; }
                          ENDP


                          AREA ||i.gdispGSetClip||, CODE, READONLY, ALIGN=1

                  gdispGSetClip PROC
;;;1235   #if GDISP_NEED_CLIP || GDISP_NEED_VALIDATION
;;;1236   	void gdispGSetClip(GDisplay *g, coord_t x, coord_t y, coord_t cx, coord_t cy) {
000000  b570              PUSH     {r4-r6,lr}
000002  9c04              LDR      r4,[sp,#0x10]
;;;1237   		MUTEX_ENTER(g);
;;;1238   
;;;1239   		// Best is using hardware clipping
;;;1240   		#if GDISP_HARDWARE_CLIP
;;;1241   			#if GDISP_HARDWARE_CLIP == HARDWARE_AUTODETECT
;;;1242   				if (gvmt(g)->setclip)
;;;1243   			#endif
;;;1244   			{
;;;1245   				g->p.x = x;
;;;1246   				g->p.y = y;
;;;1247   				g->p.cx = cx;
;;;1248   				g->p.cy = cy;
;;;1249   				gdisp_lld_set_clip(g);
;;;1250   			}
;;;1251   			#if GDISP_HARDWARE_CLIP == HARDWARE_AUTODETECT
;;;1252   				else
;;;1253   			#endif
;;;1254   		#endif
;;;1255   
;;;1256   		// Worst is using software clipping
;;;1257   		#if GDISP_HARDWARE_CLIP != TRUE
;;;1258   			{
;;;1259   				if (x < 0) { cx += x; x = 0; }
000004  2900              CMP      r1,#0
000006  da02              BGE      |L39.14|
000008  185d              ADDS     r5,r3,r1
00000a  b22b              SXTH     r3,r5
00000c  2100              MOVS     r1,#0
                  |L39.14|
;;;1260   				if (y < 0) { cy += y; y = 0; }
00000e  2a00              CMP      r2,#0
000010  da02              BGE      |L39.24|
000012  18a5              ADDS     r5,r4,r2
000014  b22c              SXTH     r4,r5
000016  2200              MOVS     r2,#0
                  |L39.24|
;;;1261   				if (cx <= 0 || cy <= 0 || x >= g->g.Width || y >= g->g.Height) { x = y = cx = cy = 0; }
000018  2b00              CMP      r3,#0
00001a  dd09              BLE      |L39.48|
00001c  2c00              CMP      r4,#0
00001e  dd07              BLE      |L39.48|
000020  f9b05008          LDRSH    r5,[r0,#8]
000024  428d              CMP      r5,r1
000026  dd03              BLE      |L39.48|
000028  f9b0500a          LDRSH    r5,[r0,#0xa]
00002c  4295              CMP      r5,r2
00002e  dc04              BGT      |L39.58|
                  |L39.48|
000030  2500              MOVS     r5,#0
000032  462c              MOV      r4,r5
000034  462b              MOV      r3,r5
000036  462a              MOV      r2,r5
000038  4629              MOV      r1,r5
                  |L39.58|
;;;1262   				g->clipx0 = x;
00003a  8401              STRH     r1,[r0,#0x20]
;;;1263   				g->clipy0 = y;
00003c  8442              STRH     r2,[r0,#0x22]
;;;1264   				g->clipx1 = x+cx;	if (g->clipx1 > g->g.Width) g->clipx1 = g->g.Width;
00003e  18cd              ADDS     r5,r1,r3
000040  b22d              SXTH     r5,r5
000042  8485              STRH     r5,[r0,#0x24]
000044  f9b05024          LDRSH    r5,[r0,#0x24]
000048  f9b06008          LDRSH    r6,[r0,#8]
00004c  42b5              CMP      r5,r6
00004e  dd01              BLE      |L39.84|
000050  8905              LDRH     r5,[r0,#8]
000052  8485              STRH     r5,[r0,#0x24]
                  |L39.84|
;;;1265   				g->clipy1 = y+cy;	if (g->clipy1 > g->g.Height) g->clipy1 = g->g.Height;
000054  1915              ADDS     r5,r2,r4
000056  b22d              SXTH     r5,r5
000058  84c5              STRH     r5,[r0,#0x26]
00005a  f9b06026          LDRSH    r6,[r0,#0x26]
00005e  f9b0500a          LDRSH    r5,[r0,#0xa]
000062  42ae              CMP      r6,r5
000064  dd01              BLE      |L39.106|
000066  8945              LDRH     r5,[r0,#0xa]
000068  84c5              STRH     r5,[r0,#0x26]
                  |L39.106|
;;;1266   			}
;;;1267   		#endif
;;;1268   		MUTEX_EXIT(g);
;;;1269   	}
00006a  bd70              POP      {r4-r6,pc}
;;;1270   #endif
                          ENDP


                          AREA ||i.gdispGetDisplay||, CODE, READONLY, ALIGN=1

                  gdispGetDisplay PROC
;;;698    
;;;699    GDisplay *gdispGetDisplay(unsigned display) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;700    	return (GDisplay *)gdriverGetInstance(GDRIVER_TYPE_DISPLAY, display);
000004  4621              MOV      r1,r4
000006  2067              MOVS     r0,#0x67
000008  f7fffffe          BL       gdriverGetInstance
;;;701    }
00000c  bd10              POP      {r4,pc}
;;;702    
                          ENDP


                          AREA ||i.gdispGetDisplayCount||, CODE, READONLY, ALIGN=1

                  gdispGetDisplayCount PROC
;;;706    
;;;707    unsigned gdispGetDisplayCount(void) {
000000  b500              PUSH     {lr}
;;;708    	return gdriverInstanceCount(GDRIVER_TYPE_DISPLAY);
000002  2067              MOVS     r0,#0x67
000004  f7fffffe          BL       gdriverInstanceCount
;;;709    }
000008  bd00              POP      {pc}
;;;710    
                          ENDP


                          AREA ||i.gdispSetDisplay||, CODE, READONLY, ALIGN=2

                  gdispSetDisplay PROC
;;;702    
;;;703    void gdispSetDisplay(GDisplay *g) {
000000  b108              CBZ      r0,|L42.6|
;;;704    	if (g) GDISP = g;
000002  4901              LDR      r1,|L42.8|
000004  6008              STR      r0,[r1,#0]  ; GDISP
                  |L42.6|
;;;705    }
000006  4770              BX       lr
;;;706    
                          ENDP

                  |L42.8|
                          DCD      GDISP

                          AREA ||i.gdriverGetDriverInstanceNumber||, CODE, READONLY, ALIGN=2

                  gdriverGetDriverInstanceNumber PROC
;;;135    
;;;136    unsigned gdriverGetDriverInstanceNumber(GDriver *driver) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
;;;137    	GDriver		*pd;
;;;138    	unsigned	instance;
;;;139    
;;;140    	// Loop to find the system instance
;;;141    	instance = 0;
000004  2300              MOVS     r3,#0
;;;142    	for(pd = dhead; pd; pd = pd->driverchain) {
000006  4809              LDR      r0,|L43.44|
000008  6801              LDR      r1,[r0,#0]  ; dhead
00000a  e00b              B        |L43.36|
                  |L43.12|
;;;143    		if (pd == driver)
00000c  4291              CMP      r1,r2
00000e  d101              BNE      |L43.20|
;;;144    			return instance;
000010  4618              MOV      r0,r3
                  |L43.18|
;;;145    		if (pd->vmt->type == driver->vmt->type)
;;;146    			instance++;
;;;147    	}
;;;148    	return (unsigned)-1;
;;;149    }
000012  bd10              POP      {r4,pc}
                  |L43.20|
000014  6848              LDR      r0,[r1,#4]            ;145
000016  8800              LDRH     r0,[r0,#0]            ;145
000018  6854              LDR      r4,[r2,#4]            ;145
00001a  8824              LDRH     r4,[r4,#0]            ;145
00001c  42a0              CMP      r0,r4                 ;145
00001e  d100              BNE      |L43.34|
000020  1c5b              ADDS     r3,r3,#1              ;146
                  |L43.34|
000022  6809              LDR      r1,[r1,#0]            ;142
                  |L43.36|
000024  2900              CMP      r1,#0                 ;142
000026  d1f1              BNE      |L43.12|
000028  1e48              SUBS     r0,r1,#1              ;148
00002a  e7f2              B        |L43.18|
;;;150    
                          ENDP

                  |L43.44|
                          DCD      dhead

                          AREA ||i.gdriverGetInstance||, CODE, READONLY, ALIGN=2

                  gdriverGetInstance PROC
;;;97     
;;;98     GDriver *gdriverGetInstance(uint16_t type, unsigned instance) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;99     	GDriver		*pd;
;;;100    	unsigned	sinstance;
;;;101    
;;;102    	// Loop to find the system instance
;;;103    	sinstance = 0;
000006  2400              MOVS     r4,#0
;;;104    	for(pd = dhead; pd; pd = pd->driverchain) {
000008  4808              LDR      r0,|L44.44|
00000a  6801              LDR      r1,[r0,#0]  ; dhead
00000c  e009              B        |L44.34|
                  |L44.14|
;;;105    		if (pd->vmt->type == type) {
00000e  6848              LDR      r0,[r1,#4]
000010  8800              LDRH     r0,[r0,#0]
000012  4290              CMP      r0,r2
000014  d104              BNE      |L44.32|
;;;106    			if (sinstance == instance)
000016  429c              CMP      r4,r3
000018  d101              BNE      |L44.30|
;;;107    				return pd;
00001a  4608              MOV      r0,r1
                  |L44.28|
;;;108    			sinstance++;
;;;109    		}
;;;110    	}
;;;111    	return 0;
;;;112    }
00001c  bd10              POP      {r4,pc}
                  |L44.30|
00001e  1c64              ADDS     r4,r4,#1              ;108
                  |L44.32|
000020  6809              LDR      r1,[r1,#0]            ;104
                  |L44.34|
000022  2900              CMP      r1,#0                 ;104
000024  d1f3              BNE      |L44.14|
000026  2000              MOVS     r0,#0                 ;111
000028  e7f8              B        |L44.28|
;;;113    
                          ENDP

00002a  0000              DCW      0x0000
                  |L44.44|
                          DCD      dhead

                          AREA ||i.gdriverGetNext||, CODE, READONLY, ALIGN=2

                  gdriverGetNext PROC
;;;126    
;;;127    GDriver *gdriverGetNext(uint16_t type, GDriver *driver) {
000000  4602              MOV      r2,r0
;;;128    	driver = driver ? driver->driverchain : dhead;
000002  b109              CBZ      r1,|L45.8|
000004  6808              LDR      r0,[r1,#0]
000006  e001              B        |L45.12|
                  |L45.8|
000008  4805              LDR      r0,|L45.32|
00000a  6800              LDR      r0,[r0,#0]  ; dhead
                  |L45.12|
00000c  4601              MOV      r1,r0
;;;129    
;;;130    	while(driver && driver->vmt->type != type)
00000e  e000              B        |L45.18|
                  |L45.16|
;;;131    		driver = driver->driverchain;
000010  6809              LDR      r1,[r1,#0]
                  |L45.18|
000012  b119              CBZ      r1,|L45.28|
000014  6848              LDR      r0,[r1,#4]            ;130
000016  8800              LDRH     r0,[r0,#0]            ;130
000018  4290              CMP      r0,r2                 ;130
00001a  d1f9              BNE      |L45.16|
                  |L45.28|
;;;132    
;;;133    	return driver;
00001c  4608              MOV      r0,r1
;;;134    }
00001e  4770              BX       lr
;;;135    
                          ENDP

                  |L45.32|
                          DCD      dhead

                          AREA ||i.gdriverInstanceCount||, CODE, READONLY, ALIGN=2

                  gdriverInstanceCount PROC
;;;113    
;;;114    unsigned gdriverInstanceCount(uint16_t type) {
000000  4602              MOV      r2,r0
;;;115    	GDriver		*pd;
;;;116    	unsigned	sinstance;
;;;117    
;;;118    	// Loop to count the system instances
;;;119    	sinstance = 0;
000002  2000              MOVS     r0,#0
;;;120    	for(pd = dhead; pd; pd = pd->driverchain) {
000004  4b05              LDR      r3,|L46.28|
000006  6819              LDR      r1,[r3,#0]  ; dhead
000008  e005              B        |L46.22|
                  |L46.10|
;;;121    		if (pd->vmt->type == type)
00000a  684b              LDR      r3,[r1,#4]
00000c  881b              LDRH     r3,[r3,#0]
00000e  4293              CMP      r3,r2
000010  d100              BNE      |L46.20|
;;;122    			sinstance++;
000012  1c40              ADDS     r0,r0,#1
                  |L46.20|
000014  6809              LDR      r1,[r1,#0]            ;120
                  |L46.22|
000016  2900              CMP      r1,#0                 ;120
000018  d1f7              BNE      |L46.10|
;;;123    	}
;;;124    	return sinstance;
;;;125    }
00001a  4770              BX       lr
;;;126    
                          ENDP

                  |L46.28|
                          DCD      dhead

                          AREA ||i.gdriverRegister||, CODE, READONLY, ALIGN=2

                  gdriverRegister PROC
;;;30     
;;;31     GDriver *gdriverRegister(const GDriverVMT *vmt, void *param) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;32     	GDriver *	pd;
;;;33     	unsigned	dinstance, sinstance;
;;;34     
;;;35     	// Loop to find the driver instance and the system instance numbers
;;;36     	dinstance = sinstance = 0;
000008  2000              MOVS     r0,#0
00000a  4607              MOV      r7,r0
00000c  4606              MOV      r6,r0
;;;37     	for(pd = dhead; pd; pd = pd->driverchain) {
00000e  481f              LDR      r0,|L47.140|
000010  6805              LDR      r5,[r0,#0]  ; dhead
000012  e00a              B        |L47.42|
                  |L47.20|
;;;38     		if (pd->vmt == vmt)
000014  6868              LDR      r0,[r5,#4]
000016  42a0              CMP      r0,r4
000018  d100              BNE      |L47.28|
;;;39     			dinstance++;
00001a  1c76              ADDS     r6,r6,#1
                  |L47.28|
;;;40     		if (pd->vmt->type == vmt->type)
00001c  6868              LDR      r0,[r5,#4]
00001e  8800              LDRH     r0,[r0,#0]
000020  8821              LDRH     r1,[r4,#0]
000022  4288              CMP      r0,r1
000024  d100              BNE      |L47.40|
;;;41     			sinstance++;
000026  1c7f              ADDS     r7,r7,#1
                  |L47.40|
000028  682d              LDR      r5,[r5,#0]            ;37
                  |L47.42|
00002a  2d00              CMP      r5,#0                 ;37
00002c  d1f2              BNE      |L47.20|
;;;42     	}
;;;43     
;;;44     	// Get a new driver instance of the correct size and initialize it
;;;45     	pd = gfxAlloc(vmt->objsize);
00002e  6860              LDR      r0,[r4,#4]
000030  f7fffffe          BL       gfxAlloc
000034  4605              MOV      r5,r0
;;;46     	if (!pd)
000036  b915              CBNZ     r5,|L47.62|
;;;47     		return 0;
000038  2000              MOVS     r0,#0
                  |L47.58|
;;;48         memset(pd, 0, vmt->objsize);
;;;49     	pd->vmt = vmt;
;;;50     	if (vmt->init && !vmt->init(pd, param, dinstance, sinstance)) {
;;;51     		gfxFree(pd);
;;;52     		return 0;
;;;53     	}
;;;54     
;;;55     	// Add it to the driver chain (at the end)
;;;56     	if (dhead)
;;;57     		dtail->driverchain = pd;
;;;58     	else
;;;59     		dhead = pd;
;;;60     	dtail = pd;
;;;61     
;;;62     	// Do the post init
;;;63     	if (vmt->postinit)
;;;64     		vmt->postinit(pd);
;;;65     
;;;66     	return pd;
;;;67     }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L47.62|
00003e  4628              MOV      r0,r5                 ;48
000040  6861              LDR      r1,[r4,#4]            ;48
000042  f7fffffe          BL       __aeabi_memclr4
000046  606c              STR      r4,[r5,#4]            ;49
000048  68a0              LDR      r0,[r4,#8]            ;50
00004a  b160              CBZ      r0,|L47.102|
00004c  463b              MOV      r3,r7                 ;50
00004e  4632              MOV      r2,r6                 ;50
000050  4641              MOV      r1,r8                 ;50
000052  4628              MOV      r0,r5                 ;50
000054  f8d4c008          LDR      r12,[r4,#8]           ;50
000058  47e0              BLX      r12                   ;50
00005a  b920              CBNZ     r0,|L47.102|
00005c  4628              MOV      r0,r5                 ;51
00005e  f7fffffe          BL       gfxFree
000062  2000              MOVS     r0,#0                 ;52
000064  e7e9              B        |L47.58|
                  |L47.102|
000066  4809              LDR      r0,|L47.140|
000068  6800              LDR      r0,[r0,#0]            ;56  ; dhead
00006a  b118              CBZ      r0,|L47.116|
00006c  4808              LDR      r0,|L47.144|
00006e  6800              LDR      r0,[r0,#0]            ;57  ; dtail
000070  6005              STR      r5,[r0,#0]            ;57
000072  e001              B        |L47.120|
                  |L47.116|
000074  4805              LDR      r0,|L47.140|
000076  6005              STR      r5,[r0,#0]            ;59  ; dhead
                  |L47.120|
000078  4805              LDR      r0,|L47.144|
00007a  6005              STR      r5,[r0,#0]            ;60  ; dtail
00007c  68e0              LDR      r0,[r4,#0xc]          ;63
00007e  b110              CBZ      r0,|L47.134|
000080  4628              MOV      r0,r5                 ;64
000082  68e1              LDR      r1,[r4,#0xc]          ;64
000084  4788              BLX      r1                    ;64
                  |L47.134|
000086  4628              MOV      r0,r5                 ;66
000088  e7d7              B        |L47.58|
;;;68     
                          ENDP

00008a  0000              DCW      0x0000
                  |L47.140|
                          DCD      dhead
                  |L47.144|
                          DCD      dtail

                          AREA ||i.gdriverUnRegister||, CODE, READONLY, ALIGN=2

                  gdriverUnRegister PROC
;;;68     
;;;69     void gdriverUnRegister(GDriver *driver) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;70     	GDriver		*pd;
;;;71     
;;;72     	// Safety
;;;73     	if (!driver)
000004  b904              CBNZ     r4,|L48.8|
                  |L48.6|
;;;74     		return;
;;;75     
;;;76     	// Remove it from the list of drivers
;;;77     	if (dhead == driver)
;;;78     		dhead = driver->driverchain;
;;;79     	else {
;;;80     		for(pd = dhead; pd->driverchain; pd = pd->driverchain) {
;;;81     			if (pd->driverchain == driver) {
;;;82     				pd->driverchain = driver->driverchain;
;;;83     				if (!pd->driverchain)
;;;84     					dtail = pd;
;;;85     				break;
;;;86     			}
;;;87     		}
;;;88     	}
;;;89     
;;;90     	// Call the deinit()
;;;91     	if (driver->vmt->deinit)
;;;92     		driver->vmt->deinit(driver);
;;;93     
;;;94     	// Cleanup
;;;95     	gfxFree(driver);
;;;96     }
000006  bd70              POP      {r4-r6,pc}
                  |L48.8|
000008  4812              LDR      r0,|L48.84|
00000a  6800              LDR      r0,[r0,#0]            ;77  ; dhead
00000c  42a0              CMP      r0,r4                 ;77
00000e  d103              BNE      |L48.24|
000010  4910              LDR      r1,|L48.84|
000012  6820              LDR      r0,[r4,#0]            ;78
000014  6008              STR      r0,[r1,#0]            ;78  ; dhead
000016  e011              B        |L48.60|
                  |L48.24|
000018  480e              LDR      r0,|L48.84|
00001a  6805              LDR      r5,[r0,#0]            ;80  ; dhead
00001c  e00a              B        |L48.52|
                  |L48.30|
00001e  6828              LDR      r0,[r5,#0]            ;81
000020  42a0              CMP      r0,r4                 ;81
000022  d106              BNE      |L48.50|
000024  6820              LDR      r0,[r4,#0]            ;82
000026  6028              STR      r0,[r5,#0]            ;82
000028  6828              LDR      r0,[r5,#0]            ;83
00002a  b908              CBNZ     r0,|L48.48|
00002c  480a              LDR      r0,|L48.88|
00002e  6005              STR      r5,[r0,#0]            ;84  ; dtail
                  |L48.48|
000030  e003              B        |L48.58|
                  |L48.50|
000032  682d              LDR      r5,[r5,#0]            ;80
                  |L48.52|
000034  6828              LDR      r0,[r5,#0]            ;80
000036  2800              CMP      r0,#0                 ;80
000038  d1f1              BNE      |L48.30|
                  |L48.58|
00003a  bf00              NOP                            ;85
                  |L48.60|
00003c  6860              LDR      r0,[r4,#4]            ;91
00003e  6900              LDR      r0,[r0,#0x10]         ;91
000040  b118              CBZ      r0,|L48.74|
000042  6860              LDR      r0,[r4,#4]            ;92
000044  6901              LDR      r1,[r0,#0x10]         ;92
000046  4620              MOV      r0,r4                 ;92
000048  4788              BLX      r1                    ;92
                  |L48.74|
00004a  4620              MOV      r0,r4                 ;95
00004c  f7fffffe          BL       gfxFree
000050  bf00              NOP      
000052  e7d8              B        |L48.6|
;;;97     
                          ENDP

                  |L48.84|
                          DCD      dhead
                  |L48.88|
                          DCD      dtail

                          AREA ||i.gfxAlloc||, CODE, READONLY, ALIGN=1

                  gfxAlloc PROC
;;;19     	}
;;;20     	void *gfxAlloc(size_t sz) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;21     		return malloc(sz);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       malloc
;;;22     	}
00000a  bd10              POP      {r4,pc}
;;;23     
                          ENDP


                          AREA ||i.gfxDeinit||, CODE, READONLY, ALIGN=2

                  gfxDeinit PROC
;;;134    
;;;135    void gfxDeinit(void)
000000  b510              PUSH     {r4,lr}
;;;136    {
;;;137    	if (!gfxInitDone)
000002  4807              LDR      r0,|L50.32|
000004  7800              LDRB     r0,[r0,#0]  ; gfxInitDone
000006  b900              CBNZ     r0,|L50.10|
                  |L50.8|
;;;138    		return;
;;;139    	gfxInitDone = FALSE;
;;;140    
;;;141    	// We deinitialise the opposite way as we initialised
;;;142    	#if GFX_USE_GWIN
;;;143    		_gwinDeinit();
;;;144    	#endif
;;;145    	#if GFX_USE_GAUDIO
;;;146    		_gaudioDeinit();
;;;147    	#endif
;;;148    	#if GFX_USE_GADC
;;;149    		_gadcDeinit();
;;;150    	#endif
;;;151    	#if GFX_USE_GINPUT
;;;152    		_ginputDeinit();
;;;153    	#endif
;;;154    	#if GFX_USE_GDISP
;;;155    		_gdispDeinit();
;;;156    	#endif
;;;157    	#if GFX_USE_GFILE
;;;158    		_gfileDeinit();
;;;159    	#endif
;;;160    	#if GFX_USE_GDRIVER
;;;161    		_gdriverDeinit();
;;;162    	#endif
;;;163    	#if GFX_USE_GTIMER
;;;164    		_gtimerDeinit();
;;;165    	#endif
;;;166    	#if GFX_USE_GEVENT
;;;167    		_geventDeinit();
;;;168    	#endif
;;;169    	#if GFX_USE_GTRANS
;;;170    		_gtransDeinit();
;;;171    	#endif
;;;172    	#if GFX_USE_GMISC
;;;173    		_gmiscDeinit();
;;;174    	#endif
;;;175    	#if GFX_USE_GQUEUE
;;;176    		_gqueueDeinit();
;;;177    	#endif
;;;178    	#ifdef GFX_OS_EXTRA_DEINIT_FUNCTION
;;;179    		GFX_OS_EXTRA_DEINIT_FUNCTION();
;;;180    	#endif
;;;181    	_gosDeinit();
;;;182    }
000008  bd10              POP      {r4,pc}
                  |L50.10|
00000a  2000              MOVS     r0,#0                 ;139
00000c  4904              LDR      r1,|L50.32|
00000e  7008              STRB     r0,[r1,#0]            ;139
000010  f7fffffe          BL       _gdispDeinit
000014  f7fffffe          BL       _gdriverDeinit
000018  f7fffffe          BL       _gosDeinit
00001c  bf00              NOP      
00001e  e7f3              B        |L50.8|
;;;9      #include "gos/gos_mk.c"
                          ENDP

                  |L50.32|
                          DCD      gfxInitDone

                          AREA ||i.gfxExit||, CODE, READONLY, ALIGN=1

                  gfxExit PROC
;;;85     
;;;86     void gfxExit(void) {
000000  b508              PUSH     {r3,lr}
;;;87     	#if defined(WIN32)
;;;88     		ExitProcess(0);
;;;89     	#else
;;;90     		volatile uint32_t	dummy;
;;;91     
;;;92     		while(1)
000002  e002              B        |L51.10|
                  |L51.4|
;;;93     			dummy++;
000004  9800              LDR      r0,[sp,#0]
000006  1c40              ADDS     r0,r0,#1
000008  9000              STR      r0,[sp,#0]
                  |L51.10|
00000a  e7fb              B        |L51.4|
;;;94     	#endif
;;;95     }
;;;96     
                          ENDP


                          AREA ||i.gfxFree||, CODE, READONLY, ALIGN=1

                  gfxFree PROC
;;;28     
;;;29     	void gfxFree(void *ptr) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;30     		free(ptr);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       free
;;;31     	}
00000a  bd10              POP      {r4,pc}
;;;32     
                          ENDP


                          AREA ||i.gfxHalt||, CODE, READONLY, ALIGN=1

                  gfxHalt PROC
;;;72     
;;;73     void gfxHalt(const char *msg) {
000000  b508              PUSH     {r3,lr}
;;;74     	#if defined(WIN32)
;;;75     		fprintf(stderr, "%s\n", msg);
;;;76     		ExitProcess(1);
;;;77     	#else
;;;78     		volatile uint32_t	dummy;
;;;79     		(void)				msg;
;;;80     
;;;81     		while(1)
000002  e002              B        |L53.10|
                  |L53.4|
;;;82     			dummy++;
000004  9800              LDR      r0,[sp,#0]
000006  1c40              ADDS     r0,r0,#1
000008  9000              STR      r0,[sp,#0]
                  |L53.10|
00000a  e7fb              B        |L53.4|
;;;83     	#endif
;;;84     }
;;;85     
                          ENDP


                          AREA ||i.gfxInit||, CODE, READONLY, ALIGN=2

                  gfxInit PROC
;;;80     
;;;81     void gfxInit(void)
000000  b510              PUSH     {r4,lr}
;;;82     {
;;;83     	/* Ensure we only initialise once */
;;;84     	if (gfxInitDone)
000002  4807              LDR      r0,|L54.32|
000004  7800              LDRB     r0,[r0,#0]  ; gfxInitDone
000006  b100              CBZ      r0,|L54.10|
                  |L54.8|
;;;85     		return;
;;;86     	gfxInitDone = TRUE;
;;;87     
;;;88     	// These must be initialised in the order of their dependancies
;;;89     
;;;90     	#ifdef GFX_OS_PRE_INIT_FUNCTION
;;;91     		GFX_OS_PRE_INIT_FUNCTION();
;;;92     	#endif
;;;93     	_gosInit();
;;;94     	#ifdef GFX_OS_EXTRA_INIT_FUNCTION
;;;95     		GFX_OS_EXTRA_INIT_FUNCTION();
;;;96     	#endif
;;;97     	#if GFX_USE_GQUEUE
;;;98     		_gqueueInit();
;;;99     	#endif
;;;100    	#if GFX_USE_GMISC
;;;101    		_gmiscInit();
;;;102    	#endif
;;;103    	#if GFX_USE_GTRANS
;;;104    		_gtransInit();
;;;105    	#endif
;;;106    	#if GFX_USE_GEVENT
;;;107    		_geventInit();
;;;108    	#endif
;;;109    	#if GFX_USE_GTIMER
;;;110    		_gtimerInit();
;;;111    	#endif
;;;112    	#if GFX_USE_GDRIVER
;;;113    		_gdriverInit();
;;;114    	#endif
;;;115    	#if GFX_USE_GFILE
;;;116    		_gfileInit();
;;;117    	#endif
;;;118    	#if GFX_USE_GDISP
;;;119    		_gdispInit();
;;;120    	#endif
;;;121    	#if GFX_USE_GINPUT
;;;122    		_ginputInit();
;;;123    	#endif
;;;124    	#if GFX_USE_GADC
;;;125    		_gadcInit();
;;;126    	#endif
;;;127    	#if GFX_USE_GAUDIO
;;;128    		_gaudioInit();
;;;129    	#endif
;;;130    	#if GFX_USE_GWIN
;;;131    		_gwinInit();
;;;132    	#endif
;;;133    }
000008  bd10              POP      {r4,pc}
                  |L54.10|
00000a  20ff              MOVS     r0,#0xff              ;86
00000c  4904              LDR      r1,|L54.32|
00000e  7008              STRB     r0,[r1,#0]            ;86
000010  f7fffffe          BL       _gosInit
000014  f7fffffe          BL       _gdriverInit
000018  f7fffffe          BL       _gdispInit
00001c  bf00              NOP      
00001e  e7f3              B        |L54.8|
;;;134    
                          ENDP

                  |L54.32|
                          DCD      gfxInitDone

                          AREA ||i.gfxMutexEnter||, CODE, READONLY, ALIGN=1

                  gfxMutexEnter PROC
;;;32     
;;;33     void gfxMutexEnter(gfxMutex *pmutex) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;34     	INTERRUPTS_OFF();
;;;35     	while (pmutex[0]) {
000004  e001              B        |L55.10|
                  |L55.6|
;;;36     		INTERRUPTS_ON();
;;;37     		gfxYield();
000006  f7fffffe          BL       gfxYield
                  |L55.10|
00000a  6820              LDR      r0,[r4,#0]            ;35
00000c  2800              CMP      r0,#0                 ;35
00000e  d1fa              BNE      |L55.6|
;;;38     		INTERRUPTS_OFF();
;;;39     	}
;;;40     	pmutex[0] = 1;
000010  2001              MOVS     r0,#1
000012  6020              STR      r0,[r4,#0]
;;;41     	INTERRUPTS_ON();
;;;42     }
000014  bd10              POP      {r4,pc}
;;;43     
                          ENDP


                          AREA ||i.gfxMutexExit||, CODE, READONLY, ALIGN=1

                  gfxMutexExit PROC
;;;43     
;;;44     void gfxMutexExit(gfxMutex *pmutex) {
000000  2100              MOVS     r1,#0
;;;45     	pmutex[0] = 0;
000002  6001              STR      r1,[r0,#0]
;;;46     }
000004  4770              BX       lr
;;;47     
                          ENDP


                          AREA ||i.gfxMutexInit||, CODE, READONLY, ALIGN=1

                  gfxMutexInit PROC
;;;28     
;;;29     void gfxMutexInit(gfxMutex *pmutex) {
000000  2100              MOVS     r1,#0
;;;30     	pmutex[0] = 0;
000002  6001              STR      r1,[r0,#0]
;;;31     }
000004  4770              BX       lr
;;;32     
                          ENDP


                          AREA ||i.gfxRealloc||, CODE, READONLY, ALIGN=1

                  gfxRealloc PROC
;;;23     
;;;24     	void *gfxRealloc(void *ptr, size_t oldsz, size_t newsz) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;25     		(void) oldsz;
;;;26     		return realloc(ptr, newsz);
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       realloc
;;;27     	}
000010  bd70              POP      {r4-r6,pc}
;;;28     
                          ENDP


                          AREA ||i.gfxSemInit||, CODE, READONLY, ALIGN=1

                  gfxSemInit PROC
;;;47     
;;;48     void gfxSemInit(gfxSem *psem, semcount_t val, semcount_t limit) {
000000  8001              STRH     r1,[r0,#0]
;;;49     	psem->cnt = val;
;;;50     	psem->limit = limit;
000002  8042              STRH     r2,[r0,#2]
;;;51     }
000004  4770              BX       lr
;;;52     
                          ENDP


                          AREA ||i.gfxSemSignal||, CODE, READONLY, ALIGN=1

                  gfxSemSignal PROC
;;;99     
;;;100    void gfxSemSignal(gfxSem *psem) {
000000  b500              PUSH     {lr}
000002  4603              MOV      r3,r0
;;;101    	INTERRUPTS_OFF();
;;;102    	gfxSemSignalI(psem);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       gfxSemSignalI
;;;103    	INTERRUPTS_ON();
;;;104    }
00000a  bd00              POP      {pc}
;;;105    
                          ENDP


                          AREA ||i.gfxSemSignalI||, CODE, READONLY, ALIGN=1

                  gfxSemSignalI PROC
;;;105    
;;;106    void gfxSemSignalI(gfxSem *psem) {
000000  f9b01000          LDRSH    r1,[r0,#0]
;;;107    	if (psem->cnt < psem->limit)
000004  f9b02002          LDRSH    r2,[r0,#2]
000008  4291              CMP      r1,r2
00000a  da03              BGE      |L61.20|
;;;108    		psem->cnt++;
00000c  8801              LDRH     r1,[r0,#0]
00000e  1c49              ADDS     r1,r1,#1
000010  b209              SXTH     r1,r1
000012  8001              STRH     r1,[r0,#0]
                  |L61.20|
;;;109    }
000014  4770              BX       lr
;;;110    
                          ENDP


                          AREA ||i.gfxSemWait||, CODE, READONLY, ALIGN=1

                  gfxSemWait PROC
;;;52     
;;;53     bool_t gfxSemWait(gfxSem *psem, delaytime_t ms) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;54     	systemticks_t	starttm, delay;
;;;55     
;;;56     	// Convert our delay to ticks
;;;57     	starttm = 0;
000008  2700              MOVS     r7,#0
;;;58     	switch (ms) {
00000a  f1b63fff          CMP      r6,#0xffffffff
00000e  d002              BEQ      |L62.22|
000010  b926              CBNZ     r6,|L62.28|
;;;59     	case TIME_IMMEDIATE:
;;;60     		delay = TIME_IMMEDIATE;
000012  2400              MOVS     r4,#0
;;;61     		break;
000014  e00c              B        |L62.48|
                  |L62.22|
;;;62     	case TIME_INFINITE:
;;;63     		delay = TIME_INFINITE;
000016  f04f34ff          MOV      r4,#0xffffffff
;;;64     		break;
00001a  e009              B        |L62.48|
                  |L62.28|
;;;65     	default:
;;;66     		delay = gfxMillisecondsToTicks(ms);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       gfxMillisecondsToTicks
000022  4604              MOV      r4,r0
;;;67     		if (!delay) delay = 1;
000024  b904              CBNZ     r4,|L62.40|
000026  2401              MOVS     r4,#1
                  |L62.40|
;;;68     		starttm = gfxSystemTicks();
000028  f7fffffe          BL       gfxSystemTicks
00002c  4607              MOV      r7,r0
00002e  bf00              NOP                            ;58
                  |L62.48|
000030  bf00              NOP                            ;61
;;;69     	}
;;;70     
;;;71     	INTERRUPTS_OFF();
;;;72     	while (psem->cnt <= 0) {
000032  e012              B        |L62.90|
                  |L62.52|
;;;73     		INTERRUPTS_ON();
;;;74     		// Check if we have exceeded the defined delay
;;;75     		switch (delay) {
000034  f1b43fff          CMP      r4,#0xffffffff
000038  d003              BEQ      |L62.66|
00003a  b91c              CBNZ     r4,|L62.68|
;;;76     		case TIME_IMMEDIATE:
;;;77     			return FALSE;
00003c  2000              MOVS     r0,#0
                  |L62.62|
;;;78     		case TIME_INFINITE:
;;;79     			break;
;;;80     		default:
;;;81     			if (gfxSystemTicks() - starttm >= delay)
;;;82     				return FALSE;
;;;83     			break;
;;;84     		}
;;;85     		gfxYield();
;;;86     		INTERRUPTS_OFF();
;;;87     	}
;;;88     	psem->cnt--;
;;;89     	INTERRUPTS_ON();
;;;90     	return TRUE;
;;;91     }
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L62.66|
000042  e007              B        |L62.84|
                  |L62.68|
000044  f7fffffe          BL       gfxSystemTicks
000048  1bc0              SUBS     r0,r0,r7              ;81
00004a  42a0              CMP      r0,r4                 ;81
00004c  d301              BCC      |L62.82|
00004e  2000              MOVS     r0,#0                 ;82
000050  e7f5              B        |L62.62|
                  |L62.82|
000052  bf00              NOP                            ;83
                  |L62.84|
000054  bf00              NOP                            ;79
000056  f7fffffe          BL       gfxYield
                  |L62.90|
00005a  f9b50000          LDRSH    r0,[r5,#0]            ;72
00005e  2800              CMP      r0,#0                 ;72
000060  dde8              BLE      |L62.52|
000062  8828              LDRH     r0,[r5,#0]            ;88
000064  1e40              SUBS     r0,r0,#1              ;88
000066  b200              SXTH     r0,r0                 ;88
000068  8028              STRH     r0,[r5,#0]            ;88
00006a  20ff              MOVS     r0,#0xff              ;90
00006c  e7e7              B        |L62.62|
;;;92     
                          ENDP


                          AREA ||i.gfxSemWaitI||, CODE, READONLY, ALIGN=1

                  gfxSemWaitI PROC
;;;92     
;;;93     bool_t gfxSemWaitI(gfxSem *psem) {
000000  4601              MOV      r1,r0
;;;94     	if (psem->cnt <= 0)
000002  f9b10000          LDRSH    r0,[r1,#0]
000006  2800              CMP      r0,#0
000008  dc01              BGT      |L63.14|
;;;95     		return FALSE;
00000a  2000              MOVS     r0,#0
                  |L63.12|
;;;96     	psem->cnt--;
;;;97     	return TRUE;
;;;98     }
00000c  4770              BX       lr
                  |L63.14|
00000e  8808              LDRH     r0,[r1,#0]            ;96
000010  1e40              SUBS     r0,r0,#1              ;96
000012  b200              SXTH     r0,r0                 ;96
000014  8008              STRH     r0,[r1,#0]            ;96
000016  20ff              MOVS     r0,#0xff              ;97
000018  e7f8              B        |L63.12|
;;;99     
                          ENDP


                          AREA ||i.gfxSleepMicroseconds||, CODE, READONLY, ALIGN=1

                  gfxSleepMicroseconds PROC
;;;136    
;;;137    void gfxSleepMicroseconds(delaytime_t ms) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;138    	systemticks_t	starttm, delay;
;;;139    
;;;140    	// Safety first
;;;141    	switch (ms) {
000006  f1b43fff          CMP      r4,#0xffffffff
00000a  d002              BEQ      |L64.18|
00000c  b92c              CBNZ     r4,|L64.26|
                  |L64.14|
;;;142    	case TIME_IMMEDIATE:
;;;143    		return;
;;;144    	case TIME_INFINITE:
;;;145    		while(1)
;;;146    			gfxYield();
;;;147    		return;
;;;148    	}
;;;149    
;;;150    	// Convert our delay to ticks
;;;151    	delay = gfxMillisecondsToTicks(ms/1000);
;;;152    	starttm = gfxSystemTicks();
;;;153    
;;;154    	do {
;;;155    		gfxYield();
;;;156    	} while (gfxSystemTicks() - starttm < delay);
;;;157    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L64.18|
000012  e001              B        |L64.24|
                  |L64.20|
000014  f7fffffe          BL       gfxYield
                  |L64.24|
000018  e7fc              B        |L64.20|
                  |L64.26|
00001a  f44f707a          MOV      r0,#0x3e8             ;151
00001e  fbb4f7f0          UDIV     r7,r4,r0              ;151
000022  4638              MOV      r0,r7                 ;151
000024  f7fffffe          BL       gfxMillisecondsToTicks
000028  4606              MOV      r6,r0                 ;151
00002a  f7fffffe          BL       gfxSystemTicks
00002e  4605              MOV      r5,r0                 ;152
000030  bf00              NOP                            ;154
                  |L64.50|
000032  f7fffffe          BL       gfxYield
000036  f7fffffe          BL       gfxSystemTicks
00003a  1b40              SUBS     r0,r0,r5              ;156
00003c  42b0              CMP      r0,r6                 ;156
00003e  d3f8              BCC      |L64.50|
000040  bf00              NOP      
000042  e7e4              B        |L64.14|
;;;158    
                          ENDP


                          AREA ||i.gfxSleepMilliseconds||, CODE, READONLY, ALIGN=1

                  gfxSleepMilliseconds PROC
;;;114    
;;;115    void gfxSleepMilliseconds(delaytime_t ms) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;116    	systemticks_t	starttm, delay;
;;;117    
;;;118    	// Safety first
;;;119    	switch (ms) {
000004  f1b53fff          CMP      r5,#0xffffffff
000008  d001              BEQ      |L65.14|
00000a  b925              CBNZ     r5,|L65.22|
                  |L65.12|
;;;120    	case TIME_IMMEDIATE:
;;;121    		return;
;;;122    	case TIME_INFINITE:
;;;123    		while(1)
;;;124    			gfxYield();
;;;125    		return;
;;;126    	}
;;;127    
;;;128    	// Convert our delay to ticks
;;;129    	delay = gfxMillisecondsToTicks(ms);
;;;130    	starttm = gfxSystemTicks();
;;;131    
;;;132    	do {
;;;133    		gfxYield();
;;;134    	} while (gfxSystemTicks() - starttm < delay);
;;;135    }
00000c  bd70              POP      {r4-r6,pc}
                  |L65.14|
00000e  e001              B        |L65.20|
                  |L65.16|
000010  f7fffffe          BL       gfxYield
                  |L65.20|
000014  e7fc              B        |L65.16|
                  |L65.22|
000016  4628              MOV      r0,r5                 ;129
000018  f7fffffe          BL       gfxMillisecondsToTicks
00001c  4606              MOV      r6,r0                 ;129
00001e  f7fffffe          BL       gfxSystemTicks
000022  4604              MOV      r4,r0                 ;130
000024  bf00              NOP                            ;132
                  |L65.38|
000026  f7fffffe          BL       gfxYield
00002a  f7fffffe          BL       gfxSystemTicks
00002e  1b00              SUBS     r0,r0,r4              ;134
000030  42b0              CMP      r0,r6                 ;134
000032  d3f8              BCC      |L65.38|
000034  bf00              NOP      
000036  e7e9              B        |L65.12|
;;;136    
                          ENDP


                          AREA ||i.gfxSystemLock||, CODE, READONLY, ALIGN=1

                  gfxSystemLock PROC
;;;20     
;;;21     void gfxSystemLock(void) {
000000  4770              BX       lr
;;;22     	INTERRUPTS_OFF();
;;;23     }
;;;24     
                          ENDP


                          AREA ||i.gfxSystemUnlock||, CODE, READONLY, ALIGN=1

                  gfxSystemUnlock PROC
;;;24     
;;;25     void gfxSystemUnlock(void) {
000000  4770              BX       lr
;;;26     	INTERRUPTS_ON();
;;;27     }
;;;28     
                          ENDP


                          AREA ||i.gfxThreadCreate||, CODE, READONLY, ALIGN=2

                  gfxThreadCreate PROC
;;;607    
;;;608    gfxThreadHandle gfxThreadCreate(void *stackarea, size_t stacksz, threadpriority_t prio, DECLARE_THREAD_FUNCTION((*fn),p), void *param) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4692              MOV      r10,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;609    	thread *	t;
;;;610    	thread *	me;
;;;611    	(void)		prio;
;;;612    
;;;613    	// Ensure we have a minimum stack size
;;;614    	if (stacksz < sizeof(thread)+64) {
000010  2e58              CMP      r6,#0x58
000012  d201              BCS      |L68.24|
;;;615    		stacksz = sizeof(thread)+64;
000014  2658              MOVS     r6,#0x58
;;;616    		stackarea = 0;
000016  2500              MOVS     r5,#0
                  |L68.24|
;;;617    	}
;;;618    
;;;619    	if (stackarea) {
000018  b11d              CBZ      r5,|L68.34|
;;;620    		t = (thread *)stackarea;
00001a  462c              MOV      r4,r5
;;;621    		t->flags = 0;
00001c  2000              MOVS     r0,#0
00001e  6060              STR      r0,[r4,#4]
000020  e009              B        |L68.54|
                  |L68.34|
;;;622    	} else {
;;;623    		t = (thread *)gfxAlloc(stacksz);
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       gfxAlloc
000028  4604              MOV      r4,r0
;;;624    		if (!t)
00002a  b914              CBNZ     r4,|L68.50|
;;;625    			return 0;
00002c  2000              MOVS     r0,#0
                  |L68.46|
;;;626    		t->flags = FLG_THD_ALLOC;
;;;627    	}
;;;628    	t->size = stacksz;
;;;629    	t->fn = fn;
;;;630    	t->param = param;
;;;631    
;;;632    	// Add the current thread to the queue because we are starting a new thread.
;;;633    	me = current;
;;;634    	Qadd(&readyQ, me);
;;;635    	current = t;
;;;636    
;;;637    	_gfxStartThread(me, t);
;;;638    
;;;639    	// Return the new thread handle
;;;640    	return t;
;;;641    }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L68.50|
000032  2001              MOVS     r0,#1                 ;626
000034  6060              STR      r0,[r4,#4]            ;626
                  |L68.54|
000036  60a6              STR      r6,[r4,#8]            ;628
000038  f8c4800c          STR      r8,[r4,#0xc]          ;629
00003c  f8c49010          STR      r9,[r4,#0x10]         ;630
000040  4807              LDR      r0,|L68.96|
000042  6807              LDR      r7,[r0,#0]            ;633  ; current
000044  4639              MOV      r1,r7                 ;634
000046  4807              LDR      r0,|L68.100|
000048  f7fffffe          BL       Qadd
00004c  4804              LDR      r0,|L68.96|
00004e  6004              STR      r4,[r0,#0]            ;635  ; current
000050  22ff              MOVS     r2,#0xff              ;637
000052  4621              MOV      r1,r4                 ;637
000054  4638              MOV      r0,r7                 ;637
000056  f7fffffe          BL       _gfxXSwitch
00005a  4620              MOV      r0,r4                 ;640
00005c  e7e7              B        |L68.46|
;;;642    
                          ENDP

00005e  0000              DCW      0x0000
                  |L68.96|
                          DCD      current
                  |L68.100|
                          DCD      readyQ

                          AREA ||i.gfxThreadExit||, CODE, READONLY, ALIGN=2

                  gfxThreadExit PROC
;;;584    // This routine is not currently public - but it could be.
;;;585    void gfxThreadExit(threadreturn_t ret) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;586    	thread	*me;
;;;587    
;;;588    	// Save the results in case someone is waiting
;;;589    	me = current;
000004  480f              LDR      r0,|L69.68|
000006  6804              LDR      r4,[r0,#0]  ; current
;;;590    	me->param = (void *)ret;
000008  6125              STR      r5,[r4,#0x10]
;;;591    	me->flags |= FLG_THD_DEAD;
00000a  6860              LDR      r0,[r4,#4]
00000c  f0400004          ORR      r0,r0,#4
000010  6060              STR      r0,[r4,#4]
;;;592    
;;;593    	// Add us to the dead list if we need deallocation as we can't free ourselves.
;;;594    	// If someone is waiting on the thread they will do the cleanup.
;;;595    	if ((me->flags & (FLG_THD_ALLOC|FLG_THD_WAIT)) == FLG_THD_ALLOC)
000012  7920              LDRB     r0,[r4,#4]
000014  f0000009          AND      r0,r0,#9
000018  2801              CMP      r0,#1
00001a  d103              BNE      |L69.36|
;;;596    		Qadd(&deadQ, me);
00001c  4621              MOV      r1,r4
00001e  480a              LDR      r0,|L69.72|
000020  f7fffffe          BL       Qadd
                  |L69.36|
;;;597    
;;;598    	// Set the next thread. Exit if it was the last thread
;;;599    	if (!(current = Qpop(&readyQ)))
000024  4809              LDR      r0,|L69.76|
000026  f7fffffe          BL       Qpop
00002a  4906              LDR      r1,|L69.68|
00002c  6008              STR      r0,[r1,#0]  ; current
00002e  b908              CBNZ     r0,|L69.52|
;;;600    		gfxExit();
000030  f7fffffe          BL       gfxExit
                  |L69.52|
;;;601    
;;;602    	// Switch to the new thread
;;;603    	_gfxTaskSwitch(me, current);
000034  2200              MOVS     r2,#0
000036  4803              LDR      r0,|L69.68|
000038  6801              LDR      r1,[r0,#0]  ; current
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       _gfxXSwitch
;;;604    
;;;605    	// We never get back here as we didn't re-queue ourselves
;;;606    }
000040  bd70              POP      {r4-r6,pc}
;;;607    
                          ENDP

000042  0000              DCW      0x0000
                  |L69.68|
                          DCD      current
                  |L69.72|
                          DCD      deadQ
                  |L69.76|
                          DCD      readyQ

                          AREA ||i.gfxThreadMe||, CODE, READONLY, ALIGN=2

                  gfxThreadMe PROC
;;;556    
;;;557    gfxThreadHandle gfxThreadMe(void) {
000000  4801              LDR      r0,|L70.8|
;;;558    	return (gfxThreadHandle)current;
000002  6800              LDR      r0,[r0,#0]  ; current
;;;559    }
000004  4770              BX       lr
;;;560    
                          ENDP

000006  0000              DCW      0x0000
                  |L70.8|
                          DCD      current

                          AREA ||i.gfxThreadWait||, CODE, READONLY, ALIGN=2

                  gfxThreadWait PROC
;;;642    
;;;643    threadreturn_t gfxThreadWait(gfxThreadHandle th) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;644    	thread *		t;
;;;645    
;;;646    	t = th;
000004  462c              MOV      r4,r5
;;;647    	if (t == current)
000006  4810              LDR      r0,|L71.72|
000008  6800              LDR      r0,[r0,#0]  ; current
00000a  4284              CMP      r4,r0
00000c  d102              BNE      |L71.20|
;;;648    		return -1;
00000e  f04f30ff          MOV      r0,#0xffffffff
                  |L71.18|
;;;649    
;;;650    	// Mark that we are waiting
;;;651    	t->flags |= FLG_THD_WAIT;
;;;652    
;;;653    	// Wait for the thread to die
;;;654    	while(!(t->flags & FLG_THD_DEAD))
;;;655    		gfxYield();
;;;656    
;;;657    	// Unmark
;;;658    	t->flags &= ~FLG_THD_WAIT;
;;;659    
;;;660    	// Clean up resources if needed
;;;661    	if (t->flags & FLG_THD_ALLOC)
;;;662    		gfxFree(t);
;;;663    
;;;664    	// Return the status left by the dead process
;;;665    	return (threadreturn_t)t->param;
;;;666    }
000012  bd70              POP      {r4-r6,pc}
                  |L71.20|
000014  6860              LDR      r0,[r4,#4]            ;651
000016  f0400008          ORR      r0,r0,#8              ;651
00001a  6060              STR      r0,[r4,#4]            ;651
00001c  e001              B        |L71.34|
                  |L71.30|
00001e  f7fffffe          BL       gfxYield
                  |L71.34|
000022  7920              LDRB     r0,[r4,#4]            ;654
000024  f0000004          AND      r0,r0,#4              ;654
000028  2800              CMP      r0,#0                 ;654
00002a  d0f8              BEQ      |L71.30|
00002c  6860              LDR      r0,[r4,#4]            ;658
00002e  f0200008          BIC      r0,r0,#8              ;658
000032  6060              STR      r0,[r4,#4]            ;658
000034  7920              LDRB     r0,[r4,#4]            ;661
000036  f0000001          AND      r0,r0,#1              ;661
00003a  b110              CBZ      r0,|L71.66|
00003c  4620              MOV      r0,r4                 ;662
00003e  f7fffffe          BL       gfxFree
                  |L71.66|
000042  6920              LDR      r0,[r4,#0x10]         ;665
000044  e7e5              B        |L71.18|
;;;667    
                          ENDP

000046  0000              DCW      0x0000
                  |L71.72|
                          DCD      current

                          AREA ||i.gfxYield||, CODE, READONLY, ALIGN=2

                  gfxYield PROC
;;;568    
;;;569    void gfxYield(void) {
000000  b510              PUSH     {r4,lr}
;;;570    	thread	*me;
;;;571    
;;;572    	// Clean up zombies
;;;573    	cleanUpDeadThreads();
000002  f7fffffe          BL       cleanUpDeadThreads
;;;574    
;;;575    	// Is there another thread to run?
;;;576    	if (!readyQ.head)
000006  480b              LDR      r0,|L72.52|
000008  6800              LDR      r0,[r0,#0]  ; readyQ
00000a  b900              CBNZ     r0,|L72.14|
                  |L72.12|
;;;577    		return;
;;;578    
;;;579    	Qadd(&readyQ, me = current);
;;;580    	current = Qpop(&readyQ);
;;;581    	_gfxTaskSwitch(me, current);
;;;582    }
00000c  bd10              POP      {r4,pc}
                  |L72.14|
00000e  480a              LDR      r0,|L72.56|
000010  6804              LDR      r4,[r0,#0]            ;579  ; current
000012  4621              MOV      r1,r4                 ;579
000014  4807              LDR      r0,|L72.52|
000016  f7fffffe          BL       Qadd
00001a  4806              LDR      r0,|L72.52|
00001c  f7fffffe          BL       Qpop
000020  4905              LDR      r1,|L72.56|
000022  6008              STR      r0,[r1,#0]            ;580  ; current
000024  2200              MOVS     r2,#0                 ;581
000026  4608              MOV      r0,r1                 ;581
000028  6801              LDR      r1,[r0,#0]            ;581  ; current
00002a  4620              MOV      r0,r4                 ;581
00002c  f7fffffe          BL       _gfxXSwitch
000030  bf00              NOP      
000032  e7eb              B        |L72.12|
;;;583    
                          ENDP

                  |L72.52|
                          DCD      readyQ
                  |L72.56|
                          DCD      current

                          AREA ||i.hline_clip||, CODE, READONLY, ALIGN=1

                  hline_clip PROC
;;;253    //	if GDISP_HARDWARE_STREAM_WRITE and GDISP_HARDWARE_STREAM_POS is set.
;;;254    static void hline_clip(GDisplay *g) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;255    	// Swap the points if necessary so it always goes from x to x1
;;;256    	if (g->p.x1 < g->p.x) {
000004  f9b40030          LDRSH    r0,[r4,#0x30]
000008  f9b41028          LDRSH    r1,[r4,#0x28]
00000c  4288              CMP      r0,r1
00000e  da05              BGE      |L73.28|
;;;257    		g->p.cx = g->p.x; g->p.x = g->p.x1; g->p.x1 = g->p.cx;
000010  8d21              LDRH     r1,[r4,#0x28]
000012  85a1              STRH     r1,[r4,#0x2c]
000014  8e20              LDRH     r0,[r4,#0x30]
000016  8520              STRH     r0,[r4,#0x28]
000018  8da1              LDRH     r1,[r4,#0x2c]
00001a  8621              STRH     r1,[r4,#0x30]
                  |L73.28|
;;;258    	}
;;;259    
;;;260    	// Clipping
;;;261    	#if NEED_CLIPPING
;;;262    		#if GDISP_HARDWARE_CLIP == HARDWARE_AUTODETECT
;;;263    			if (!gvmt(g)->setclip)
;;;264    		#endif
;;;265    		{
;;;266    			if (g->p.y < g->clipy0 || g->p.y >= g->clipy1) return;
00001c  f9b4002a          LDRSH    r0,[r4,#0x2a]
000020  f9b41022          LDRSH    r1,[r4,#0x22]
000024  4288              CMP      r0,r1
000026  db05              BLT      |L73.52|
000028  f9b4002a          LDRSH    r0,[r4,#0x2a]
00002c  f9b41026          LDRSH    r1,[r4,#0x26]
000030  4288              CMP      r0,r1
000032  db00              BLT      |L73.54|
                  |L73.52|
;;;267    			if (g->p.x < g->clipx0) g->p.x = g->clipx0;
;;;268    			if (g->p.x1 >= g->clipx1) g->p.x1 = g->clipx1 - 1;
;;;269    			if (g->p.x1 < g->p.x) return;
;;;270    		}
;;;271    	#endif
;;;272    
;;;273    	// This is an optimization for the point case. It is only worthwhile however if we
;;;274    	// have hardware fills or if we support both hardware pixel drawing and hardware streaming
;;;275    	#if GDISP_HARDWARE_FILLS || (GDISP_HARDWARE_DRAWPIXEL && GDISP_HARDWARE_STREAM_WRITE)
;;;276    		// Is this a point
;;;277    		if (g->p.x == g->p.x1) {
;;;278    			drawpixel(g);
;;;279    			return;
;;;280    		}
;;;281    	#endif
;;;282    
;;;283    	// Best is hardware accelerated area fill
;;;284    	#if GDISP_HARDWARE_FILLS
;;;285    		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
;;;286    			if (gvmt(g)->fill)
;;;287    		#endif
;;;288    		{
;;;289    			g->p.cx = g->p.x1 - g->p.x + 1;
;;;290    			g->p.cy = 1;
;;;291    			gdisp_lld_fill_area(g);
;;;292    			return;
;;;293    		}
;;;294    	#endif
;;;295    
;;;296    	// Next best is cursor based streaming
;;;297    	#if GDISP_HARDWARE_FILLS != TRUE && GDISP_HARDWARE_STREAM_POS && GDISP_HARDWARE_STREAM_WRITE
;;;298    		#if GDISP_HARDWARE_STREAM_POS == HARDWARE_AUTODETECT
;;;299    			if (gvmt(g)->writepos)
;;;300    		#endif
;;;301    		{
;;;302    			if (!(g->flags & GDISP_FLG_SCRSTREAM))
;;;303    				setglobalwindow(g);
;;;304    			g->p.cx = g->p.x1 - g->p.x + 1;
;;;305    			gdisp_lld_write_pos(g);
;;;306    			do { gdisp_lld_write_color(g); } while(--g->p.cx);
;;;307    			return;
;;;308    		}
;;;309    	#endif
;;;310    
;;;311    	// Next best is streaming
;;;312    	#if GDISP_HARDWARE_FILLS != TRUE && GDISP_HARDWARE_STREAM_POS != TRUE && GDISP_HARDWARE_STREAM_WRITE
;;;313    		#if GDISP_HARDWARE_STREAM_WRITE == HARDWARE_AUTODETECT
;;;314    			if (gvmt(g)->writestart)
;;;315    		#endif
;;;316    		{
;;;317    			g->p.cx = g->p.x1 - g->p.x + 1;
;;;318    			g->p.cy = 1;
;;;319    			gdisp_lld_write_start(g);
;;;320    			do { gdisp_lld_write_color(g); } while(--g->p.cx);
;;;321    			gdisp_lld_write_stop(g);
;;;322    			return;
;;;323    		}
;;;324    	#endif
;;;325    
;;;326    	// Worst is drawing pixels
;;;327    	#if GDISP_HARDWARE_FILLS != TRUE && GDISP_HARDWARE_STREAM_WRITE != TRUE && GDISP_HARDWARE_DRAWPIXEL
;;;328    		// The following test is unneeded because we are guaranteed to have draw pixel if we don't have streaming
;;;329    		//#if GDISP_HARDWARE_DRAWPIXEL == HARDWARE_AUTODETECT
;;;330    		//	if (gvmt(g)->pixel)
;;;331    		//#endif
;;;332    		{
;;;333    			for(; g->p.x <= g->p.x1; g->p.x++)
;;;334    				gdisp_lld_draw_pixel(g);
;;;335    			return;
;;;336    		}
;;;337    	#endif
;;;338    }
000034  bd10              POP      {r4,pc}
                  |L73.54|
000036  f9b40028          LDRSH    r0,[r4,#0x28]         ;267
00003a  f9b41020          LDRSH    r1,[r4,#0x20]         ;267
00003e  4288              CMP      r0,r1                 ;267
000040  da01              BGE      |L73.70|
000042  8c20              LDRH     r0,[r4,#0x20]         ;267
000044  8520              STRH     r0,[r4,#0x28]         ;267
                  |L73.70|
000046  f9b40030          LDRSH    r0,[r4,#0x30]         ;268
00004a  f9b41024          LDRSH    r1,[r4,#0x24]         ;268
00004e  4288              CMP      r0,r1                 ;268
000050  db03              BLT      |L73.90|
000052  8ca0              LDRH     r0,[r4,#0x24]         ;268
000054  1e40              SUBS     r0,r0,#1              ;268
000056  b201              SXTH     r1,r0                 ;268
000058  8621              STRH     r1,[r4,#0x30]         ;268
                  |L73.90|
00005a  f9b40030          LDRSH    r0,[r4,#0x30]         ;269
00005e  f9b41028          LDRSH    r1,[r4,#0x28]         ;269
000062  4288              CMP      r0,r1                 ;269
000064  da00              BGE      |L73.104|
000066  e7e5              B        |L73.52|
                  |L73.104|
000068  e006              B        |L73.120|
                  |L73.106|
00006a  4620              MOV      r0,r4                 ;334
00006c  f7fffffe          BL       gdisp_lld_draw_pixel
000070  8d20              LDRH     r0,[r4,#0x28]         ;333
000072  1c40              ADDS     r0,r0,#1              ;333
000074  b200              SXTH     r0,r0                 ;333
000076  8520              STRH     r0,[r4,#0x28]         ;333
                  |L73.120|
000078  f9b41028          LDRSH    r1,[r4,#0x28]         ;333
00007c  f9b40030          LDRSH    r0,[r4,#0x30]         ;333
000080  4281              CMP      r1,r0                 ;333
000082  ddf2              BLE      |L73.106|
000084  bf00              NOP                            ;335
000086  e7d5              B        |L73.52|
;;;339    
                          ENDP


                          AREA ||i.line_clip||, CODE, READONLY, ALIGN=1

                  line_clip PROC
;;;426    // Alters:		x,y x1,y1 cx,cy
;;;427    static void line_clip(GDisplay *g) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4604              MOV      r4,r0
;;;428    	int16_t dy, dx;
;;;429    	int16_t addx, addy;
;;;430    	int16_t P, diff, i;
;;;431    
;;;432    	// Is this a horizontal line (or a point)
;;;433    	if (g->p.y == g->p.y1) {
000006  f9b4102a          LDRSH    r1,[r4,#0x2a]
00000a  f9b40032          LDRSH    r0,[r4,#0x32]
00000e  4281              CMP      r1,r0
000010  d104              BNE      |L74.28|
;;;434    		hline_clip(g);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       hline_clip
                  |L74.24|
;;;435    		return;
;;;436    	}
;;;437    
;;;438    	// Is this a vertical line (or a point)
;;;439    	if (g->p.x == g->p.x1) {
;;;440    		vline_clip(g);
;;;441    		return;
;;;442    	}
;;;443    
;;;444    	// Not horizontal or vertical
;;;445    
;;;446    	// Use Bresenham's line drawing algorithm.
;;;447    	//	This should be replaced with fixed point slope based line drawing
;;;448    	//	which is more efficient on modern processors as it branches less.
;;;449    	//	When clipping is needed, all the clipping could also be done up front
;;;450    	//	instead of on each pixel.
;;;451    
;;;452    	if (g->p.x1 >= g->p.x) {
;;;453    		dx = g->p.x1 - g->p.x;
;;;454    		addx = 1;
;;;455    	} else {
;;;456    		dx = g->p.x - g->p.x1;
;;;457    		addx = -1;
;;;458    	}
;;;459    	if (g->p.y1 >= g->p.y) {
;;;460    		dy = g->p.y1 - g->p.y;
;;;461    		addy = 1;
;;;462    	} else {
;;;463    		dy = g->p.y - g->p.y1;
;;;464    		addy = -1;
;;;465    	}
;;;466    
;;;467    	if (dx >= dy) {
;;;468    		dy <<= 1;
;;;469    		P = dy - dx;
;;;470    		diff = P - dx;
;;;471    
;;;472    		for(i=0; i<=dx; ++i) {
;;;473    			drawpixel_clip(g);
;;;474    			if (P < 0) {
;;;475    				P  += dy;
;;;476    				g->p.x += addx;
;;;477    			} else {
;;;478    				P  += diff;
;;;479    				g->p.x += addx;
;;;480    				g->p.y += addy;
;;;481    			}
;;;482    		}
;;;483    	} else {
;;;484    		dx <<= 1;
;;;485    		P = dx - dy;
;;;486    		diff = P - dy;
;;;487    
;;;488    		for(i=0; i<=dy; ++i) {
;;;489    			drawpixel_clip(g);
;;;490    			if (P < 0) {
;;;491    				P  += dx;
;;;492    				g->p.y += addy;
;;;493    			} else {
;;;494    				P  += diff;
;;;495    				g->p.x += addx;
;;;496    				g->p.y += addy;
;;;497    			}
;;;498    		}
;;;499    	}
;;;500    }
000018  e8bd9ff0          POP      {r4-r12,pc}
                  |L74.28|
00001c  f9b41028          LDRSH    r1,[r4,#0x28]         ;439
000020  f9b40030          LDRSH    r0,[r4,#0x30]         ;439
000024  4281              CMP      r1,r0                 ;439
000026  d103              BNE      |L74.48|
000028  4620              MOV      r0,r4                 ;440
00002a  f7fffffe          BL       vline_clip
00002e  e7f3              B        |L74.24|
                  |L74.48|
000030  f9b40030          LDRSH    r0,[r4,#0x30]         ;452
000034  f9b41028          LDRSH    r1,[r4,#0x28]         ;452
000038  4288              CMP      r0,r1                 ;452
00003a  db06              BLT      |L74.74|
00003c  8e20              LDRH     r0,[r4,#0x30]         ;453
00003e  8d21              LDRH     r1,[r4,#0x28]         ;453
000040  1a40              SUBS     r0,r0,r1              ;453
000042  b207              SXTH     r7,r0                 ;453
000044  f04f0901          MOV      r9,#1                 ;454
000048  e005              B        |L74.86|
                  |L74.74|
00004a  8d21              LDRH     r1,[r4,#0x28]         ;456
00004c  8e20              LDRH     r0,[r4,#0x30]         ;456
00004e  1a08              SUBS     r0,r1,r0              ;456
000050  b207              SXTH     r7,r0                 ;456
000052  f04f39ff          MOV      r9,#0xffffffff        ;457
                  |L74.86|
000056  f9b41032          LDRSH    r1,[r4,#0x32]         ;459
00005a  f9b4002a          LDRSH    r0,[r4,#0x2a]         ;459
00005e  4281              CMP      r1,r0                 ;459
000060  db06              BLT      |L74.112|
000062  8e61              LDRH     r1,[r4,#0x32]         ;460
000064  8d60              LDRH     r0,[r4,#0x2a]         ;460
000066  1a08              SUBS     r0,r1,r0              ;460
000068  b206              SXTH     r6,r0                 ;460
00006a  f04f0a01          MOV      r10,#1                ;461
00006e  e005              B        |L74.124|
                  |L74.112|
000070  8d61              LDRH     r1,[r4,#0x2a]         ;463
000072  8e60              LDRH     r0,[r4,#0x32]         ;463
000074  1a08              SUBS     r0,r1,r0              ;463
000076  b206              SXTH     r6,r0                 ;463
000078  f04f3aff          MOV      r10,#0xffffffff       ;464
                  |L74.124|
00007c  42b7              CMP      r7,r6                 ;467
00007e  db27              BLT      |L74.208|
000080  0070              LSLS     r0,r6,#1              ;468
000082  b206              SXTH     r6,r0                 ;468
000084  1bf0              SUBS     r0,r6,r7              ;469
000086  b205              SXTH     r5,r0                 ;469
000088  1be8              SUBS     r0,r5,r7              ;470
00008a  fa0ffb80          SXTH     r11,r0                ;470
00008e  f04f0800          MOV      r8,#0                 ;472
000092  e01a              B        |L74.202|
                  |L74.148|
000094  4620              MOV      r0,r4                 ;473
000096  f7fffffe          BL       drawpixel_clip
00009a  2d00              CMP      r5,#0                 ;474
00009c  da06              BGE      |L74.172|
00009e  19a8              ADDS     r0,r5,r6              ;475
0000a0  b205              SXTH     r5,r0                 ;475
0000a2  8d20              LDRH     r0,[r4,#0x28]         ;476
0000a4  4448              ADD      r0,r0,r9              ;476
0000a6  b200              SXTH     r0,r0                 ;476
0000a8  8520              STRH     r0,[r4,#0x28]         ;476
0000aa  e00a              B        |L74.194|
                  |L74.172|
0000ac  eb05000b          ADD      r0,r5,r11             ;478
0000b0  b205              SXTH     r5,r0                 ;478
0000b2  8d20              LDRH     r0,[r4,#0x28]         ;479
0000b4  4448              ADD      r0,r0,r9              ;479
0000b6  b200              SXTH     r0,r0                 ;479
0000b8  8520              STRH     r0,[r4,#0x28]         ;479
0000ba  8d60              LDRH     r0,[r4,#0x2a]         ;480
0000bc  4450              ADD      r0,r0,r10             ;480
0000be  b201              SXTH     r1,r0                 ;480
0000c0  8561              STRH     r1,[r4,#0x2a]         ;480
                  |L74.194|
0000c2  f1080001          ADD      r0,r8,#1              ;472
0000c6  fa0ff880          SXTH     r8,r0                 ;472
                  |L74.202|
0000ca  45b8              CMP      r8,r7                 ;472
0000cc  dde2              BLE      |L74.148|
0000ce  e026              B        |L74.286|
                  |L74.208|
0000d0  0078              LSLS     r0,r7,#1              ;484
0000d2  b207              SXTH     r7,r0                 ;484
0000d4  1bb8              SUBS     r0,r7,r6              ;485
0000d6  b205              SXTH     r5,r0                 ;485
0000d8  1ba8              SUBS     r0,r5,r6              ;486
0000da  fa0ffb80          SXTH     r11,r0                ;486
0000de  f04f0800          MOV      r8,#0                 ;488
0000e2  e01a              B        |L74.282|
                  |L74.228|
0000e4  4620              MOV      r0,r4                 ;489
0000e6  f7fffffe          BL       drawpixel_clip
0000ea  2d00              CMP      r5,#0                 ;490
0000ec  da06              BGE      |L74.252|
0000ee  19e8              ADDS     r0,r5,r7              ;491
0000f0  b205              SXTH     r5,r0                 ;491
0000f2  8d60              LDRH     r0,[r4,#0x2a]         ;492
0000f4  4450              ADD      r0,r0,r10             ;492
0000f6  b201              SXTH     r1,r0                 ;492
0000f8  8561              STRH     r1,[r4,#0x2a]         ;492
0000fa  e00a              B        |L74.274|
                  |L74.252|
0000fc  eb05000b          ADD      r0,r5,r11             ;494
000100  b205              SXTH     r5,r0                 ;494
000102  8d20              LDRH     r0,[r4,#0x28]         ;495
000104  4448              ADD      r0,r0,r9              ;495
000106  b200              SXTH     r0,r0                 ;495
000108  8520              STRH     r0,[r4,#0x28]         ;495
00010a  8d60              LDRH     r0,[r4,#0x2a]         ;496
00010c  4450              ADD      r0,r0,r10             ;496
00010e  b201              SXTH     r1,r0                 ;496
000110  8561              STRH     r1,[r4,#0x2a]         ;496
                  |L74.274|
000112  f1080001          ADD      r0,r8,#1              ;488
000116  fa0ff880          SXTH     r8,r0                 ;488
                  |L74.282|
00011a  45b0              CMP      r8,r6                 ;488
00011c  dde2              BLE      |L74.228|
                  |L74.286|
00011e  bf00              NOP      
000120  e77a              B        |L74.24|
;;;501    
                          ENDP


                          AREA ||i.vline_clip||, CODE, READONLY, ALIGN=1

                  vline_clip PROC
;;;341    // Alters:		x,y x1,y1 cx,cy
;;;342    static void vline_clip(GDisplay *g) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;343    	// Swap the points if necessary so it always goes from y to y1
;;;344    	if (g->p.y1 < g->p.y) {
000004  f9b41032          LDRSH    r1,[r4,#0x32]
000008  f9b4002a          LDRSH    r0,[r4,#0x2a]
00000c  4281              CMP      r1,r0
00000e  da05              BGE      |L75.28|
;;;345    		g->p.cy = g->p.y; g->p.y = g->p.y1; g->p.y1 = g->p.cy;
000010  8d61              LDRH     r1,[r4,#0x2a]
000012  85e1              STRH     r1,[r4,#0x2e]
000014  8e61              LDRH     r1,[r4,#0x32]
000016  8561              STRH     r1,[r4,#0x2a]
000018  8de1              LDRH     r1,[r4,#0x2e]
00001a  8661              STRH     r1,[r4,#0x32]
                  |L75.28|
;;;346    	}
;;;347    
;;;348    	// Clipping
;;;349    	#if NEED_CLIPPING
;;;350    		#if GDISP_HARDWARE_CLIP == HARDWARE_AUTODETECT
;;;351    			if (!gvmt(g)->setclip)
;;;352    		#endif
;;;353    		{
;;;354    			if (g->p.x < g->clipx0 || g->p.x >= g->clipx1) return;
00001c  f9b40028          LDRSH    r0,[r4,#0x28]
000020  f9b41020          LDRSH    r1,[r4,#0x20]
000024  4288              CMP      r0,r1
000026  db05              BLT      |L75.52|
000028  f9b40028          LDRSH    r0,[r4,#0x28]
00002c  f9b41024          LDRSH    r1,[r4,#0x24]
000030  4288              CMP      r0,r1
000032  db00              BLT      |L75.54|
                  |L75.52|
;;;355    			if (g->p.y < g->clipy0) g->p.y = g->clipy0;
;;;356    			if (g->p.y1 >= g->clipy1) g->p.y1 = g->clipy1 - 1;
;;;357    			if (g->p.y1 < g->p.y) return;
;;;358    		}
;;;359    	#endif
;;;360    
;;;361    	// This is an optimization for the point case. It is only worthwhile however if we
;;;362    	// have hardware fills or if we support both hardware pixel drawing and hardware streaming
;;;363    	#if GDISP_HARDWARE_FILLS || (GDISP_HARDWARE_DRAWPIXEL && GDISP_HARDWARE_STREAM_WRITE) || (GDISP_HARDWARE_STREAM_POS && GDISP_HARDWARE_STREAM_WRITE)
;;;364    		// Is this a point
;;;365    		if (g->p.y == g->p.y1) {
;;;366    			drawpixel(g);
;;;367    			return;
;;;368    		}
;;;369    	#endif
;;;370    
;;;371    	// Best is hardware accelerated area fill
;;;372    	#if GDISP_HARDWARE_FILLS
;;;373    		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
;;;374    			if (gvmt(g)->fill)
;;;375    		#endif
;;;376    		{
;;;377    			g->p.cy = g->p.y1 - g->p.y + 1;
;;;378    			g->p.cx = 1;
;;;379    			gdisp_lld_fill_area(g);
;;;380    			return;
;;;381    		}
;;;382    	#endif
;;;383    
;;;384    	// Next best is streaming
;;;385    	#if GDISP_HARDWARE_FILLS != TRUE && GDISP_HARDWARE_STREAM_WRITE
;;;386    		#if GDISP_HARDWARE_STREAM_WRITE == HARDWARE_AUTODETECT
;;;387    			if (gvmt(g)->writestart)
;;;388    		#endif
;;;389    		{
;;;390    			#if GDISP_HARDWARE_STREAM_POS
;;;391    				if ((g->flags & GDISP_FLG_SCRSTREAM)) {
;;;392    					gdisp_lld_write_stop(g);
;;;393    					g->flags &= ~GDISP_FLG_SCRSTREAM;
;;;394    				}
;;;395    			#endif
;;;396    			g->p.cy = g->p.y1 - g->p.y + 1;
;;;397    			g->p.cx = 1;
;;;398    			gdisp_lld_write_start(g);
;;;399    			#if GDISP_HARDWARE_STREAM_POS
;;;400    				#if GDISP_HARDWARE_STREAM_POS == HARDWARE_AUTODETECT
;;;401    					if (gvmt(g)->writepos)
;;;402    				#endif
;;;403    				gdisp_lld_write_pos(g);
;;;404    			#endif
;;;405    			do { gdisp_lld_write_color(g); } while(--g->p.cy);
;;;406    			gdisp_lld_write_stop(g);
;;;407    			return;
;;;408    		}
;;;409    	#endif
;;;410    
;;;411    	// Worst is drawing pixels
;;;412    	#if GDISP_HARDWARE_FILLS != TRUE && GDISP_HARDWARE_STREAM_WRITE != TRUE && GDISP_HARDWARE_DRAWPIXEL
;;;413    		// The following test is unneeded because we are guaranteed to have draw pixel if we don't have streaming
;;;414    		//#if GDISP_HARDWARE_DRAWPIXEL == HARDWARE_AUTODETECT
;;;415    		//	if (gvmt(g)->pixel)
;;;416    		//#endif
;;;417    		{
;;;418    			for(; g->p.y <= g->p.y1; g->p.y++)
;;;419    				gdisp_lld_draw_pixel(g);
;;;420    			return;
;;;421    		}
;;;422    	#endif
;;;423    }
000034  bd10              POP      {r4,pc}
                  |L75.54|
000036  f9b4002a          LDRSH    r0,[r4,#0x2a]         ;355
00003a  f9b41022          LDRSH    r1,[r4,#0x22]         ;355
00003e  4288              CMP      r0,r1                 ;355
000040  da01              BGE      |L75.70|
000042  8c61              LDRH     r1,[r4,#0x22]         ;355
000044  8561              STRH     r1,[r4,#0x2a]         ;355
                  |L75.70|
000046  f9b40032          LDRSH    r0,[r4,#0x32]         ;356
00004a  f9b41026          LDRSH    r1,[r4,#0x26]         ;356
00004e  4288              CMP      r0,r1                 ;356
000050  db03              BLT      |L75.90|
000052  8ce0              LDRH     r0,[r4,#0x26]         ;356
000054  1e40              SUBS     r0,r0,#1              ;356
000056  b201              SXTH     r1,r0                 ;356
000058  8661              STRH     r1,[r4,#0x32]         ;356
                  |L75.90|
00005a  f9b41032          LDRSH    r1,[r4,#0x32]         ;357
00005e  f9b4002a          LDRSH    r0,[r4,#0x2a]         ;357
000062  4281              CMP      r1,r0                 ;357
000064  da00              BGE      |L75.104|
000066  e7e5              B        |L75.52|
                  |L75.104|
000068  e006              B        |L75.120|
                  |L75.106|
00006a  4620              MOV      r0,r4                 ;419
00006c  f7fffffe          BL       gdisp_lld_draw_pixel
000070  8d60              LDRH     r0,[r4,#0x2a]         ;418
000072  1c40              ADDS     r0,r0,#1              ;418
000074  b201              SXTH     r1,r0                 ;418
000076  8561              STRH     r1,[r4,#0x2a]         ;418
                  |L75.120|
000078  f9b4102a          LDRSH    r1,[r4,#0x2a]         ;418
00007c  f9b40032          LDRSH    r0,[r4,#0x32]         ;418
000080  4281              CMP      r1,r0                 ;418
000082  ddf2              BLE      |L75.106|
000084  bf00              NOP                            ;420
000086  e7d5              B        |L75.52|
;;;424    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  mainthread
                          %        24
                  maincxt
                          %        160

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  blks
000000  00020006          DCW      0x0002,0x0006
000004  0001000a          DCW      0x0001,0x000a
000008  0003000b          DCW      0x0003,0x000b
00000c  00040001          DCW      0x0004,0x0001
000010  00060006          DCW      0x0006,0x0006
000014  00010006          DCW      0x0001,0x0006
000018  00080000          DCW      0x0008,0x0000
00001c  0001000c          DCW      0x0001,0x000c
000020  00090000          DCW      0x0009,0x0000
000024  00060001          DCW      0x0006,0x0001
000028  0009000b          DCW      0x0009,0x000b
00002c  00060001          DCW      0x0006,0x0001
000030  000e0006          DCW      0x000e,0x0006
000034  00010005          DCW      0x0001,0x0005
000038  000c0006          DCW      0x000c,0x0006
00003c  00020001          DCW      0x0002,0x0001
000040  00100000          DCW      0x0010,0x0000
000044  0001000c          DCW      0x0001,0x000c
000048  00110000          DCW      0x0011,0x0000
00004c  00060001          DCW      0x0006,0x0001
000050  00110006          DCW      0x0011,0x0006
000054  00030001          DCW      0x0003,0x0001
000058  00160006          DCW      0x0016,0x0006
00005c  00070001          DCW      0x0007,0x0001
000060  00180000          DCW      0x0018,0x0000
000064  00010006          DCW      0x0001,0x0006
000068  00160007          DCW      0x0016,0x0007
00006c  00010005          DCW      0x0001,0x0005
000070  001c0000          DCW      0x001c,0x0000
000074  00010006          DCW      0x0001,0x0006
000078  001a0007          DCW      0x001a,0x0007
00007c  00010005          DCW      0x0001,0x0005

                          AREA ||.data||, DATA, ALIGN=2

                  gfxInitDone
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  readyQ
                          %        8
                  deadQ
                          %        8
                  current
                          DCD      0x00000000
                  stackdirup
000018  00000000          DCB      0x00,0x00,0x00,0x00
                  jmpmask1
                          DCD      0x00000000
                  jmpmask2
                          DCD      0x00000000
                  stackbase
                          DCD      0x00000000
                  pframeinfo
                          DCD      0x00000000
                  dhead
                          DCD      0x00000000
                  dtail
                          DCD      0x00000000
                  GDISP
                          DCD      0x00000000
                  gdispInitDone
000038  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\external\\ugfx\\src\\gfx_mk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_gfx_mk_c_gfxInit____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_gfx_mk_c_gfxInit____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_gfx_mk_c_gfxInit____REVSH|
#line 402
|__asm___8_gfx_mk_c_gfxInit____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_gfx_mk_c_gfxInit____RRX|
#line 587
|__asm___8_gfx_mk_c_gfxInit____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
