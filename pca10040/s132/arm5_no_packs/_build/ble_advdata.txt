; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\ble_advdata.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\ble_advdata.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\ble_advdata.crf ..\..\..\..\..\..\components\ble\common\ble_advdata.c]
                          THUMB

                          AREA ||i.adv_data_encode||, CODE, READONLY, ALIGN=1

                  adv_data_encode PROC
;;;473    
;;;474    uint32_t adv_data_encode(ble_advdata_t const * const p_advdata,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;475                             uint8_t             * const p_encoded_data,
;;;476                             uint16_t            * const p_len)
;;;477    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;478        uint32_t err_code = NRF_SUCCESS;
00000a  2500              MOVS     r5,#0
;;;479        uint16_t max_size = *p_len;
00000c  8837              LDRH     r7,[r6,#0]
;;;480        *p_len = 0;
00000e  2000              MOVS     r0,#0
000010  8030              STRH     r0,[r6,#0]
;;;481    
;;;482        // Encode LE Bluetooth Device Address
;;;483        if (p_advdata->include_ble_device_addr)
000012  f894002d          LDRB     r0,[r4,#0x2d]
000016  b158              CBZ      r0,|L1.48|
;;;484        {
;;;485            err_code = ble_device_addr_encode(p_encoded_data, p_len, max_size);
000018  463a              MOV      r2,r7
00001a  4631              MOV      r1,r6
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       ble_device_addr_encode
000022  4605              MOV      r5,r0
;;;486            VERIFY_SUCCESS(err_code);
000024  bf00              NOP      
000026  b115              CBZ      r5,|L1.46|
000028  4628              MOV      r0,r5
                  |L1.42|
;;;487        }
;;;488    
;;;489        // Encode appearance.
;;;490        if (p_advdata->include_appearance)
;;;491        {
;;;492            err_code = appearance_encode(p_encoded_data, p_len, max_size);
;;;493            VERIFY_SUCCESS(err_code);
;;;494        }
;;;495    
;;;496        //Encode Flags
;;;497        if (p_advdata->flags != 0 )
;;;498        {
;;;499            err_code = flags_encode(p_advdata->flags, p_encoded_data, p_len, max_size);
;;;500            VERIFY_SUCCESS(err_code);
;;;501        }
;;;502    
;;;503        // Encode TX power level.
;;;504        if (p_advdata->p_tx_power_level != NULL)
;;;505        {
;;;506            err_code = tx_power_level_encode(*p_advdata->p_tx_power_level,
;;;507                                             p_encoded_data,
;;;508                                             p_len,
;;;509                                             max_size);
;;;510            VERIFY_SUCCESS(err_code);
;;;511        }
;;;512    
;;;513        // Encode 'more available' uuid list.
;;;514        if (p_advdata->uuids_more_available.uuid_cnt > 0)
;;;515        {
;;;516            err_code = uuid_list_encode(&p_advdata->uuids_more_available,
;;;517                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;518                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;519                                        p_encoded_data,
;;;520                                        p_len,
;;;521                                        max_size);
;;;522            VERIFY_SUCCESS(err_code);
;;;523        }
;;;524    
;;;525        // Encode 'complete' uuid list.
;;;526        if (p_advdata->uuids_complete.uuid_cnt > 0)
;;;527        {
;;;528            err_code = uuid_list_encode(&p_advdata->uuids_complete,
;;;529                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
;;;530                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
;;;531                                        p_encoded_data,
;;;532                                        p_len,
;;;533                                        max_size);
;;;534            VERIFY_SUCCESS(err_code);
;;;535        }
;;;536    
;;;537        // Encode 'solicited service' uuid list.
;;;538        if (p_advdata->uuids_solicited.uuid_cnt > 0)
;;;539        {
;;;540            err_code = uuid_list_encode(&p_advdata->uuids_solicited,
;;;541                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
;;;542                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
;;;543                                        p_encoded_data,
;;;544                                        p_len,
;;;545                                        max_size);
;;;546            VERIFY_SUCCESS(err_code);
;;;547        }
;;;548    
;;;549        // Encode Slave Connection Interval Range.
;;;550        if (p_advdata->p_slave_conn_int != NULL)
;;;551        {
;;;552            err_code = conn_int_encode(p_advdata->p_slave_conn_int, p_encoded_data, p_len, max_size);
;;;553            VERIFY_SUCCESS(err_code);
;;;554        }
;;;555    
;;;556        // Encode Manufacturer Specific Data.
;;;557        if (p_advdata->p_manuf_specific_data != NULL)
;;;558        {
;;;559            err_code = manuf_specific_data_encode(p_advdata->p_manuf_specific_data,
;;;560                                                  p_encoded_data,
;;;561                                                  p_len,
;;;562                                                  max_size);
;;;563            VERIFY_SUCCESS(err_code);
;;;564        }
;;;565    
;;;566        // Encode Service Data.
;;;567        if (p_advdata->service_data_count > 0)
;;;568        {
;;;569            err_code = service_data_encode(p_advdata, p_encoded_data, p_len, max_size);
;;;570            VERIFY_SUCCESS(err_code);
;;;571        }
;;;572    
;;;573        // Encode name. WARNING: it is encoded last on purpose since too long device name is truncated.
;;;574        if (p_advdata->name_type != BLE_ADVDATA_NO_NAME)
;;;575        {
;;;576            err_code = name_encode(p_advdata, p_encoded_data, p_len, max_size);
;;;577            VERIFY_SUCCESS(err_code);
;;;578        }
;;;579    
;;;580        return err_code;
;;;581    }
00002a  e8bd81fc          POP      {r2-r8,pc}
                  |L1.46|
00002e  bf00              NOP                            ;486
                  |L1.48|
000030  78a0              LDRB     r0,[r4,#2]            ;490
000032  b150              CBZ      r0,|L1.74|
000034  463a              MOV      r2,r7                 ;492
000036  4631              MOV      r1,r6                 ;492
000038  4640              MOV      r0,r8                 ;492
00003a  f7fffffe          BL       appearance_encode
00003e  4605              MOV      r5,r0                 ;492
000040  bf00              NOP                            ;493
000042  b10d              CBZ      r5,|L1.72|
000044  4628              MOV      r0,r5                 ;493
000046  e7f0              B        |L1.42|
                  |L1.72|
000048  bf00              NOP                            ;493
                  |L1.74|
00004a  78e0              LDRB     r0,[r4,#3]            ;497
00004c  b160              CBZ      r0,|L1.104|
00004e  78e1              LDRB     r1,[r4,#3]            ;499
000050  b248              SXTB     r0,r1                 ;499
000052  463b              MOV      r3,r7                 ;499
000054  4632              MOV      r2,r6                 ;499
000056  4641              MOV      r1,r8                 ;499
000058  f7fffffe          BL       flags_encode
00005c  4605              MOV      r5,r0                 ;499
00005e  bf00              NOP                            ;500
000060  b10d              CBZ      r5,|L1.102|
000062  4628              MOV      r0,r5                 ;500
000064  e7e1              B        |L1.42|
                  |L1.102|
000066  bf00              NOP                            ;500
                  |L1.104|
000068  6860              LDR      r0,[r4,#4]            ;504
00006a  b168              CBZ      r0,|L1.136|
00006c  6861              LDR      r1,[r4,#4]            ;506
00006e  f9910000          LDRSB    r0,[r1,#0]            ;506
000072  463b              MOV      r3,r7                 ;506
000074  4632              MOV      r2,r6                 ;506
000076  4641              MOV      r1,r8                 ;506
000078  f7fffffe          BL       tx_power_level_encode
00007c  4605              MOV      r5,r0                 ;506
00007e  bf00              NOP                            ;510
000080  b10d              CBZ      r5,|L1.134|
000082  4628              MOV      r0,r5                 ;510
000084  e7d1              B        |L1.42|
                  |L1.134|
000086  bf00              NOP                            ;510
                  |L1.136|
000088  8920              LDRH     r0,[r4,#8]            ;514
00008a  2800              CMP      r0,#0                 ;514
00008c  dd0e              BLE      |L1.172|
00008e  4643              MOV      r3,r8                 ;516
000090  2206              MOVS     r2,#6                 ;516
000092  2102              MOVS     r1,#2                 ;516
000094  f1040008          ADD      r0,r4,#8              ;516
000098  e9cd6700          STRD     r6,r7,[sp,#0]         ;516
00009c  f7fffffe          BL       uuid_list_encode
0000a0  4605              MOV      r5,r0                 ;516
0000a2  bf00              NOP                            ;522
0000a4  b10d              CBZ      r5,|L1.170|
0000a6  4628              MOV      r0,r5                 ;522
0000a8  e7bf              B        |L1.42|
                  |L1.170|
0000aa  bf00              NOP                            ;522
                  |L1.172|
0000ac  8a20              LDRH     r0,[r4,#0x10]         ;526
0000ae  2800              CMP      r0,#0                 ;526
0000b0  dd0e              BLE      |L1.208|
0000b2  4643              MOV      r3,r8                 ;528
0000b4  2207              MOVS     r2,#7                 ;528
0000b6  2103              MOVS     r1,#3                 ;528
0000b8  f1040010          ADD      r0,r4,#0x10           ;528
0000bc  e9cd6700          STRD     r6,r7,[sp,#0]         ;528
0000c0  f7fffffe          BL       uuid_list_encode
0000c4  4605              MOV      r5,r0                 ;528
0000c6  bf00              NOP                            ;534
0000c8  b10d              CBZ      r5,|L1.206|
0000ca  4628              MOV      r0,r5                 ;534
0000cc  e7ad              B        |L1.42|
                  |L1.206|
0000ce  bf00              NOP                            ;534
                  |L1.208|
0000d0  8b20              LDRH     r0,[r4,#0x18]         ;538
0000d2  2800              CMP      r0,#0                 ;538
0000d4  dd0e              BLE      |L1.244|
0000d6  4643              MOV      r3,r8                 ;540
0000d8  2215              MOVS     r2,#0x15              ;540
0000da  2114              MOVS     r1,#0x14              ;540
0000dc  f1040018          ADD      r0,r4,#0x18           ;540
0000e0  e9cd6700          STRD     r6,r7,[sp,#0]         ;540
0000e4  f7fffffe          BL       uuid_list_encode
0000e8  4605              MOV      r5,r0                 ;540
0000ea  bf00              NOP                            ;546
0000ec  b10d              CBZ      r5,|L1.242|
0000ee  4628              MOV      r0,r5                 ;546
0000f0  e79b              B        |L1.42|
                  |L1.242|
0000f2  bf00              NOP                            ;546
                  |L1.244|
0000f4  6a20              LDR      r0,[r4,#0x20]         ;550
0000f6  b158              CBZ      r0,|L1.272|
0000f8  463b              MOV      r3,r7                 ;552
0000fa  4632              MOV      r2,r6                 ;552
0000fc  4641              MOV      r1,r8                 ;552
0000fe  6a20              LDR      r0,[r4,#0x20]         ;552
000100  f7fffffe          BL       conn_int_encode
000104  4605              MOV      r5,r0                 ;552
000106  bf00              NOP                            ;553
000108  b10d              CBZ      r5,|L1.270|
00010a  4628              MOV      r0,r5                 ;553
00010c  e78d              B        |L1.42|
                  |L1.270|
00010e  bf00              NOP                            ;553
                  |L1.272|
000110  6a60              LDR      r0,[r4,#0x24]         ;557
000112  b158              CBZ      r0,|L1.300|
000114  463b              MOV      r3,r7                 ;559
000116  4632              MOV      r2,r6                 ;559
000118  4641              MOV      r1,r8                 ;559
00011a  6a60              LDR      r0,[r4,#0x24]         ;559
00011c  f7fffffe          BL       manuf_specific_data_encode
000120  4605              MOV      r5,r0                 ;559
000122  bf00              NOP                            ;563
000124  b10d              CBZ      r5,|L1.298|
000126  4628              MOV      r0,r5                 ;563
000128  e77f              B        |L1.42|
                  |L1.298|
00012a  bf00              NOP                            ;563
                  |L1.300|
00012c  f894002c          LDRB     r0,[r4,#0x2c]         ;567
000130  2800              CMP      r0,#0                 ;567
000132  dd0b              BLE      |L1.332|
000134  463b              MOV      r3,r7                 ;569
000136  4632              MOV      r2,r6                 ;569
000138  4641              MOV      r1,r8                 ;569
00013a  4620              MOV      r0,r4                 ;569
00013c  f7fffffe          BL       service_data_encode
000140  4605              MOV      r5,r0                 ;569
000142  bf00              NOP                            ;570
000144  b10d              CBZ      r5,|L1.330|
000146  4628              MOV      r0,r5                 ;570
000148  e76f              B        |L1.42|
                  |L1.330|
00014a  bf00              NOP                            ;570
                  |L1.332|
00014c  7820              LDRB     r0,[r4,#0]            ;574
00014e  b158              CBZ      r0,|L1.360|
000150  463b              MOV      r3,r7                 ;576
000152  4632              MOV      r2,r6                 ;576
000154  4641              MOV      r1,r8                 ;576
000156  4620              MOV      r0,r4                 ;576
000158  f7fffffe          BL       name_encode
00015c  4605              MOV      r5,r0                 ;576
00015e  bf00              NOP                            ;577
000160  b10d              CBZ      r5,|L1.358|
000162  4628              MOV      r0,r5                 ;577
000164  e761              B        |L1.42|
                  |L1.358|
000166  bf00              NOP                            ;577
                  |L1.360|
000168  4628              MOV      r0,r5                 ;580
00016a  e75e              B        |L1.42|
;;;582    
                          ENDP


                          AREA ||i.advdata_check||, CODE, READONLY, ALIGN=1

                  advdata_check PROC
;;;583    
;;;584    static uint32_t advdata_check(const ble_advdata_t * p_advdata)
000000  4601              MOV      r1,r0
;;;585    {
;;;586        // Flags must be included in advertising data, and the BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED flag must be set.
;;;587        if (
000002  78c8              LDRB     r0,[r1,#3]
000004  f0000004          AND      r0,r0,#4
000008  b908              CBNZ     r0,|L2.14|
;;;588            ((p_advdata->flags & BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED) == 0)
;;;589           )
;;;590        {
;;;591            return NRF_ERROR_INVALID_PARAM;
00000a  2007              MOVS     r0,#7
                  |L2.12|
;;;592        }
;;;593    
;;;594        return NRF_SUCCESS;
;;;595    }
00000c  4770              BX       lr
                  |L2.14|
00000e  2000              MOVS     r0,#0                 ;594
000010  e7fc              B        |L2.12|
;;;596    
                          ENDP


                          AREA ||i.appearance_encode||, CODE, READONLY, ALIGN=1

                  appearance_encode PROC
;;;141    
;;;142    static uint32_t appearance_encode(uint8_t  * p_encoded_data,
000000  b5f8              PUSH     {r3-r7,lr}
;;;143                                      uint16_t * p_offset,
;;;144                                      uint16_t   max_size)
;;;145    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
;;;146        uint32_t err_code;
;;;147        uint16_t appearance;
;;;148    
;;;149        // Check for buffer overflow.
;;;150        if (((*p_offset) + AD_TYPE_APPEARANCE_SIZE) > max_size)
000008  8820              LDRH     r0,[r4,#0]
00000a  1d00              ADDS     r0,r0,#4
00000c  42b8              CMP      r0,r7
00000e  d901              BLS      |L3.20|
;;;151        {
;;;152            return NRF_ERROR_DATA_SIZE;
000010  200c              MOVS     r0,#0xc
                  |L3.18|
;;;153        }
;;;154    
;;;155        // Get GAP appearance field.
;;;156        err_code = sd_ble_gap_appearance_get(&appearance);
;;;157        VERIFY_SUCCESS(err_code);
;;;158    
;;;159        // Encode Length, AD Type and Appearance.
;;;160        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + AD_TYPE_APPEARANCE_DATA_SIZE);
;;;161        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;162        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_APPEARANCE;
;;;163        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;164        *p_offset                 += uint16_encode(appearance, &p_encoded_data[*p_offset]);
;;;165    
;;;166        return NRF_SUCCESS;
;;;167    }
000012  bdf8              POP      {r3-r7,pc}
                  |L3.20|
000014  4668              MOV      r0,sp                 ;156
000016  df79              SVC      #0x79                 ;156
000018  4606              MOV      r6,r0                 ;156
00001a  bf00              NOP                            ;157
00001c  b10e              CBZ      r6,|L3.34|
00001e  4630              MOV      r0,r6                 ;157
000020  e7f7              B        |L3.18|
                  |L3.34|
000022  bf00              NOP                            ;157
000024  2003              MOVS     r0,#3                 ;160
000026  8821              LDRH     r1,[r4,#0]            ;160
000028  5468              STRB     r0,[r5,r1]            ;160
00002a  8820              LDRH     r0,[r4,#0]            ;161
00002c  1c40              ADDS     r0,r0,#1              ;161
00002e  8020              STRH     r0,[r4,#0]            ;161
000030  2019              MOVS     r0,#0x19              ;162
000032  8821              LDRH     r1,[r4,#0]            ;162
000034  5468              STRB     r0,[r5,r1]            ;162
000036  8820              LDRH     r0,[r4,#0]            ;163
000038  1c40              ADDS     r0,r0,#1              ;163
00003a  8020              STRH     r0,[r4,#0]            ;163
00003c  8820              LDRH     r0,[r4,#0]            ;164
00003e  1941              ADDS     r1,r0,r5              ;164
000040  f8bd0000          LDRH     r0,[sp,#0]            ;164
000044  f7fffffe          BL       uint16_encode
000048  8821              LDRH     r1,[r4,#0]            ;164
00004a  4408              ADD      r0,r0,r1              ;164
00004c  8020              STRH     r0,[r4,#0]            ;164
00004e  2000              MOVS     r0,#0                 ;166
000050  e7df              B        |L3.18|
;;;168    
                          ENDP


                          AREA ||i.ble_advdata_set||, CODE, READONLY, ALIGN=1

                  ble_advdata_set PROC
;;;609    
;;;610    uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;611    {
000004  b092              SUB      sp,sp,#0x48
000006  4680              MOV      r8,r0
000008  460d              MOV      r5,r1
;;;612        uint32_t  err_code;
;;;613        uint16_t  len_advdata = BLE_GAP_ADV_MAX_SIZE;
00000a  201f              MOVS     r0,#0x1f
00000c  9011              STR      r0,[sp,#0x44]
;;;614        uint16_t  len_srdata  = BLE_GAP_ADV_MAX_SIZE;
00000e  9010              STR      r0,[sp,#0x40]
;;;615        uint8_t   encoded_advdata[BLE_GAP_ADV_MAX_SIZE];
;;;616        uint8_t   encoded_srdata[BLE_GAP_ADV_MAX_SIZE];
;;;617        uint8_t * p_encoded_advdata;
;;;618        uint8_t * p_encoded_srdata;
;;;619    
;;;620        // Encode advertising data (if supplied).
;;;621        if (p_advdata != NULL)
000010  f1b80f00          CMP      r8,#0
000014  d017              BEQ      |L4.70|
;;;622        {
;;;623            err_code = advdata_check(p_advdata);
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       advdata_check
00001c  4604              MOV      r4,r0
;;;624            VERIFY_SUCCESS(err_code);
00001e  bf00              NOP      
000020  b11c              CBZ      r4,|L4.42|
000022  4620              MOV      r0,r4
                  |L4.36|
;;;625    
;;;626            err_code = adv_data_encode(p_advdata, encoded_advdata, &len_advdata);
;;;627            VERIFY_SUCCESS(err_code);
;;;628            p_encoded_advdata = encoded_advdata;
;;;629        }
;;;630        else
;;;631        {
;;;632            p_encoded_advdata = NULL;
;;;633            len_advdata = 0;
;;;634        }
;;;635    
;;;636        // Encode scan response data (if supplied).
;;;637        if (p_srdata != NULL)
;;;638        {
;;;639            err_code = srdata_check(p_srdata);
;;;640            VERIFY_SUCCESS(err_code);
;;;641    
;;;642            err_code = adv_data_encode(p_srdata, encoded_srdata, &len_srdata);
;;;643            VERIFY_SUCCESS(err_code);
;;;644            p_encoded_srdata = encoded_srdata;
;;;645        }
;;;646        else
;;;647        {
;;;648            p_encoded_srdata = NULL;
;;;649            len_srdata = 0;
;;;650        }
;;;651    
;;;652        // Pass encoded advertising data and/or scan response data to the stack.
;;;653        return sd_ble_gap_adv_data_set(p_encoded_advdata, len_advdata, p_encoded_srdata, len_srdata);
;;;654    }
000024  b012              ADD      sp,sp,#0x48
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L4.42|
00002a  bf00              NOP                            ;624
00002c  aa11              ADD      r2,sp,#0x44           ;626
00002e  a908              ADD      r1,sp,#0x20           ;626
000030  4640              MOV      r0,r8                 ;626
000032  f7fffffe          BL       adv_data_encode
000036  4604              MOV      r4,r0                 ;626
000038  bf00              NOP                            ;627
00003a  b10c              CBZ      r4,|L4.64|
00003c  4620              MOV      r0,r4                 ;627
00003e  e7f1              B        |L4.36|
                  |L4.64|
000040  bf00              NOP                            ;627
000042  ae08              ADD      r6,sp,#0x20           ;628
000044  e002              B        |L4.76|
                  |L4.70|
000046  2600              MOVS     r6,#0                 ;632
000048  2000              MOVS     r0,#0                 ;633
00004a  9011              STR      r0,[sp,#0x44]         ;633
                  |L4.76|
00004c  b1ad              CBZ      r5,|L4.122|
00004e  4628              MOV      r0,r5                 ;639
000050  f7fffffe          BL       srdata_check
000054  4604              MOV      r4,r0                 ;639
000056  bf00              NOP                            ;640
000058  b10c              CBZ      r4,|L4.94|
00005a  4620              MOV      r0,r4                 ;640
00005c  e7e2              B        |L4.36|
                  |L4.94|
00005e  bf00              NOP                            ;640
000060  aa10              ADD      r2,sp,#0x40           ;642
000062  4669              MOV      r1,sp                 ;642
000064  4628              MOV      r0,r5                 ;642
000066  f7fffffe          BL       adv_data_encode
00006a  4604              MOV      r4,r0                 ;642
00006c  bf00              NOP                            ;643
00006e  b10c              CBZ      r4,|L4.116|
000070  4620              MOV      r0,r4                 ;643
000072  e7d7              B        |L4.36|
                  |L4.116|
000074  bf00              NOP                            ;643
000076  466f              MOV      r7,sp                 ;644
000078  e002              B        |L4.128|
                  |L4.122|
00007a  2700              MOVS     r7,#0                 ;648
00007c  2000              MOVS     r0,#0                 ;649
00007e  9010              STR      r0,[sp,#0x40]         ;649
                  |L4.128|
000080  f8bd0040          LDRH     r0,[sp,#0x40]         ;653
000084  b2c3              UXTB     r3,r0                 ;653
000086  f8bd0044          LDRH     r0,[sp,#0x44]         ;653
00008a  b2c1              UXTB     r1,r0                 ;653
00008c  463a              MOV      r2,r7                 ;653
00008e  4630              MOV      r0,r6                 ;653
000090  df72              SVC      #0x72                 ;653
000092  e7c7              B        |L4.36|
                          ENDP


                          AREA ||i.ble_device_addr_encode||, CODE, READONLY, ALIGN=1

                  ble_device_addr_encode PROC
;;;23     
;;;24     static uint32_t ble_device_addr_encode(uint8_t  * p_encoded_data,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;25                                            uint16_t * p_offset,
;;;26                                            uint16_t   max_size)
;;;27     {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;28         uint32_t err_code;
;;;29         ble_gap_addr_t device_addr;
;;;30     
;;;31         // Check for buffer overflow.
;;;32         if (((*p_offset) + AD_TYPE_BLE_DEVICE_ADDR_SIZE) > max_size)
00000a  8820              LDRH     r0,[r4,#0]
00000c  3009              ADDS     r0,r0,#9
00000e  42b8              CMP      r0,r7
000010  d902              BLS      |L5.24|
;;;33         {
;;;34             return NRF_ERROR_DATA_SIZE;
000012  200c              MOVS     r0,#0xc
                  |L5.20|
;;;35         }
;;;36     
;;;37         // Get BLE address.
;;;38         #if (NRF_SD_BLE_API_VERSION == 3)
;;;39             err_code = sd_ble_gap_addr_get(&device_addr);
;;;40         #else
;;;41             err_code = sd_ble_gap_address_get(&device_addr);
;;;42         #endif
;;;43         VERIFY_SUCCESS(err_code);
;;;44     
;;;45         // Encode LE Bluetooth Device Address.
;;;46         p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE +
;;;47                                                    AD_TYPE_BLE_DEVICE_ADDR_DATA_SIZE);
;;;48         *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;49         p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS;
;;;50         *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;51         memcpy(&p_encoded_data[*p_offset], &device_addr.addr[0], BLE_GAP_ADDR_LEN);
;;;52         *p_offset                 += BLE_GAP_ADDR_LEN;
;;;53         if (BLE_GAP_ADDR_TYPE_PUBLIC == device_addr.addr_type)
;;;54         {
;;;55             p_encoded_data[*p_offset] = AD_TYPE_BLE_DEVICE_ADDR_TYPE_PUBLIC;
;;;56         }
;;;57         else
;;;58         {
;;;59             p_encoded_data[*p_offset] = AD_TYPE_BLE_DEVICE_ADDR_TYPE_RANDOM;
;;;60         }
;;;61         *p_offset += AD_TYPE_BLE_DEVICE_ADDR_TYPE_SIZE;
;;;62     
;;;63         return NRF_SUCCESS;
;;;64     }
000014  e8bd81fc          POP      {r2-r8,pc}
                  |L5.24|
000018  4668              MOV      r0,sp                 ;39
00001a  df6d              SVC      #0x6d                 ;39
00001c  4606              MOV      r6,r0                 ;39
00001e  bf00              NOP                            ;43
000020  b10e              CBZ      r6,|L5.38|
000022  4630              MOV      r0,r6                 ;43
000024  e7f6              B        |L5.20|
                  |L5.38|
000026  bf00              NOP                            ;43
000028  2008              MOVS     r0,#8                 ;46
00002a  8821              LDRH     r1,[r4,#0]            ;46
00002c  5468              STRB     r0,[r5,r1]            ;46
00002e  8820              LDRH     r0,[r4,#0]            ;48
000030  1c40              ADDS     r0,r0,#1              ;48
000032  8020              STRH     r0,[r4,#0]            ;48
000034  201b              MOVS     r0,#0x1b              ;49
000036  8821              LDRH     r1,[r4,#0]            ;49
000038  5468              STRB     r0,[r5,r1]            ;49
00003a  8820              LDRH     r0,[r4,#0]            ;50
00003c  1c40              ADDS     r0,r0,#1              ;50
00003e  8020              STRH     r0,[r4,#0]            ;50
000040  8820              LDRH     r0,[r4,#0]            ;51
000042  4428              ADD      r0,r0,r5              ;51
000044  f8dd1001          LDR      r1,[sp,#1]            ;51
000048  6001              STR      r1,[r0,#0]            ;51
00004a  f8bd1005          LDRH     r1,[sp,#5]            ;51
00004e  8081              STRH     r1,[r0,#4]            ;51
000050  8820              LDRH     r0,[r4,#0]            ;52
000052  1d80              ADDS     r0,r0,#6              ;52
000054  8020              STRH     r0,[r4,#0]            ;52
000056  f89d0000          LDRB     r0,[sp,#0]            ;53
00005a  0840              LSRS     r0,r0,#1              ;53
00005c  b918              CBNZ     r0,|L5.102|
00005e  2000              MOVS     r0,#0                 ;55
000060  8821              LDRH     r1,[r4,#0]            ;55
000062  5468              STRB     r0,[r5,r1]            ;55
000064  e002              B        |L5.108|
                  |L5.102|
000066  2001              MOVS     r0,#1                 ;59
000068  8821              LDRH     r1,[r4,#0]            ;59
00006a  5468              STRB     r0,[r5,r1]            ;59
                  |L5.108|
00006c  8820              LDRH     r0,[r4,#0]            ;61
00006e  1c40              ADDS     r0,r0,#1              ;61
000070  8020              STRH     r0,[r4,#0]            ;61
000072  2000              MOVS     r0,#0                 ;63
000074  e7ce              B        |L5.20|
;;;65     
                          ENDP


                          AREA ||i.conn_int_check||, CODE, READONLY, ALIGN=1

                  conn_int_check PROC
;;;310    
;;;311    static uint32_t conn_int_check(const ble_advdata_conn_int_t *p_conn_int)
000000  4601              MOV      r1,r0
;;;312    {
;;;313        // Check Minimum Connection Interval.
;;;314        if ((p_conn_int->min_conn_interval < 0x0006) ||
000002  8808              LDRH     r0,[r1,#0]
000004  2806              CMP      r0,#6
000006  db08              BLT      |L6.26|
;;;315            (
;;;316                (p_conn_int->min_conn_interval > 0x0c80) &&
000008  8808              LDRH     r0,[r1,#0]
00000a  f5b06f48          CMP      r0,#0xc80
00000e  dd06              BLE      |L6.30|
;;;317                (p_conn_int->min_conn_interval != 0xffff)
000010  8808              LDRH     r0,[r1,#0]
000012  f64f72ff          MOV      r2,#0xffff
000016  4290              CMP      r0,r2
000018  d001              BEQ      |L6.30|
                  |L6.26|
;;;318            )
;;;319           )
;;;320        {
;;;321            return NRF_ERROR_INVALID_PARAM;
00001a  2007              MOVS     r0,#7
                  |L6.28|
;;;322        }
;;;323    
;;;324        // Check Maximum Connection Interval.
;;;325        if ((p_conn_int->max_conn_interval < 0x0006) ||
;;;326            (
;;;327                (p_conn_int->max_conn_interval > 0x0c80) &&
;;;328                (p_conn_int->max_conn_interval != 0xffff)
;;;329            )
;;;330           )
;;;331        {
;;;332            return NRF_ERROR_INVALID_PARAM;
;;;333        }
;;;334    
;;;335        // Make sure Minimum Connection Interval is not bigger than Maximum Connection Interval.
;;;336        if ((p_conn_int->min_conn_interval != 0xffff) &&
;;;337            (p_conn_int->max_conn_interval != 0xffff) &&
;;;338            (p_conn_int->min_conn_interval > p_conn_int->max_conn_interval)
;;;339            )
;;;340        {
;;;341            return NRF_ERROR_INVALID_PARAM;
;;;342        }
;;;343    
;;;344        return NRF_SUCCESS;
;;;345    }
00001c  4770              BX       lr
                  |L6.30|
00001e  8848              LDRH     r0,[r1,#2]            ;325
000020  2806              CMP      r0,#6                 ;325
000022  db08              BLT      |L6.54|
000024  8848              LDRH     r0,[r1,#2]            ;327
000026  f5b06f48          CMP      r0,#0xc80             ;327
00002a  dd06              BLE      |L6.58|
00002c  8848              LDRH     r0,[r1,#2]            ;328
00002e  f64f72ff          MOV      r2,#0xffff            ;328
000032  4290              CMP      r0,r2                 ;328
000034  d001              BEQ      |L6.58|
                  |L6.54|
000036  2007              MOVS     r0,#7                 ;332
000038  e7f0              B        |L6.28|
                  |L6.58|
00003a  8808              LDRH     r0,[r1,#0]            ;336
00003c  f64f72ff          MOV      r2,#0xffff            ;336
000040  4290              CMP      r0,r2                 ;336
000042  d008              BEQ      |L6.86|
000044  8848              LDRH     r0,[r1,#2]            ;337
000046  4290              CMP      r0,r2                 ;337
000048  d005              BEQ      |L6.86|
00004a  8808              LDRH     r0,[r1,#0]            ;338
00004c  884a              LDRH     r2,[r1,#2]            ;338
00004e  4290              CMP      r0,r2                 ;338
000050  dd01              BLE      |L6.86|
000052  2007              MOVS     r0,#7                 ;341
000054  e7e2              B        |L6.28|
                  |L6.86|
000056  2000              MOVS     r0,#0                 ;344
000058  e7e0              B        |L6.28|
;;;346    
                          ENDP


                          AREA ||i.conn_int_encode||, CODE, READONLY, ALIGN=1

                  conn_int_encode PROC
;;;347    
;;;348    static uint32_t conn_int_encode(const ble_advdata_conn_int_t * p_conn_int,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;349                                    uint8_t                      * p_encoded_data,
;;;350                                    uint16_t                     * p_offset,
;;;351                                    uint16_t                       max_size)
;;;352    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
;;;353        uint32_t err_code;
;;;354    
;;;355        // Check for buffer overflow.
;;;356        if (((*p_offset) + AD_TYPE_CONN_INT_SIZE) > max_size)
00000c  8820              LDRH     r0,[r4,#0]
00000e  1d80              ADDS     r0,r0,#6
000010  4540              CMP      r0,r8
000012  d902              BLS      |L7.26|
;;;357        {
;;;358            return NRF_ERROR_DATA_SIZE;
000014  200c              MOVS     r0,#0xc
                  |L7.22|
;;;359        }
;;;360    
;;;361        // Check parameters.
;;;362        err_code = conn_int_check(p_conn_int);
;;;363        VERIFY_SUCCESS(err_code);
;;;364    
;;;365        // Encode Length and AD Type.
;;;366        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + AD_TYPE_CONN_INT_DATA_SIZE);
;;;367        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;368        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE;
;;;369        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;370    
;;;371        // Encode Minimum and Maximum Connection Intervals.
;;;372        *p_offset += uint16_encode(p_conn_int->min_conn_interval, &p_encoded_data[*p_offset]);
;;;373        *p_offset += uint16_encode(p_conn_int->max_conn_interval, &p_encoded_data[*p_offset]);
;;;374    
;;;375        return NRF_SUCCESS;
;;;376    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L7.26|
00001a  4630              MOV      r0,r6                 ;362
00001c  f7fffffe          BL       conn_int_check
000020  4607              MOV      r7,r0                 ;362
000022  bf00              NOP                            ;363
000024  b10f              CBZ      r7,|L7.42|
000026  4638              MOV      r0,r7                 ;363
000028  e7f5              B        |L7.22|
                  |L7.42|
00002a  bf00              NOP                            ;363
00002c  2005              MOVS     r0,#5                 ;366
00002e  8821              LDRH     r1,[r4,#0]            ;366
000030  5468              STRB     r0,[r5,r1]            ;366
000032  8820              LDRH     r0,[r4,#0]            ;367
000034  1c40              ADDS     r0,r0,#1              ;367
000036  8020              STRH     r0,[r4,#0]            ;367
000038  2012              MOVS     r0,#0x12              ;368
00003a  8821              LDRH     r1,[r4,#0]            ;368
00003c  5468              STRB     r0,[r5,r1]            ;368
00003e  8820              LDRH     r0,[r4,#0]            ;369
000040  1c40              ADDS     r0,r0,#1              ;369
000042  8020              STRH     r0,[r4,#0]            ;369
000044  8822              LDRH     r2,[r4,#0]            ;372
000046  1951              ADDS     r1,r2,r5              ;372
000048  8830              LDRH     r0,[r6,#0]            ;372
00004a  f7fffffe          BL       uint16_encode
00004e  8821              LDRH     r1,[r4,#0]            ;372
000050  4408              ADD      r0,r0,r1              ;372
000052  8020              STRH     r0,[r4,#0]            ;372
000054  8822              LDRH     r2,[r4,#0]            ;373
000056  1951              ADDS     r1,r2,r5              ;373
000058  8870              LDRH     r0,[r6,#2]            ;373
00005a  f7fffffe          BL       uint16_encode
00005e  8821              LDRH     r1,[r4,#0]            ;373
000060  4408              ADD      r0,r0,r1              ;373
000062  8020              STRH     r0,[r4,#0]            ;373
000064  2000              MOVS     r0,#0                 ;375
000066  e7d6              B        |L7.22|
;;;377    
                          ENDP


                          AREA ||i.flags_encode||, CODE, READONLY, ALIGN=1

                  flags_encode PROC
;;;168    
;;;169    static uint32_t flags_encode(int8_t     flags,
000000  b530              PUSH     {r4,r5,lr}
;;;170                                 uint8_t  * p_encoded_data,
;;;171                                 uint16_t * p_offset,
;;;172                                 uint16_t   max_size)
;;;173    {
000002  4604              MOV      r4,r0
;;;174        // Check for buffer overflow.
;;;175        if (((*p_offset) + AD_TYPE_FLAGS_SIZE) > max_size)
000004  8810              LDRH     r0,[r2,#0]
000006  1cc0              ADDS     r0,r0,#3
000008  4298              CMP      r0,r3
00000a  d901              BLS      |L8.16|
;;;176        {
;;;177            return NRF_ERROR_DATA_SIZE;
00000c  200c              MOVS     r0,#0xc
                  |L8.14|
;;;178        }
;;;179    
;;;180        // Encode flags.
;;;181        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + AD_TYPE_FLAGS_DATA_SIZE);
;;;182        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;183        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_FLAGS;
;;;184        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;185        p_encoded_data[*p_offset]  = flags;
;;;186        *p_offset                 += AD_TYPE_FLAGS_DATA_SIZE;
;;;187    
;;;188        return NRF_SUCCESS;
;;;189    }
00000e  bd30              POP      {r4,r5,pc}
                  |L8.16|
000010  2002              MOVS     r0,#2                 ;181
000012  8815              LDRH     r5,[r2,#0]            ;181
000014  5548              STRB     r0,[r1,r5]            ;181
000016  8810              LDRH     r0,[r2,#0]            ;182
000018  1c40              ADDS     r0,r0,#1              ;182
00001a  8010              STRH     r0,[r2,#0]            ;182
00001c  2001              MOVS     r0,#1                 ;183
00001e  8815              LDRH     r5,[r2,#0]            ;183
000020  5548              STRB     r0,[r1,r5]            ;183
000022  8810              LDRH     r0,[r2,#0]            ;184
000024  1c40              ADDS     r0,r0,#1              ;184
000026  8010              STRH     r0,[r2,#0]            ;184
000028  8815              LDRH     r5,[r2,#0]            ;185
00002a  554c              STRB     r4,[r1,r5]            ;185
00002c  8810              LDRH     r0,[r2,#0]            ;186
00002e  1c40              ADDS     r0,r0,#1              ;186
000030  8010              STRH     r0,[r2,#0]            ;186
000032  2000              MOVS     r0,#0                 ;188
000034  e7eb              B        |L8.14|
;;;190    
                          ENDP


                          AREA ||i.manuf_specific_data_encode||, CODE, READONLY, ALIGN=1

                  manuf_specific_data_encode PROC
;;;378    
;;;379    static uint32_t manuf_specific_data_encode(const ble_advdata_manuf_data_t * p_manuf_sp_data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;380                                               uint8_t                        * p_encoded_data,
;;;381                                               uint16_t                       * p_offset,
;;;382                                               uint16_t                         max_size)
;;;383    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
;;;384        uint32_t data_size = AD_TYPE_MANUF_SPEC_DATA_ID_SIZE + p_manuf_sp_data->data.size;
00000c  88a8              LDRH     r0,[r5,#4]
00000e  1c87              ADDS     r7,r0,#2
;;;385    
;;;386        // Check for buffer overflow.
;;;387        if (((*p_offset) + ADV_AD_DATA_OFFSET + data_size) > max_size)
000010  8820              LDRH     r0,[r4,#0]
000012  1c80              ADDS     r0,r0,#2
000014  4438              ADD      r0,r0,r7
000016  4540              CMP      r0,r8
000018  d902              BLS      |L9.32|
;;;388        {
;;;389            return NRF_ERROR_DATA_SIZE;
00001a  200c              MOVS     r0,#0xc
                  |L9.28|
;;;390        }
;;;391    
;;;392        // There is only 1 byte intended to encode length which is (data_size + ADV_AD_TYPE_FIELD_SIZE)
;;;393        if (data_size > (0x00FF - ADV_AD_TYPE_FIELD_SIZE))
;;;394        {
;;;395            return NRF_ERROR_DATA_SIZE;
;;;396        }
;;;397    
;;;398        // Encode Length and AD Type.
;;;399        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + data_size);
;;;400        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;401        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
;;;402        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;403    
;;;404        // Encode Company Identifier.
;;;405        *p_offset += uint16_encode(p_manuf_sp_data->company_identifier, &p_encoded_data[*p_offset]);
;;;406    
;;;407        // Encode additional manufacturer specific data.
;;;408        if (p_manuf_sp_data->data.size > 0)
;;;409        {
;;;410            if (p_manuf_sp_data->data.p_data == NULL)
;;;411            {
;;;412                return NRF_ERROR_INVALID_PARAM;
;;;413            }
;;;414            memcpy(&p_encoded_data[*p_offset], p_manuf_sp_data->data.p_data, p_manuf_sp_data->data.size);
;;;415            *p_offset += p_manuf_sp_data->data.size;
;;;416        }
;;;417    
;;;418        return NRF_SUCCESS;
;;;419    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L9.32|
000020  2ffe              CMP      r7,#0xfe              ;393
000022  d901              BLS      |L9.40|
000024  200c              MOVS     r0,#0xc               ;395
000026  e7f9              B        |L9.28|
                  |L9.40|
000028  1c78              ADDS     r0,r7,#1              ;399
00002a  8821              LDRH     r1,[r4,#0]            ;399
00002c  5470              STRB     r0,[r6,r1]            ;399
00002e  8820              LDRH     r0,[r4,#0]            ;400
000030  1c40              ADDS     r0,r0,#1              ;400
000032  8020              STRH     r0,[r4,#0]            ;400
000034  20ff              MOVS     r0,#0xff              ;401
000036  8821              LDRH     r1,[r4,#0]            ;401
000038  5470              STRB     r0,[r6,r1]            ;401
00003a  8820              LDRH     r0,[r4,#0]            ;402
00003c  1c40              ADDS     r0,r0,#1              ;402
00003e  8020              STRH     r0,[r4,#0]            ;402
000040  8822              LDRH     r2,[r4,#0]            ;405
000042  1991              ADDS     r1,r2,r6              ;405
000044  8828              LDRH     r0,[r5,#0]            ;405
000046  f7fffffe          BL       uint16_encode
00004a  8821              LDRH     r1,[r4,#0]            ;405
00004c  4408              ADD      r0,r0,r1              ;405
00004e  8020              STRH     r0,[r4,#0]            ;405
000050  88a8              LDRH     r0,[r5,#4]            ;408
000052  2800              CMP      r0,#0                 ;408
000054  dd0d              BLE      |L9.114|
000056  68a8              LDR      r0,[r5,#8]            ;410
000058  b908              CBNZ     r0,|L9.94|
00005a  2007              MOVS     r0,#7                 ;412
00005c  e7de              B        |L9.28|
                  |L9.94|
00005e  88aa              LDRH     r2,[r5,#4]            ;414
000060  8823              LDRH     r3,[r4,#0]            ;414
000062  1998              ADDS     r0,r3,r6              ;414
000064  68a9              LDR      r1,[r5,#8]            ;414
000066  f7fffffe          BL       __aeabi_memcpy
00006a  8820              LDRH     r0,[r4,#0]            ;415
00006c  88a9              LDRH     r1,[r5,#4]            ;415
00006e  4408              ADD      r0,r0,r1              ;415
000070  8020              STRH     r0,[r4,#0]            ;415
                  |L9.114|
000072  2000              MOVS     r0,#0                 ;418
000074  e7d2              B        |L9.28|
;;;420    
                          ENDP


                          AREA ||i.name_encode||, CODE, READONLY, ALIGN=1

                  name_encode PROC
;;;65     
;;;66     static uint32_t name_encode(const ble_advdata_t * p_advdata,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;67                                 uint8_t             * p_encoded_data,
;;;68                                 uint16_t            * p_offset,
;;;69                                 uint16_t              max_size)
;;;70     {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
;;;71         uint32_t err_code;
;;;72         uint16_t rem_adv_data_len;
;;;73         uint16_t actual_length;
;;;74         uint8_t  adv_data_format;
;;;75     
;;;76     
;;;77         // Validate parameters
;;;78         if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) && (0 == p_advdata->short_name_len))
00000c  7828              LDRB     r0,[r5,#0]
00000e  2801              CMP      r0,#1
000010  d104              BNE      |L10.28|
000012  7868              LDRB     r0,[r5,#1]
000014  b910              CBNZ     r0,|L10.28|
;;;79         {
;;;80             return NRF_ERROR_INVALID_PARAM;
000016  2007              MOVS     r0,#7
                  |L10.24|
;;;81         }
;;;82     
;;;83         // Check for buffer overflow.
;;;84         if ( (((*p_offset) + ADV_AD_DATA_OFFSET) > max_size) ||
;;;85              ( (BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
;;;86                (((*p_offset) + ADV_AD_DATA_OFFSET + p_advdata->short_name_len) > max_size)))
;;;87         {
;;;88             return NRF_ERROR_DATA_SIZE;
;;;89         }
;;;90     
;;;91         rem_adv_data_len = max_size - (*p_offset) - ADV_AD_DATA_OFFSET;
;;;92         actual_length    = rem_adv_data_len;
;;;93     
;;;94         // Get GAP device name and length
;;;95         err_code = sd_ble_gap_device_name_get(&p_encoded_data[(*p_offset) + ADV_AD_DATA_OFFSET],
;;;96                                               &actual_length);
;;;97         VERIFY_SUCCESS(err_code);
;;;98     
;;;99         // Check if device intend to use short name and it can fit available data size.
;;;100        if ((p_advdata->name_type == BLE_ADVDATA_FULL_NAME) && (actual_length <= rem_adv_data_len))
;;;101        {
;;;102            // Complete device name can fit, setting Complete Name in Adv Data.
;;;103            adv_data_format = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
;;;104        }
;;;105        else
;;;106        {
;;;107            // Else short name needs to be used. Or application has requested use of short name.
;;;108            adv_data_format = BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME;
;;;109    
;;;110            // If application has set a preference on the short name size, it needs to be considered,
;;;111            // else fit what can be fit.
;;;112            if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
;;;113                    (p_advdata->short_name_len <= rem_adv_data_len))
;;;114            {
;;;115                // Short name fits available size.
;;;116                actual_length = p_advdata->short_name_len;
;;;117            }
;;;118            // Else whatever can fit the data buffer will be packed.
;;;119            else
;;;120            {
;;;121                actual_length = rem_adv_data_len;
;;;122            }
;;;123        }
;;;124    
;;;125        // There is only 1 byte intended to encode length which is (actual_length + ADV_AD_TYPE_FIELD_SIZE)
;;;126        if (actual_length > (0x00FF - ADV_AD_TYPE_FIELD_SIZE))
;;;127        {
;;;128            return NRF_ERROR_DATA_SIZE;
;;;129        }
;;;130    
;;;131        // Complete name field in encoded data.
;;;132        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + actual_length);
;;;133        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;134        p_encoded_data[*p_offset]  = adv_data_format;
;;;135        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;136        *p_offset                 += actual_length;
;;;137    
;;;138        return NRF_SUCCESS;
;;;139    }
000018  e8bd8ff8          POP      {r3-r11,pc}
                  |L10.28|
00001c  8820              LDRH     r0,[r4,#0]            ;84
00001e  1c80              ADDS     r0,r0,#2              ;84
000020  4540              CMP      r0,r8                 ;84
000022  d808              BHI      |L10.54|
000024  7828              LDRB     r0,[r5,#0]            ;85
000026  2801              CMP      r0,#1                 ;85
000028  d107              BNE      |L10.58|
00002a  8820              LDRH     r0,[r4,#0]            ;86
00002c  1c80              ADDS     r0,r0,#2              ;86
00002e  7869              LDRB     r1,[r5,#1]            ;86
000030  4408              ADD      r0,r0,r1              ;86
000032  4540              CMP      r0,r8                 ;86
000034  d901              BLS      |L10.58|
                  |L10.54|
000036  200c              MOVS     r0,#0xc               ;88
000038  e7ee              B        |L10.24|
                  |L10.58|
00003a  8820              LDRH     r0,[r4,#0]            ;91
00003c  eba80000          SUB      r0,r8,r0              ;91
000040  1e80              SUBS     r0,r0,#2              ;91
000042  b286              UXTH     r6,r0                 ;91
000044  9600              STR      r6,[sp,#0]            ;92
000046  8821              LDRH     r1,[r4,#0]            ;95
000048  1c89              ADDS     r1,r1,#2              ;95
00004a  19c8              ADDS     r0,r1,r7              ;95
00004c  4669              MOV      r1,sp                 ;95
00004e  df7d              SVC      #0x7d                 ;95
000050  4681              MOV      r9,r0                 ;95
000052  bf00              NOP                            ;97
000054  f1b90f00          CMP      r9,#0                 ;97
000058  d001              BEQ      |L10.94|
00005a  4648              MOV      r0,r9                 ;97
00005c  e7dc              B        |L10.24|
                  |L10.94|
00005e  bf00              NOP                            ;97
000060  7828              LDRB     r0,[r5,#0]            ;100
000062  2802              CMP      r0,#2                 ;100
000064  d106              BNE      |L10.116|
000066  f8bd0000          LDRH     r0,[sp,#0]            ;100
00006a  42b0              CMP      r0,r6                 ;100
00006c  dc02              BGT      |L10.116|
00006e  f04f0a09          MOV      r10,#9                ;103
000072  e00b              B        |L10.140|
                  |L10.116|
000074  f04f0a08          MOV      r10,#8                ;108
000078  7828              LDRB     r0,[r5,#0]            ;112
00007a  2801              CMP      r0,#1                 ;112
00007c  d105              BNE      |L10.138|
00007e  7868              LDRB     r0,[r5,#1]            ;113
000080  42b0              CMP      r0,r6                 ;113
000082  dc02              BGT      |L10.138|
000084  7868              LDRB     r0,[r5,#1]            ;116
000086  9000              STR      r0,[sp,#0]            ;116
000088  e000              B        |L10.140|
                  |L10.138|
00008a  9600              STR      r6,[sp,#0]            ;121
                  |L10.140|
00008c  f8bd0000          LDRH     r0,[sp,#0]            ;126
000090  28fe              CMP      r0,#0xfe              ;126
000092  d901              BLS      |L10.152|
000094  200c              MOVS     r0,#0xc               ;128
000096  e7bf              B        |L10.24|
                  |L10.152|
000098  f8bd0000          LDRH     r0,[sp,#0]            ;132
00009c  1c40              ADDS     r0,r0,#1              ;132
00009e  8821              LDRH     r1,[r4,#0]            ;132
0000a0  5478              STRB     r0,[r7,r1]            ;132
0000a2  8820              LDRH     r0,[r4,#0]            ;133
0000a4  1c40              ADDS     r0,r0,#1              ;133
0000a6  8020              STRH     r0,[r4,#0]            ;133
0000a8  8820              LDRH     r0,[r4,#0]            ;134
0000aa  f807a000          STRB     r10,[r7,r0]           ;134
0000ae  8820              LDRH     r0,[r4,#0]            ;135
0000b0  1c40              ADDS     r0,r0,#1              ;135
0000b2  8020              STRH     r0,[r4,#0]            ;135
0000b4  8820              LDRH     r0,[r4,#0]            ;136
0000b6  f8bd1000          LDRH     r1,[sp,#0]            ;136
0000ba  4408              ADD      r0,r0,r1              ;136
0000bc  8020              STRH     r0,[r4,#0]            ;136
0000be  2000              MOVS     r0,#0                 ;138
0000c0  e7aa              B        |L10.24|
;;;140    
                          ENDP


                          AREA ||i.service_data_encode||, CODE, READONLY, ALIGN=1

                  service_data_encode PROC
;;;421    // Implemented only for 16-bit UUIDs
;;;422    static uint32_t service_data_encode(const ble_advdata_t * p_advdata,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;423                                        uint8_t             * p_encoded_data,
;;;424                                        uint16_t            * p_offset,
;;;425                                        uint16_t              max_size)
;;;426    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  469a              MOV      r10,r3
;;;427        uint8_t i;
;;;428    
;;;429        // Check parameter consistency.
;;;430        if (p_advdata->p_service_data_array == NULL)
00000c  6ab8              LDR      r0,[r7,#0x28]
00000e  b910              CBNZ     r0,|L11.22|
;;;431        {
;;;432            return NRF_ERROR_INVALID_PARAM;
000010  2007              MOVS     r0,#7
                  |L11.18|
;;;433        }
;;;434    
;;;435        for (i = 0; i < p_advdata->service_data_count; i++)
;;;436        {
;;;437            ble_advdata_service_data_t * p_service_data;
;;;438            uint32_t                     data_size;
;;;439    
;;;440            p_service_data = &p_advdata->p_service_data_array[i];
;;;441            // For now implemented only for 16-bit UUIDs
;;;442            data_size      = AD_TYPE_SERV_DATA_16BIT_UUID_SIZE + p_service_data->data.size;
;;;443    
;;;444            // There is only 1 byte intended to encode length which is (data_size + ADV_AD_TYPE_FIELD_SIZE)
;;;445            if (data_size > (0x00FF - ADV_AD_TYPE_FIELD_SIZE))
;;;446            {
;;;447                return NRF_ERROR_DATA_SIZE;
;;;448            }
;;;449    
;;;450            // Encode Length and AD Type.
;;;451            p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + data_size);
;;;452            *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;453            p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SERVICE_DATA;
;;;454            *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;455    
;;;456            // Encode service 16-bit UUID.
;;;457            *p_offset += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_offset]);
;;;458    
;;;459            // Encode additional service data.
;;;460            if (p_service_data->data.size > 0)
;;;461            {
;;;462                if (p_service_data->data.p_data == NULL)
;;;463                {
;;;464                    return NRF_ERROR_INVALID_PARAM;
;;;465                }
;;;466                memcpy(&p_encoded_data[*p_offset], p_service_data->data.p_data, p_service_data->data.size);
;;;467                *p_offset += p_service_data->data.size;
;;;468            }
;;;469        }
;;;470    
;;;471        return NRF_SUCCESS;
;;;472    }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L11.22|
000016  f04f0800          MOV      r8,#0                 ;435
00001a  e036              B        |L11.138|
                  |L11.28|
00001c  eb080148          ADD      r1,r8,r8,LSL #1       ;440
000020  6ab8              LDR      r0,[r7,#0x28]         ;440
000022  eb000581          ADD      r5,r0,r1,LSL #2       ;440
000026  88a8              LDRH     r0,[r5,#4]            ;442
000028  f1000902          ADD      r9,r0,#2              ;442
00002c  f1b90ffe          CMP      r9,#0xfe              ;445
000030  d901              BLS      |L11.54|
000032  200c              MOVS     r0,#0xc               ;447
000034  e7ed              B        |L11.18|
                  |L11.54|
000036  f1090001          ADD      r0,r9,#1              ;451
00003a  8821              LDRH     r1,[r4,#0]            ;451
00003c  5470              STRB     r0,[r6,r1]            ;451
00003e  8820              LDRH     r0,[r4,#0]            ;452
000040  1c40              ADDS     r0,r0,#1              ;452
000042  8020              STRH     r0,[r4,#0]            ;452
000044  2016              MOVS     r0,#0x16              ;453
000046  8821              LDRH     r1,[r4,#0]            ;453
000048  5470              STRB     r0,[r6,r1]            ;453
00004a  8820              LDRH     r0,[r4,#0]            ;454
00004c  1c40              ADDS     r0,r0,#1              ;454
00004e  8020              STRH     r0,[r4,#0]            ;454
000050  8822              LDRH     r2,[r4,#0]            ;457
000052  1991              ADDS     r1,r2,r6              ;457
000054  8828              LDRH     r0,[r5,#0]            ;457
000056  f7fffffe          BL       uint16_encode
00005a  8821              LDRH     r1,[r4,#0]            ;457
00005c  4408              ADD      r0,r0,r1              ;457
00005e  8020              STRH     r0,[r4,#0]            ;457
000060  88a8              LDRH     r0,[r5,#4]            ;460
000062  2800              CMP      r0,#0                 ;460
000064  dd0d              BLE      |L11.130|
000066  68a8              LDR      r0,[r5,#8]            ;462
000068  b908              CBNZ     r0,|L11.110|
00006a  2007              MOVS     r0,#7                 ;464
00006c  e7d1              B        |L11.18|
                  |L11.110|
00006e  88aa              LDRH     r2,[r5,#4]            ;466
000070  8823              LDRH     r3,[r4,#0]            ;466
000072  1998              ADDS     r0,r3,r6              ;466
000074  68a9              LDR      r1,[r5,#8]            ;466
000076  f7fffffe          BL       __aeabi_memcpy
00007a  8820              LDRH     r0,[r4,#0]            ;467
00007c  88a9              LDRH     r1,[r5,#4]            ;467
00007e  4408              ADD      r0,r0,r1              ;467
000080  8020              STRH     r0,[r4,#0]            ;467
                  |L11.130|
000082  f1080001          ADD      r0,r8,#1              ;435
000086  f00008ff          AND      r8,r0,#0xff           ;435
                  |L11.138|
00008a  f897002c          LDRB     r0,[r7,#0x2c]         ;435
00008e  4540              CMP      r0,r8                 ;435
000090  dcc4              BGT      |L11.28|
000092  2000              MOVS     r0,#0                 ;471
000094  e7bd              B        |L11.18|
;;;473    
                          ENDP


                          AREA ||i.srdata_check||, CODE, READONLY, ALIGN=1

                  srdata_check PROC
;;;597    
;;;598    static uint32_t srdata_check(const ble_advdata_t * p_srdata)
000000  4601              MOV      r1,r0
;;;599    {
;;;600        // Flags shall not be included in the scan response data.
;;;601        if (p_srdata->flags)
000002  78c8              LDRB     r0,[r1,#3]
000004  b108              CBZ      r0,|L12.10|
;;;602        {
;;;603            return NRF_ERROR_INVALID_PARAM;
000006  2007              MOVS     r0,#7
                  |L12.8|
;;;604        }
;;;605    
;;;606        return NRF_SUCCESS;
;;;607    }
000008  4770              BX       lr
                  |L12.10|
00000a  2000              MOVS     r0,#0                 ;606
00000c  e7fc              B        |L12.8|
;;;608    
                          ENDP


                          AREA ||i.tx_power_level_encode||, CODE, READONLY, ALIGN=1

                  tx_power_level_encode PROC
;;;190    
;;;191    static uint32_t tx_power_level_encode(int8_t     tx_power_level,
000000  b530              PUSH     {r4,r5,lr}
;;;192                                          uint8_t  * p_encoded_data,
;;;193                                          uint16_t * p_offset,
;;;194                                          uint16_t   max_size)
;;;195    {
000002  4604              MOV      r4,r0
;;;196        // Check for buffer overflow.
;;;197        if (((*p_offset) + AD_TYPE_TX_POWER_LEVEL_SIZE) > max_size)
000004  8810              LDRH     r0,[r2,#0]
000006  1cc0              ADDS     r0,r0,#3
000008  4298              CMP      r0,r3
00000a  d901              BLS      |L13.16|
;;;198        {
;;;199            return NRF_ERROR_DATA_SIZE;
00000c  200c              MOVS     r0,#0xc
                  |L13.14|
;;;200        }
;;;201    
;;;202        // Encode TX Power Level.
;;;203        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE +
;;;204                                                      AD_TYPE_TX_POWER_LEVEL_DATA_SIZE);
;;;205        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;206        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_TX_POWER_LEVEL;
;;;207        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;208        p_encoded_data[*p_offset]  = tx_power_level;
;;;209        *p_offset                 += AD_TYPE_TX_POWER_LEVEL_DATA_SIZE;
;;;210    
;;;211        return NRF_SUCCESS;
;;;212    }
00000e  bd30              POP      {r4,r5,pc}
                  |L13.16|
000010  2002              MOVS     r0,#2                 ;203
000012  8815              LDRH     r5,[r2,#0]            ;203
000014  5548              STRB     r0,[r1,r5]            ;203
000016  8810              LDRH     r0,[r2,#0]            ;205
000018  1c40              ADDS     r0,r0,#1              ;205
00001a  8010              STRH     r0,[r2,#0]            ;205
00001c  200a              MOVS     r0,#0xa               ;206
00001e  8815              LDRH     r5,[r2,#0]            ;206
000020  5548              STRB     r0,[r1,r5]            ;206
000022  8810              LDRH     r0,[r2,#0]            ;207
000024  1c40              ADDS     r0,r0,#1              ;207
000026  8010              STRH     r0,[r2,#0]            ;207
000028  8815              LDRH     r5,[r2,#0]            ;208
00002a  554c              STRB     r4,[r1,r5]            ;208
00002c  8810              LDRH     r0,[r2,#0]            ;209
00002e  1c40              ADDS     r0,r0,#1              ;209
000030  8010              STRH     r0,[r2,#0]            ;209
000032  2000              MOVS     r0,#0                 ;211
000034  e7eb              B        |L13.14|
;;;213    
                          ENDP


                          AREA ||i.uint16_encode||, CODE, READONLY, ALIGN=1

                  uint16_encode PROC
;;;293     */
;;;294    static __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
000000  4602              MOV      r2,r0
;;;295    {
;;;296        p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
000002  700a              STRB     r2,[r1,#0]
;;;297        p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
000004  0a10              LSRS     r0,r2,#8
000006  7048              STRB     r0,[r1,#1]
;;;298        return sizeof(uint16_t);
000008  2002              MOVS     r0,#2
;;;299    }
00000a  4770              BX       lr
;;;300    
                          ENDP


                          AREA ||i.uuid_list_encode||, CODE, READONLY, ALIGN=1

                  uuid_list_encode PROC
;;;279    
;;;280    static uint32_t uuid_list_encode(const ble_advdata_uuid_list_t * p_uuid_list,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;281                                     uint8_t                         adv_type_16,
;;;282                                     uint8_t                         adv_type_128,
;;;283                                     uint8_t                       * p_encoded_data,
;;;284                                     uint16_t                      * p_offset,
;;;285                                     uint16_t                        max_size)
;;;286    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
00000a  469a              MOV      r10,r3
00000c  e9dd670a          LDRD     r6,r7,[sp,#0x28]
;;;287        uint32_t err_code;
;;;288    
;;;289        // Encode 16 bit UUIDs.
;;;290        err_code = uuid_list_sized_encode(p_uuid_list,
000010  4653              MOV      r3,r10
000012  2202              MOVS     r2,#2
000014  4649              MOV      r1,r9
000016  4640              MOV      r0,r8
000018  e9cd6700          STRD     r6,r7,[sp,#0]
00001c  f7fffffe          BL       uuid_list_sized_encode
000020  4604              MOV      r4,r0
;;;291                                          adv_type_16,
;;;292                                          sizeof(uint16_le_t),
;;;293                                          p_encoded_data,
;;;294                                          p_offset,
;;;295                                          max_size);
;;;296        VERIFY_SUCCESS(err_code);
000022  bf00              NOP      
000024  b114              CBZ      r4,|L15.44|
000026  4620              MOV      r0,r4
                  |L15.40|
;;;297    
;;;298        // Encode 128 bit UUIDs.
;;;299        err_code = uuid_list_sized_encode(p_uuid_list,
;;;300                                          adv_type_128,
;;;301                                          sizeof(ble_uuid128_t),
;;;302                                          p_encoded_data,
;;;303                                          p_offset,
;;;304                                          max_size);
;;;305        VERIFY_SUCCESS(err_code);
;;;306    
;;;307        return NRF_SUCCESS;
;;;308    }
000028  e8bd87fc          POP      {r2-r10,pc}
                  |L15.44|
00002c  bf00              NOP                            ;296
00002e  4653              MOV      r3,r10                ;299
000030  2210              MOVS     r2,#0x10              ;299
000032  4629              MOV      r1,r5                 ;299
000034  4640              MOV      r0,r8                 ;299
000036  e9cd6700          STRD     r6,r7,[sp,#0]         ;299
00003a  f7fffffe          BL       uuid_list_sized_encode
00003e  4604              MOV      r4,r0                 ;299
000040  bf00              NOP                            ;305
000042  b10c              CBZ      r4,|L15.72|
000044  4620              MOV      r0,r4                 ;305
000046  e7ef              B        |L15.40|
                  |L15.72|
000048  bf00              NOP                            ;305
00004a  2000              MOVS     r0,#0                 ;307
00004c  e7ec              B        |L15.40|
;;;309    
                          ENDP


                          AREA ||i.uuid_list_sized_encode||, CODE, READONLY, ALIGN=1

                  uuid_list_sized_encode PROC
;;;214    
;;;215    static uint32_t uuid_list_sized_encode(const ble_advdata_uuid_list_t * p_uuid_list,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;216                                           uint8_t                         adv_type,
;;;217                                           uint8_t                         uuid_size,
;;;218                                           uint8_t                       * p_encoded_data,
;;;219                                           uint16_t                      * p_offset,
;;;220                                           uint16_t                        max_size)
;;;221    {
000004  4606              MOV      r6,r0
000006  468b              MOV      r11,r1
000008  4696              MOV      lr,r2
00000a  461d              MOV      r5,r3
00000c  9c0e              LDR      r4,[sp,#0x38]
;;;222        int      i;
;;;223        bool     is_heading_written = false;
00000e  f04f0800          MOV      r8,#0
;;;224        uint16_t start_pos          = *p_offset;
000012  8820              LDRH     r0,[r4,#0]
000014  9003              STR      r0,[sp,#0xc]
;;;225        uint16_t length;
;;;226    
;;;227        for (i = 0; i < p_uuid_list->uuid_cnt; i++)
000016  2700              MOVS     r7,#0
000018  e04a              B        |L16.176|
                  |L16.26|
;;;228        {
;;;229            uint32_t   err_code;
;;;230            uint8_t    encoded_size;
;;;231            ble_uuid_t uuid = p_uuid_list->p_uuids[i];
00001a  6870              LDR      r0,[r6,#4]
00001c  eb000087          ADD      r0,r0,r7,LSL #2
000020  6800              LDR      r0,[r0,#0]
000022  9001              STR      r0,[sp,#4]
;;;232    
;;;233            // Find encoded uuid size.
;;;234            err_code = sd_ble_uuid_encode(&uuid, &encoded_size, NULL);
000024  2200              MOVS     r2,#0
000026  a902              ADD      r1,sp,#8
000028  a801              ADD      r0,sp,#4
00002a  df65              SVC      #0x65
00002c  4682              MOV      r10,r0
;;;235            VERIFY_SUCCESS(err_code);
00002e  bf00              NOP      
000030  f1ba0f00          CMP      r10,#0
000034  d003              BEQ      |L16.62|
000036  4650              MOV      r0,r10
                  |L16.56|
;;;236    
;;;237            // Check size.
;;;238            if (encoded_size == uuid_size)
;;;239            {
;;;240                uint8_t heading_bytes = (is_heading_written) ? 0 : ADV_AD_DATA_OFFSET;
;;;241    
;;;242                // Check for buffer overflow
;;;243                if (((*p_offset) + encoded_size + heading_bytes) > max_size)
;;;244                {
;;;245                    return NRF_ERROR_DATA_SIZE;
;;;246                }
;;;247    
;;;248                if (!is_heading_written)
;;;249                {
;;;250                    // Write AD structure heading.
;;;251                    *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;252                    p_encoded_data[*p_offset]  = adv_type;
;;;253                    *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;254                    is_heading_written         = true;
;;;255                }
;;;256    
;;;257                // Write UUID.
;;;258                err_code = sd_ble_uuid_encode(&uuid, &encoded_size, &p_encoded_data[*p_offset]);
;;;259                VERIFY_SUCCESS(err_code);
;;;260                *p_offset += encoded_size;
;;;261            }
;;;262        }
;;;263    
;;;264        if (is_heading_written)
;;;265        {
;;;266            // Write length.
;;;267            length = (*p_offset) - (start_pos + ADV_LENGTH_FIELD_SIZE);
;;;268            // There is only 1 byte intended to encode length
;;;269            if (length > 0x00FF)
;;;270            {
;;;271                return NRF_ERROR_DATA_SIZE;
;;;272            }
;;;273            p_encoded_data[start_pos] = (uint8_t)length;
;;;274        }
;;;275    
;;;276        return NRF_SUCCESS;
;;;277    }
000038  b004              ADD      sp,sp,#0x10
00003a  e8bd9ff0          POP      {r4-r12,pc}
                  |L16.62|
00003e  bf00              NOP                            ;235
000040  f89d0008          LDRB     r0,[sp,#8]            ;238
000044  4570              CMP      r0,lr                 ;238
000046  d132              BNE      |L16.174|
000048  f1b80f00          CMP      r8,#0                 ;240
00004c  d001              BEQ      |L16.82|
00004e  2000              MOVS     r0,#0                 ;240
000050  e000              B        |L16.84|
                  |L16.82|
000052  2002              MOVS     r0,#2                 ;240
                  |L16.84|
000054  9000              STR      r0,[sp,#0]            ;240
000056  8820              LDRH     r0,[r4,#0]            ;243
000058  f89d1008          LDRB     r1,[sp,#8]            ;243
00005c  4401              ADD      r1,r1,r0              ;243
00005e  9800              LDR      r0,[sp,#0]            ;243
000060  4401              ADD      r1,r1,r0              ;243
000062  980f              LDR      r0,[sp,#0x3c]         ;243
000064  4281              CMP      r1,r0                 ;243
000066  dd01              BLE      |L16.108|
000068  200c              MOVS     r0,#0xc               ;245
00006a  e7e5              B        |L16.56|
                  |L16.108|
00006c  f1b80f00          CMP      r8,#0                 ;248
000070  d10a              BNE      |L16.136|
000072  8820              LDRH     r0,[r4,#0]            ;251
000074  1c40              ADDS     r0,r0,#1              ;251
000076  8020              STRH     r0,[r4,#0]            ;251
000078  8820              LDRH     r0,[r4,#0]            ;252
00007a  f805b000          STRB     r11,[r5,r0]           ;252
00007e  8820              LDRH     r0,[r4,#0]            ;253
000080  1c40              ADDS     r0,r0,#1              ;253
000082  8020              STRH     r0,[r4,#0]            ;253
000084  f04f0801          MOV      r8,#1                 ;254
                  |L16.136|
000088  8820              LDRH     r0,[r4,#0]            ;258
00008a  1942              ADDS     r2,r0,r5              ;258
00008c  a902              ADD      r1,sp,#8              ;258
00008e  a801              ADD      r0,sp,#4              ;258
000090  df65              SVC      #0x65                 ;258
000092  4682              MOV      r10,r0                ;258
000094  bf00              NOP                            ;259
000096  f1ba0f00          CMP      r10,#0                ;259
00009a  d001              BEQ      |L16.160|
00009c  4650              MOV      r0,r10                ;259
00009e  e7cb              B        |L16.56|
                  |L16.160|
0000a0  bf00              NOP                            ;259
0000a2  8820              LDRH     r0,[r4,#0]            ;260
0000a4  f89d1008          LDRB     r1,[sp,#8]            ;260
0000a8  4408              ADD      r0,r0,r1              ;260
0000aa  8020              STRH     r0,[r4,#0]            ;260
0000ac  bf00              NOP                            ;261
                  |L16.174|
0000ae  1c7f              ADDS     r7,r7,#1              ;227
                  |L16.176|
0000b0  8830              LDRH     r0,[r6,#0]            ;227
0000b2  42b8              CMP      r0,r7                 ;227
0000b4  dcb1              BGT      |L16.26|
0000b6  f1b80f00          CMP      r8,#0                 ;264
0000ba  d00d              BEQ      |L16.216|
0000bc  8821              LDRH     r1,[r4,#0]            ;267
0000be  9803              LDR      r0,[sp,#0xc]          ;267
0000c0  1c40              ADDS     r0,r0,#1              ;267
0000c2  1a08              SUBS     r0,r1,r0              ;267
0000c4  fa1ff980          UXTH     r9,r0                 ;267
0000c8  f1b90fff          CMP      r9,#0xff              ;269
0000cc  dd01              BLE      |L16.210|
0000ce  200c              MOVS     r0,#0xc               ;271
0000d0  e7b2              B        |L16.56|
                  |L16.210|
0000d2  9803              LDR      r0,[sp,#0xc]          ;273
0000d4  f8059000          STRB     r9,[r5,r0]            ;273
                  |L16.216|
0000d8  2000              MOVS     r0,#0                 ;276
0000da  e7ad              B        |L16.56|
;;;278    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\common\\ble_advdata.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_ble_advdata_c_7f4862ed____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_ble_advdata_c_7f4862ed____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_ble_advdata_c_7f4862ed____REVSH|
#line 402
|__asm___13_ble_advdata_c_7f4862ed____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_ble_advdata_c_7f4862ed____RRX|
#line 587
|__asm___13_ble_advdata_c_7f4862ed____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
