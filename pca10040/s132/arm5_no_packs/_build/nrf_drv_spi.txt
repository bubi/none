; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\nrf_drv_spi.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\nrf_drv_spi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\nrf_drv_spi.crf ..\..\..\..\..\..\components\drivers_nrf\spi_master\nrf_drv_spi.c]
                          THUMB

                          AREA ||i.SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler||, CODE, READONLY, ALIGN=2

                  SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler PROC
;;;592    #if SPI0_ENABLED
;;;593    IRQ_HANDLER(0)
000000  b510              PUSH     {r4,lr}
;;;594    {
;;;595        spi_control_block_t * p_cb  = &m_cb[SPI0_INSTANCE_INDEX];
000002  4c03              LDR      r4,|L1.16|
;;;596        #if SPI0_USE_EASY_DMA
;;;597            irq_handler_spim(NRF_SPIM0, p_cb);
;;;598        #else
;;;599            irq_handler_spi(NRF_SPI0, p_cb);
000004  4621              MOV      r1,r4
000006  4803              LDR      r0,|L1.20|
000008  f7fffffe          BL       irq_handler_spi
;;;600        #endif
;;;601    }
00000c  bd10              POP      {r4,pc}
;;;602    #endif // SPI0_ENABLED
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      m_cb
                  |L1.20|
                          DCD      0x40003000

                          AREA ||i.finish_transfer||, CODE, READONLY, ALIGN=1

                  finish_transfer PROC
;;;325    
;;;326    static void finish_transfer(spi_control_block_t * p_cb)
000000  b510              PUSH     {r4,lr}
;;;327    {
000002  4604              MOV      r4,r0
;;;328        // If Slave Select signal is used, this is the time to deactivate it.
;;;329        if (p_cb->ss_pin != NRF_DRV_SPI_PIN_NOT_USED)
000004  7ea0              LDRB     r0,[r4,#0x1a]
000006  28ff              CMP      r0,#0xff
000008  d002              BEQ      |L2.16|
;;;330        {
;;;331            nrf_gpio_pin_set(p_cb->ss_pin);
00000a  7ea0              LDRB     r0,[r4,#0x1a]
00000c  f7fffffe          BL       nrf_gpio_pin_set
                  |L2.16|
;;;332        }
;;;333    
;;;334        // By clearing this flag before calling the handler we allow subsequent
;;;335        // transfers to be started directly from the handler function.
;;;336        p_cb->transfer_in_progress = false;
000010  2000              MOVS     r0,#0
000012  7660              STRB     r0,[r4,#0x19]
;;;337        p_cb->evt.type = NRF_DRV_SPI_EVENT_DONE;
000014  7120              STRB     r0,[r4,#4]
;;;338        p_cb->handler(&p_cb->evt);
000016  1d20              ADDS     r0,r4,#4
000018  6821              LDR      r1,[r4,#0]
00001a  4788              BLX      r1
;;;339    }
00001c  bd10              POP      {r4,pc}
;;;340    
                          ENDP


                          AREA ||i.irq_handler_spi||, CODE, READONLY, ALIGN=1

                  irq_handler_spi PROC
;;;578    #ifdef SPI_IN_USE
;;;579    static void irq_handler_spi(NRF_SPI_Type * p_spi, spi_control_block_t * p_cb)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;581        ASSERT(p_cb->handler);
;;;582    
;;;583        nrf_spi_event_clear(p_spi, NRF_SPI_EVENT_READY);
000006  f44f7184          MOV      r1,#0x108
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       nrf_spi_event_clear
;;;584    
;;;585        if (!transfer_byte(p_spi, p_cb))
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       transfer_byte
000018  b910              CBNZ     r0,|L3.32|
;;;586        {
;;;587            finish_transfer(p_cb);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       finish_transfer
                  |L3.32|
;;;588        }
;;;589    }
000020  bd70              POP      {r4-r6,pc}
;;;590    #endif // SPI_IN_USE
                          ENDP


                          AREA ||i.nrf_drv_spi_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_spi_init PROC
;;;137    
;;;138    ret_code_t nrf_drv_spi_init(nrf_drv_spi_t const * const p_instance,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;139                                nrf_drv_spi_config_t const * p_config,
;;;140                                nrf_drv_spi_handler_t handler)
;;;141    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4692              MOV      r10,r2
;;;142        ASSERT(p_config);
;;;143        spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
00000a  7978              LDRB     r0,[r7,#5]
00000c  494b              LDR      r1,|L4.316|
00000e  eb011840          ADD      r8,r1,r0,LSL #5
;;;144    
;;;145        if (p_cb->state != NRF_DRV_STATE_UNINITIALIZED)
000012  f8980018          LDRB     r0,[r8,#0x18]
000016  b110              CBZ      r0,|L4.30|
;;;146        {
;;;147            return NRF_ERROR_INVALID_STATE;
000018  2008              MOVS     r0,#8
                  |L4.26|
;;;148        }
;;;149    
;;;150    #if PERIPHERAL_RESOURCE_SHARING_ENABLED
;;;151        if (nrf_drv_common_per_res_acquire(p_instance->p_registers,
;;;152                m_irq_handlers[p_instance->drv_inst_idx]) != NRF_SUCCESS)
;;;153        {
;;;154            return NRF_ERROR_BUSY;
;;;155        }
;;;156    #endif
;;;157    
;;;158        p_cb->handler = handler;
;;;159    
;;;160        uint32_t mosi_pin;
;;;161        uint32_t miso_pin;
;;;162        // Configure pins used by the peripheral:
;;;163        // - SCK - output with initial value corresponding with the SPI mode used:
;;;164        //   0 - for modes 0 and 1 (CPOL = 0), 1 - for modes 2 and 3 (CPOL = 1);
;;;165        //   according to the reference manual guidelines this pin and its input
;;;166        //   buffer must always be connected for the SPI to work.
;;;167        if (p_config->mode <= NRF_DRV_SPI_MODE_1)
;;;168        {
;;;169            nrf_gpio_pin_clear(p_config->sck_pin);
;;;170        }
;;;171        else
;;;172        {
;;;173            nrf_gpio_pin_set(p_config->sck_pin);
;;;174        }
;;;175        NRF_GPIO->PIN_CNF[p_config->sck_pin] =
;;;176            (GPIO_PIN_CNF_DIR_Output        << GPIO_PIN_CNF_DIR_Pos)
;;;177          | (GPIO_PIN_CNF_INPUT_Connect     << GPIO_PIN_CNF_INPUT_Pos)
;;;178          | (GPIO_PIN_CNF_PULL_Disabled     << GPIO_PIN_CNF_PULL_Pos)
;;;179          | (GPIO_PIN_CNF_DRIVE_S0S1        << GPIO_PIN_CNF_DRIVE_Pos)
;;;180          | (GPIO_PIN_CNF_SENSE_Disabled    << GPIO_PIN_CNF_SENSE_Pos);
;;;181        // - MOSI (optional) - output with initial value 0,
;;;182        if (p_config->mosi_pin != NRF_DRV_SPI_PIN_NOT_USED)
;;;183        {
;;;184            mosi_pin = p_config->mosi_pin;
;;;185            nrf_gpio_pin_clear(mosi_pin);
;;;186            nrf_gpio_cfg_output(mosi_pin);
;;;187        }
;;;188        else
;;;189        {
;;;190            mosi_pin = NRF_SPI_PIN_NOT_CONNECTED;
;;;191        }
;;;192        // - MISO (optional) - input,
;;;193        if (p_config->miso_pin != NRF_DRV_SPI_PIN_NOT_USED)
;;;194        {
;;;195            miso_pin = p_config->miso_pin;
;;;196            nrf_gpio_cfg_input(miso_pin, NRF_GPIO_PIN_NOPULL);
;;;197        }
;;;198        else
;;;199        {
;;;200            miso_pin = NRF_SPI_PIN_NOT_CONNECTED;
;;;201        }
;;;202        // - Slave Select (optional) - output with initial value 1 (inactive).
;;;203        if (p_config->ss_pin != NRF_DRV_SPI_PIN_NOT_USED)
;;;204        {
;;;205            nrf_gpio_pin_set(p_config->ss_pin);
;;;206            nrf_gpio_cfg_output(p_config->ss_pin);
;;;207        }
;;;208        m_cb[p_instance->drv_inst_idx].ss_pin = p_config->ss_pin;
;;;209    
;;;210        CODE_FOR_SPIM
;;;211        (
;;;212            NRF_SPIM_Type * p_spim = p_instance->p_registers;
;;;213            nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
;;;214            nrf_spim_frequency_set(p_spim,
;;;215                (nrf_spim_frequency_t)p_config->frequency);
;;;216            nrf_spim_configure(p_spim,
;;;217                (nrf_spim_mode_t)p_config->mode,
;;;218                (nrf_spim_bit_order_t)p_config->bit_order);
;;;219    
;;;220            nrf_spim_orc_set(p_spim, p_config->orc);
;;;221    
;;;222            if (p_cb->handler)
;;;223            {
;;;224                nrf_spim_int_enable(p_spim, END_INT_MASK);
;;;225            }
;;;226    
;;;227            nrf_spim_enable(p_spim);
;;;228        )
;;;229        CODE_FOR_SPI
;;;230        (
;;;231            NRF_SPI_Type * p_spi = p_instance->p_registers;
;;;232            nrf_spi_pins_set(p_spi, p_config->sck_pin, mosi_pin, miso_pin);
;;;233            nrf_spi_frequency_set(p_spi,
;;;234                (nrf_spi_frequency_t)p_config->frequency);
;;;235            nrf_spi_configure(p_spi,
;;;236                (nrf_spi_mode_t)p_config->mode,
;;;237                (nrf_spi_bit_order_t)p_config->bit_order);
;;;238    
;;;239            m_cb[p_instance->drv_inst_idx].orc = p_config->orc;
;;;240    
;;;241            if (p_cb->handler)
;;;242            {
;;;243                nrf_spi_int_enable(p_spi, NRF_SPI_INT_READY_MASK);
;;;244            }
;;;245    
;;;246            nrf_spi_enable(p_spi);
;;;247        )
;;;248    
;;;249        if (p_cb->handler)
;;;250        {
;;;251            nrf_drv_common_irq_enable(p_instance->irq, p_config->irq_priority);
;;;252        }
;;;253    
;;;254        p_cb->transfer_in_progress = false;
;;;255        p_cb->state = NRF_DRV_STATE_INITIALIZED;
;;;256    
;;;257        NRF_LOG_INFO("Init\r\n");
;;;258    
;;;259        return NRF_SUCCESS;
;;;260    }
00001a  e8bd87fc          POP      {r2-r10,pc}
                  |L4.30|
00001e  f8c8a000          STR      r10,[r8,#0]           ;158
000022  7b20              LDRB     r0,[r4,#0xc]          ;167
000024  2801              CMP      r0,#1                 ;167
000026  dc03              BGT      |L4.48|
000028  7820              LDRB     r0,[r4,#0]            ;169
00002a  f7fffffe          BL       nrf_gpio_pin_clear
00002e  e002              B        |L4.54|
                  |L4.48|
000030  7820              LDRB     r0,[r4,#0]            ;173
000032  f7fffffe          BL       nrf_gpio_pin_set
                  |L4.54|
000036  2101              MOVS     r1,#1                 ;175
000038  4841              LDR      r0,|L4.320|
00003a  7822              LDRB     r2,[r4,#0]            ;175
00003c  f8401022          STR      r1,[r0,r2,LSL #2]     ;175
000040  7860              LDRB     r0,[r4,#1]            ;182
000042  28ff              CMP      r0,#0xff              ;182
000044  d008              BEQ      |L4.88|
000046  f8949001          LDRB     r9,[r4,#1]            ;184
00004a  4648              MOV      r0,r9                 ;185
00004c  f7fffffe          BL       nrf_gpio_pin_clear
000050  4648              MOV      r0,r9                 ;186
000052  f7fffffe          BL       nrf_gpio_cfg_output
000056  e001              B        |L4.92|
                  |L4.88|
000058  f04f39ff          MOV      r9,#0xffffffff        ;190
                  |L4.92|
00005c  78a0              LDRB     r0,[r4,#2]            ;193
00005e  28ff              CMP      r0,#0xff              ;193
000060  d00c              BEQ      |L4.124|
000062  78a6              LDRB     r6,[r4,#2]            ;195
000064  2500              MOVS     r5,#0                 ;196
000066  2000              MOVS     r0,#0                 ;196
000068  9000              STR      r0,[sp,#0]            ;196
00006a  462b              MOV      r3,r5                 ;196
00006c  4602              MOV      r2,r0                 ;196
00006e  4601              MOV      r1,r0                 ;196
000070  9001              STR      r0,[sp,#4]            ;196
000072  4630              MOV      r0,r6                 ;196
000074  f7fffffe          BL       nrf_gpio_cfg
000078  bf00              NOP                            ;196
00007a  e001              B        |L4.128|
                  |L4.124|
00007c  f04f36ff          MOV      r6,#0xffffffff        ;200
                  |L4.128|
000080  78e0              LDRB     r0,[r4,#3]            ;203
000082  28ff              CMP      r0,#0xff              ;203
000084  d005              BEQ      |L4.146|
000086  78e0              LDRB     r0,[r4,#3]            ;205
000088  f7fffffe          BL       nrf_gpio_pin_set
00008c  78e0              LDRB     r0,[r4,#3]            ;206
00008e  f7fffffe          BL       nrf_gpio_cfg_output
                  |L4.146|
000092  78e0              LDRB     r0,[r4,#3]            ;208
000094  7979              LDRB     r1,[r7,#5]            ;208
000096  4a29              LDR      r2,|L4.316|
000098  eb021141          ADD      r1,r2,r1,LSL #5       ;208
00009c  7688              STRB     r0,[r1,#0x1a]         ;208
00009e  683d              LDR      r5,[r7,#0]            ;229
0000a0  4628              MOV      r0,r5                 ;229
0000a2  7821              LDRB     r1,[r4,#0]            ;229
0000a4  f8c01508          STR      r1,[r0,#0x508]        ;229
0000a8  f8c0950c          STR      r9,[r0,#0x50c]        ;229
0000ac  f44f62a2          MOV      r2,#0x510             ;229
0000b0  5016              STR      r6,[r2,r0]            ;229
0000b2  bf00              NOP                            ;229
0000b4  68a0              LDR      r0,[r4,#8]            ;229
0000b6  f8c50524          STR      r0,[r5,#0x524]        ;229
0000ba  bf00              NOP                            ;229
0000bc  7b21              LDRB     r1,[r4,#0xc]          ;229
0000be  7b62              LDRB     r2,[r4,#0xd]          ;229
0000c0  b10a              CBZ      r2,|L4.198|
0000c2  2301              MOVS     r3,#1                 ;229
0000c4  e000              B        |L4.200|
                  |L4.198|
0000c6  2300              MOVS     r3,#0                 ;229
                  |L4.200|
0000c8  4618              MOV      r0,r3                 ;229
0000ca  b131              CBZ      r1,|L4.218|
0000cc  2901              CMP      r1,#1                 ;229
0000ce  d006              BEQ      |L4.222|
0000d0  2902              CMP      r1,#2                 ;229
0000d2  d007              BEQ      |L4.228|
0000d4  2903              CMP      r1,#3                 ;229
0000d6  d008              BEQ      |L4.234|
0000d8  bf00              NOP                            ;229
                  |L4.218|
0000da  bf00              NOP                            ;229
0000dc  e008              B        |L4.240|
                  |L4.222|
0000de  f0400002          ORR      r0,r0,#2              ;229
0000e2  e005              B        |L4.240|
                  |L4.228|
0000e4  f0400004          ORR      r0,r0,#4              ;229
0000e8  e002              B        |L4.240|
                  |L4.234|
0000ea  f0400006          ORR      r0,r0,#6              ;229
0000ee  bf00              NOP                            ;229
                  |L4.240|
0000f0  bf00              NOP                            ;229
0000f2  f8c50554          STR      r0,[r5,#0x554]        ;229
0000f6  bf00              NOP                            ;229
0000f8  7960              LDRB     r0,[r4,#5]            ;229
0000fa  7979              LDRB     r1,[r7,#5]            ;229
0000fc  4a0f              LDR      r2,|L4.316|
0000fe  eb021141          ADD      r1,r2,r1,LSL #5       ;229
000102  76c8              STRB     r0,[r1,#0x1b]         ;229
000104  f8d80000          LDR      r0,[r8,#0]            ;229
000108  b118              CBZ      r0,|L4.274|
00010a  2104              MOVS     r1,#4                 ;229
00010c  4628              MOV      r0,r5                 ;229
00010e  f7fffffe          BL       nrf_spi_int_enable
                  |L4.274|
000112  bf00              NOP                            ;229
000114  2001              MOVS     r0,#1                 ;229
000116  f8c50500          STR      r0,[r5,#0x500]        ;229
00011a  bf00              NOP                            ;229
00011c  f8d80000          LDR      r0,[r8,#0]            ;249
000120  b120              CBZ      r0,|L4.300|
000122  7921              LDRB     r1,[r4,#4]            ;251
000124  f9970004          LDRSB    r0,[r7,#4]            ;251
000128  f7fffffe          BL       nrf_drv_common_irq_enable
                  |L4.300|
00012c  2000              MOVS     r0,#0                 ;254
00012e  f8880019          STRB     r0,[r8,#0x19]         ;254
000132  2001              MOVS     r0,#1                 ;255
000134  f8880018          STRB     r0,[r8,#0x18]         ;255
000138  2000              MOVS     r0,#0                 ;259
00013a  e76e              B        |L4.26|
;;;261    
                          ENDP

                  |L4.316|
                          DCD      m_cb
                  |L4.320|
                          DCD      0x50000700

                          AREA ||i.nrf_drv_spi_transfer||, CODE, READONLY, ALIGN=1

                  nrf_drv_spi_transfer PROC
;;;307    
;;;308    ret_code_t nrf_drv_spi_transfer(nrf_drv_spi_t const * const p_instance,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;309                                    uint8_t const * p_tx_buffer,
;;;310                                    uint8_t         tx_buffer_length,
;;;311                                    uint8_t       * p_rx_buffer,
;;;312                                    uint8_t         rx_buffer_length)
;;;313    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;314        nrf_drv_spi_xfer_desc_t xfer_desc;
;;;315        xfer_desc.p_tx_buffer = p_tx_buffer;
000010  9400              STR      r4,[sp,#0]
;;;316        xfer_desc.p_rx_buffer = p_rx_buffer;
000012  9602              STR      r6,[sp,#8]
;;;317        xfer_desc.tx_length   = tx_buffer_length;
000014  f88d5004          STRB     r5,[sp,#4]
;;;318        xfer_desc.rx_length   = rx_buffer_length;
000018  f88d800c          STRB     r8,[sp,#0xc]
;;;319    
;;;320        NRF_LOG_INFO("Transfer tx_len:%d, rx_len:%d\r\n", tx_buffer_length, rx_buffer_length);
;;;321        NRF_LOG_DEBUG("Tx data:\r\n");
;;;322        NRF_LOG_HEXDUMP_DEBUG((uint8_t *)p_tx_buffer, tx_buffer_length);
;;;323        return nrf_drv_spi_xfer(p_instance, &xfer_desc, 0);
00001c  2200              MOVS     r2,#0
00001e  4669              MOV      r1,sp
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       nrf_drv_spi_xfer
;;;324    }
000026  b004              ADD      sp,sp,#0x10
000028  e8bd81f0          POP      {r4-r8,pc}
;;;325    
                          ENDP


                          AREA ||i.nrf_drv_spi_uninit||, CODE, READONLY, ALIGN=2

                  nrf_drv_spi_uninit PROC
;;;261    
;;;262    void nrf_drv_spi_uninit(nrf_drv_spi_t const * const p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;263    {
000002  4604              MOV      r4,r0
;;;264        spi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000004  7960              LDRB     r0,[r4,#5]
000006  4911              LDR      r1,|L6.76|
000008  eb011540          ADD      r5,r1,r0,LSL #5
;;;265        ASSERT(p_cb->state != NRF_DRV_STATE_UNINITIALIZED);
;;;266    
;;;267        if (p_cb->handler)
00000c  6828              LDR      r0,[r5,#0]
00000e  b168              CBZ      r0,|L6.44|
;;;268        {
;;;269            nrf_drv_common_irq_disable(p_instance->irq);
000010  f9940004          LDRSB    r0,[r4,#4]
000014  bf00              NOP      
000016  f000021f          AND      r2,r0,#0x1f
00001a  2101              MOVS     r1,#1
00001c  4091              LSLS     r1,r1,r2
00001e  4a0c              LDR      r2,|L6.80|
000020  0943              LSRS     r3,r0,#5
000022  f8421023          STR      r1,[r2,r3,LSL #2]
000026  bf00              NOP      
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L6.44|
;;;270        }
;;;271    
;;;272        #define DISABLE_ALL  0xFFFFFFFF
;;;273    
;;;274        CODE_FOR_SPIM
;;;275        (
;;;276            NRF_SPIM_Type * p_spim = p_instance->p_registers;
;;;277            if (p_cb->handler)
;;;278            {
;;;279                nrf_spim_int_disable(p_spim, DISABLE_ALL);
;;;280                if (p_cb->transfer_in_progress)
;;;281                {
;;;282                    // Ensure that SPI is not performing any transfer.
;;;283                    nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_STOP);
;;;284                    while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STOPPED)) {}
;;;285                    p_cb->transfer_in_progress = false;
;;;286                }
;;;287            }
;;;288            nrf_spim_disable(p_spim);
;;;289        )
;;;290        CODE_FOR_SPI
00002c  6826              LDR      r6,[r4,#0]
00002e  6828              LDR      r0,[r5,#0]
000030  b120              CBZ      r0,|L6.60|
000032  f04f31ff          MOV      r1,#0xffffffff
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       nrf_spi_int_disable
                  |L6.60|
00003c  bf00              NOP      
00003e  2000              MOVS     r0,#0
000040  f8c60500          STR      r0,[r6,#0x500]
000044  bf00              NOP      
;;;291        (
;;;292            NRF_SPI_Type * p_spi = p_instance->p_registers;
;;;293            if (p_cb->handler)
;;;294            {
;;;295                nrf_spi_int_disable(p_spi, DISABLE_ALL);
;;;296            }
;;;297            nrf_spi_disable(p_spi);
;;;298        )
;;;299        #undef DISABLE_ALL
;;;300    
;;;301    #if PERIPHERAL_RESOURCE_SHARING_ENABLED
;;;302        nrf_drv_common_per_res_release(p_instance->p_registers);
;;;303    #endif
;;;304    
;;;305        p_cb->state = NRF_DRV_STATE_UNINITIALIZED;
000046  7628              STRB     r0,[r5,#0x18]
;;;306    }
000048  bd70              POP      {r4-r6,pc}
;;;307    
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      m_cb
                  |L6.80|
                          DCD      0xe000e180

                          AREA ||i.nrf_drv_spi_xfer||, CODE, READONLY, ALIGN=2

                  nrf_drv_spi_xfer PROC
;;;508    
;;;509    ret_code_t nrf_drv_spi_xfer(nrf_drv_spi_t     const * const p_instance,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;510                                nrf_drv_spi_xfer_desc_t const * p_xfer_desc,
;;;511                                uint32_t                        flags)
;;;512    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;513        spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
00000a  7968              LDRB     r0,[r5,#5]
00000c  4917              LDR      r1,|L7.108|
00000e  eb011440          ADD      r4,r1,r0,LSL #5
;;;514        ASSERT(p_cb->state != NRF_DRV_STATE_UNINITIALIZED);
;;;515        ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
;;;516        ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
;;;517    
;;;518        if (p_cb->transfer_in_progress)
000012  7e60              LDRB     r0,[r4,#0x19]
000014  b110              CBZ      r0,|L7.28|
;;;519        {
;;;520            return NRF_ERROR_BUSY;
000016  2011              MOVS     r0,#0x11
                  |L7.24|
;;;521        }
;;;522        else
;;;523        {
;;;524            if (p_cb->handler && !(flags & (NRF_DRV_SPI_FLAG_REPEATED_XFER | NRF_DRV_SPI_FLAG_NO_XFER_EVT_HANDLER)))
;;;525            {
;;;526                p_cb->transfer_in_progress = true;
;;;527            }
;;;528        }
;;;529    
;;;530        p_cb->evt.data.done = *p_xfer_desc;
;;;531        p_cb->tx_done = false;
;;;532        p_cb->rx_done = false;
;;;533    
;;;534        if (p_cb->ss_pin != NRF_DRV_SPI_PIN_NOT_USED)
;;;535        {
;;;536            nrf_gpio_pin_clear(p_cb->ss_pin);
;;;537        }
;;;538        CODE_FOR_SPIM
;;;539        (
;;;540            return spim_xfer(p_instance->p_registers, p_cb,  p_xfer_desc, flags);
;;;541        )
;;;542        CODE_FOR_SPI
;;;543        (
;;;544            if (flags)
;;;545            {
;;;546                p_cb->transfer_in_progress = false;
;;;547                return NRF_ERROR_NOT_SUPPORTED;
;;;548            }
;;;549            spi_xfer(p_instance->p_registers, p_cb, p_xfer_desc);
;;;550            return NRF_SUCCESS;
;;;551        )
;;;552    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L7.28|
00001c  6820              LDR      r0,[r4,#0]            ;524
00001e  b120              CBZ      r0,|L7.42|
000020  f0070014          AND      r0,r7,#0x14           ;524
000024  b908              CBNZ     r0,|L7.42|
000026  2001              MOVS     r0,#1                 ;526
000028  7660              STRB     r0,[r4,#0x19]         ;526
                  |L7.42|
00002a  e896100e          LDM      r6,{r1-r3,r12}        ;530
00002e  e9c43c04          STRD     r3,r12,[r4,#0x10]     ;530
000032  e9c41202          STRD     r1,r2,[r4,#8]         ;530
000036  7f60              LDRB     r0,[r4,#0x1d]         ;531
000038  f0200001          BIC      r0,r0,#1              ;531
00003c  7760              STRB     r0,[r4,#0x1d]         ;531
00003e  7f60              LDRB     r0,[r4,#0x1d]         ;532
000040  f0200002          BIC      r0,r0,#2              ;532
000044  7760              STRB     r0,[r4,#0x1d]         ;532
000046  7ea0              LDRB     r0,[r4,#0x1a]         ;534
000048  28ff              CMP      r0,#0xff              ;534
00004a  d002              BEQ      |L7.82|
00004c  7ea0              LDRB     r0,[r4,#0x1a]         ;536
00004e  f7fffffe          BL       nrf_gpio_pin_clear
                  |L7.82|
000052  b11f              CBZ      r7,|L7.92|
000054  2000              MOVS     r0,#0                 ;542
000056  7660              STRB     r0,[r4,#0x19]         ;542
000058  2006              MOVS     r0,#6                 ;542
00005a  e7dd              B        |L7.24|
                  |L7.92|
00005c  4632              MOV      r2,r6                 ;542
00005e  4621              MOV      r1,r4                 ;542
000060  6828              LDR      r0,[r5,#0]            ;542
000062  f7fffffe          BL       spi_xfer
000066  2000              MOVS     r0,#0                 ;542
000068  e7d6              B        |L7.24|
;;;553    #ifdef SPIM_IN_USE
                          ENDP

00006a  0000              DCW      0x0000
                  |L7.108|
                          DCD      m_cb

                          AREA ||i.nrf_gpio_cfg||, CODE, READONLY, ALIGN=2

                  nrf_gpio_cfg PROC
;;;453    
;;;454    __STATIC_INLINE void nrf_gpio_cfg(
000000  b5f0              PUSH     {r4-r7,lr}
;;;455            uint32_t             pin_number,
;;;456            nrf_gpio_pin_dir_t   dir,
;;;457            nrf_gpio_pin_input_t input,
;;;458            nrf_gpio_pin_pull_t  pull,
;;;459            nrf_gpio_pin_drive_t drive,
;;;460            nrf_gpio_pin_sense_t sense)
;;;461    {
000002  e9dd4505          LDRD     r4,r5,[sp,#0x14]
;;;462        NRF_GPIO->PIN_CNF[pin_number] = ((uint32_t)dir   << GPIO_PIN_CNF_DIR_Pos)
000006  ea410642          ORR      r6,r1,r2,LSL #1
00000a  ea460683          ORR      r6,r6,r3,LSL #2
00000e  ea462604          ORR      r6,r6,r4,LSL #8
000012  ea464705          ORR      r7,r6,r5,LSL #16
000016  4e02              LDR      r6,|L8.32|
000018  f8467020          STR      r7,[r6,r0,LSL #2]
;;;463                                      | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
;;;464                                      | ((uint32_t)pull  << GPIO_PIN_CNF_PULL_Pos)
;;;465                                      | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
;;;466                                      | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
;;;467    }
00001c  bdf0              POP      {r4-r7,pc}
;;;468    
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      0x50000700

                          AREA ||i.nrf_gpio_cfg_output||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_output PROC
;;;468    
;;;469    __STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;470    {
000002  4604              MOV      r4,r0
;;;471        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4611              MOV      r1,r2
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;472                pin_number,
;;;473                NRF_GPIO_PIN_DIR_OUTPUT,
;;;474                NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;475                NRF_GPIO_PIN_NOPULL,
;;;476                NRF_GPIO_PIN_S0S1,
;;;477                NRF_GPIO_PIN_NOSENSE);
;;;478    }
000016  bd1c              POP      {r2-r4,pc}
;;;479    
                          ENDP


                          AREA ||i.nrf_gpio_pin_clear||, CODE, READONLY, ALIGN=2

                  nrf_gpio_pin_clear PROC
;;;562    
;;;563    __STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
000000  2101              MOVS     r1,#1
;;;564    {
;;;565        NRF_GPIO->OUTCLR = (1UL << pin_number);
000002  4081              LSLS     r1,r1,r0
000004  4a01              LDR      r2,|L10.12|
000006  6011              STR      r1,[r2,#0]
;;;566    }
000008  4770              BX       lr
;;;567    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x5000050c

                          AREA ||i.nrf_gpio_pin_set||, CODE, READONLY, ALIGN=2

                  nrf_gpio_pin_set PROC
;;;552    
;;;553    __STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
000000  2101              MOVS     r1,#1
;;;554    {
;;;555        NRF_GPIO->OUTSET = (1UL << pin_number);
000002  4081              LSLS     r1,r1,r0
000004  4a01              LDR      r2,|L11.12|
000006  6011              STR      r1,[r2,#0]
;;;556    }
000008  4770              BX       lr
;;;557    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x50000508

                          AREA ||i.nrf_spi_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_spi_event_clear PROC
;;;229    
;;;230    __STATIC_INLINE void nrf_spi_event_clear(NRF_SPI_Type * p_reg,
000000  b508              PUSH     {r3,lr}
;;;231                                             nrf_spi_event_t spi_event)
;;;232    {
;;;233        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spi_event)) = 0x0UL;
000002  2200              MOVS     r2,#0
000004  5042              STR      r2,[r0,r1]
;;;234    #if __CORTEX_M == 0x04
;;;235        volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)spi_event));
000006  5842              LDR      r2,[r0,r1]
000008  9200              STR      r2,[sp,#0]
;;;236        (void)dummy;
00000a  bf00              NOP      
;;;237    #endif
;;;238    }
00000c  bd08              POP      {r3,pc}
;;;239    
                          ENDP


                          AREA ||i.nrf_spi_int_disable||, CODE, READONLY, ALIGN=1

                  nrf_spi_int_disable PROC
;;;257    
;;;258    __STATIC_INLINE void nrf_spi_int_disable(NRF_SPI_Type * p_reg,
000000  f8c01308          STR      r1,[r0,#0x308]
;;;259                                             uint32_t spi_int_mask)
;;;260    {
;;;261        p_reg->INTENCLR = spi_int_mask;
;;;262    }
000004  4770              BX       lr
;;;263    
                          ENDP


                          AREA ||i.nrf_spi_int_enable||, CODE, READONLY, ALIGN=1

                  nrf_spi_int_enable PROC
;;;251    
;;;252    __STATIC_INLINE void nrf_spi_int_enable(NRF_SPI_Type * p_reg,
000000  f8c01304          STR      r1,[r0,#0x304]
;;;253                                            uint32_t spi_int_mask)
;;;254    {
;;;255        p_reg->INTENSET = spi_int_mask;
;;;256    }
000004  4770              BX       lr
;;;257    
                          ENDP


                          AREA ||i.nrf_spi_txd_set||, CODE, READONLY, ALIGN=1

                  nrf_spi_txd_set PROC
;;;289    
;;;290    __STATIC_INLINE void nrf_spi_txd_set(NRF_SPI_Type * p_reg, uint8_t data)
000000  f8c0151c          STR      r1,[r0,#0x51c]
;;;291    {
;;;292        p_reg->TXD = data;
;;;293    }
000004  4770              BX       lr
;;;294    
                          ENDP


                          AREA ||i.spi_xfer||, CODE, READONLY, ALIGN=1

                  spi_xfer PROC
;;;381    
;;;382    static void spi_xfer(NRF_SPI_Type                  * p_spi,
000000  b570              PUSH     {r4-r6,lr}
;;;383                         spi_control_block_t           * p_cb,
;;;384                         nrf_drv_spi_xfer_desc_t const * p_xfer_desc)
;;;385    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;386        p_cb->bytes_transferred = 0;
000008  2000              MOVS     r0,#0
00000a  7720              STRB     r0,[r4,#0x1c]
;;;387        nrf_spi_int_disable(p_spi, NRF_SPI_INT_READY_MASK);
00000c  2104              MOVS     r1,#4
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       nrf_spi_int_disable
;;;388    
;;;389        nrf_spi_event_clear(p_spi, NRF_SPI_EVENT_READY);
000014  f44f7184          MOV      r1,#0x108
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       nrf_spi_event_clear
;;;390    
;;;391        // Start the transfer by writing some byte to the TXD register;
;;;392        // if TX buffer is not empty, take the first byte from this buffer,
;;;393        // otherwise - use over-run character.
;;;394        nrf_spi_txd_set(p_spi,
00001e  7928              LDRB     r0,[r5,#4]
000020  2800              CMP      r0,#0
000022  dd02              BLE      |L16.42|
;;;395            (p_xfer_desc->tx_length > 0 ?  p_xfer_desc->p_tx_buffer[0] : p_cb->orc));
000024  6828              LDR      r0,[r5,#0]
000026  7800              LDRB     r0,[r0,#0]
000028  e000              B        |L16.44|
                  |L16.42|
00002a  7ee0              LDRB     r0,[r4,#0x1b]
                  |L16.44|
00002c  4601              MOV      r1,r0
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       nrf_spi_txd_set
;;;396    
;;;397        // TXD register is double buffered, so next byte to be transmitted can
;;;398        // be written immediately, if needed, i.e. if TX or RX transfer is to
;;;399        // be more that 1 byte long. Again - if there is something more in TX
;;;400        // buffer send it, otherwise use over-run character.
;;;401        if (p_xfer_desc->tx_length > 1)
000034  7928              LDRB     r0,[r5,#4]
000036  2801              CMP      r0,#1
000038  dd05              BLE      |L16.70|
;;;402        {
;;;403            nrf_spi_txd_set(p_spi, p_xfer_desc->p_tx_buffer[1]);
00003a  6828              LDR      r0,[r5,#0]
00003c  7841              LDRB     r1,[r0,#1]
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       nrf_spi_txd_set
000044  e006              B        |L16.84|
                  |L16.70|
;;;404        }
;;;405        else if (p_xfer_desc->rx_length > 1)
000046  7b28              LDRB     r0,[r5,#0xc]
000048  2801              CMP      r0,#1
00004a  dd03              BLE      |L16.84|
;;;406        {
;;;407            nrf_spi_txd_set(p_spi, p_cb->orc);
00004c  7ee1              LDRB     r1,[r4,#0x1b]
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       nrf_spi_txd_set
                  |L16.84|
;;;408        }
;;;409    
;;;410        // For blocking mode (user handler not provided) wait here for READY
;;;411        // events (indicating that the byte from TXD register was transmitted
;;;412        // and a new incoming byte was moved to the RXD register) and continue
;;;413        // transaction until all requested bytes are transferred.
;;;414        // In non-blocking mode - IRQ service routine will do this stuff.
;;;415        if (p_cb->handler)
000054  6820              LDR      r0,[r4,#0]
000056  b120              CBZ      r0,|L16.98|
;;;416        {
;;;417            nrf_spi_int_enable(p_spi, NRF_SPI_INT_READY_MASK);
000058  2104              MOVS     r1,#4
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       nrf_spi_int_enable
000060  e01c              B        |L16.156|
                  |L16.98|
;;;418        }
;;;419        else
;;;420        {
;;;421            do {
000062  bf00              NOP      
                  |L16.100|
;;;422                while (!nrf_spi_event_check(p_spi, NRF_SPI_EVENT_READY)) {}
000064  bf00              NOP      
                  |L16.102|
000066  4630              MOV      r0,r6
000068  f44f7184          MOV      r1,#0x108
00006c  5842              LDR      r2,[r0,r1]
00006e  b10a              CBZ      r2,|L16.116|
000070  2201              MOVS     r2,#1
000072  e000              B        |L16.118|
                  |L16.116|
000074  2200              MOVS     r2,#0
                  |L16.118|
000076  2a00              CMP      r2,#0
000078  d0f5              BEQ      |L16.102|
;;;423                nrf_spi_event_clear(p_spi, NRF_SPI_EVENT_READY);
00007a  f44f7184          MOV      r1,#0x108
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       nrf_spi_event_clear
;;;424            } while (transfer_byte(p_spi, p_cb));
000084  4621              MOV      r1,r4
000086  4630              MOV      r0,r6
000088  f7fffffe          BL       transfer_byte
00008c  2800              CMP      r0,#0
00008e  d1e9              BNE      |L16.100|
;;;425            if (p_cb->ss_pin != NRF_DRV_SPI_PIN_NOT_USED)
000090  7ea0              LDRB     r0,[r4,#0x1a]
000092  28ff              CMP      r0,#0xff
000094  d002              BEQ      |L16.156|
;;;426            {
;;;427                nrf_gpio_pin_set(p_cb->ss_pin);
000096  7ea0              LDRB     r0,[r4,#0x1a]
000098  f7fffffe          BL       nrf_gpio_pin_set
                  |L16.156|
;;;428            }
;;;429        }
;;;430    }
00009c  bd70              POP      {r4-r6,pc}
;;;431    #endif // SPI_IN_USE
                          ENDP


                          AREA ||i.transfer_byte||, CODE, READONLY, ALIGN=1

                  transfer_byte PROC
;;;345    // there is nothing more to send/receive) it returns false.
;;;346    static bool transfer_byte(NRF_SPI_Type * p_spi, spi_control_block_t * p_cb)
000000  b5f8              PUSH     {r3-r7,lr}
;;;347    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;348        // Read the data byte received in this transfer and store it in RX buffer,
;;;349        // if needed.
;;;350        volatile uint8_t rx_data = nrf_spi_rxd_get(p_spi);
000006  bf00              NOP      
000008  f8d60518          LDR      r0,[r6,#0x518]
00000c  b2c0              UXTB     r0,r0
00000e  9000              STR      r0,[sp,#0]
;;;351        if (p_cb->bytes_transferred < p_cb->evt.data.done.rx_length)
000010  7f21              LDRB     r1,[r4,#0x1c]
000012  7d20              LDRB     r0,[r4,#0x14]
000014  4281              CMP      r1,r0
000016  da04              BGE      |L17.34|
;;;352        {
;;;353            p_cb->evt.data.done.p_rx_buffer[p_cb->bytes_transferred] = rx_data;
000018  f89d1000          LDRB     r1,[sp,#0]
00001c  7f22              LDRB     r2,[r4,#0x1c]
00001e  6920              LDR      r0,[r4,#0x10]
000020  5481              STRB     r1,[r0,r2]
                  |L17.34|
;;;354        }
;;;355    
;;;356        ++p_cb->bytes_transferred;
000022  7f20              LDRB     r0,[r4,#0x1c]
000024  1c40              ADDS     r0,r0,#1
000026  7720              STRB     r0,[r4,#0x1c]
;;;357    
;;;358        // Check if there are more bytes to send or receive and write proper data
;;;359        // byte (next one from TX buffer or over-run character) to the TXD register
;;;360        // when needed.
;;;361        // NOTE - we've already used 'p_cb->bytes_transferred + 1' bytes from our
;;;362        //        buffers, because we take advantage of double buffering of TXD
;;;363        //        register (so in effect one byte is still being transmitted now);
;;;364        //        see how the transfer is started in the 'nrf_drv_spi_transfer'
;;;365        //        function.
;;;366        uint16_t bytes_used = p_cb->bytes_transferred + 1;
000028  7f20              LDRB     r0,[r4,#0x1c]
00002a  1c45              ADDS     r5,r0,#1
;;;367        if (bytes_used < p_cb->evt.data.done.tx_length)
00002c  7b20              LDRB     r0,[r4,#0xc]
00002e  42a8              CMP      r0,r5
000030  dd06              BLE      |L17.64|
;;;368        {
;;;369            nrf_spi_txd_set(p_spi, p_cb->evt.data.done.p_tx_buffer[bytes_used]);
000032  68a0              LDR      r0,[r4,#8]
000034  5d41              LDRB     r1,[r0,r5]
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       nrf_spi_txd_set
;;;370            return true;
00003c  2001              MOVS     r0,#1
                  |L17.62|
;;;371        }
;;;372        else if (bytes_used < p_cb->evt.data.done.rx_length)
;;;373        {
;;;374            nrf_spi_txd_set(p_spi, p_cb->orc);
;;;375            return true;
;;;376        }
;;;377    
;;;378        return (p_cb->bytes_transferred < p_cb->evt.data.done.tx_length ||
;;;379                p_cb->bytes_transferred < p_cb->evt.data.done.rx_length);
;;;380    }
00003e  bdf8              POP      {r3-r7,pc}
                  |L17.64|
000040  7d20              LDRB     r0,[r4,#0x14]         ;372
000042  42a8              CMP      r0,r5                 ;372
000044  dd05              BLE      |L17.82|
000046  7ee1              LDRB     r1,[r4,#0x1b]         ;374
000048  4630              MOV      r0,r6                 ;374
00004a  f7fffffe          BL       nrf_spi_txd_set
00004e  2001              MOVS     r0,#1                 ;375
000050  e7f5              B        |L17.62|
                  |L17.82|
000052  7f21              LDRB     r1,[r4,#0x1c]         ;378
000054  7b20              LDRB     r0,[r4,#0xc]          ;378
000056  4281              CMP      r1,r0                 ;378
000058  db03              BLT      |L17.98|
00005a  7f21              LDRB     r1,[r4,#0x1c]         ;379
00005c  7d20              LDRB     r0,[r4,#0x14]         ;379
00005e  4281              CMP      r1,r0                 ;379
000060  da01              BGE      |L17.102|
                  |L17.98|
000062  2001              MOVS     r0,#1                 ;379
000064  e7eb              B        |L17.62|
                  |L17.102|
000066  2000              MOVS     r0,#0                 ;379
000068  e7e9              B        |L17.62|
;;;381    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_cb
                          %        32

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\spi_master\\nrf_drv_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_nrf_drv_spi_c_66dec11a____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_nrf_drv_spi_c_66dec11a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_nrf_drv_spi_c_66dec11a____REVSH|
#line 402
|__asm___13_nrf_drv_spi_c_66dec11a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_nrf_drv_spi_c_66dec11a____RRX|
#line 587
|__asm___13_nrf_drv_spi_c_66dec11a____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
