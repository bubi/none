; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\id_manager.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\id_manager.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\id_manager.crf ..\..\..\..\..\..\components\ble\peer_manager\id_manager.c]
                          THUMB

                          AREA ||i.addr_compare||, CODE, READONLY, ALIGN=1

                  addr_compare PROC
;;;207     */
;;;208    bool addr_compare(ble_gap_addr_t const * p_addr1, ble_gap_addr_t const * p_addr2)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;210        // @note emdi: use NRF_PM_DEBUG_CHECK ?
;;;211        if ((p_addr1 == NULL) || (p_addr2 == NULL))
000006  b105              CBZ      r5,|L1.10|
000008  b90c              CBNZ     r4,|L1.14|
                  |L1.10|
;;;212        {
;;;213            return false;
00000a  2000              MOVS     r0,#0
                  |L1.12|
;;;214        }
;;;215    
;;;216        // Check that the addr type is identical, return false if it is not
;;;217        if (p_addr1->addr_type != p_addr2->addr_type)
;;;218        {
;;;219            return false;
;;;220        }
;;;221        // Check if the addr bytes are is identical
;;;222        return (memcmp(p_addr1->addr, p_addr2->addr, BLE_GAP_ADDR_LEN) == 0);
;;;223    }
00000c  bd70              POP      {r4-r6,pc}
                  |L1.14|
00000e  7828              LDRB     r0,[r5,#0]            ;217
000010  0840              LSRS     r0,r0,#1              ;217
000012  7821              LDRB     r1,[r4,#0]            ;217
000014  ebb00f51          CMP      r0,r1,LSR #1          ;217
000018  d001              BEQ      |L1.30|
00001a  2000              MOVS     r0,#0                 ;219
00001c  e7f6              B        |L1.12|
                  |L1.30|
00001e  2206              MOVS     r2,#6                 ;222
000020  1c61              ADDS     r1,r4,#1              ;222
000022  1c68              ADDS     r0,r5,#1              ;222
000024  f7fffffe          BL       memcmp
000028  b908              CBNZ     r0,|L1.46|
00002a  2001              MOVS     r0,#1                 ;222
00002c  e7ee              B        |L1.12|
                  |L1.46|
00002e  2000              MOVS     r0,#0                 ;222
000030  e7ec              B        |L1.12|
;;;224    
                          ENDP


                          AREA ||i.ah||, CODE, READONLY, ALIGN=1

                  ||ah|| PROC
;;;1022    */
;;;1023   void ah(uint8_t const * p_k, uint8_t const * p_r, uint8_t * p_local_hash)
000000  b570              PUSH     {r4-r6,lr}
;;;1024   {
000002  b08c              SUB      sp,sp,#0x30
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1025       nrf_ecb_hal_data_t ecb_hal_data;
;;;1026   
;;;1027       for (uint32_t i = 0; i < SOC_ECB_KEY_LENGTH; i++)
00000a  2000              MOVS     r0,#0
00000c  e005              B        |L2.26|
                  |L2.14|
;;;1028       {
;;;1029           ecb_hal_data.key[i] = p_k[SOC_ECB_KEY_LENGTH - 1 - i];
00000e  f1c0010f          RSB      r1,r0,#0xf
000012  5c61              LDRB     r1,[r4,r1]
000014  f80d1000          STRB     r1,[sp,r0]
000018  1c40              ADDS     r0,r0,#1              ;1027
                  |L2.26|
00001a  2810              CMP      r0,#0x10              ;1027
00001c  d3f7              BCC      |L2.14|
;;;1030       }
;;;1031   
;;;1032       memset(ecb_hal_data.cleartext, 0, SOC_ECB_KEY_LENGTH - IM_ADDR_CLEARTEXT_LENGTH);
00001e  210d              MOVS     r1,#0xd
000020  a804              ADD      r0,sp,#0x10
000022  f7fffffe          BL       __aeabi_memclr4
;;;1033   
;;;1034       for (uint32_t i = 0; i < IM_ADDR_CLEARTEXT_LENGTH; i++)
000026  2000              MOVS     r0,#0
000028  e005              B        |L2.54|
                  |L2.42|
;;;1035       {
;;;1036           ecb_hal_data.cleartext[SOC_ECB_KEY_LENGTH - 1 - i] = p_r[i];
00002a  5c2a              LDRB     r2,[r5,r0]
00002c  f1c0030f          RSB      r3,r0,#0xf
000030  a904              ADD      r1,sp,#0x10
000032  54ca              STRB     r2,[r1,r3]
000034  1c40              ADDS     r0,r0,#1              ;1034
                  |L2.54|
000036  2803              CMP      r0,#3                 ;1034
000038  d3f7              BCC      |L2.42|
;;;1037       }
;;;1038   
;;;1039       // Can only return NRF_SUCCESS.
;;;1040       (void) sd_ecb_block_encrypt(&ecb_hal_data);
00003a  4668              MOV      r0,sp
00003c  df43              SVC      #0x43
;;;1041   
;;;1042       for (uint32_t i = 0; i < IM_ADDR_CIPHERTEXT_LENGTH; i++)
00003e  2000              MOVS     r0,#0
000040  e005              B        |L2.78|
                  |L2.66|
;;;1043       {
;;;1044           p_local_hash[i] = ecb_hal_data.ciphertext[SOC_ECB_KEY_LENGTH - 1 - i];
000042  f1c0020f          RSB      r2,r0,#0xf
000046  a908              ADD      r1,sp,#0x20
000048  5c89              LDRB     r1,[r1,r2]
00004a  5431              STRB     r1,[r6,r0]
00004c  1c40              ADDS     r0,r0,#1              ;1042
                  |L2.78|
00004e  2803              CMP      r0,#3                 ;1042
000050  d3f7              BCC      |L2.66|
;;;1045       }
;;;1046   }
000052  b00c              ADD      sp,sp,#0x30
000054  bd70              POP      {r4-r6,pc}
;;;1047   
                          ENDP


                          AREA ||i.evt_send||, CODE, READONLY, ALIGN=2

                  evt_send PROC
;;;83      */
;;;84     static void evt_send(im_evt_t * p_event)
000000  b570              PUSH     {r4-r6,lr}
;;;85     {
000002  4605              MOV      r5,r0
;;;86         for (uint32_t i = 0; i < IM_EVENT_HANDLERS_CNT; i++)
000004  2400              MOVS     r4,#0
000006  e005              B        |L3.20|
                  |L3.8|
;;;87         {
;;;88             m_evt_handlers[i](p_event);
000008  4804              LDR      r0,|L3.28|
00000a  f8501024          LDR      r1,[r0,r4,LSL #2]
00000e  4628              MOV      r0,r5
000010  4788              BLX      r1
000012  1c64              ADDS     r4,r4,#1              ;86
                  |L3.20|
000014  2c02              CMP      r4,#2                 ;86
000016  d3f7              BCC      |L3.8|
;;;89         }
;;;90     }
000018  bd70              POP      {r4-r6,pc}
;;;91     
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      m_evt_handlers

                          AREA ||i.get_connection_by_conn_handle||, CODE, READONLY, ALIGN=2

                  get_connection_by_conn_handle PROC
;;;123     */
;;;124    uint8_t get_connection_by_conn_handle(uint16_t conn_handle)
000000  b510              PUSH     {r4,lr}
;;;125    {
000002  4604              MOV      r4,r0
;;;126        if (ble_conn_state_user_flag_get(conn_handle, m_conn_state_user_flag_id))
000004  480b              LDR      r0,|L4.52|
000006  7801              LDRB     r1,[r0,#0]  ; m_conn_state_user_flag_id
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       ble_conn_state_user_flag_get
00000e  b170              CBZ      r0,|L4.46|
;;;127        {
;;;128            for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000010  2100              MOVS     r1,#0
000012  e00a              B        |L4.42|
                  |L4.20|
;;;129            {
;;;130                if (m_connections[i].conn_handle == conn_handle)
000014  eb010041          ADD      r0,r1,r1,LSL #1
000018  4a07              LDR      r2,|L4.56|
00001a  eb020080          ADD      r0,r2,r0,LSL #2
00001e  8840              LDRH     r0,[r0,#2]
000020  42a0              CMP      r0,r4
000022  d101              BNE      |L4.40|
;;;131                {
;;;132                    return i;
000024  b2c8              UXTB     r0,r1
                  |L4.38|
;;;133                }
;;;134            }
;;;135        }
;;;136        // If all connection handles belong to a valid connection, return IM_NO_INVALID_CONN_HANDLES.
;;;137        return IM_NO_INVALID_CONN_HANDLES;
;;;138    }
000026  bd10              POP      {r4,pc}
                  |L4.40|
000028  1c49              ADDS     r1,r1,#1              ;128
                  |L4.42|
00002a  2908              CMP      r1,#8                 ;128
00002c  d3f2              BCC      |L4.20|
                  |L4.46|
00002e  20ff              MOVS     r0,#0xff              ;137
000030  e7f9              B        |L4.38|
;;;139    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      m_conn_state_user_flag_id
                  |L4.56|
                          DCD      m_connections

                          AREA ||i.get_free_connection||, CODE, READONLY, ALIGN=2

                  get_free_connection PROC
;;;100     */
;;;101    uint8_t get_free_connection()
000000  b510              PUSH     {r4,lr}
;;;102    {
;;;103        for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000002  2400              MOVS     r4,#0
000004  e00d              B        |L5.34|
                  |L5.6|
;;;104        {
;;;105            // Query the connection state module to check if the
;;;106            // connection handle does not belong to a valid connection.
;;;107            if (!ble_conn_state_user_flag_get(m_connections[i].conn_handle, m_conn_state_user_flag_id))
000006  eb040144          ADD      r1,r4,r4,LSL #1
00000a  4a08              LDR      r2,|L5.44|
00000c  eb020181          ADD      r1,r2,r1,LSL #2
000010  8848              LDRH     r0,[r1,#2]
000012  4907              LDR      r1,|L5.48|
000014  7809              LDRB     r1,[r1,#0]  ; m_conn_state_user_flag_id
000016  f7fffffe          BL       ble_conn_state_user_flag_get
00001a  b908              CBNZ     r0,|L5.32|
;;;108            {
;;;109                return i;
00001c  b2e0              UXTB     r0,r4
                  |L5.30|
;;;110            }
;;;111        }
;;;112        // If all connection handles belong to a valid connection, return IM_NO_INVALID_CONN_HANDLES.
;;;113        return IM_NO_INVALID_CONN_HANDLES;
;;;114    }
00001e  bd10              POP      {r4,pc}
                  |L5.32|
000020  1c64              ADDS     r4,r4,#1              ;103
                  |L5.34|
000022  2c08              CMP      r4,#8                 ;103
000024  d3ef              BCC      |L5.6|
000026  20ff              MOVS     r0,#0xff              ;113
000028  e7f9              B        |L5.30|
;;;115    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      m_connections
                  |L5.48|
                          DCD      m_conn_state_user_flag_id

                          AREA ||i.im_address_resolve||, CODE, READONLY, ALIGN=1

                  im_address_resolve PROC
;;;1048   
;;;1049   bool im_address_resolve(ble_gap_addr_t const * p_addr, ble_gap_irk_t const * p_irk)
000000  b53e              PUSH     {r1-r5,lr}
;;;1050   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1051       NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;1052   
;;;1053       uint8_t hash[IM_ADDR_CIPHERTEXT_LENGTH];
;;;1054       uint8_t local_hash[IM_ADDR_CIPHERTEXT_LENGTH];
;;;1055       uint8_t prand[IM_ADDR_CLEARTEXT_LENGTH];
;;;1056   
;;;1057       if (p_addr->addr_type != BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE)
000006  7820              LDRB     r0,[r4,#0]
000008  2102              MOVS     r1,#2
00000a  ebb10f50          CMP      r1,r0,LSR #1
00000e  d001              BEQ      |L6.20|
;;;1058       {
;;;1059           return false;
000010  2000              MOVS     r0,#0
                  |L6.18|
;;;1060       }
;;;1061   
;;;1062       memcpy(hash, p_addr->addr, IM_ADDR_CIPHERTEXT_LENGTH);
;;;1063       memcpy(prand, &p_addr->addr[IM_ADDR_CIPHERTEXT_LENGTH], IM_ADDR_CLEARTEXT_LENGTH);
;;;1064       ah(p_irk->irk, prand, local_hash);
;;;1065   
;;;1066       return (memcmp(hash, local_hash, IM_ADDR_CIPHERTEXT_LENGTH) == 0);
;;;1067   }
000012  bd3e              POP      {r1-r5,pc}
                  |L6.20|
000014  f8b40001          LDRH     r0,[r4,#1]            ;1062
000018  f8ad0008          STRH     r0,[sp,#8]            ;1062
00001c  78e0              LDRB     r0,[r4,#3]            ;1062
00001e  f88d000a          STRB     r0,[sp,#0xa]          ;1062
000022  88a1              LDRH     r1,[r4,#4]            ;1063
000024  f8ad1000          STRH     r1,[sp,#0]            ;1063
000028  79a0              LDRB     r0,[r4,#6]            ;1063
00002a  f88d0002          STRB     r0,[sp,#2]            ;1063
00002e  aa01              ADD      r2,sp,#4              ;1064
000030  4669              MOV      r1,sp                 ;1064
000032  4628              MOV      r0,r5                 ;1064
000034  f7fffffe          BL       ||ah||
000038  2203              MOVS     r2,#3                 ;1066
00003a  a901              ADD      r1,sp,#4              ;1066
00003c  a802              ADD      r0,sp,#8              ;1066
00003e  f7fffffe          BL       memcmp
000042  b908              CBNZ     r0,|L6.72|
000044  2001              MOVS     r0,#1                 ;1066
000046  e7e4              B        |L6.18|
                  |L6.72|
000048  2000              MOVS     r0,#0                 ;1066
00004a  e7e2              B        |L6.18|
;;;1068   #endif //PEER_MANAGER_ENABLED
                          ENDP


                          AREA ||i.im_ble_addr_get||, CODE, READONLY, ALIGN=2

                  im_ble_addr_get PROC
;;;441    
;;;442    ret_code_t im_ble_addr_get(uint16_t conn_handle, ble_gap_addr_t * p_ble_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;443    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;444        uint8_t conn_index;
;;;445    
;;;446        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;447        NRF_PM_DEBUG_CHECK(p_ble_addr != NULL);
;;;448    
;;;449        conn_index = get_connection_by_conn_handle(conn_handle);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       get_connection_by_conn_handle
00000c  4605              MOV      r5,r0
;;;450    
;;;451        if (conn_index != IM_NO_INVALID_CONN_HANDLES)
00000e  2dff              CMP      r5,#0xff
000010  d00c              BEQ      |L7.44|
;;;452        {
;;;453            *p_ble_addr = m_connections[conn_index].peer_address;
000012  eb050045          ADD      r0,r5,r5,LSL #1
000016  4906              LDR      r1,|L7.48|
000018  eb010080          ADD      r0,r1,r0,LSL #2
00001c  6841              LDR      r1,[r0,#4]
00001e  6021              STR      r1,[r4,#0]
000020  8901              LDRH     r1,[r0,#8]
000022  80a1              STRH     r1,[r4,#4]
000024  7a80              LDRB     r0,[r0,#0xa]
000026  71a0              STRB     r0,[r4,#6]
;;;454            return NRF_SUCCESS;
000028  2000              MOVS     r0,#0
                  |L7.42|
;;;455        }
;;;456    
;;;457        return NRF_ERROR_NOT_FOUND;
;;;458    }
00002a  bd70              POP      {r4-r6,pc}
                  |L7.44|
00002c  2005              MOVS     r0,#5                 ;457
00002e  e7fc              B        |L7.42|
;;;459    
                          ENDP

                  |L7.48|
                          DCD      m_connections

                          AREA ||i.im_ble_evt_handler||, CODE, READONLY, ALIGN=1

                  im_ble_evt_handler PROC
;;;225    
;;;226    void im_ble_evt_handler(ble_evt_t * ble_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;227    {
000002  b090              SUB      sp,sp,#0x40
000004  4604              MOV      r4,r0
;;;228        ble_gap_evt_t gap_evt;
;;;229        pm_peer_id_t  bonded_matching_peer_id;
;;;230    
;;;231        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;232    
;;;233        if (ble_evt->header.evt_id != BLE_GAP_EVT_CONNECTED)
000006  8820              LDRH     r0,[r4,#0]
000008  2810              CMP      r0,#0x10
00000a  d001              BEQ      |L8.16|
                  |L8.12|
;;;234        {
;;;235            // Nothing to do.
;;;236            return;
;;;237        }
;;;238    
;;;239        gap_evt                 = ble_evt->evt.gap_evt;
;;;240        bonded_matching_peer_id = PM_PEER_ID_INVALID;
;;;241    
;;;242        if (   gap_evt.params.connected.peer_addr.addr_type
;;;243            != BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE)
;;;244        {
;;;245            /* Search the database for bonding data matching the one that triggered the event.
;;;246             * Public and static addresses can be matched on address alone, while resolvable
;;;247             * random addresses can be resolved agains known IRKs. Non-resolvable random addresses
;;;248             * are never matching because they are not longterm form of identification.
;;;249             */
;;;250    
;;;251            pm_peer_id_t         peer_id;
;;;252            pm_peer_data_flash_t peer_data;
;;;253    
;;;254            pds_peer_data_iterate_prepare();
;;;255    
;;;256            switch (gap_evt.params.connected.peer_addr.addr_type)
;;;257            {
;;;258                case BLE_GAP_ADDR_TYPE_PUBLIC:
;;;259                case BLE_GAP_ADDR_TYPE_RANDOM_STATIC:
;;;260                {
;;;261                    while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data))
;;;262                    {
;;;263                        if (addr_compare(&gap_evt.params.connected.peer_addr,
;;;264                                         &peer_data.p_bonding_data->peer_id.id_addr_info))
;;;265                        {
;;;266                            bonded_matching_peer_id = peer_id;
;;;267                            break;
;;;268                        }
;;;269                    }
;;;270                }
;;;271                break;
;;;272    
;;;273                case BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE:
;;;274                {
;;;275                    while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data))
;;;276                    {
;;;277                        if (im_address_resolve(&gap_evt.params.connected.peer_addr,
;;;278                                               &peer_data.p_bonding_data->peer_id.id_info))
;;;279                        {
;;;280                            bonded_matching_peer_id = peer_id;
;;;281                            break;
;;;282                        }
;;;283                    }
;;;284                }
;;;285                break;
;;;286    
;;;287                default:
;;;288                    NRF_PM_DEBUG_CHECK(false);
;;;289                    break;
;;;290            }
;;;291        }
;;;292    
;;;293        uint8_t new_index = new_connection(gap_evt.conn_handle,
;;;294                                           &gap_evt.params.connected.peer_addr);
;;;295        UNUSED_VARIABLE(new_index);
;;;296    
;;;297        if (bonded_matching_peer_id != PM_PEER_ID_INVALID)
;;;298        {
;;;299            im_new_peer_id(gap_evt.conn_handle, bonded_matching_peer_id);
;;;300    
;;;301            // Send a bonded peer event
;;;302            im_evt_t im_evt;
;;;303            im_evt.conn_handle = gap_evt.conn_handle;
;;;304            im_evt.evt_id      = IM_EVT_BONDED_PEER_CONNECTED;
;;;305            evt_send(&im_evt);
;;;306        }
;;;307    }
00000c  b010              ADD      sp,sp,#0x40
00000e  bd70              POP      {r4-r6,pc}
                  |L8.16|
000010  2234              MOVS     r2,#0x34              ;239
000012  1d21              ADDS     r1,r4,#4              ;239
000014  a803              ADD      r0,sp,#0xc            ;239
000016  f7fffffe          BL       __aeabi_memcpy4
00001a  f64f75ff          MOV      r5,#0xffff            ;240
00001e  f89d0010          LDRB     r0,[sp,#0x10]         ;242
000022  2103              MOVS     r1,#3                 ;242
000024  ebb10f50          CMP      r1,r0,LSR #1          ;242
000028  d035              BEQ      |L8.150|
00002a  f7fffffe          BL       pds_peer_data_iterate_prepare
00002e  f89d0010          LDRB     r0,[sp,#0x10]         ;256
000032  0840              LSRS     r0,r0,#1              ;256
000034  b120              CBZ      r0,|L8.64|
000036  2801              CMP      r0,#1                 ;256
000038  d003              BEQ      |L8.66|
00003a  2802              CMP      r0,#2                 ;256
00003c  d128              BNE      |L8.144|
00003e  e014              B        |L8.106|
                  |L8.64|
000040  bf00              NOP                            ;259
                  |L8.66|
000042  e009              B        |L8.88|
                  |L8.68|
000044  9801              LDR      r0,[sp,#4]            ;263
000046  f1000111          ADD      r1,r0,#0x11           ;263
00004a  a804              ADD      r0,sp,#0x10           ;263
00004c  f7fffffe          BL       addr_compare
000050  b110              CBZ      r0,|L8.88|
000052  f8bd5008          LDRH     r5,[sp,#8]            ;266
000056  e006              B        |L8.102|
                  |L8.88|
000058  466a              MOV      r2,sp                 ;261
00005a  a902              ADD      r1,sp,#8              ;261
00005c  2007              MOVS     r0,#7                 ;261
00005e  f7fffffe          BL       pds_peer_data_iterate
000062  2800              CMP      r0,#0                 ;261
000064  d1ee              BNE      |L8.68|
                  |L8.102|
000066  bf00              NOP                            ;267
000068  e013              B        |L8.146|
                  |L8.106|
00006a  e008              B        |L8.126|
                  |L8.108|
00006c  9801              LDR      r0,[sp,#4]            ;277
00006e  1c41              ADDS     r1,r0,#1              ;277
000070  a804              ADD      r0,sp,#0x10           ;277
000072  f7fffffe          BL       im_address_resolve
000076  b110              CBZ      r0,|L8.126|
000078  f8bd5008          LDRH     r5,[sp,#8]            ;280
00007c  e006              B        |L8.140|
                  |L8.126|
00007e  466a              MOV      r2,sp                 ;275
000080  a902              ADD      r1,sp,#8              ;275
000082  2007              MOVS     r0,#7                 ;275
000084  f7fffffe          BL       pds_peer_data_iterate
000088  2800              CMP      r0,#0                 ;275
00008a  d1ef              BNE      |L8.108|
                  |L8.140|
00008c  bf00              NOP                            ;281
00008e  e000              B        |L8.146|
                  |L8.144|
000090  bf00              NOP                            ;289
                  |L8.146|
000092  bf00              NOP                            ;271
000094  bf00              NOP                            ;291
                  |L8.150|
000096  f8bd000c          LDRH     r0,[sp,#0xc]          ;293
00009a  a904              ADD      r1,sp,#0x10           ;293
00009c  f7fffffe          BL       new_connection
0000a0  4606              MOV      r6,r0                 ;293
0000a2  f64f70ff          MOV      r0,#0xffff            ;297
0000a6  4285              CMP      r5,r0                 ;297
0000a8  d00f              BEQ      |L8.202|
0000aa  f8bd000c          LDRH     r0,[sp,#0xc]          ;299
0000ae  4629              MOV      r1,r5                 ;299
0000b0  f7fffffe          BL       im_new_peer_id
0000b4  f8bd000c          LDRH     r0,[sp,#0xc]          ;303
0000b8  f8ad0006          STRH     r0,[sp,#6]            ;303
0000bc  2001              MOVS     r0,#1                 ;304
0000be  f88d0004          STRB     r0,[sp,#4]            ;304
0000c2  a801              ADD      r0,sp,#4              ;305
0000c4  f7fffffe          BL       evt_send
0000c8  bf00              NOP                            ;306
                  |L8.202|
0000ca  bf00              NOP      
0000cc  e79e              B        |L8.12|
;;;308    
                          ENDP


                          AREA ||i.im_conn_handle_get||, CODE, READONLY, ALIGN=2

                  im_conn_handle_get PROC
;;;507    
;;;508    uint16_t im_conn_handle_get(pm_peer_id_t peer_id)
000000  4602              MOV      r2,r0
;;;509    {
;;;510        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;511    
;;;512        for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000002  2100              MOVS     r1,#0
000004  e00d              B        |L9.34|
                  |L9.6|
;;;513        {
;;;514            if (peer_id == m_connections[i].peer_id)
000006  eb010041          ADD      r0,r1,r1,LSL #1
00000a  4b08              LDR      r3,|L9.44|
00000c  f8330020          LDRH     r0,[r3,r0,LSL #2]
000010  4290              CMP      r0,r2
000012  d105              BNE      |L9.32|
;;;515            {
;;;516                return m_connections[i].conn_handle;
000014  eb010041          ADD      r0,r1,r1,LSL #1
000018  eb030080          ADD      r0,r3,r0,LSL #2
00001c  8840              LDRH     r0,[r0,#2]
                  |L9.30|
;;;517            }
;;;518        }
;;;519        return BLE_CONN_HANDLE_INVALID;
;;;520    }
00001e  4770              BX       lr
                  |L9.32|
000020  1c49              ADDS     r1,r1,#1              ;512
                  |L9.34|
000022  2908              CMP      r1,#8                 ;512
000024  d3ef              BCC      |L9.6|
000026  f64f70ff          MOV      r0,#0xffff            ;519
00002a  e7f8              B        |L9.30|
;;;521    
                          ENDP

                  |L9.44|
                          DCD      m_connections

                          AREA ||i.im_device_identities_list_set||, CODE, READONLY, ALIGN=1

                  im_device_identities_list_set PROC
;;;670    
;;;671    ret_code_t im_device_identities_list_set(pm_peer_id_t const * p_peers,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;672                                             uint32_t             peer_cnt)
;;;673    {
000004  b0ce              SUB      sp,sp,#0x138
000006  4607              MOV      r7,r0
000008  460c              MOV      r4,r1
;;;674        #if (NRF_SD_BLE_API_VERSION == 3)
;;;675    
;;;676            ret_code_t             ret;
;;;677            pm_peer_data_t         peer_data;
;;;678            pm_peer_data_bonding_t bond_data;
;;;679    
;;;680            ble_gap_id_key_t         keys[BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT];
;;;681            ble_gap_id_key_t const * key_ptrs[BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT];
;;;682    
;;;683            if ((p_peers == NULL) || (peer_cnt == 0))
00000a  b107              CBZ      r7,|L10.14|
00000c  b934              CBNZ     r4,|L10.28|
                  |L10.14|
;;;684            {
;;;685                // Clear the device identities list.
;;;686                return sd_ble_gap_device_identities_set(NULL, NULL, 0);
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4610              MOV      r0,r2
000014  df6f              SVC      #0x6f
                  |L10.22|
;;;687            }
;;;688    
;;;689            peer_data.p_bonding_data = &bond_data;
;;;690            uint32_t const buf_size  = sizeof(bond_data);
;;;691    
;;;692            memset(keys, 0x00, sizeof(keys));
;;;693            for (uint32_t i = 0; i < BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT; i++)
;;;694            {
;;;695                key_ptrs[i] = &keys[i];
;;;696            }
;;;697    
;;;698            for (uint32_t i = 0; i < peer_cnt; i++)
;;;699            {
;;;700                memset(&bond_data, 0x00, sizeof(bond_data));
;;;701    
;;;702                // Read peer data from flash.
;;;703                ret = pds_peer_data_read(p_peers[i], PM_PEER_DATA_ID_BONDING,
;;;704                                         &peer_data, &buf_size);
;;;705    
;;;706                if ((ret == NRF_ERROR_NOT_FOUND) || (ret == NRF_ERROR_INVALID_PARAM))
;;;707                {
;;;708                    // Peer data coulnd't be found in flash or peer ID is not valid.
;;;709                    return NRF_ERROR_NOT_FOUND;
;;;710                }
;;;711    
;;;712                uint8_t const addr_type = bond_data.peer_id.id_addr_info.addr_type;
;;;713    
;;;714                if ((addr_type != BLE_GAP_ADDR_TYPE_PUBLIC) &&
;;;715                    (addr_type != BLE_GAP_ADDR_TYPE_RANDOM_STATIC))
;;;716                {
;;;717                    // The address shared by the peer during bonding can't be whitelisted.
;;;718                    return BLE_ERROR_GAP_INVALID_BLE_ADDR;
;;;719                }
;;;720    
;;;721                // Copy data to the buffer.
;;;722                memcpy(&keys[i], &bond_data.peer_id, sizeof(ble_gap_id_key_t));
;;;723            }
;;;724    
;;;725            return sd_ble_gap_device_identities_set(key_ptrs, NULL, peer_cnt);
;;;726    
;;;727        #else
;;;728    
;;;729            return NRF_ERROR_NOT_SUPPORTED;
;;;730    
;;;731        #endif
;;;732    }
000016  b04e              ADD      sp,sp,#0x138
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L10.28|
00001c  a838              ADD      r0,sp,#0xe0           ;689
00001e  904d              STR      r0,[sp,#0x134]        ;689
000020  2050              MOVS     r0,#0x50              ;690
000022  9001              STR      r0,[sp,#4]            ;690
000024  21b8              MOVS     r1,#0xb8              ;692
000026  a80a              ADD      r0,sp,#0x28           ;692
000028  f7fffffe          BL       __aeabi_memclr4
00002c  2000              MOVS     r0,#0                 ;693
00002e  e009              B        |L10.68|
                  |L10.48|
000030  ebc001c0          RSB      r1,r0,r0,LSL #3       ;695
000034  eb011100          ADD      r1,r1,r0,LSL #4       ;695
000038  aa0a              ADD      r2,sp,#0x28           ;695
00003a  4411              ADD      r1,r1,r2              ;695
00003c  aa02              ADD      r2,sp,#8              ;695
00003e  f8421020          STR      r1,[r2,r0,LSL #2]     ;695
000042  1c40              ADDS     r0,r0,#1              ;693
                  |L10.68|
000044  2808              CMP      r0,#8                 ;693
000046  d3f3              BCC      |L10.48|
000048  2600              MOVS     r6,#0                 ;698
00004a  e02a              B        |L10.162|
                  |L10.76|
00004c  2150              MOVS     r1,#0x50              ;700
00004e  a838              ADD      r0,sp,#0xe0           ;700
000050  f7fffffe          BL       __aeabi_memclr4
000054  f8370016          LDRH     r0,[r7,r6,LSL #1]     ;703
000058  ab01              ADD      r3,sp,#4              ;703
00005a  aa4c              ADD      r2,sp,#0x130          ;703
00005c  2107              MOVS     r1,#7                 ;703
00005e  f7fffffe          BL       pds_peer_data_read
000062  4605              MOV      r5,r0                 ;703
000064  2d05              CMP      r5,#5                 ;706
000066  d001              BEQ      |L10.108|
000068  2d07              CMP      r5,#7                 ;706
00006a  d101              BNE      |L10.112|
                  |L10.108|
00006c  2005              MOVS     r0,#5                 ;709
00006e  e7d2              B        |L10.22|
                  |L10.112|
000070  a838              ADD      r0,sp,#0xe0           ;712
000072  7c40              LDRB     r0,[r0,#0x11]         ;712
000074  ea4f0850          LSR      r8,r0,#1              ;712
000078  f1b80f00          CMP      r8,#0                 ;714
00007c  d005              BEQ      |L10.138|
00007e  f1b80f01          CMP      r8,#1                 ;715
000082  d002              BEQ      |L10.138|
000084  f2432002          MOV      r0,#0x3202            ;718
000088  e7c5              B        |L10.22|
                  |L10.138|
00008a  ebc601c6          RSB      r1,r6,r6,LSL #3       ;722
00008e  eb011106          ADD      r1,r1,r6,LSL #4       ;722
000092  aa0a              ADD      r2,sp,#0x28           ;722
000094  1888              ADDS     r0,r1,r2              ;722
000096  2217              MOVS     r2,#0x17              ;722
000098  f10d01e1          ADD      r1,sp,#0xe1           ;722
00009c  f7fffffe          BL       __aeabi_memcpy
0000a0  1c76              ADDS     r6,r6,#1              ;698
                  |L10.162|
0000a2  42a6              CMP      r6,r4                 ;698
0000a4  d3d2              BCC      |L10.76|
0000a6  b2e2              UXTB     r2,r4                 ;725
0000a8  2100              MOVS     r1,#0                 ;725
0000aa  a802              ADD      r0,sp,#8              ;725
0000ac  df6f              SVC      #0x6f                 ;725
0000ae  e7b2              B        |L10.22|
;;;733    
                          ENDP


                          AREA ||i.im_id_addr_get||, CODE, READONLY, ALIGN=1

                  im_id_addr_get PROC
;;;800    
;;;801    ret_code_t im_id_addr_get(ble_gap_addr_t * p_addr)
000000  b510              PUSH     {r4,lr}
;;;802    {
000002  4604              MOV      r4,r0
;;;803        NRF_PM_DEBUG_CHECK(p_addr != NULL);
;;;804    
;;;805        #if (NRF_SD_BLE_API_VERSION == 2)
;;;806            memcpy(p_addr, &m_current_id_addr, sizeof(ble_gap_addr_t));
;;;807            return NRF_SUCCESS;
;;;808        #else
;;;809            return sd_ble_gap_addr_get(p_addr);
000004  4620              MOV      r0,r4
000006  df6d              SVC      #0x6d
;;;810        #endif
;;;811    }
000008  bd10              POP      {r4,pc}
;;;812    
                          ENDP


                          AREA ||i.im_id_addr_set||, CODE, READONLY, ALIGN=1

                  im_id_addr_set PROC
;;;759    
;;;760    ret_code_t im_id_addr_set(ble_gap_addr_t const * p_addr)
000000  b510              PUSH     {r4,lr}
;;;761    {
000002  4604              MOV      r4,r0
;;;762        #if (NRF_SD_BLE_API_VERSION == 2)
;;;763    
;;;764            ret_code_t     ret;
;;;765            ble_gap_addr_t current_addr;
;;;766    
;;;767            NRF_PM_DEBUG_CHECK(p_addr != NULL);
;;;768    
;;;769            (void) sd_ble_gap_address_get(&current_addr);
;;;770    
;;;771            ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_NONE, (ble_gap_addr_t *)p_addr);
;;;772            if (ret != NRF_SUCCESS)
;;;773            {
;;;774                return ret;
;;;775            }
;;;776    
;;;777            if (   current_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE
;;;778                || current_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE)
;;;779            {
;;;780                // If currently using privacy, it must be re-enabled.
;;;781                // We force AUTO when privacy is enabled.
;;;782                ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_AUTO, &current_addr);
;;;783                if (ret != NRF_SUCCESS)
;;;784                {
;;;785                    return ret;
;;;786                }
;;;787            }
;;;788    
;;;789            memcpy(&m_current_id_addr, p_addr, sizeof(ble_gap_addr_t));
;;;790    
;;;791            return NRF_SUCCESS;
;;;792    
;;;793        #else
;;;794    
;;;795            return sd_ble_gap_addr_set(p_addr);
000004  4620              MOV      r0,r4
000006  df6c              SVC      #0x6c
;;;796    
;;;797        #endif
;;;798    }
000008  bd10              POP      {r4,pc}
;;;799    
                          ENDP


                          AREA ||i.im_init||, CODE, READONLY, ALIGN=2

                  im_init PROC
;;;398    
;;;399    ret_code_t im_init(void)
000000  b510              PUSH     {r4,lr}
;;;400    {
;;;401        NRF_PM_DEBUG_CHECK(!m_module_initialized);
;;;402    
;;;403        internal_state_reset();
000002  f7fffffe          BL       internal_state_reset
;;;404    
;;;405        m_conn_state_user_flag_id = ble_conn_state_user_flag_acquire();
000006  f7fffffe          BL       ble_conn_state_user_flag_acquire
00000a  4906              LDR      r1,|L13.36|
00000c  7008              STRB     r0,[r1,#0]
;;;406        if (m_conn_state_user_flag_id == BLE_CONN_STATE_USER_FLAG_INVALID)
00000e  4608              MOV      r0,r1
000010  7800              LDRB     r0,[r0,#0]  ; m_conn_state_user_flag_id
000012  2818              CMP      r0,#0x18
000014  d101              BNE      |L13.26|
;;;407        {
;;;408            return NRF_ERROR_INTERNAL;
000016  2003              MOVS     r0,#3
                  |L13.24|
;;;409        }
;;;410    
;;;411        #if (NRF_SD_BLE_API_VERSION == 2)
;;;412            ret_code_t ret_code = sd_ble_gap_address_get(&m_current_id_addr);
;;;413            if (ret_code != NRF_SUCCESS)
;;;414            {
;;;415                return NRF_ERROR_INTERNAL;
;;;416            }
;;;417        #endif
;;;418    
;;;419        m_module_initialized = true;
;;;420    
;;;421        return NRF_SUCCESS;
;;;422    }
000018  bd10              POP      {r4,pc}
                  |L13.26|
00001a  2001              MOVS     r0,#1                 ;419
00001c  4902              LDR      r1,|L13.40|
00001e  7008              STRB     r0,[r1,#0]            ;419
000020  2000              MOVS     r0,#0                 ;421
000022  e7f9              B        |L13.24|
;;;423    
                          ENDP

                  |L13.36|
                          DCD      m_conn_state_user_flag_id
                  |L13.40|
                          DCD      m_module_initialized

                          AREA ||i.im_is_duplicate_bonding_data||, CODE, READONLY, ALIGN=1

                  im_is_duplicate_bonding_data PROC
;;;317     */
;;;318    bool im_is_duplicate_bonding_data(pm_peer_data_bonding_t const * p_bonding_data1,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;319                                      pm_peer_data_bonding_t const * p_bonding_data2)
;;;320    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;321        NRF_PM_DEBUG_CHECK(p_bonding_data1 != NULL);
;;;322        NRF_PM_DEBUG_CHECK(p_bonding_data2 != NULL);
;;;323    
;;;324        if (!is_valid_irk(&p_bonding_data1->peer_id.id_info))
000008  1c60              ADDS     r0,r4,#1
00000a  f7fffffe          BL       is_valid_irk
00000e  b910              CBNZ     r0,|L14.22|
;;;325        {
;;;326            return false;
000010  2000              MOVS     r0,#0
                  |L14.18|
;;;327        }
;;;328    
;;;329        bool duplicate_irk = (memcmp(p_bonding_data1->peer_id.id_info.irk,
;;;330                                     p_bonding_data2->peer_id.id_info.irk,
;;;331                                     BLE_GAP_SEC_KEY_LEN) == 0);
;;;332    
;;;333        bool duplicate_addr = addr_compare(&p_bonding_data1->peer_id.id_addr_info,
;;;334                                           &p_bonding_data2->peer_id.id_addr_info);
;;;335    
;;;336        return duplicate_irk || duplicate_addr;
;;;337    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L14.22|
000016  2210              MOVS     r2,#0x10              ;329
000018  1c69              ADDS     r1,r5,#1              ;329
00001a  1c60              ADDS     r0,r4,#1              ;329
00001c  f7fffffe          BL       memcmp
000020  b908              CBNZ     r0,|L14.38|
000022  2001              MOVS     r0,#1                 ;329
000024  e000              B        |L14.40|
                  |L14.38|
000026  2000              MOVS     r0,#0                 ;329
                  |L14.40|
000028  4607              MOV      r7,r0                 ;329
00002a  f1050111          ADD      r1,r5,#0x11           ;333
00002e  f1040011          ADD      r0,r4,#0x11           ;333
000032  f7fffffe          BL       addr_compare
000036  4606              MOV      r6,r0                 ;333
000038  b907              CBNZ     r7,|L14.60|
00003a  b10e              CBZ      r6,|L14.64|
                  |L14.60|
00003c  2001              MOVS     r0,#1                 ;336
00003e  e7e8              B        |L14.18|
                  |L14.64|
000040  2000              MOVS     r0,#0                 ;336
000042  e7e6              B        |L14.18|
;;;338    
                          ENDP


                          AREA ||i.im_master_id_is_valid||, CODE, READONLY, ALIGN=1

                  im_master_id_is_valid PROC
;;;522    
;;;523    bool im_master_id_is_valid(ble_gap_master_id_t const * p_master_id)
000000  4602              MOV      r2,r0
;;;524    {
;;;525        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;526    
;;;527        if (p_master_id->ediv != 0)
000002  8810              LDRH     r0,[r2,#0]
000004  b108              CBZ      r0,|L15.10|
;;;528        {
;;;529            return true;
000006  2001              MOVS     r0,#1
                  |L15.8|
;;;530        }
;;;531    
;;;532        for (uint32_t i = 0; i < BLE_GAP_SEC_RAND_LEN; i++)
;;;533        {
;;;534            if (p_master_id->rand[i] != 0)
;;;535            {
;;;536                return true;
;;;537            }
;;;538        }
;;;539        return false;
;;;540    }
000008  4770              BX       lr
                  |L15.10|
00000a  2100              MOVS     r1,#0                 ;532
00000c  e005              B        |L15.26|
                  |L15.14|
00000e  1c90              ADDS     r0,r2,#2              ;534
000010  5c40              LDRB     r0,[r0,r1]            ;534
000012  b108              CBZ      r0,|L15.24|
000014  2001              MOVS     r0,#1                 ;536
000016  e7f7              B        |L15.8|
                  |L15.24|
000018  1c49              ADDS     r1,r1,#1              ;532
                  |L15.26|
00001a  2908              CMP      r1,#8                 ;532
00001c  d3f7              BCC      |L15.14|
00001e  2000              MOVS     r0,#0                 ;539
000020  e7f2              B        |L15.8|
;;;541    
                          ENDP


                          AREA ||i.im_master_ids_compare||, CODE, READONLY, ALIGN=1

                  im_master_ids_compare PROC
;;;460    
;;;461    bool im_master_ids_compare(ble_gap_master_id_t const * p_master_id1,
000000  b570              PUSH     {r4-r6,lr}
;;;462                               ble_gap_master_id_t const * p_master_id2)
;;;463    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;464        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;465        NRF_PM_DEBUG_CHECK(p_master_id1 != NULL);
;;;466        NRF_PM_DEBUG_CHECK(p_master_id2 != NULL);
;;;467    
;;;468        if (!im_master_id_is_valid(p_master_id1))
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       im_master_id_is_valid
00000c  b908              CBNZ     r0,|L16.18|
;;;469        {
;;;470            return false;
00000e  2000              MOVS     r0,#0
                  |L16.16|
;;;471        }
;;;472    
;;;473        if (p_master_id1->ediv != p_master_id2->ediv)
;;;474        {
;;;475            return false;
;;;476        }
;;;477    
;;;478        return (memcmp(p_master_id1->rand, p_master_id2->rand, BLE_GAP_SEC_RAND_LEN) == 0);
;;;479    }
000010  bd70              POP      {r4-r6,pc}
                  |L16.18|
000012  8828              LDRH     r0,[r5,#0]            ;473
000014  8821              LDRH     r1,[r4,#0]            ;473
000016  4288              CMP      r0,r1                 ;473
000018  d001              BEQ      |L16.30|
00001a  2000              MOVS     r0,#0                 ;475
00001c  e7f8              B        |L16.16|
                  |L16.30|
00001e  2208              MOVS     r2,#8                 ;478
000020  1ca1              ADDS     r1,r4,#2              ;478
000022  1ca8              ADDS     r0,r5,#2              ;478
000024  f7fffffe          BL       memcmp
000028  b908              CBNZ     r0,|L16.46|
00002a  2001              MOVS     r0,#1                 ;478
00002c  e7f0              B        |L16.16|
                  |L16.46|
00002e  2000              MOVS     r0,#0                 ;478
000030  e7ee              B        |L16.16|
;;;480    
                          ENDP


                          AREA ||i.im_new_peer_id||, CODE, READONLY, ALIGN=1

                  im_new_peer_id PROC
;;;557    
;;;558    void im_new_peer_id(uint16_t conn_handle, pm_peer_id_t peer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;559    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;560        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;561    
;;;562        peer_id_set(conn_handle, peer_id);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       peer_id_set
;;;563    }
00000e  bd70              POP      {r4-r6,pc}
;;;564    
                          ENDP


                          AREA ||i.im_pdb_evt_handler||, CODE, READONLY, ALIGN=1

                  im_pdb_evt_handler PROC
;;;344     */
;;;345    void im_pdb_evt_handler(pdb_evt_t const * p_event)
000000  b530              PUSH     {r4,r5,lr}
;;;346    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;347        ret_code_t           ret;
;;;348        pm_peer_id_t         peer_id;
;;;349        pm_peer_data_flash_t peer_data;
;;;350        pm_peer_data_flash_t peer_data_duplicate;
;;;351    
;;;352        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;353        NRF_PM_DEBUG_CHECK(p_event != NULL);
;;;354    
;;;355        if ((p_event->evt_id  != PDB_EVT_WRITE_BUF_STORED) ||
000006  7820              LDRB     r0,[r4,#0]
000008  b910              CBNZ     r0,|L18.16|
;;;356            (p_event->data_id != PM_PEER_DATA_ID_BONDING))
00000a  7920              LDRB     r0,[r4,#4]
00000c  2807              CMP      r0,#7
00000e  d001              BEQ      |L18.20|
                  |L18.16|
;;;357        {
;;;358            return;
;;;359        }
;;;360    
;;;361        // If new data about peer id has been stored it is compared to other peers peer ids in
;;;362        // search of duplicates.
;;;363    
;;;364        ret = pdb_peer_data_ptr_get(p_event->peer_id, PM_PEER_DATA_ID_BONDING, &peer_data);
;;;365    
;;;366        if (ret != NRF_SUCCESS)
;;;367        {
;;;368            // @note emdi: this shouldn't happen, since the data was just stored, right?
;;;369            NRF_PM_DEBUG_CHECK(false);
;;;370            return;
;;;371        }
;;;372    
;;;373        pds_peer_data_iterate_prepare();
;;;374    
;;;375        while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data_duplicate))
;;;376        {
;;;377            if (p_event->peer_id == peer_id)
;;;378            {
;;;379                // Skip the iteration if the bonding data retrieved is for a peer
;;;380                // with the same ID as the one contained in the event.
;;;381                continue;
;;;382            }
;;;383    
;;;384            if (im_is_duplicate_bonding_data(peer_data.p_bonding_data,
;;;385                                             peer_data_duplicate.p_bonding_data))
;;;386            {
;;;387                im_evt_t im_evt;
;;;388                im_evt.conn_handle                   = im_conn_handle_get(p_event->peer_id);
;;;389                im_evt.evt_id                        = IM_EVT_DUPLICATE_ID;
;;;390                im_evt.params.duplicate_id.peer_id_1 = p_event->peer_id;
;;;391                im_evt.params.duplicate_id.peer_id_2 = peer_id;
;;;392                evt_send(&im_evt);
;;;393                break;
;;;394            }
;;;395        }
;;;396    }
000010  b007              ADD      sp,sp,#0x1c
000012  bd30              POP      {r4,r5,pc}
                  |L18.20|
000014  8860              LDRH     r0,[r4,#2]            ;364
000016  aa04              ADD      r2,sp,#0x10           ;364
000018  2107              MOVS     r1,#7                 ;364
00001a  f7fffffe          BL       pdb_peer_data_ptr_get
00001e  4605              MOV      r5,r0                 ;364
000020  b105              CBZ      r5,|L18.36|
000022  e7f5              B        |L18.16|
                  |L18.36|
000024  f7fffffe          BL       pds_peer_data_iterate_prepare
000028  e01e              B        |L18.104|
                  |L18.42|
00002a  8860              LDRH     r0,[r4,#2]            ;377
00002c  f8bd1018          LDRH     r1,[sp,#0x18]         ;377
000030  4288              CMP      r0,r1                 ;377
000032  d100              BNE      |L18.54|
000034  e018              B        |L18.104|
                  |L18.54|
000036  9903              LDR      r1,[sp,#0xc]          ;384
000038  9805              LDR      r0,[sp,#0x14]         ;384
00003a  f7fffffe          BL       im_is_duplicate_bonding_data
00003e  b190              CBZ      r0,|L18.102|
000040  8860              LDRH     r0,[r4,#2]            ;388
000042  f7fffffe          BL       im_conn_handle_get
000046  f8ad0002          STRH     r0,[sp,#2]            ;388
00004a  2000              MOVS     r0,#0                 ;389
00004c  f88d0000          STRB     r0,[sp,#0]            ;389
000050  8860              LDRH     r0,[r4,#2]            ;390
000052  f8ad0004          STRH     r0,[sp,#4]            ;390
000056  f8bd1018          LDRH     r1,[sp,#0x18]         ;391
00005a  f8ad1006          STRH     r1,[sp,#6]            ;391
00005e  4668              MOV      r0,sp                 ;392
000060  f7fffffe          BL       evt_send
000064  e007              B        |L18.118|
                  |L18.102|
000066  bf00              NOP                            ;381
                  |L18.104|
000068  aa02              ADD      r2,sp,#8              ;375
00006a  a906              ADD      r1,sp,#0x18           ;375
00006c  2007              MOVS     r0,#7                 ;375
00006e  f7fffffe          BL       pds_peer_data_iterate
000072  2800              CMP      r0,#0                 ;375
000074  d1d9              BNE      |L18.42|
                  |L18.118|
000076  bf00              NOP                            ;393
000078  bf00              NOP      
00007a  e7c9              B        |L18.16|
;;;397    
                          ENDP


                          AREA ||i.im_peer_free||, CODE, READONLY, ALIGN=1

                  im_peer_free PROC
;;;565    
;;;566    ret_code_t im_peer_free(pm_peer_id_t peer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;567    {
000002  4606              MOV      r6,r0
;;;568        uint16_t   conn_handle;
;;;569        ret_code_t ret;
;;;570    
;;;571        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;572    
;;;573        conn_handle = im_conn_handle_get(peer_id);
000004  4630              MOV      r0,r6
000006  f7fffffe          BL       im_conn_handle_get
00000a  4604              MOV      r4,r0
;;;574        ret         = pdb_peer_free(peer_id);
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       pdb_peer_free
000012  4605              MOV      r5,r0
;;;575    
;;;576        if ((conn_handle != BLE_CONN_HANDLE_INVALID) && (ret == NRF_SUCCESS))
000014  f64f70ff          MOV      r0,#0xffff
000018  4284              CMP      r4,r0
00001a  d004              BEQ      |L19.38|
00001c  b91d              CBNZ     r5,|L19.38|
;;;577        {
;;;578            peer_id_set(conn_handle, PM_PEER_ID_INVALID);
00001e  4601              MOV      r1,r0
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       peer_id_set
                  |L19.38|
;;;579        }
;;;580        return ret;
000026  4628              MOV      r0,r5
;;;581    }
000028  bd70              POP      {r4-r6,pc}
;;;582    
                          ENDP


                          AREA ||i.im_peer_id_get_by_conn_handle||, CODE, READONLY, ALIGN=2

                  im_peer_id_get_by_conn_handle PROC
;;;424    
;;;425    pm_peer_id_t im_peer_id_get_by_conn_handle(uint16_t conn_handle)
000000  b570              PUSH     {r4-r6,lr}
;;;426    {
000002  4605              MOV      r5,r0
;;;427        uint8_t conn_index;
;;;428    
;;;429        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;430    
;;;431        conn_index = get_connection_by_conn_handle(conn_handle);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       get_connection_by_conn_handle
00000a  4604              MOV      r4,r0
;;;432    
;;;433        if (conn_index != IM_NO_INVALID_CONN_HANDLES)
00000c  2cff              CMP      r4,#0xff
00000e  d005              BEQ      |L20.28|
;;;434        {
;;;435            return m_connections[conn_index].peer_id;
000010  eb040044          ADD      r0,r4,r4,LSL #1
000014  4903              LDR      r1,|L20.36|
000016  f8310020          LDRH     r0,[r1,r0,LSL #2]
                  |L20.26|
;;;436        }
;;;437    
;;;438        return PM_PEER_ID_INVALID;
;;;439    }
00001a  bd70              POP      {r4-r6,pc}
                  |L20.28|
00001c  f64f70ff          MOV      r0,#0xffff            ;438
000020  e7fb              B        |L20.26|
;;;440    
                          ENDP

000022  0000              DCW      0x0000
                  |L20.36|
                          DCD      m_connections

                          AREA ||i.im_peer_id_get_by_master_id||, CODE, READONLY, ALIGN=1

                  im_peer_id_get_by_master_id PROC
;;;481    
;;;482    pm_peer_id_t im_peer_id_get_by_master_id(ble_gap_master_id_t * p_master_id)
000000  b53e              PUSH     {r1-r5,lr}
;;;483    {
000002  4604              MOV      r4,r0
;;;484        pm_peer_id_t         peer_id;
;;;485        pm_peer_data_flash_t peer_data;
;;;486    
;;;487        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;488        NRF_PM_DEBUG_CHECK(p_master_id != NULL);
;;;489    
;;;490        pds_peer_data_iterate_prepare();
000004  f7fffffe          BL       pds_peer_data_iterate_prepare
;;;491    
;;;492        // For each stored peer, check if the master_id matches p_master_id
;;;493        while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data))
000008  e010              B        |L21.44|
                  |L21.10|
;;;494        {
;;;495            if (im_master_ids_compare(p_master_id, &peer_data.p_bonding_data->own_ltk.master_id) ||
00000a  9801              LDR      r0,[sp,#4]
00000c  f1000146          ADD      r1,r0,#0x46
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       im_master_ids_compare
000016  b930              CBNZ     r0,|L21.38|
;;;496                im_master_ids_compare(p_master_id, &peer_data.p_bonding_data->peer_ltk.master_id))
000018  9801              LDR      r0,[sp,#4]
00001a  f100012a          ADD      r1,r0,#0x2a
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       im_master_ids_compare
000024  b110              CBZ      r0,|L21.44|
                  |L21.38|
;;;497            {
;;;498                // If a matching master ID is found then return the peer ID.
;;;499                return peer_id;
000026  f8bd0008          LDRH     r0,[sp,#8]
                  |L21.42|
;;;500            }
;;;501        }
;;;502    
;;;503        // If no matching master ID is found return PM_PEER_ID_INVALID.
;;;504        return PM_PEER_ID_INVALID;
;;;505    }
00002a  bd3e              POP      {r1-r5,pc}
                  |L21.44|
00002c  466a              MOV      r2,sp                 ;493
00002e  a902              ADD      r1,sp,#8              ;493
000030  2007              MOVS     r0,#7                 ;493
000032  f7fffffe          BL       pds_peer_data_iterate
000036  2800              CMP      r0,#0                 ;493
000038  d1e7              BNE      |L21.10|
00003a  f64f70ff          MOV      r0,#0xffff            ;504
00003e  e7f4              B        |L21.42|
;;;506    
                          ENDP


                          AREA ||i.im_privacy_get||, CODE, READONLY, ALIGN=1

                  im_privacy_get PROC
;;;862    
;;;863    ret_code_t im_privacy_get(pm_privacy_params_t * p_privacy_params)
000000  b510              PUSH     {r4,lr}
;;;864    {
000002  4604              MOV      r4,r0
;;;865        #if (NRF_SD_BLE_API_VERSION == 2)
;;;866    
;;;867            ble_gap_addr_t cur_addr;
;;;868            ble_opt_t      cur_privacy_opt;
;;;869    
;;;870            NRF_PM_DEBUG_CHECK(p_privacy_params               != NULL);
;;;871            NRF_PM_DEBUG_CHECK(p_privacy_params->p_device_irk != NULL);
;;;872    
;;;873            cur_privacy_opt.gap_opt.privacy.p_irk = p_privacy_params->p_device_irk;
;;;874    
;;;875            // Can not fail.
;;;876            (void) sd_ble_gap_address_get(&cur_addr);
;;;877    
;;;878            if (   cur_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE
;;;879                || cur_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE)
;;;880            {
;;;881                p_privacy_params->privacy_mode      = BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY;
;;;882                p_privacy_params->private_addr_type = cur_addr.addr_type;
;;;883            }
;;;884            else
;;;885            {
;;;886                p_privacy_params->privacy_mode = BLE_GAP_PRIVACY_MODE_OFF;
;;;887            }
;;;888    
;;;889            // Can not fail.
;;;890            (void) sd_ble_opt_get(BLE_GAP_OPT_PRIVACY, &cur_privacy_opt);
;;;891    
;;;892            p_privacy_params->private_addr_cycle_s = cur_privacy_opt.gap_opt.privacy.interval_s;
;;;893    
;;;894            return NRF_SUCCESS;
;;;895    
;;;896        #else
;;;897    
;;;898            return sd_ble_gap_privacy_get(p_privacy_params);
000004  4620              MOV      r0,r4
000006  df71              SVC      #0x71
;;;899    
;;;900        #endif
;;;901    }
000008  bd10              POP      {r4,pc}
;;;902    
                          ENDP


                          AREA ||i.im_privacy_set||, CODE, READONLY, ALIGN=1

                  im_privacy_set PROC
;;;813    
;;;814    ret_code_t im_privacy_set(pm_privacy_params_t const * p_privacy_params)
000000  b510              PUSH     {r4,lr}
;;;815    {
000002  4604              MOV      r4,r0
;;;816        #if (NRF_SD_BLE_API_VERSION == 2)
;;;817    
;;;818            ret_code_t     ret;
;;;819            ble_gap_addr_t privacy_addr;
;;;820            ble_gap_irk_t  current_irk;
;;;821            ble_opt_t      privacy_options;
;;;822            ble_opt_t      current_privacy_options;
;;;823    
;;;824            NRF_PM_DEBUG_CHECK(p_privacy_params != NULL);
;;;825    
;;;826            privacy_addr.addr_type                        = p_privacy_params->private_addr_type;
;;;827            privacy_options.gap_opt.privacy.p_irk         = p_privacy_params->p_device_irk;
;;;828            privacy_options.gap_opt.privacy.interval_s    = p_privacy_params->private_addr_cycle_s;
;;;829            current_privacy_options.gap_opt.privacy.p_irk = &current_irk;
;;;830    
;;;831            // Can not fail.
;;;832            (void) sd_ble_opt_get(BLE_GAP_OPT_PRIVACY, &current_privacy_options);
;;;833            (void) sd_ble_opt_set(BLE_GAP_OPT_PRIVACY, &privacy_options);
;;;834    
;;;835            if (p_privacy_params->privacy_mode == BLE_GAP_PRIVACY_MODE_OFF)
;;;836            {
;;;837                ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_NONE, &m_current_id_addr);
;;;838            }
;;;839            else
;;;840            {
;;;841                ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_AUTO, &privacy_addr);
;;;842            }
;;;843    
;;;844            if (ret != NRF_SUCCESS)
;;;845            {
;;;846                // Restore previous settings.
;;;847                (void) sd_ble_opt_set(BLE_GAP_OPT_PRIVACY, &current_privacy_options);
;;;848            }
;;;849    
;;;850            // NRF_ERROR_BUSY,
;;;851            // NRF_ERROR_INVALID_STATE,
;;;852            // NRF_ERROR_INVALID_PARAM, if address type is not valid.
;;;853            return ret;
;;;854    
;;;855        #else
;;;856    
;;;857            return sd_ble_gap_privacy_set(p_privacy_params);
000004  4620              MOV      r0,r4
000006  df70              SVC      #0x70
;;;858    
;;;859        #endif
;;;860    }
000008  bd10              POP      {r4,pc}
;;;861    
                          ENDP


                          AREA ||i.im_whitelist_get||, CODE, READONLY, ALIGN=2

                  im_whitelist_get PROC
;;;906     */
;;;907    ret_code_t im_whitelist_get(ble_gap_addr_t * p_addrs,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;908                                uint32_t       * p_addr_cnt,
;;;909                                ble_gap_irk_t  * p_irks,
;;;910                                uint32_t       * p_irk_cnt)
;;;911    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;912        // One of the two buffers has to be provided.
;;;913        NRF_PM_DEBUG_CHECK((p_addrs    != NULL) || (p_irks    != NULL));
;;;914        NRF_PM_DEBUG_CHECK((p_addr_cnt != NULL) || (p_irk_cnt != NULL));
;;;915    
;;;916        if (((p_addr_cnt != NULL) && (m_wlisted_peer_cnt > *p_addr_cnt)) ||
00000c  b124              CBZ      r4,|L24.24|
00000e  490c              LDR      r1,|L24.64|
000010  7809              LDRB     r1,[r1,#0]  ; m_wlisted_peer_cnt
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d305              BCC      |L24.36|
                  |L24.24|
;;;917            ((p_irk_cnt  != NULL) && (m_wlisted_peer_cnt > *p_irk_cnt)))
000018  b13d              CBZ      r5,|L24.42|
00001a  4909              LDR      r1,|L24.64|
00001c  7809              LDRB     r1,[r1,#0]  ; m_wlisted_peer_cnt
00001e  6828              LDR      r0,[r5,#0]
000020  4288              CMP      r0,r1
000022  d202              BCS      |L24.42|
                  |L24.36|
;;;918        {
;;;919            // The size of the cached list of peers is larger than the provided buffers.
;;;920            return NRF_ERROR_NO_MEM;
000024  2004              MOVS     r0,#4
                  |L24.38|
;;;921        }
;;;922    
;;;923        // NRF_SUCCESS or
;;;924        // NRF_ERROR_NOT_FOUND,            if a peer or its data were not found.
;;;925        // BLE_ERROR_GAP_INVALID_BLE_ADDR, if a peer address can not be used for whitelisting.
;;;926        return peers_id_keys_get(m_wlisted_peers, m_wlisted_peer_cnt,
;;;927                                 p_addrs, p_addr_cnt,
;;;928                                 p_irks,  p_irk_cnt);
;;;929    }
000026  e8bd81fc          POP      {r2-r8,pc}
                  |L24.42|
00002a  4623              MOV      r3,r4                 ;926
00002c  4632              MOV      r2,r6                 ;926
00002e  4804              LDR      r0,|L24.64|
000030  e9cd7500          STRD     r7,r5,[sp,#0]         ;926
000034  7801              LDRB     r1,[r0,#0]            ;926  ; m_wlisted_peer_cnt
000036  4803              LDR      r0,|L24.68|
000038  f7fffffe          BL       peers_id_keys_get
00003c  e7f3              B        |L24.38|
;;;930    
                          ENDP

00003e  0000              DCW      0x0000
                  |L24.64|
                          DCD      m_wlisted_peer_cnt
                  |L24.68|
                          DCD      m_wlisted_peers

                          AREA ||i.im_whitelist_set||, CODE, READONLY, ALIGN=2

                  im_whitelist_set PROC
;;;936     */
;;;937    ret_code_t im_whitelist_set(pm_peer_id_t const * p_peers,
000000  b570              PUSH     {r4-r6,lr}
;;;938                                uint32_t             peer_cnt)
;;;939    {
000002  b09a              SUB      sp,sp,#0x68
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;940        // Clear the cache of whitelisted peers.
;;;941        memset(m_wlisted_peers, 0x00, sizeof(m_wlisted_peers));
000008  2110              MOVS     r1,#0x10
00000a  481b              LDR      r0,|L25.120|
00000c  f7fffffe          BL       __aeabi_memclr
;;;942    
;;;943        if ((p_peers == NULL) || (peer_cnt == 0))
000010  b105              CBZ      r5,|L25.20|
000012  b93c              CBNZ     r4,|L25.36|
                  |L25.20|
;;;944        {
;;;945            // Clear the current whitelist.
;;;946            m_wlisted_peer_cnt = 0;
000014  2000              MOVS     r0,#0
000016  4919              LDR      r1,|L25.124|
000018  7008              STRB     r0,[r1,#0]
;;;947            #if (NRF_SD_BLE_API_VERSION == 3)
;;;948                // NRF_SUCCESS, or
;;;949                // BLE_GAP_ERROR_WHITELIST_IN_USE
;;;950                return sd_ble_gap_whitelist_set(NULL, 0);
00001a  2100              MOVS     r1,#0
00001c  4608              MOV      r0,r1
00001e  df6e              SVC      #0x6e
                  |L25.32|
;;;951            #else
;;;952                // The cached list of whitelisted peers is already cleared; nothing to do.
;;;953                return NRF_SUCCESS;
;;;954            #endif
;;;955        }
;;;956    
;;;957        // @todo emdi: should not ever cache more than BLE_GAP_WHITELIST_ADDR_MAX_COUNT...
;;;958    
;;;959        // Copy the new whitelisted peers.
;;;960        m_wlisted_peer_cnt = peer_cnt;
;;;961        memcpy(m_wlisted_peers, p_peers, sizeof(pm_peer_id_t) * peer_cnt);
;;;962    
;;;963        #if (NRF_SD_BLE_API_VERSION == 3)
;;;964    
;;;965            ret_code_t ret;
;;;966            uint32_t   wlist_addr_cnt = 0;
;;;967    
;;;968            ble_gap_addr_t const * addr_ptrs[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];
;;;969            ble_gap_addr_t         addrs[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];
;;;970    
;;;971            memset(addrs, 0x00, sizeof(addrs));
;;;972    
;;;973            // Fetch GAP addresses for these peers, but don't fetch IRKs.
;;;974            ret = peers_id_keys_get(p_peers, peer_cnt, addrs, &wlist_addr_cnt, NULL, NULL);
;;;975    
;;;976            if (ret != NRF_SUCCESS)
;;;977            {
;;;978                // NRF_ERROR_NOT_FOUND,            if a peer or its data were not found.
;;;979                // BLE_ERROR_GAP_INVALID_BLE_ADDR, if a peer address can not be used for whitelisting.
;;;980                return ret;
;;;981            }
;;;982    
;;;983            for (uint32_t i = 0; i < BLE_GAP_WHITELIST_ADDR_MAX_COUNT; i++)
;;;984            {
;;;985                addr_ptrs[i] = &addrs[i];
;;;986            }
;;;987    
;;;988            // NRF_ERROR_DATA_SIZE,             if peer_cnt > BLE_GAP_WHITELIST_ADDR_MAX_COUNT.
;;;989            // BLE_ERROR_GAP_WHITELIST_IN_USE,  if a whitelist is in use.
;;;990            return sd_ble_gap_whitelist_set(addr_ptrs, peer_cnt);
;;;991    
;;;992        #else
;;;993    
;;;994            return NRF_SUCCESS;
;;;995    
;;;996        #endif
;;;997    }
000020  b01a              ADD      sp,sp,#0x68
000022  bd70              POP      {r4-r6,pc}
                  |L25.36|
000024  4915              LDR      r1,|L25.124|
000026  700c              STRB     r4,[r1,#0]            ;960
000028  0062              LSLS     r2,r4,#1              ;961
00002a  4629              MOV      r1,r5                 ;961
00002c  4812              LDR      r0,|L25.120|
00002e  f7fffffe          BL       __aeabi_memcpy
000032  2000              MOVS     r0,#0                 ;966
000034  9019              STR      r0,[sp,#0x64]         ;966
000036  2138              MOVS     r1,#0x38              ;971
000038  a803              ADD      r0,sp,#0xc            ;971
00003a  f7fffffe          BL       __aeabi_memclr4
00003e  2000              MOVS     r0,#0                 ;974
000040  9000              STR      r0,[sp,#0]            ;974
000042  ab19              ADD      r3,sp,#0x64           ;974
000044  aa03              ADD      r2,sp,#0xc            ;974
000046  4621              MOV      r1,r4                 ;974
000048  9001              STR      r0,[sp,#4]            ;974
00004a  4628              MOV      r0,r5                 ;974
00004c  f7fffffe          BL       peers_id_keys_get
000050  4606              MOV      r6,r0                 ;974
000052  b10e              CBZ      r6,|L25.88|
000054  4630              MOV      r0,r6                 ;980
000056  e7e3              B        |L25.32|
                  |L25.88|
000058  2000              MOVS     r0,#0                 ;983
00005a  e007              B        |L25.108|
                  |L25.92|
00005c  ebc001c0          RSB      r1,r0,r0,LSL #3       ;985
000060  aa03              ADD      r2,sp,#0xc            ;985
000062  4411              ADD      r1,r1,r2              ;985
000064  aa11              ADD      r2,sp,#0x44           ;985
000066  f8421020          STR      r1,[r2,r0,LSL #2]     ;985
00006a  1c40              ADDS     r0,r0,#1              ;983
                  |L25.108|
00006c  2808              CMP      r0,#8                 ;983
00006e  d3f5              BCC      |L25.92|
000070  b2e1              UXTB     r1,r4                 ;990
000072  a811              ADD      r0,sp,#0x44           ;990
000074  df6e              SVC      #0x6e                 ;990
000076  e7d3              B        |L25.32|
;;;998    
                          ENDP

                  |L25.120|
                          DCD      m_wlisted_peers
                  |L25.124|
                          DCD      m_wlisted_peer_cnt

                          AREA ||i.internal_state_reset||, CODE, READONLY, ALIGN=2

                  internal_state_reset PROC
;;;68     
;;;69     static void internal_state_reset()
000000  2018              MOVS     r0,#0x18
;;;70     {
;;;71         m_conn_state_user_flag_id = BLE_CONN_STATE_USER_FLAG_INVALID;
000002  4908              LDR      r1,|L26.36|
000004  7008              STRB     r0,[r1,#0]
;;;72     
;;;73         for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000006  2000              MOVS     r0,#0
000008  e008              B        |L26.28|
                  |L26.10|
;;;74         {
;;;75             m_connections[i].conn_handle = BLE_CONN_HANDLE_INVALID;
00000a  f64f71ff          MOV      r1,#0xffff
00000e  eb000240          ADD      r2,r0,r0,LSL #1
000012  4b05              LDR      r3,|L26.40|
000014  eb030282          ADD      r2,r3,r2,LSL #2
000018  8051              STRH     r1,[r2,#2]
00001a  1c40              ADDS     r0,r0,#1              ;73
                  |L26.28|
00001c  2808              CMP      r0,#8                 ;73
00001e  d3f4              BCC      |L26.10|
;;;76         }
;;;77     }
000020  4770              BX       lr
;;;78     
                          ENDP

000022  0000              DCW      0x0000
                  |L26.36|
                          DCD      m_conn_state_user_flag_id
                  |L26.40|
                          DCD      m_connections

                          AREA ||i.is_valid_irk||, CODE, READONLY, ALIGN=1

                  is_valid_irk PROC
;;;182     */
;;;183    bool is_valid_irk(ble_gap_irk_t const * p_irk)
000000  4602              MOV      r2,r0
;;;184    {
;;;185        NRF_PM_DEBUG_CHECK(p_irk != NULL);
;;;186    
;;;187        for (uint32_t i = 0; i < BLE_GAP_SEC_KEY_LEN; i++)
000002  2100              MOVS     r1,#0
000004  e004              B        |L27.16|
                  |L27.6|
;;;188        {
;;;189            if (p_irk->irk[i] != 0)
000006  5c50              LDRB     r0,[r2,r1]
000008  b108              CBZ      r0,|L27.14|
;;;190            {
;;;191                return true;
00000a  2001              MOVS     r0,#1
                  |L27.12|
;;;192            }
;;;193        }
;;;194        return false;
;;;195    }
00000c  4770              BX       lr
                  |L27.14|
00000e  1c49              ADDS     r1,r1,#1              ;187
                  |L27.16|
000010  2910              CMP      r1,#0x10              ;187
000012  d3f8              BCC      |L27.6|
000014  2000              MOVS     r0,#0                 ;194
000016  e7f9              B        |L27.12|
;;;196    
                          ENDP


                          AREA ||i.new_connection||, CODE, READONLY, ALIGN=2

                  new_connection PROC
;;;148     */
;;;149    uint8_t new_connection(uint16_t conn_handle, ble_gap_addr_t * p_ble_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;151        uint8_t conn_index = IM_NO_INVALID_CONN_HANDLES;
000006  24ff              MOVS     r4,#0xff
;;;152    
;;;153        if ((p_ble_addr != NULL) && (conn_handle != BLE_CONN_HANDLE_INVALID))
000008  b366              CBZ      r6,|L28.100|
00000a  f64f70ff          MOV      r0,#0xffff
00000e  4285              CMP      r5,r0
000010  d028              BEQ      |L28.100|
;;;154        {
;;;155            ble_conn_state_user_flag_set(conn_handle, m_conn_state_user_flag_id, true);
000012  2201              MOVS     r2,#1
000014  4814              LDR      r0,|L28.104|
000016  7801              LDRB     r1,[r0,#0]  ; m_conn_state_user_flag_id
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       ble_conn_state_user_flag_set
;;;156    
;;;157            conn_index = get_connection_by_conn_handle(conn_handle);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       get_connection_by_conn_handle
000024  4604              MOV      r4,r0
;;;158            if (conn_index == IM_NO_INVALID_CONN_HANDLES)
000026  2cff              CMP      r4,#0xff
000028  d102              BNE      |L28.48|
;;;159            {
;;;160                conn_index = get_free_connection();
00002a  f7fffffe          BL       get_free_connection
00002e  4604              MOV      r4,r0
                  |L28.48|
;;;161            }
;;;162    
;;;163            if (conn_index != IM_NO_INVALID_CONN_HANDLES)
000030  2cff              CMP      r4,#0xff
000032  d017              BEQ      |L28.100|
;;;164            {
;;;165                m_connections[conn_index].conn_handle  = conn_handle;
000034  eb040044          ADD      r0,r4,r4,LSL #1
000038  490c              LDR      r1,|L28.108|
00003a  eb010080          ADD      r0,r1,r0,LSL #2
00003e  8045              STRH     r5,[r0,#2]
;;;166                m_connections[conn_index].peer_id      = PM_PEER_ID_INVALID;
000040  f64f70ff          MOV      r0,#0xffff
000044  eb040144          ADD      r1,r4,r4,LSL #1
000048  4a08              LDR      r2,|L28.108|
00004a  f8220021          STRH     r0,[r2,r1,LSL #2]
;;;167                m_connections[conn_index].peer_address = *p_ble_addr;
00004e  eb040044          ADD      r0,r4,r4,LSL #1
000052  4611              MOV      r1,r2
000054  eb010080          ADD      r0,r1,r0,LSL #2
000058  6831              LDR      r1,[r6,#0]
00005a  6041              STR      r1,[r0,#4]
00005c  88b1              LDRH     r1,[r6,#4]
00005e  8101              STRH     r1,[r0,#8]
000060  79b1              LDRB     r1,[r6,#6]
000062  7281              STRB     r1,[r0,#0xa]
                  |L28.100|
;;;168            }
;;;169        }
;;;170        return conn_index;
000064  4620              MOV      r0,r4
;;;171    }
000066  bd70              POP      {r4-r6,pc}
;;;172    
                          ENDP

                  |L28.104|
                          DCD      m_conn_state_user_flag_id
                  |L28.108|
                          DCD      m_connections

                          AREA ||i.peer_id_set||, CODE, READONLY, ALIGN=2

                  peer_id_set PROC
;;;547     */
;;;548    static void peer_id_set(uint16_t conn_handle, pm_peer_id_t peer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;549    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;550        uint8_t conn_index = get_connection_by_conn_handle(conn_handle);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       get_connection_by_conn_handle
00000c  4605              MOV      r5,r0
;;;551        if (conn_index != IM_NO_INVALID_CONN_HANDLES)
00000e  2dff              CMP      r5,#0xff
000010  d004              BEQ      |L29.28|
;;;552        {
;;;553            m_connections[conn_index].peer_id = peer_id;
000012  eb050045          ADD      r0,r5,r5,LSL #1
000016  4902              LDR      r1,|L29.32|
000018  f8214020          STRH     r4,[r1,r0,LSL #2]
                  |L29.28|
;;;554        }
;;;555    }
00001c  bd70              POP      {r4-r6,pc}
;;;556    
                          ENDP

00001e  0000              DCW      0x0000
                  |L29.32|
                          DCD      m_connections

                          AREA ||i.peers_id_keys_get||, CODE, READONLY, ALIGN=1

                  peers_id_keys_get PROC
;;;585     */
;;;586    static ret_code_t peers_id_keys_get(pm_peer_id_t   const * p_peers,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;587                                        uint32_t               peer_cnt,
;;;588                                        ble_gap_addr_t       * p_gap_addrs,
;;;589                                        uint32_t             * p_addr_cnt,
;;;590                                        ble_gap_irk_t        * p_gap_irks,
;;;591                                        uint32_t             * p_irk_cnt)
;;;592    {
000004  b099              SUB      sp,sp,#0x64
000006  4682              MOV      r10,r0
000008  468b              MOV      r11,r1
00000a  4690              MOV      r8,r2
00000c  461c              MOV      r4,r3
00000e  9e23              LDR      r6,[sp,#0x8c]
;;;593        ret_code_t ret;
;;;594    
;;;595        pm_peer_data_bonding_t bond_data;
;;;596        pm_peer_data_t         peer_data;
;;;597    
;;;598        uint32_t const buf_size = sizeof(bond_data);
000010  2050              MOVS     r0,#0x50
000012  9002              STR      r0,[sp,#8]
;;;599    
;;;600        bool copy_addrs = false;
000014  2000              MOVS     r0,#0
000016  9001              STR      r0,[sp,#4]
;;;601        bool copy_irks  = false;
000018  9000              STR      r0,[sp,#0]
;;;602    
;;;603        NRF_PM_DEBUG_CHECK(p_peers != NULL);
;;;604    
;;;605        // One of these two has to be provided.
;;;606        NRF_PM_DEBUG_CHECK((p_gap_addrs != NULL) || (p_gap_irks != NULL));
;;;607    
;;;608        if ((p_gap_addrs != NULL) && (p_addr_cnt != NULL))
00001a  f1b80f00          CMP      r8,#0
00001e  d004              BEQ      |L30.42|
000020  b11c              CBZ      r4,|L30.42|
;;;609        {
;;;610            NRF_PM_DEBUG_CHECK((*p_addr_cnt) >= peer_cnt);
;;;611    
;;;612            copy_addrs  = true;
000022  2001              MOVS     r0,#1
000024  9001              STR      r0,[sp,#4]
;;;613            *p_addr_cnt = 0;
000026  2000              MOVS     r0,#0
000028  6020              STR      r0,[r4,#0]
                  |L30.42|
;;;614        }
;;;615    
;;;616        if ((p_gap_irks != NULL) && (p_irk_cnt != NULL))
00002a  9822              LDR      r0,[sp,#0x88]
00002c  b120              CBZ      r0,|L30.56|
00002e  b11e              CBZ      r6,|L30.56|
;;;617        {
;;;618            NRF_PM_DEBUG_CHECK((*p_irk_cnt) >= peer_cnt);
;;;619    
;;;620            copy_irks  = true;
000030  2001              MOVS     r0,#1
000032  9000              STR      r0,[sp,#0]
;;;621            *p_irk_cnt = 0;
000034  2000              MOVS     r0,#0
000036  6030              STR      r0,[r6,#0]
                  |L30.56|
;;;622        }
;;;623    
;;;624        memset(&peer_data, 0x00, sizeof(peer_data));
000038  2000              MOVS     r0,#0
00003a  9003              STR      r0,[sp,#0xc]
00003c  9004              STR      r0,[sp,#0x10]
;;;625        peer_data.p_bonding_data = &bond_data;
00003e  a805              ADD      r0,sp,#0x14
000040  9004              STR      r0,[sp,#0x10]
;;;626    
;;;627        // Read through flash memory and look for peers ID keys.
;;;628    
;;;629        for (uint32_t i = 0; i < peer_cnt; i++)
000042  2500              MOVS     r5,#0
000044  e041              B        |L30.202|
                  |L30.70|
;;;630        {
;;;631            memset(&bond_data, 0x00, sizeof(bond_data));
000046  2150              MOVS     r1,#0x50
000048  a805              ADD      r0,sp,#0x14
00004a  f7fffffe          BL       __aeabi_memclr4
;;;632    
;;;633            // Read peer data from flash.
;;;634            ret = pds_peer_data_read(p_peers[i], PM_PEER_DATA_ID_BONDING,
00004e  f83a0015          LDRH     r0,[r10,r5,LSL #1]
000052  ab02              ADD      r3,sp,#8
000054  aa03              ADD      r2,sp,#0xc
000056  2107              MOVS     r1,#7
000058  f7fffffe          BL       pds_peer_data_read
00005c  4607              MOV      r7,r0
;;;635                                     &peer_data, &buf_size);
;;;636    
;;;637            if ((ret == NRF_ERROR_NOT_FOUND) || (ret == NRF_ERROR_INVALID_PARAM))
00005e  2f05              CMP      r7,#5
000060  d001              BEQ      |L30.102|
000062  2f07              CMP      r7,#7
000064  d103              BNE      |L30.110|
                  |L30.102|
;;;638            {
;;;639                // Peer data coulnd't be found in flash or peer ID is not valid.
;;;640                return NRF_ERROR_NOT_FOUND;
000066  2005              MOVS     r0,#5
                  |L30.104|
;;;641            }
;;;642    
;;;643            uint8_t const addr_type = bond_data.peer_id.id_addr_info.addr_type;
;;;644    
;;;645            if ((addr_type != BLE_GAP_ADDR_TYPE_PUBLIC) &&
;;;646                (addr_type != BLE_GAP_ADDR_TYPE_RANDOM_STATIC))
;;;647            {
;;;648                // The address shared by the peer during bonding can't be used for whitelisting.
;;;649                return BLE_ERROR_GAP_INVALID_BLE_ADDR;
;;;650            }
;;;651    
;;;652            // Copy the GAP address.
;;;653            if (copy_addrs)
;;;654            {
;;;655                memcpy(&p_gap_addrs[i], &bond_data.peer_id.id_addr_info, sizeof(ble_gap_addr_t));
;;;656                (*p_addr_cnt)++;
;;;657            }
;;;658    
;;;659            // Copy the IRK.
;;;660            if (copy_irks)
;;;661            {
;;;662                memcpy(&p_gap_irks[i], bond_data.peer_id.id_info.irk, BLE_GAP_SEC_KEY_LEN);
;;;663                (*p_irk_cnt)++;
;;;664            }
;;;665        }
;;;666    
;;;667        return NRF_SUCCESS;
;;;668    }
000068  b019              ADD      sp,sp,#0x64
00006a  e8bd8ff0          POP      {r4-r11,pc}
                  |L30.110|
00006e  a805              ADD      r0,sp,#0x14           ;643
000070  7c40              LDRB     r0,[r0,#0x11]         ;643
000072  ea4f0950          LSR      r9,r0,#1              ;643
000076  f1b90f00          CMP      r9,#0                 ;645
00007a  d005              BEQ      |L30.136|
00007c  f1b90f01          CMP      r9,#1                 ;646
000080  d002              BEQ      |L30.136|
000082  f2432002          MOV      r0,#0x3202            ;649
000086  e7ef              B        |L30.104|
                  |L30.136|
000088  9801              LDR      r0,[sp,#4]            ;653
00008a  b180              CBZ      r0,|L30.174|
00008c  ebc500c5          RSB      r0,r5,r5,LSL #3       ;655
000090  eb000108          ADD      r1,r0,r8              ;655
000094  f10d0015          ADD      r0,sp,#0x15           ;655
000098  f8dd2025          LDR      r2,[sp,#0x25]         ;655
00009c  600a              STR      r2,[r1,#0]            ;655
00009e  f8bd2029          LDRH     r2,[sp,#0x29]         ;655
0000a2  808a              STRH     r2,[r1,#4]            ;655
0000a4  7d80              LDRB     r0,[r0,#0x16]         ;655
0000a6  7188              STRB     r0,[r1,#6]            ;655
0000a8  6820              LDR      r0,[r4,#0]            ;656
0000aa  1c40              ADDS     r0,r0,#1              ;656
0000ac  6020              STR      r0,[r4,#0]            ;656
                  |L30.174|
0000ae  9800              LDR      r0,[sp,#0]            ;660
0000b0  b150              CBZ      r0,|L30.200|
0000b2  9922              LDR      r1,[sp,#0x88]         ;662
0000b4  eb011005          ADD      r0,r1,r5,LSL #4       ;662
0000b8  2210              MOVS     r2,#0x10              ;662
0000ba  f10d0115          ADD      r1,sp,#0x15           ;662
0000be  f7fffffe          BL       __aeabi_memcpy
0000c2  6830              LDR      r0,[r6,#0]            ;663
0000c4  1c40              ADDS     r0,r0,#1              ;663
0000c6  6030              STR      r0,[r6,#0]            ;663
                  |L30.200|
0000c8  1c6d              ADDS     r5,r5,#1              ;629
                  |L30.202|
0000ca  455d              CMP      r5,r11                ;629
0000cc  d3bb              BCC      |L30.70|
0000ce  2000              MOVS     r0,#0                 ;667
0000d0  e7ca              B        |L30.104|
;;;669    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  m_connections
                          %        96
                  m_wlisted_peers
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  m_evt_handlers
                          DCD      pm_im_evt_handler
                          DCD      gcm_im_evt_handler

                          AREA ||.data||, DATA, ALIGN=0

                  m_module_initialized
000000  00                DCB      0x00
                  m_conn_state_user_flag_id
000001  00                DCB      0x00
                  m_wlisted_peer_cnt
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\peer_manager\\id_manager.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_id_manager_c_40579113____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_id_manager_c_40579113____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_id_manager_c_40579113____REVSH|
#line 402
|__asm___12_id_manager_c_40579113____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_id_manager_c_40579113____RRX|
#line 587
|__asm___12_id_manager_c_40579113____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
