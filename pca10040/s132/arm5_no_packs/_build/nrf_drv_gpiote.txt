; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\_build\nrf_drv_gpiote.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\nrf_drv_gpiote.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config\bluetoothds_template_pca10040_s132 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mailbox -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\bsp -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\none -I..\..\..\..\..\..\components\drivers_ext\LS013B7DH06 -I..\..\..\..\..\..\external\ugfx -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\framebuffer -I..\..\..\..\..\..\external\ugfx\src\gdisp -I..\..\..\..\..\..\external\ugfx\drivers\gdisp\ -IC:\Users\Michael\Documents\none\nRF5_SDK_12.1.0_0d23e2a\examples\ble_peripheral\none\pca10040\s132\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.9.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DNRF52 -DBLE_STACK_SUPPORT_REQD -D__HEAP_SIZE=0 -DS132 -DNRF_SD_BLE_API_VERSION=3 -DBOARD_PCA10040 -DNRF52_PAN_12 -DNRF52_PAN_15 -DNRF52_PAN_20 -DNRF52_PAN_30 -DNRF52_PAN_31 -DNRF52_PAN_36 -DNRF52_PAN_51 -DNRF52_PAN_53 -DNRF52_PAN_54 -DNRF52_PAN_55 -DNRF52_PAN_58 -DNRF52_PAN_62 -DNRF52_PAN_63 -DNRF52_PAN_64 -DCONFIG_GPIO_AS_PINRESET -DSOFTDEVICE_PRESENT -DNRF52832 -DNRF52 -DSWI_DISABLE0 --omf_browse=.\_build\nrf_drv_gpiote.crf ..\..\..\..\..\..\components\drivers_nrf\gpiote\nrf_drv_gpiote.c]
                          THUMB

                          AREA ||i.GPIOTE_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPIOTE_IRQHandler PROC
;;;530    
;;;531    void GPIOTE_IRQHandler(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;532    {
000004  b087              SUB      sp,sp,#0x1c
;;;533        uint32_t status = 0;
000006  2700              MOVS     r7,#0
;;;534        uint32_t input = 0;
000008  46ba              MOV      r10,r7
;;;535    
;;;536        /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
;;;537        uint32_t i;
;;;538        nrf_gpiote_events_t event = NRF_GPIOTE_EVENTS_IN_0;
00000a  f44f7080          MOV      r0,#0x100
00000e  9006              STR      r0,[sp,#0x18]
;;;539        uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
000010  2501              MOVS     r5,#1
;;;540        for (i = 0; i < GPIOTE_CH_NUM; i++)
000012  2400              MOVS     r4,#0
000014  e012              B        |L1.60|
                  |L1.22|
;;;541        {
;;;542            if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
000016  9806              LDR      r0,[sp,#0x18]
000018  f7fffffe          BL       nrf_gpiote_event_is_set
00001c  b140              CBZ      r0,|L1.48|
00001e  bf00              NOP      
000020  4861              LDR      r0,|L1.424|
000022  6800              LDR      r0,[r0,#0]
000024  4028              ANDS     r0,r0,r5
000026  b118              CBZ      r0,|L1.48|
;;;543            {
;;;544                nrf_gpiote_event_clear(event);
000028  9806              LDR      r0,[sp,#0x18]
00002a  f7fffffe          BL       nrf_gpiote_event_clear
;;;545                status |= mask;
00002e  432f              ORRS     r7,r7,r5
                  |L1.48|
;;;546            }
;;;547            mask <<= 1;
000030  006d              LSLS     r5,r5,#1
;;;548            /* Incrementing to next event, utilizing the fact that events are grouped together
;;;549             * in ascending order. */
;;;550            event = (nrf_gpiote_events_t)((uint32_t)event + sizeof(uint32_t));
000032  9806              LDR      r0,[sp,#0x18]
000034  1d00              ADDS     r0,r0,#4
000036  b280              UXTH     r0,r0
000038  9006              STR      r0,[sp,#0x18]
00003a  1c64              ADDS     r4,r4,#1              ;540
                  |L1.60|
00003c  2c08              CMP      r4,#8                 ;540
00003e  d3ea              BCC      |L1.22|
;;;551        }
;;;552    
;;;553        /* collect PORT status event, if event is set read pins state. Processing is postponed to the
;;;554         * end of interrupt. */
;;;555        if (nrf_gpiote_event_is_set(NRF_GPIOTE_EVENTS_PORT))
000040  f44f70be          MOV      r0,#0x17c
000044  f7fffffe          BL       nrf_gpiote_event_is_set
000048  b148              CBZ      r0,|L1.94|
;;;556        {
;;;557            nrf_gpiote_event_clear(NRF_GPIOTE_EVENTS_PORT);
00004a  f44f70be          MOV      r0,#0x17c
00004e  f7fffffe          BL       nrf_gpiote_event_clear
;;;558            status |= (uint32_t)NRF_GPIOTE_INT_PORT_MASK;
000052  f0474700          ORR      r7,r7,#0x80000000
;;;559            input = nrf_gpio_pins_read();
000056  bf00              NOP      
000058  4854              LDR      r0,|L1.428|
00005a  6800              LDR      r0,[r0,#0]
00005c  4682              MOV      r10,r0
                  |L1.94|
;;;560        }
;;;561    
;;;562        /* Process pin events. */
;;;563        if (status & NRF_GPIOTE_INT_IN_MASK)
00005e  b2f8              UXTB     r0,r7
000060  b300              CBZ      r0,|L1.164|
;;;564        {
;;;565            mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
000062  2501              MOVS     r5,#1
;;;566            for (i = 0; i < GPIOTE_CH_NUM; i++)
000064  2400              MOVS     r4,#0
000066  e01b              B        |L1.160|
                  |L1.104|
;;;567            {
;;;568                if (mask & status)
000068  ea050007          AND      r0,r5,r7
00006c  b1b0              CBZ      r0,|L1.156|
;;;569                {
;;;570                    nrf_drv_gpiote_pin_t pin = nrf_gpiote_event_pin_get(i);
00006e  bf00              NOP      
000070  484f              LDR      r0,|L1.432|
000072  f8500024          LDR      r0,[r0,r4,LSL #2]
000076  f3c02004          UBFX     r0,r0,#8,#5
00007a  4680              MOV      r8,r0
;;;571                    nrf_gpiote_polarity_t polarity = nrf_gpiote_event_polarity_get(i);
00007c  bf00              NOP      
00007e  484c              LDR      r0,|L1.432|
000080  f8500024          LDR      r0,[r0,r4,LSL #2]
000084  f3c04001          UBFX     r0,r0,#16,#2
000088  4681              MOV      r9,r0
;;;572                    nrf_drv_gpiote_evt_handler_t handler = channel_handler_get(i);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       channel_handler_get
000090  4606              MOV      r6,r0
;;;573                    if (handler)
000092  b116              CBZ      r6,|L1.154|
;;;574                    {
;;;575                        handler(pin,polarity);
000094  4649              MOV      r1,r9
000096  4640              MOV      r0,r8
000098  47b0              BLX      r6
                  |L1.154|
;;;576                    }
;;;577                }
00009a  bf00              NOP      
                  |L1.156|
;;;578                mask <<= 1;
00009c  006d              LSLS     r5,r5,#1
00009e  1c64              ADDS     r4,r4,#1              ;566
                  |L1.160|
0000a0  2c08              CMP      r4,#8                 ;566
0000a2  d3e1              BCC      |L1.104|
                  |L1.164|
;;;579            }
;;;580        }
;;;581    
;;;582        if (status & (uint32_t)NRF_GPIOTE_INT_PORT_MASK)
0000a4  f0074000          AND      r0,r7,#0x80000000
0000a8  2800              CMP      r0,#0
0000aa  d079              BEQ      |L1.416|
;;;583        {
;;;584            /* Process port event. */
;;;585            uint8_t repeat = 0;
0000ac  f04f0b00          MOV      r11,#0
;;;586            uint32_t toggle_mask = 0;
0000b0  2000              MOVS     r0,#0
0000b2  9005              STR      r0,[sp,#0x14]
;;;587            uint32_t pins_to_check = 0xFFFFFFFFuL;
0000b4  1e40              SUBS     r0,r0,#1
0000b6  9004              STR      r0,[sp,#0x10]
;;;588    
;;;589            do
0000b8  bf00              NOP      
                  |L1.186|
;;;590            {
;;;591                repeat = 0;
0000ba  f04f0b00          MOV      r11,#0
;;;592                for (i = 0; i < GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS; i++)
0000be  2400              MOVS     r4,#0
0000c0  e057              B        |L1.370|
                  |L1.194|
;;;593                {
;;;594                    uint8_t pin_and_sense = m_cb.port_handlers_pins[i];
0000c2  483c              LDR      r0,|L1.436|
0000c4  5d00              LDRB     r0,[r0,r4]
0000c6  9003              STR      r0,[sp,#0xc]
;;;595                    nrf_drv_gpiote_pin_t pin = (pin_and_sense & ~SENSE_FIELD_MASK);
0000c8  9803              LDR      r0,[sp,#0xc]
0000ca  f02006c0          BIC      r6,r0,#0xc0
;;;596    
;;;597                    if ((m_cb.port_handlers_pins[i] != PIN_NOT_USED)
0000ce  4839              LDR      r0,|L1.436|
0000d0  5700              LDRSB    r0,[r0,r4]
0000d2  1c40              ADDS     r0,r0,#1
0000d4  2800              CMP      r0,#0
0000d6  d04b              BEQ      |L1.368|
;;;598                        && ((1UL << pin) & pins_to_check))
0000d8  2001              MOVS     r0,#1
0000da  40b0              LSLS     r0,r0,r6
0000dc  9904              LDR      r1,[sp,#0x10]
0000de  4008              ANDS     r0,r0,r1
0000e0  2800              CMP      r0,#0
0000e2  d045              BEQ      |L1.368|
;;;599                    {
;;;600                        nrf_gpiote_polarity_t polarity =
0000e4  9803              LDR      r0,[sp,#0xc]
0000e6  ea4f1990          LSR      r9,r0,#6
;;;601                                    (nrf_gpiote_polarity_t)((pin_and_sense & SENSE_FIELD_MASK) >> SENSE_FIELD_POS);
;;;602                        nrf_drv_gpiote_evt_handler_t handler = channel_handler_get(channel_port_get(pin));
0000ea  4630              MOV      r0,r6
0000ec  f7fffffe          BL       channel_port_get
0000f0  4680              MOV      r8,r0
0000f2  f7fffffe          BL       channel_handler_get
0000f6  9002              STR      r0,[sp,#8]
;;;603                        if (handler || polarity == NRF_GPIOTE_POLARITY_TOGGLE)
0000f8  9802              LDR      r0,[sp,#8]
0000fa  b910              CBNZ     r0,|L1.258|
0000fc  f1b90f03          CMP      r9,#3
000100  d135              BNE      |L1.366|
                  |L1.258|
;;;604                        {
;;;605                            mask = 1 << pin;
000102  2001              MOVS     r0,#1
000104  fa00f506          LSL      r5,r0,r6
;;;606                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
000108  f1b90f03          CMP      r9,#3
00010c  d102              BNE      |L1.276|
;;;607                            {
;;;608                                toggle_mask |= mask;
00010e  9805              LDR      r0,[sp,#0x14]
000110  4328              ORRS     r0,r0,r5
000112  9005              STR      r0,[sp,#0x14]
                  |L1.276|
;;;609                            }
;;;610                            nrf_gpio_pin_sense_t sense = nrf_gpio_pin_sense_get(pin);
000114  bf00              NOP      
000116  4828              LDR      r0,|L1.440|
000118  f8500026          LDR      r0,[r0,r6,LSL #2]
00011c  f3c04801          UBFX     r8,r0,#16,#2
000120  bf00              NOP      
;;;611    
;;;612                            if (((mask & input) && (sense==NRF_GPIO_PIN_SENSE_HIGH)) ||
000122  ea05000a          AND      r0,r5,r10
000126  b110              CBZ      r0,|L1.302|
000128  f1b80f02          CMP      r8,#2
00012c  d005              BEQ      |L1.314|
                  |L1.302|
;;;613                               (!(mask & input) && (sense==NRF_GPIO_PIN_SENSE_LOW))  )
00012e  ea05000a          AND      r0,r5,r10
000132  b9d8              CBNZ     r0,|L1.364|
000134  f1b80f03          CMP      r8,#3
000138  d118              BNE      |L1.364|
                  |L1.314|
;;;614                            {
;;;615                                if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
00013a  f1b90f03          CMP      r9,#3
00013e  d10f              BNE      |L1.352|
;;;616                                {
;;;617                                    nrf_gpio_pin_sense_t next_sense = (sense == NRF_GPIO_PIN_SENSE_HIGH) ?
000140  f1b80f02          CMP      r8,#2
000144  d101              BNE      |L1.330|
;;;618                                            NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
000146  2003              MOVS     r0,#3
000148  e000              B        |L1.332|
                  |L1.330|
00014a  2002              MOVS     r0,#2
                  |L1.332|
00014c  9001              STR      r0,[sp,#4]
;;;619                                    nrf_gpio_cfg_sense_set(pin, next_sense);
00014e  4630              MOV      r0,r6
000150  9901              LDR      r1,[sp,#4]
000152  f7fffffe          BL       nrf_gpio_cfg_sense_set
;;;620                                    ++repeat;
000156  f10b0001          ADD      r0,r11,#1
00015a  f0000bff          AND      r11,r0,#0xff
;;;621                                }
00015e  bf00              NOP      
                  |L1.352|
;;;622                                if (handler)
000160  9802              LDR      r0,[sp,#8]
000162  b118              CBZ      r0,|L1.364|
;;;623                                {
;;;624                                    handler(pin, polarity);
000164  4649              MOV      r1,r9
000166  4630              MOV      r0,r6
000168  9a02              LDR      r2,[sp,#8]
00016a  4790              BLX      r2
                  |L1.364|
;;;625                                }
;;;626                            }
;;;627                        }
00016c  bf00              NOP      
                  |L1.366|
;;;628                    }
00016e  bf00              NOP      
                  |L1.368|
000170  1c64              ADDS     r4,r4,#1              ;592
                  |L1.370|
000172  2c04              CMP      r4,#4                 ;592
000174  d3a5              BCC      |L1.194|
;;;629                }
;;;630    
;;;631                if (repeat)
000176  f1bb0f00          CMP      r11,#0
00017a  d00d              BEQ      |L1.408|
;;;632                {
;;;633                    // When one of the pins in low-accuracy and toggle mode becomes active,
;;;634                    // it's sense mode is inverted to clear the internal SENSE signal.
;;;635                    // State of any other enabled low-accuracy input in toggle mode must be checked
;;;636                    // explicitly, because it does not trigger the interrput when SENSE signal is active.
;;;637                    // For more information about SENSE functionality, refer to Product Specification.
;;;638                    uint32_t new_input = nrf_gpio_pins_read();
00017c  bf00              NOP      
00017e  490b              LDR      r1,|L1.428|
000180  6809              LDR      r1,[r1,#0]
000182  4608              MOV      r0,r1
;;;639                    if (new_input == input)
000184  4550              CMP      r0,r10
000186  d103              BNE      |L1.400|
;;;640                    {
;;;641                        //No change.
;;;642                        repeat = 0;
000188  f04f0b00          MOV      r11,#0
00018c  e003              B        |L1.406|
00018e  e007              B        |L1.416|
                  |L1.400|
;;;643                    }
;;;644                    else
;;;645                    {
;;;646                        input = new_input;
000190  4682              MOV      r10,r0
;;;647                        pins_to_check = toggle_mask;
000192  9905              LDR      r1,[sp,#0x14]
000194  9104              STR      r1,[sp,#0x10]
                  |L1.406|
;;;648                    }
;;;649                }
000196  bf00              NOP      
                  |L1.408|
;;;650            }
;;;651            while (repeat);
000198  f1bb0f00          CMP      r11,#0
00019c  d18d              BNE      |L1.186|
;;;652        }
00019e  bf00              NOP      
                  |L1.416|
;;;653    }
0001a0  b007              ADD      sp,sp,#0x1c
0001a2  e8bd8ff0          POP      {r4-r11,pc}
;;;654    //lint -restore
                          ENDP

0001a6  0000              DCW      0x0000
                  |L1.424|
                          DCD      0x40006304
                  |L1.428|
                          DCD      0x50000510
                  |L1.432|
                          DCD      0x40006510
                  |L1.436|
                          DCD      m_cb+0x50
                  |L1.440|
                          DCD      0x50000700

                          AREA ||i.channel_free||, CODE, READONLY, ALIGN=2

                  channel_free PROC
;;;154    
;;;155    static void channel_free(uint8_t channel_id)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;156    {
;;;157        m_cb.handlers[channel_id] = FORBIDDEN_HANDLER_ADDRESS;
000004  4a05              LDR      r2,|L2.28|
000006  f8421020          STR      r1,[r2,r0,LSL #2]
;;;158        if (channel_id >= GPIOTE_CH_NUM)
00000a  2808              CMP      r0,#8
00000c  db04              BLT      |L2.24|
;;;159        {
;;;160            m_cb.port_handlers_pins[channel_id - GPIOTE_CH_NUM] = (int8_t)PIN_NOT_USED;
00000e  23ff              MOVS     r3,#0xff
000010  f1a00108          SUB      r1,r0,#8
000014  3250              ADDS     r2,r2,#0x50
000016  5453              STRB     r3,[r2,r1]
                  |L2.24|
;;;161        }
;;;162    }
000018  4770              BX       lr
;;;163    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      m_cb

                          AREA ||i.channel_handler_get||, CODE, READONLY, ALIGN=2

                  channel_handler_get PROC
;;;127    
;;;128    __STATIC_INLINE nrf_drv_gpiote_evt_handler_t channel_handler_get(uint32_t channel)
000000  4601              MOV      r1,r0
;;;129    {
;;;130        return m_cb.handlers[channel];
000002  4802              LDR      r0,|L3.12|
000004  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;131    }
000008  4770              BX       lr
;;;132    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      m_cb

                          AREA ||i.channel_port_alloc||, CODE, READONLY, ALIGN=2

                  channel_port_alloc PROC
;;;132    
;;;133    static int8_t channel_port_alloc(uint32_t pin,nrf_drv_gpiote_evt_handler_t handler, bool channel)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;134    {
000004  4603              MOV      r3,r0
000006  460c              MOV      r4,r1
;;;135        int8_t channel_id = NO_CHANNELS;
000008  f04f39ff          MOV      r9,#0xffffffff
;;;136        uint32_t i;
;;;137    
;;;138        uint32_t start_idx = channel ? 0 : GPIOTE_CH_NUM;
00000c  b10a              CBZ      r2,|L4.18|
00000e  2000              MOVS     r0,#0
000010  e000              B        |L4.20|
                  |L4.18|
000012  2008              MOVS     r0,#8
                  |L4.20|
000014  4684              MOV      r12,r0
;;;139        uint32_t end_idx = channel ? GPIOTE_CH_NUM : (GPIOTE_CH_NUM + GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS);
000016  b10a              CBZ      r2,|L4.28|
000018  2008              MOVS     r0,#8
00001a  e000              B        |L4.30|
                  |L4.28|
00001c  200c              MOVS     r0,#0xc
                  |L4.30|
00001e  4680              MOV      r8,r0
;;;140        //critical section
;;;141    
;;;142        for (i = start_idx; i < end_idx; i++)
000020  4661              MOV      r1,r12
000022  e024              B        |L4.110|
                  |L4.36|
;;;143        {
;;;144            if (m_cb.handlers[i] == FORBIDDEN_HANDLER_ADDRESS)
000024  4815              LDR      r0,|L4.124|
000026  f8500021          LDR      r0,[r0,r1,LSL #2]
00002a  1c40              ADDS     r0,r0,#1
00002c  b9f0              CBNZ     r0,|L4.108|
;;;145            {
;;;146                pin_in_use_by_te_set(pin, i, handler, channel);
00002e  461d              MOV      r5,r3
000030  4608              MOV      r0,r1
000032  4627              MOV      r7,r4
000034  4616              MOV      r6,r2
000036  fa4ffb80          SXTB     r11,r0
00003a  f8dfa040          LDR      r10,|L4.124|
00003e  f10a0a30          ADD      r10,r10,#0x30
000042  f80ab005          STRB     r11,[r10,r5]
000046  f8dfa034          LDR      r10,|L4.124|
00004a  f84a7020          STR      r7,[r10,r0,LSL #2]
00004e  b94e              CBNZ     r6,|L4.100|
000050  fa4ffb85          SXTB     r11,r5
000054  f1a00a08          SUB      r10,r0,#8
000058  f8dfe020          LDR      lr,|L4.124|
00005c  f10e0e50          ADD      lr,lr,#0x50
000060  f80eb00a          STRB     r11,[lr,r10]
                  |L4.100|
000064  bf00              NOP      
;;;147                channel_id = i;
000066  fa4ff981          SXTB     r9,r1
;;;148                break;
00006a  e002              B        |L4.114|
                  |L4.108|
00006c  1c49              ADDS     r1,r1,#1              ;142
                  |L4.110|
00006e  4541              CMP      r1,r8                 ;142
000070  d3d8              BCC      |L4.36|
                  |L4.114|
000072  bf00              NOP      
;;;149            }
;;;150        }
;;;151        //critical section
;;;152        return channel_id;
000074  4648              MOV      r0,r9
;;;153    }
000076  e8bd8ff0          POP      {r4-r11,pc}
;;;154    
                          ENDP

00007a  0000              DCW      0x0000
                  |L4.124|
                          DCD      m_cb

                          AREA ||i.channel_port_get||, CODE, READONLY, ALIGN=2

                  channel_port_get PROC
;;;122    
;;;123    __STATIC_INLINE int8_t channel_port_get(uint32_t pin)
000000  4601              MOV      r1,r0
;;;124    {
;;;125        return m_cb.pin_assignments[pin];
000002  4801              LDR      r0,|L5.8|
000004  5640              LDRSB    r0,[r0,r1]
;;;126    }
000006  4770              BX       lr
;;;127    
                          ENDP

                  |L5.8|
                          DCD      m_cb+0x30

                          AREA ||i.nrf_drv_gpiote_clr_task_addr_get||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_clr_task_addr_get PROC
;;;347    #if defined(GPIOTE_FEATURE_CLR_PRESENT)
;;;348    uint32_t nrf_drv_gpiote_clr_task_addr_get(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;349    {
000002  4604              MOV      r4,r0
;;;350        ASSERT(pin < NUMBER_OF_PINS);
;;;351        ASSERT(pin_in_use_by_te(pin));
;;;352    
;;;353        nrf_gpiote_tasks_t task = TE_CLR_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0080              LSLS     r0,r0,#2
00000c  3060              ADDS     r0,r0,#0x60
00000e  b2c5              UXTB     r5,r0
;;;354        return nrf_gpiote_task_addr_get(task);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       nrf_gpiote_task_addr_get
;;;355    }
000016  bd70              POP      {r4-r6,pc}
;;;356    #endif  // defined(GPIOTE_FEATURE_CLR_PRESENT)
                          ENDP


                          AREA ||i.nrf_drv_gpiote_clr_task_trigger||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_clr_task_trigger PROC
;;;390    #if  defined(GPIOTE_FEATURE_CLR_PRESENT)
;;;391    void nrf_drv_gpiote_clr_task_trigger(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;392    {
000002  4604              MOV      r4,r0
;;;393        ASSERT(pin < NUMBER_OF_PINS);
;;;394        ASSERT(pin_in_use(pin));
;;;395        ASSERT(pin_in_use_by_te(pin));
;;;396    
;;;397        nrf_gpiote_tasks_t task = TE_CLR_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0080              LSLS     r0,r0,#2
00000c  3060              ADDS     r0,r0,#0x60
00000e  b2c5              UXTB     r5,r0
;;;398        nrf_gpiote_task_set(task);
000010  bf00              NOP      
000012  2001              MOVS     r0,#1
000014  4901              LDR      r1,|L7.28|
000016  5068              STR      r0,[r5,r1]
000018  bf00              NOP      
;;;399    }
00001a  bd70              POP      {r4-r6,pc}
;;;400    #endif // defined(GPIOTE_FEATURE_CLR_PRESENT)
                          ENDP

                  |L7.28|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_in_event_addr_get||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_in_event_addr_get PROC
;;;521    
;;;522    uint32_t nrf_drv_gpiote_in_event_addr_get(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;523    {
000002  4604              MOV      r4,r0
;;;524        ASSERT(pin < NUMBER_OF_PINS);
;;;525        ASSERT(pin_in_use_by_te(pin));
;;;526    
;;;527        nrf_gpiote_events_t event = TE_IDX_TO_EVENT_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0080              LSLS     r0,r0,#2
00000c  f5007080          ADD      r0,r0,#0x100
000010  b285              UXTH     r5,r0
;;;528        return nrf_gpiote_event_addr_get(event);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       nrf_gpiote_event_addr_get
;;;529    }
000018  bd70              POP      {r4-r6,pc}
;;;530    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_in_event_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_in_event_disable PROC
;;;485    
;;;486    void nrf_drv_gpiote_in_event_disable(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;487    {
000002  4605              MOV      r5,r0
;;;488        ASSERT(pin < NUMBER_OF_PINS);
;;;489        ASSERT(pin_in_use_by_gpiote(pin));
;;;490        if (pin_in_use_by_port(pin))
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       pin_in_use_by_port
00000a  b120              CBZ      r0,|L9.22|
;;;491        {
;;;492            nrf_gpio_cfg_sense_set(pin,NRF_GPIO_PIN_NOSENSE);
00000c  2100              MOVS     r1,#0
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       nrf_gpio_cfg_sense_set
000014  e018              B        |L9.72|
                  |L9.22|
;;;493        }
;;;494        else if (pin_in_use_by_te(pin))
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       pin_in_use_by_te
00001c  b1a0              CBZ      r0,|L9.72|
;;;495        {
;;;496            int32_t channel = (int32_t)channel_port_get(pin);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       channel_port_get
000024  4604              MOV      r4,r0
;;;497            nrf_gpiote_event_disable(channel);
000026  4620              MOV      r0,r4
000028  4908              LDR      r1,|L9.76|
00002a  f8511020          LDR      r1,[r1,r0,LSL #2]
00002e  f0210201          BIC      r2,r1,#1
000032  4906              LDR      r1,|L9.76|
000034  f8412020          STR      r2,[r1,r0,LSL #2]
000038  bf00              NOP      
;;;498            nrf_gpiote_int_disable(1 << channel);
00003a  2101              MOVS     r1,#1
00003c  fa01f004          LSL      r0,r1,r4
000040  4903              LDR      r1,|L9.80|
000042  6008              STR      r0,[r1,#0]
000044  bf00              NOP      
;;;499        }
000046  bf00              NOP      
                  |L9.72|
;;;500    }
000048  bd70              POP      {r4-r6,pc}
;;;501    
                          ENDP

00004a  0000              DCW      0x0000
                  |L9.76|
                          DCD      0x40006510
                  |L9.80|
                          DCD      0x40006308

                          AREA ||i.nrf_drv_gpiote_in_event_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_in_event_enable PROC
;;;443    
;;;444    void nrf_drv_gpiote_in_event_enable(nrf_drv_gpiote_pin_t pin, bool int_enable)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;445    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;446        ASSERT(pin < NUMBER_OF_PINS);
;;;447        ASSERT(pin_in_use_by_gpiote(pin));
;;;448        if (pin_in_use_by_port(pin))
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       pin_in_use_by_port
00000e  b1f8              CBZ      r0,|L10.80|
;;;449        {
;;;450            uint8_t pin_and_sense = m_cb.port_handlers_pins[channel_port_get(pin) - GPIOTE_CH_NUM];
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       channel_port_get
000016  3808              SUBS     r0,r0,#8
000018  4924              LDR      r1,|L10.172|
00001a  5c0f              LDRB     r7,[r1,r0]
;;;451            nrf_gpiote_polarity_t polarity = (nrf_gpiote_polarity_t)(pin_and_sense >> SENSE_FIELD_POS);
00001c  11bc              ASRS     r4,r7,#6
;;;452            nrf_gpio_pin_sense_t sense;
;;;453            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
00001e  2c03              CMP      r4,#3
000020  d10b              BNE      |L10.58|
;;;454            {
;;;455                /* read current pin state and set for next sense to oposit */
;;;456                sense = (nrf_gpio_pins_read() & (1 << pin)) ?
000022  bf00              NOP      
000024  4822              LDR      r0,|L10.176|
000026  6800              LDR      r0,[r0,#0]
000028  2101              MOVS     r1,#1
00002a  40a9              LSLS     r1,r1,r5
00002c  4008              ANDS     r0,r0,r1
00002e  b108              CBZ      r0,|L10.52|
;;;457                        NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
000030  2003              MOVS     r0,#3
000032  e000              B        |L10.54|
                  |L10.52|
000034  2002              MOVS     r0,#2
                  |L10.54|
000036  4680              MOV      r8,r0
000038  e005              B        |L10.70|
                  |L10.58|
;;;458            }
;;;459            else
;;;460            {
;;;461                sense = (polarity == NRF_GPIOTE_POLARITY_LOTOHI) ?
00003a  2c01              CMP      r4,#1
00003c  d101              BNE      |L10.66|
;;;462                        NRF_GPIO_PIN_SENSE_HIGH : NRF_GPIO_PIN_SENSE_LOW;
00003e  2002              MOVS     r0,#2
000040  e000              B        |L10.68|
                  |L10.66|
000042  2003              MOVS     r0,#3
                  |L10.68|
000044  4680              MOV      r8,r0
                  |L10.70|
;;;463            }
;;;464            nrf_gpio_cfg_sense_set(pin,sense);
000046  4641              MOV      r1,r8
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       nrf_gpio_cfg_sense_set
;;;465        }
00004e  e02a              B        |L10.166|
                  |L10.80|
;;;466        else if (pin_in_use_by_te(pin))
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       pin_in_use_by_te
000056  b330              CBZ      r0,|L10.166|
;;;467        {
;;;468            int32_t channel = (int32_t)channel_port_get(pin);
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       channel_port_get
00005e  4604              MOV      r4,r0
;;;469            nrf_gpiote_events_t event = TE_IDX_TO_EVENT_ADDR(channel);
000060  00a0              LSLS     r0,r4,#2
000062  f5007080          ADD      r0,r0,#0x100
000066  b287              UXTH     r7,r0
;;;470    
;;;471            nrf_gpiote_event_enable(channel);
000068  4620              MOV      r0,r4
00006a  4912              LDR      r1,|L10.180|
00006c  f8511020          LDR      r1,[r1,r0,LSL #2]
000070  f0410201          ORR      r2,r1,#1
000074  490f              LDR      r1,|L10.180|
000076  f8412020          STR      r2,[r1,r0,LSL #2]
00007a  bf00              NOP      
;;;472    
;;;473            nrf_gpiote_event_clear(event);
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       nrf_gpiote_event_clear
;;;474            if (int_enable)
000082  b17e              CBZ      r6,|L10.164|
;;;475            {
;;;476                nrf_drv_gpiote_evt_handler_t handler = channel_handler_get(channel_port_get(pin));
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       channel_port_get
00008a  4681              MOV      r9,r0
00008c  f7fffffe          BL       channel_handler_get
000090  4680              MOV      r8,r0
;;;477                // Enable the interrupt only if event handler was provided.
;;;478                if (handler)
000092  f1b80f00          CMP      r8,#0
000096  d004              BEQ      |L10.162|
;;;479                {
;;;480                    nrf_gpiote_int_enable(1 << channel);
000098  2101              MOVS     r1,#1
00009a  fa01f004          LSL      r0,r1,r4
00009e  f7fffffe          BL       nrf_gpiote_int_enable
                  |L10.162|
;;;481                }
;;;482            }
0000a2  bf00              NOP      
                  |L10.164|
;;;483        }
0000a4  bf00              NOP      
                  |L10.166|
;;;484    }
0000a6  e8bd87f0          POP      {r4-r10,pc}
;;;485    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L10.172|
                          DCD      m_cb+0x50
                  |L10.176|
                          DCD      0x50000510
                  |L10.180|
                          DCD      0x40006510

                          AREA ||i.nrf_drv_gpiote_in_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_in_init PROC
;;;401    
;;;402    ret_code_t nrf_drv_gpiote_in_init(nrf_drv_gpiote_pin_t pin,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;403                                      nrf_drv_gpiote_in_config_t const * p_config,
;;;404                                      nrf_drv_gpiote_evt_handler_t evt_handler)
;;;405    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;406        ASSERT(pin < NUMBER_OF_PINS);
;;;407        ret_code_t result = NRF_SUCCESS;
00000a  f04f0800          MOV      r8,#0
;;;408        /* Only one GPIOTE channel can be assigned to one physical pin. */
;;;409        if (pin_in_use_by_gpiote(pin))
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       pin_in_use_by_gpiote
000014  b110              CBZ      r0,|L11.28|
;;;410        {
;;;411            result = NRF_ERROR_INVALID_STATE;
000016  f04f0808          MOV      r8,#8
00001a  e051              B        |L11.192|
                  |L11.28|
;;;412        }
;;;413        else
;;;414        {
;;;415            int8_t channel = channel_port_alloc(pin, evt_handler, p_config->hi_accuracy);
00001c  78f2              LDRB     r2,[r6,#3]
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       channel_port_alloc
000026  4605              MOV      r5,r0
;;;416            if (channel != NO_CHANNELS)
000028  1c68              ADDS     r0,r5,#1
00002a  2800              CMP      r0,#0
00002c  d045              BEQ      |L11.186|
;;;417            {
;;;418                if (p_config->is_watcher)
00002e  78b0              LDRB     r0,[r6,#2]
000030  b160              CBZ      r0,|L11.76|
;;;419                {
;;;420                    nrf_gpio_cfg_watcher(pin);
000032  bf00              NOP      
000034  00a1              LSLS     r1,r4,#2
000036  f10141a0          ADD      r1,r1,#0x50000000
00003a  f8d11700          LDR      r1,[r1,#0x700]
00003e  f0210002          BIC      r0,r1,#2
000042  4921              LDR      r1,|L11.200|
000044  f8410024          STR      r0,[r1,r4,LSL #2]
000048  bf00              NOP      
00004a  e00c              B        |L11.102|
                  |L11.76|
;;;421                }
;;;422                else
;;;423                {
;;;424                    nrf_gpio_cfg_input(pin,p_config->pull);
00004c  f8969001          LDRB     r9,[r6,#1]
000050  2000              MOVS     r0,#0
000052  9000              STR      r0,[sp,#0]
000054  464b              MOV      r3,r9
000056  4602              MOV      r2,r0
000058  4601              MOV      r1,r0
00005a  9001              STR      r0,[sp,#4]
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       nrf_gpio_cfg
000062  bf00              NOP      
000064  bf00              NOP      
                  |L11.102|
;;;425                }
;;;426    
;;;427                if (p_config->hi_accuracy)
000066  78f0              LDRB     r0,[r6,#3]
000068  b1d0              CBZ      r0,|L11.160|
;;;428                {
;;;429                    nrf_gpiote_event_configure(channel, pin,p_config->sense);
00006a  7830              LDRB     r0,[r6,#0]
00006c  4917              LDR      r1,|L11.204|
00006e  f8511025          LDR      r1,[r1,r5,LSL #2]
000072  4a17              LDR      r2,|L11.208|
000074  4011              ANDS     r1,r1,r2
000076  4a15              LDR      r2,|L11.204|
000078  f8421025          STR      r1,[r2,r5,LSL #2]
00007c  4611              MOV      r1,r2
00007e  f8511025          LDR      r1,[r1,r5,LSL #2]
000082  f44f52f8          MOV      r2,#0x1f00
000086  ea022204          AND      r2,r2,r4,LSL #8
00008a  f44f3340          MOV      r3,#0x30000
00008e  ea034300          AND      r3,r3,r0,LSL #16
000092  431a              ORRS     r2,r2,r3
000094  4311              ORRS     r1,r1,r2
000096  4a0d              LDR      r2,|L11.204|
000098  f8421025          STR      r1,[r2,r5,LSL #2]
00009c  bf00              NOP      
00009e  e00e              B        |L11.190|
                  |L11.160|
;;;430                }
;;;431                else
;;;432                {
;;;433                    m_cb.port_handlers_pins[channel - GPIOTE_CH_NUM] |= (p_config->sense)<< SENSE_FIELD_POS;
0000a0  f1a50008          SUB      r0,r5,#8
0000a4  490b              LDR      r1,|L11.212|
0000a6  5c08              LDRB     r0,[r1,r0]
0000a8  7831              LDRB     r1,[r6,#0]
0000aa  ea401081          ORR      r0,r0,r1,LSL #6
0000ae  b242              SXTB     r2,r0
0000b0  f1a50008          SUB      r0,r5,#8
0000b4  4907              LDR      r1,|L11.212|
0000b6  540a              STRB     r2,[r1,r0]
0000b8  e001              B        |L11.190|
                  |L11.186|
;;;434                }
;;;435            }
;;;436            else
;;;437            {
;;;438                result = NRF_ERROR_NO_MEM;
0000ba  f04f0804          MOV      r8,#4
                  |L11.190|
;;;439            }
;;;440        }
0000be  bf00              NOP      
                  |L11.192|
;;;441        return result;
0000c0  4640              MOV      r0,r8
;;;442    }
0000c2  e8bd87fc          POP      {r2-r10,pc}
;;;443    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L11.200|
                          DCD      0x50000700
                  |L11.204|
                          DCD      0x40006510
                  |L11.208|
                          DCD      0xfffce0ff
                  |L11.212|
                          DCD      m_cb+0x50

                          AREA ||i.nrf_drv_gpiote_in_is_set||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_in_is_set PROC
;;;515    
;;;516    bool nrf_drv_gpiote_in_is_set(nrf_drv_gpiote_pin_t pin)
000000  4601              MOV      r1,r0
;;;517    {
;;;518        ASSERT(pin < NUMBER_OF_PINS);
;;;519        return nrf_gpio_pin_read(pin) ? true : false;
000002  bf00              NOP      
000004  4804              LDR      r0,|L12.24|
000006  6800              LDR      r0,[r0,#0]
000008  40c8              LSRS     r0,r0,r1
00000a  f0000001          AND      r0,r0,#1
00000e  b108              CBZ      r0,|L12.20|
000010  2001              MOVS     r0,#1
                  |L12.18|
;;;520    }
000012  4770              BX       lr
                  |L12.20|
000014  2000              MOVS     r0,#0                 ;519
000016  e7fc              B        |L12.18|
;;;521    
                          ENDP

                  |L12.24|
                          DCD      0x50000510

                          AREA ||i.nrf_drv_gpiote_in_uninit||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_in_uninit PROC
;;;501    
;;;502    void nrf_drv_gpiote_in_uninit(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;503    {
000002  4604              MOV      r4,r0
;;;504        ASSERT(pin < NUMBER_OF_PINS);
;;;505        ASSERT(pin_in_use_by_gpiote(pin));
;;;506        nrf_drv_gpiote_in_event_disable(pin);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_drv_gpiote_in_event_disable
;;;507        if (pin_in_use_by_te(pin))
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       pin_in_use_by_te
000010  b128              CBZ      r0,|L13.30|
;;;508        {
;;;509            nrf_gpiote_te_default(channel_port_get(pin));
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       channel_port_get
000018  4605              MOV      r5,r0
00001a  f7fffffe          BL       nrf_gpiote_te_default
                  |L13.30|
;;;510        }
;;;511        nrf_gpio_cfg_default(pin);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       nrf_gpio_cfg_default
;;;512        channel_free((uint8_t)channel_port_get(pin));
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       channel_port_get
00002a  b2c5              UXTB     r5,r0
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       channel_free
;;;513        pin_in_use_clear(pin);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       pin_in_use_clear
;;;514    }
000038  bd70              POP      {r4-r6,pc}
;;;515    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_init PROC
;;;163    
;;;164    ret_code_t nrf_drv_gpiote_init(void)
000000  b510              PUSH     {r4,lr}
;;;165    {
;;;166        if (m_cb.state != NRF_DRV_STATE_UNINITIALIZED)
000002  4815              LDR      r0,|L14.88|
000004  f8900054          LDRB     r0,[r0,#0x54]  ; m_cb
000008  b108              CBZ      r0,|L14.14|
;;;167        {
;;;168            return NRF_ERROR_INVALID_STATE;
00000a  2008              MOVS     r0,#8
                  |L14.12|
;;;169        }
;;;170    
;;;171        uint8_t i;
;;;172        for (i = 0; i < NUMBER_OF_PINS; i++)
;;;173        {
;;;174            pin_in_use_clear(i);
;;;175        }
;;;176        for (i = 0; i < (GPIOTE_CH_NUM + GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS); i++)
;;;177        {
;;;178            channel_free(i);
;;;179        }
;;;180    
;;;181        nrf_drv_common_irq_enable(GPIOTE_IRQn, GPIOTE_CONFIG_IRQ_PRIORITY);
;;;182        nrf_gpiote_event_clear(NRF_GPIOTE_EVENTS_PORT);
;;;183        nrf_gpiote_int_enable(GPIOTE_INTENSET_PORT_Msk);
;;;184        m_cb.state = NRF_DRV_STATE_INITIALIZED;
;;;185    
;;;186        return NRF_SUCCESS;
;;;187    }
00000c  bd10              POP      {r4,pc}
                  |L14.14|
00000e  2400              MOVS     r4,#0                 ;172
000010  e004              B        |L14.28|
                  |L14.18|
000012  4620              MOV      r0,r4                 ;174
000014  f7fffffe          BL       pin_in_use_clear
000018  1c60              ADDS     r0,r4,#1              ;172
00001a  b2c4              UXTB     r4,r0                 ;172
                  |L14.28|
00001c  2c20              CMP      r4,#0x20              ;172
00001e  dbf8              BLT      |L14.18|
000020  2400              MOVS     r4,#0                 ;176
000022  e004              B        |L14.46|
                  |L14.36|
000024  4620              MOV      r0,r4                 ;178
000026  f7fffffe          BL       channel_free
00002a  1c60              ADDS     r0,r4,#1              ;176
00002c  b2c4              UXTB     r4,r0                 ;176
                  |L14.46|
00002e  2c0c              CMP      r4,#0xc               ;176
000030  dbf8              BLT      |L14.36|
000032  2106              MOVS     r1,#6                 ;181
000034  4608              MOV      r0,r1                 ;181
000036  f7fffffe          BL       nrf_drv_common_irq_enable
00003a  f44f70be          MOV      r0,#0x17c             ;182
00003e  f7fffffe          BL       nrf_gpiote_event_clear
000042  f04f4000          MOV      r0,#0x80000000        ;183
000046  f7fffffe          BL       nrf_gpiote_int_enable
00004a  2001              MOVS     r0,#1                 ;184
00004c  4902              LDR      r1,|L14.88|
00004e  f8810054          STRB     r0,[r1,#0x54]         ;184
000052  2000              MOVS     r0,#0                 ;186
000054  e7da              B        |L14.12|
;;;188    
                          ENDP

000056  0000              DCW      0x0000
                  |L14.88|
                          DCD      m_cb

                          AREA ||i.nrf_drv_gpiote_is_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_is_init PROC
;;;188    
;;;189    bool nrf_drv_gpiote_is_init(void)
000000  4803              LDR      r0,|L15.16|
;;;190    {
;;;191        return (m_cb.state != NRF_DRV_STATE_UNINITIALIZED) ? true : false;
000002  f8900054          LDRB     r0,[r0,#0x54]  ; m_cb
000006  b108              CBZ      r0,|L15.12|
000008  2001              MOVS     r0,#1
                  |L15.10|
;;;192    }
00000a  4770              BX       lr
                  |L15.12|
00000c  2000              MOVS     r0,#0                 ;191
00000e  e7fc              B        |L15.10|
;;;193    
                          ENDP

                  |L15.16|
                          DCD      m_cb

                          AREA ||i.nrf_drv_gpiote_out_clear||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_clear PROC
;;;290    
;;;291    void nrf_drv_gpiote_out_clear(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;292    {
000002  4604              MOV      r4,r0
;;;293        ASSERT(pin < NUMBER_OF_PINS);
;;;294        ASSERT(pin_in_use(pin));
;;;295        ASSERT(!pin_in_use_by_te(pin))
;;;296    
;;;297        nrf_gpio_pin_clear(pin);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpio_pin_clear
;;;298    }
00000a  bd10              POP      {r4,pc}
;;;299    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_out_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_init PROC
;;;215    
;;;216    ret_code_t nrf_drv_gpiote_out_init(nrf_drv_gpiote_pin_t pin,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;217                                       nrf_drv_gpiote_out_config_t const * p_config)
;;;218    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;219        ASSERT(pin < NUMBER_OF_PINS);
;;;220        ASSERT(m_cb.state == NRF_DRV_STATE_INITIALIZED);
;;;221        ASSERT(p_config);
;;;222    
;;;223        ret_code_t result = NRF_SUCCESS;
000008  2700              MOVS     r7,#0
;;;224    
;;;225        if (pin_in_use(pin))
00000a  4620              MOV      r0,r4
00000c  492c              LDR      r1,|L17.192|
00000e  5609              LDRSB    r1,[r1,r0]
000010  1c49              ADDS     r1,r1,#1
000012  b109              CBZ      r1,|L17.24|
000014  2101              MOVS     r1,#1
000016  e000              B        |L17.26|
                  |L17.24|
000018  2100              MOVS     r1,#0
                  |L17.26|
00001a  b109              CBZ      r1,|L17.32|
;;;226        {
;;;227            result = NRF_ERROR_INVALID_STATE;
00001c  2708              MOVS     r7,#8
00001e  e04b              B        |L17.184|
                  |L17.32|
;;;228        }
;;;229        else
;;;230        {
;;;231            if (p_config->task_pin)
000020  78b0              LDRB     r0,[r6,#2]
000022  b360              CBZ      r0,|L17.126|
;;;232            {
;;;233                int8_t channel = channel_port_alloc(pin, NULL, true);
000024  2201              MOVS     r2,#1
000026  2100              MOVS     r1,#0
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       channel_port_alloc
00002e  4605              MOV      r5,r0
;;;234    
;;;235                if (channel != NO_CHANNELS)
000030  1c68              ADDS     r0,r5,#1
000032  b310              CBZ      r0,|L17.122|
;;;236                {
;;;237                    nrf_gpiote_task_configure(channel, pin, p_config->action, p_config->init_state);
000034  7830              LDRB     r0,[r6,#0]
000036  7871              LDRB     r1,[r6,#1]
000038  4a22              LDR      r2,|L17.196|
00003a  f8522025          LDR      r2,[r2,r5,LSL #2]
00003e  4b22              LDR      r3,|L17.200|
000040  401a              ANDS     r2,r2,r3
000042  4b20              LDR      r3,|L17.196|
000044  f8432025          STR      r2,[r3,r5,LSL #2]
000048  461a              MOV      r2,r3
00004a  f8523025          LDR      r3,[r2,r5,LSL #2]
00004e  f44f52f8          MOV      r2,#0x1f00
000052  ea022204          AND      r2,r2,r4,LSL #8
000056  f44f3c40          MOV      r12,#0x30000
00005a  ea0c4c00          AND      r12,r12,r0,LSL #16
00005e  ea42020c          ORR      r2,r2,r12
000062  f44f1c80          MOV      r12,#0x100000
000066  ea0c5c01          AND      r12,r12,r1,LSL #20
00006a  ea42020c          ORR      r2,r2,r12
00006e  4313              ORRS     r3,r3,r2
000070  4a14              LDR      r2,|L17.196|
000072  f8423025          STR      r3,[r2,r5,LSL #2]
000076  bf00              NOP      
000078  e000              B        |L17.124|
                  |L17.122|
;;;238                }
;;;239                else
;;;240                {
;;;241                    result = NRF_ERROR_NO_MEM;
00007a  2704              MOVS     r7,#4
                  |L17.124|
;;;242                }
;;;243            }
00007c  e005              B        |L17.138|
                  |L17.126|
;;;244            else
;;;245            {
;;;246                pin_in_use_set(pin);
00007e  bf00              NOP      
000080  21fe              MOVS     r1,#0xfe
000082  480f              LDR      r0,|L17.192|
000084  5501              STRB     r1,[r0,r4]
000086  bf00              NOP      
000088  bf00              NOP      
                  |L17.138|
;;;247            }
;;;248    
;;;249            if (result == NRF_SUCCESS)
00008a  b9af              CBNZ     r7,|L17.184|
;;;250            {
;;;251                if (p_config->init_state == NRF_GPIOTE_INITIAL_VALUE_HIGH)
00008c  7870              LDRB     r0,[r6,#1]
00008e  2801              CMP      r0,#1
000090  d103              BNE      |L17.154|
;;;252                {
;;;253                    nrf_gpio_pin_set(pin);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       nrf_gpio_pin_set
000098  e002              B        |L17.160|
                  |L17.154|
;;;254                }
;;;255                else
;;;256                {
;;;257                    nrf_gpio_pin_clear(pin);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       nrf_gpio_pin_clear
                  |L17.160|
;;;258                }
;;;259    
;;;260                nrf_gpio_cfg_output(pin);
0000a0  bf00              NOP      
0000a2  2000              MOVS     r0,#0
0000a4  9000              STR      r0,[sp,#0]
0000a6  4603              MOV      r3,r0
0000a8  2201              MOVS     r2,#1
0000aa  4611              MOV      r1,r2
0000ac  9001              STR      r0,[sp,#4]
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       nrf_gpio_cfg
0000b4  bf00              NOP      
0000b6  bf00              NOP      
                  |L17.184|
;;;261            }
;;;262        }
;;;263    
;;;264        return result;
0000b8  4638              MOV      r0,r7
;;;265    }
0000ba  e8bd81fc          POP      {r2-r8,pc}
;;;266    
                          ENDP

0000be  0000              DCW      0x0000
                  |L17.192|
                          DCD      m_cb+0x30
                  |L17.196|
                          DCD      0x40006510
                  |L17.200|
                          DCD      0xffece0ff

                          AREA ||i.nrf_drv_gpiote_out_set||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_set PROC
;;;281    
;;;282    void nrf_drv_gpiote_out_set(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;283    {
000002  4604              MOV      r4,r0
;;;284        ASSERT(pin < NUMBER_OF_PINS);
;;;285        ASSERT(pin_in_use(pin));
;;;286        ASSERT(!pin_in_use_by_te(pin))
;;;287    
;;;288        nrf_gpio_pin_set(pin);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpio_pin_set
;;;289    }
00000a  bd10              POP      {r4,pc}
;;;290    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_out_task_addr_get||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_task_addr_get PROC
;;;326    
;;;327    uint32_t nrf_drv_gpiote_out_task_addr_get(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;328    {
000002  4604              MOV      r4,r0
;;;329        ASSERT(pin < NUMBER_OF_PINS);
;;;330        ASSERT(pin_in_use_by_te(pin));
;;;331    
;;;332        nrf_gpiote_tasks_t task = TE_OUT_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0680              LSLS     r0,r0,#26
00000c  0e05              LSRS     r5,r0,#24
;;;333        return nrf_gpiote_task_addr_get(task);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       nrf_gpiote_task_addr_get
;;;334    }
000014  bd70              POP      {r4-r6,pc}
;;;335    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_out_task_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_disable PROC
;;;317    
;;;318    void nrf_drv_gpiote_out_task_disable(nrf_drv_gpiote_pin_t pin)
000000  4601              MOV      r1,r0
;;;319    {
;;;320        ASSERT(pin < NUMBER_OF_PINS);
;;;321        ASSERT(pin_in_use(pin));
;;;322        ASSERT(pin_in_use_by_te(pin))
;;;323    
;;;324        nrf_gpiote_task_disable(m_cb.pin_assignments[pin]);
000002  4a06              LDR      r2,|L20.28|
000004  5650              LDRSB    r0,[r2,r1]
000006  4a06              LDR      r2,|L20.32|
000008  f8522020          LDR      r2,[r2,r0,LSL #2]
00000c  f0220303          BIC      r3,r2,#3
000010  4a03              LDR      r2,|L20.32|
000012  f8423020          STR      r3,[r2,r0,LSL #2]
000016  bf00              NOP      
;;;325    }
000018  4770              BX       lr
;;;326    
                          ENDP

00001a  0000              DCW      0x0000
                  |L20.28|
                          DCD      m_cb+0x30
                  |L20.32|
                          DCD      0x40006510

                          AREA ||i.nrf_drv_gpiote_out_task_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_enable PROC
;;;308    
;;;309    void nrf_drv_gpiote_out_task_enable(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;310    {
000002  4601              MOV      r1,r0
;;;311        ASSERT(pin < NUMBER_OF_PINS);
;;;312        ASSERT(pin_in_use(pin));
;;;313        ASSERT(pin_in_use_by_te(pin))
;;;314    
;;;315        nrf_gpiote_task_enable(m_cb.pin_assignments[pin]);
000004  4a0a              LDR      r2,|L21.48|
000006  5650              LDRSB    r0,[r2,r1]
000008  4c0a              LDR      r4,|L21.52|
00000a  eb040380          ADD      r3,r4,r0,LSL #2
00000e  f8d33510          LDR      r3,[r3,#0x510]
000012  f0430203          ORR      r2,r3,#3
000016  f44254f8          ORR      r4,r2,#0x1f00
00001a  4b07              LDR      r3,|L21.56|
00001c  f8434020          STR      r4,[r3,r0,LSL #2]
000020  bf00              NOP      
000022  bf00              NOP      
000024  bf00              NOP      
000026  4b04              LDR      r3,|L21.56|
000028  f8432020          STR      r2,[r3,r0,LSL #2]
00002c  bf00              NOP      
;;;316    }
00002e  bd10              POP      {r4,pc}
;;;317    
                          ENDP

                  |L21.48|
                          DCD      m_cb+0x30
                  |L21.52|
                          DCD      0x40006000
                  |L21.56|
                          DCD      0x40006510

                          AREA ||i.nrf_drv_gpiote_out_task_force||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_force PROC
;;;357    
;;;358    void nrf_drv_gpiote_out_task_force(nrf_drv_gpiote_pin_t pin, uint8_t state)
000000  b530              PUSH     {r4,r5,lr}
;;;359    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;360        ASSERT(pin < NUMBER_OF_PINS);
;;;361        ASSERT(pin_in_use(pin));
;;;362        ASSERT(pin_in_use_by_te(pin));
;;;363    
;;;364        nrf_gpiote_outinit_t init_val = state ? NRF_GPIOTE_INITIAL_VALUE_HIGH : NRF_GPIOTE_INITIAL_VALUE_LOW;
000006  b10b              CBZ      r3,|L22.12|
000008  2101              MOVS     r1,#1
00000a  e000              B        |L22.14|
                  |L22.12|
00000c  2100              MOVS     r1,#0
                  |L22.14|
00000e  4608              MOV      r0,r1
;;;365        nrf_gpiote_task_force(m_cb.pin_assignments[pin], init_val);
000010  4c05              LDR      r4,|L22.40|
000012  56a1              LDRSB    r1,[r4,r2]
000014  4c05              LDR      r4,|L22.44|
000016  f8544021          LDR      r4,[r4,r1,LSL #2]
00001a  f3605414          BFI      r4,r0,#20,#1
00001e  4d03              LDR      r5,|L22.44|
000020  f8454021          STR      r4,[r5,r1,LSL #2]
000024  bf00              NOP      
;;;366    }
000026  bd30              POP      {r4,r5,pc}
;;;367    
                          ENDP

                  |L22.40|
                          DCD      m_cb+0x30
                  |L22.44|
                          DCD      0x40006510

                          AREA ||i.nrf_drv_gpiote_out_task_trigger||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_trigger PROC
;;;367    
;;;368    void nrf_drv_gpiote_out_task_trigger(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;369    {
000002  4604              MOV      r4,r0
;;;370        ASSERT(pin < NUMBER_OF_PINS);
;;;371        ASSERT(pin_in_use(pin));
;;;372        ASSERT(pin_in_use_by_te(pin));
;;;373    
;;;374        nrf_gpiote_tasks_t task = TE_OUT_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0680              LSLS     r0,r0,#26
00000c  0e05              LSRS     r5,r0,#24
;;;375        nrf_gpiote_task_set(task);
00000e  bf00              NOP      
000010  2001              MOVS     r0,#1
000012  4902              LDR      r1,|L23.28|
000014  5068              STR      r0,[r5,r1]
000016  bf00              NOP      
;;;376    }
000018  bd70              POP      {r4-r6,pc}
;;;377    
                          ENDP

00001a  0000              DCW      0x0000
                  |L23.28|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_out_toggle||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_toggle PROC
;;;299    
;;;300    void nrf_drv_gpiote_out_toggle(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;301    {
;;;302        ASSERT(pin < NUMBER_OF_PINS);
;;;303        ASSERT(pin_in_use(pin));
;;;304        ASSERT(!pin_in_use_by_te(pin))
;;;305    
;;;306        nrf_gpio_pin_toggle(pin);
000002  bf00              NOP      
000004  2201              MOVS     r2,#1
000006  fa02f100          LSL      r1,r2,r0
00000a  4b07              LDR      r3,|L24.40|
00000c  681a              LDR      r2,[r3,#0]
00000e  ea210302          BIC      r3,r1,r2
000012  4c05              LDR      r4,|L24.40|
000014  1d24              ADDS     r4,r4,#4
000016  6023              STR      r3,[r4,#0]
000018  ea020301          AND      r3,r2,r1
00001c  1d24              ADDS     r4,r4,#4
00001e  6023              STR      r3,[r4,#0]
000020  bf00              NOP      
000022  bf00              NOP      
;;;307    }
000024  bd10              POP      {r4,pc}
;;;308    
                          ENDP

000026  0000              DCW      0x0000
                  |L24.40|
                          DCD      0x50000504

                          AREA ||i.nrf_drv_gpiote_out_uninit||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_uninit PROC
;;;266    
;;;267    void nrf_drv_gpiote_out_uninit(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;268    {
000002  4604              MOV      r4,r0
;;;269        ASSERT(pin < NUMBER_OF_PINS);
;;;270        ASSERT(pin_in_use(pin));
;;;271    
;;;272        if (pin_in_use_by_te(pin))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       pin_in_use_by_te
00000a  b160              CBZ      r0,|L25.38|
;;;273        {
;;;274            channel_free((uint8_t)channel_port_get(pin));
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       channel_port_get
000012  b2c5              UXTB     r5,r0
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       channel_free
;;;275            nrf_gpiote_te_default(channel_port_get(pin));
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       channel_port_get
000020  4605              MOV      r5,r0
000022  f7fffffe          BL       nrf_gpiote_te_default
                  |L25.38|
;;;276        }
;;;277        pin_in_use_clear(pin);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       pin_in_use_clear
;;;278    
;;;279        nrf_gpio_cfg_default(pin);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       nrf_gpio_cfg_default
;;;280    }
000032  bd70              POP      {r4-r6,pc}
;;;281    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_set_task_addr_get||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_set_task_addr_get PROC
;;;336    #if defined(GPIOTE_FEATURE_SET_PRESENT)
;;;337    uint32_t nrf_drv_gpiote_set_task_addr_get(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;338    {
000002  4604              MOV      r4,r0
;;;339        ASSERT(pin < NUMBER_OF_PINS);
;;;340        ASSERT(pin_in_use_by_te(pin));
;;;341    
;;;342        nrf_gpiote_tasks_t task = TE_SET_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0080              LSLS     r0,r0,#2
00000c  3030              ADDS     r0,r0,#0x30
00000e  b2c5              UXTB     r5,r0
;;;343        return nrf_gpiote_task_addr_get(task);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       nrf_gpiote_task_addr_get
;;;344    }
000016  bd70              POP      {r4-r6,pc}
;;;345    #endif  // defined(GPIOTE_FEATURE_SET_PRESENT)
                          ENDP


                          AREA ||i.nrf_drv_gpiote_set_task_trigger||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_set_task_trigger PROC
;;;378    #if defined(GPIOTE_FEATURE_SET_PRESENT)
;;;379    void nrf_drv_gpiote_set_task_trigger(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;380    {
000002  4604              MOV      r4,r0
;;;381        ASSERT(pin < NUMBER_OF_PINS);
;;;382        ASSERT(pin_in_use(pin));
;;;383        ASSERT(pin_in_use_by_te(pin));
;;;384    
;;;385        nrf_gpiote_tasks_t task = TE_SET_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0080              LSLS     r0,r0,#2
00000c  3030              ADDS     r0,r0,#0x30
00000e  b2c5              UXTB     r5,r0
;;;386        nrf_gpiote_task_set(task);
000010  bf00              NOP      
000012  2001              MOVS     r0,#1
000014  4901              LDR      r1,|L27.28|
000016  5068              STR      r0,[r5,r1]
000018  bf00              NOP      
;;;387    }
00001a  bd70              POP      {r4-r6,pc}
;;;388    #endif // defined(GPIOTE_FEATURE_SET_PRESENT)
                          ENDP

                  |L27.28|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_uninit||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_uninit PROC
;;;193    
;;;194    void nrf_drv_gpiote_uninit(void)
000000  b510              PUSH     {r4,lr}
;;;195    {
;;;196        ASSERT(m_cb.state!=NRF_DRV_STATE_UNINITIALIZED);
;;;197    
;;;198        uint32_t i;
;;;199        for (i = 0; i < NUMBER_OF_PINS; i++)
000002  2400              MOVS     r4,#0
000004  e014              B        |L28.48|
                  |L28.6|
;;;200        {
;;;201            if (pin_in_use_as_non_task_out(i))
000006  4620              MOV      r0,r4
000008  490d              LDR      r1,|L28.64|
00000a  5609              LDRSB    r1,[r1,r0]
00000c  1c89              ADDS     r1,r1,#2
00000e  b909              CBNZ     r1,|L28.20|
000010  2101              MOVS     r1,#1
000012  e000              B        |L28.22|
                  |L28.20|
000014  2100              MOVS     r1,#0
                  |L28.22|
000016  b119              CBZ      r1,|L28.32|
;;;202            {
;;;203                nrf_drv_gpiote_out_uninit(i);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       nrf_drv_gpiote_out_uninit
00001e  e006              B        |L28.46|
                  |L28.32|
;;;204            }
;;;205            else if ( pin_in_use_by_gpiote(i))
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       pin_in_use_by_gpiote
000026  b110              CBZ      r0,|L28.46|
;;;206            {
;;;207                /* Disable gpiote_in is having the same effect on out pin as gpiote_out_uninit on
;;;208                 * so it can be called on all pins used by GPIOTE.
;;;209                 */
;;;210                nrf_drv_gpiote_in_uninit(i);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       nrf_drv_gpiote_in_uninit
                  |L28.46|
00002e  1c64              ADDS     r4,r4,#1              ;199
                  |L28.48|
000030  2c20              CMP      r4,#0x20              ;199
000032  d3e8              BCC      |L28.6|
;;;211            }
;;;212        }
;;;213        m_cb.state = NRF_DRV_STATE_UNINITIALIZED;
000034  2000              MOVS     r0,#0
000036  4902              LDR      r1,|L28.64|
000038  3930              SUBS     r1,r1,#0x30
00003a  f8810054          STRB     r0,[r1,#0x54]
;;;214    }
00003e  bd10              POP      {r4,pc}
;;;215    
                          ENDP

                  |L28.64|
                          DCD      m_cb+0x30

                          AREA ||i.nrf_gpio_cfg||, CODE, READONLY, ALIGN=2

                  nrf_gpio_cfg PROC
;;;453    
;;;454    __STATIC_INLINE void nrf_gpio_cfg(
000000  b5f0              PUSH     {r4-r7,lr}
;;;455            uint32_t             pin_number,
;;;456            nrf_gpio_pin_dir_t   dir,
;;;457            nrf_gpio_pin_input_t input,
;;;458            nrf_gpio_pin_pull_t  pull,
;;;459            nrf_gpio_pin_drive_t drive,
;;;460            nrf_gpio_pin_sense_t sense)
;;;461    {
000002  e9dd4505          LDRD     r4,r5,[sp,#0x14]
;;;462        NRF_GPIO->PIN_CNF[pin_number] = ((uint32_t)dir   << GPIO_PIN_CNF_DIR_Pos)
000006  ea410642          ORR      r6,r1,r2,LSL #1
00000a  ea460683          ORR      r6,r6,r3,LSL #2
00000e  ea462604          ORR      r6,r6,r4,LSL #8
000012  ea464705          ORR      r7,r6,r5,LSL #16
000016  4e02              LDR      r6,|L29.32|
000018  f8467020          STR      r7,[r6,r0,LSL #2]
;;;463                                      | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
;;;464                                      | ((uint32_t)pull  << GPIO_PIN_CNF_PULL_Pos)
;;;465                                      | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
;;;466                                      | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
;;;467    }
00001c  bdf0              POP      {r4-r7,pc}
;;;468    
                          ENDP

00001e  0000              DCW      0x0000
                  |L29.32|
                          DCD      0x50000700

                          AREA ||i.nrf_gpio_cfg_default||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_default PROC
;;;490    
;;;491    __STATIC_INLINE void nrf_gpio_cfg_default(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;492    {
000002  4604              MOV      r4,r0
;;;493        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4601              MOV      r1,r0
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;494                pin_number,
;;;495                NRF_GPIO_PIN_DIR_INPUT,
;;;496                NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;497                NRF_GPIO_PIN_NOPULL,
;;;498                NRF_GPIO_PIN_S0S1,
;;;499                NRF_GPIO_PIN_NOSENSE);
;;;500    }
000016  bd1c              POP      {r2-r4,pc}
;;;501    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_sense_set||, CODE, READONLY, ALIGN=2

                  nrf_gpio_cfg_sense_set PROC
;;;526    
;;;527    __STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config)
000000  4a07              LDR      r2,|L31.32|
;;;528    {
;;;529        /*lint -e{845} // A zero has been given as right argument to operator '|'" */
;;;530        //uint32_t cnf = NRF_GPIO->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
;;;531        NRF_GPIO->PIN_CNF[pin_number] &= ~GPIO_PIN_CNF_SENSE_Msk;
000002  f8522020          LDR      r2,[r2,r0,LSL #2]
000006  f4223340          BIC      r3,r2,#0x30000
00000a  4a05              LDR      r2,|L31.32|
00000c  f8423020          STR      r3,[r2,r0,LSL #2]
;;;532        NRF_GPIO->PIN_CNF[pin_number] |= (sense_config << GPIO_PIN_CNF_SENSE_Pos);
000010  f8522020          LDR      r2,[r2,r0,LSL #2]
000014  ea424301          ORR      r3,r2,r1,LSL #16
000018  4a01              LDR      r2,|L31.32|
00001a  f8423020          STR      r3,[r2,r0,LSL #2]
;;;533    }
00001e  4770              BX       lr
;;;534    
                          ENDP

                  |L31.32|
                          DCD      0x50000700

                          AREA ||i.nrf_gpio_pin_clear||, CODE, READONLY, ALIGN=2

                  nrf_gpio_pin_clear PROC
;;;562    
;;;563    __STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
000000  2101              MOVS     r1,#1
;;;564    {
;;;565        NRF_GPIO->OUTCLR = (1UL << pin_number);
000002  4081              LSLS     r1,r1,r0
000004  4a01              LDR      r2,|L32.12|
000006  6011              STR      r1,[r2,#0]
;;;566    }
000008  4770              BX       lr
;;;567    
                          ENDP

00000a  0000              DCW      0x0000
                  |L32.12|
                          DCD      0x5000050c

                          AREA ||i.nrf_gpio_pin_set||, CODE, READONLY, ALIGN=2

                  nrf_gpio_pin_set PROC
;;;552    
;;;553    __STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
000000  2101              MOVS     r1,#1
;;;554    {
;;;555        NRF_GPIO->OUTSET = (1UL << pin_number);
000002  4081              LSLS     r1,r1,r0
000004  4a01              LDR      r2,|L33.12|
000006  6011              STR      r1,[r2,#0]
;;;556    }
000008  4770              BX       lr
;;;557    
                          ENDP

00000a  0000              DCW      0x0000
                  |L33.12|
                          DCD      0x50000508

                          AREA ||i.nrf_gpiote_event_addr_get||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_event_addr_get PROC
;;;297    
;;;298    __STATIC_INLINE uint32_t nrf_gpiote_event_addr_get(nrf_gpiote_events_t event)
000000  4601              MOV      r1,r0
;;;299    {
;;;300        return ((uint32_t)NRF_GPIOTE + event);
000002  4801              LDR      r0,|L34.8|
000004  4408              ADD      r0,r0,r1
;;;301    }
000006  4770              BX       lr
;;;302    
                          ENDP

                  |L34.8|
                          DCD      0x40006000

                          AREA ||i.nrf_gpiote_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_gpiote_event_clear PROC
;;;288    
;;;289    __STATIC_INLINE void nrf_gpiote_event_clear(nrf_gpiote_events_t event)
000000  b538              PUSH     {r3-r5,lr}
;;;290    {
000002  4604              MOV      r4,r0
;;;291        *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpiote_event_addr_get
00000a  2100              MOVS     r1,#0
00000c  6001              STR      r1,[r0,#0]
;;;292    #if __CORTEX_M == 0x04
;;;293        volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       nrf_gpiote_event_addr_get
000014  6800              LDR      r0,[r0,#0]
000016  9000              STR      r0,[sp,#0]
;;;294        (void)dummy;
000018  bf00              NOP      
;;;295    #endif
;;;296    }
00001a  bd38              POP      {r3-r5,pc}
;;;297    
                          ENDP


                          AREA ||i.nrf_gpiote_event_is_set||, CODE, READONLY, ALIGN=1

                  nrf_gpiote_event_is_set PROC
;;;283    
;;;284    __STATIC_INLINE bool nrf_gpiote_event_is_set(nrf_gpiote_events_t event)
000000  b510              PUSH     {r4,lr}
;;;285    {
000002  4604              MOV      r4,r0
;;;286        return (*(uint32_t *)nrf_gpiote_event_addr_get(event) == 0x1UL) ? true : false;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpiote_event_addr_get
00000a  6800              LDR      r0,[r0,#0]
00000c  2801              CMP      r0,#1
00000e  d100              BNE      |L36.18|
                  |L36.16|
;;;287    }
000010  bd10              POP      {r4,pc}
                  |L36.18|
000012  2000              MOVS     r0,#0                 ;286
000014  e7fc              B        |L36.16|
;;;288    
                          ENDP


                          AREA ||i.nrf_gpiote_int_enable||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_int_enable PROC
;;;302    
;;;303    __STATIC_INLINE void nrf_gpiote_int_enable(uint32_t mask)
000000  4901              LDR      r1,|L37.8|
;;;304    {
;;;305        NRF_GPIOTE->INTENSET = mask;
000002  6008              STR      r0,[r1,#0]
;;;306    }
000004  4770              BX       lr
;;;307    
                          ENDP

000006  0000              DCW      0x0000
                  |L37.8|
                          DCD      0x40006304

                          AREA ||i.nrf_gpiote_task_addr_get||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_task_addr_get PROC
;;;278    
;;;279    __STATIC_INLINE uint32_t nrf_gpiote_task_addr_get(nrf_gpiote_tasks_t task)
000000  4601              MOV      r1,r0
;;;280    {
;;;281        return ((uint32_t)NRF_GPIOTE + task);
000002  4801              LDR      r0,|L38.8|
000004  4408              ADD      r0,r0,r1
;;;282    }
000006  4770              BX       lr
;;;283    
                          ENDP

                  |L38.8|
                          DCD      0x40006000

                          AREA ||i.nrf_gpiote_te_default||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_te_default PROC
;;;382    
;;;383    __STATIC_INLINE void nrf_gpiote_te_default(uint32_t idx)
000000  2200              MOVS     r2,#0
;;;384    {
;;;385        NRF_GPIOTE->CONFIG[idx] = 0;
000002  4902              LDR      r1,|L39.12|
000004  f8412020          STR      r2,[r1,r0,LSL #2]
;;;386    }
000008  4770              BX       lr
;;;387    #endif //SUPPRESS_INLINE_IMPLEMENTATION
                          ENDP

00000a  0000              DCW      0x0000
                  |L39.12|
                          DCD      0x40006510

                          AREA ||i.pin_in_use_by_gpiote||, CODE, READONLY, ALIGN=2

                  pin_in_use_by_gpiote PROC
;;;94     
;;;95     __STATIC_INLINE bool pin_in_use_by_gpiote(uint32_t pin)
000000  4601              MOV      r1,r0
;;;96     {
;;;97         return (m_cb.pin_assignments[pin] >= 0);
000002  4805              LDR      r0,|L40.24|
000004  5640              LDRSB    r0,[r0,r1]
000006  2201              MOVS     r2,#1
000008  eb0270e0          ADD      r0,r2,r0,ASR #31
00000c  b108              CBZ      r0,|L40.18|
00000e  2001              MOVS     r0,#1
                  |L40.16|
;;;98     }
000010  4770              BX       lr
                  |L40.18|
000012  2000              MOVS     r0,#0                 ;97
000014  e7fc              B        |L40.16|
;;;99     
                          ENDP

000016  0000              DCW      0x0000
                  |L40.24|
                          DCD      m_cb+0x30

                          AREA ||i.pin_in_use_by_port||, CODE, READONLY, ALIGN=2

                  pin_in_use_by_port PROC
;;;89     
;;;90     __STATIC_INLINE bool pin_in_use_by_port(uint32_t pin)
000000  4601              MOV      r1,r0
;;;91     {
;;;92         return (m_cb.pin_assignments[pin] >= GPIOTE_CH_NUM);
000002  4804              LDR      r0,|L41.20|
000004  5640              LDRSB    r0,[r0,r1]
000006  2808              CMP      r0,#8
000008  db01              BLT      |L41.14|
00000a  2001              MOVS     r0,#1
                  |L41.12|
;;;93     }
00000c  4770              BX       lr
                  |L41.14|
00000e  2000              MOVS     r0,#0                 ;92
000010  e7fc              B        |L41.12|
;;;94     
                          ENDP

000012  0000              DCW      0x0000
                  |L41.20|
                          DCD      m_cb+0x30

                          AREA ||i.pin_in_use_by_te||, CODE, READONLY, ALIGN=2

                  pin_in_use_by_te PROC
;;;84     
;;;85     __STATIC_INLINE bool pin_in_use_by_te(uint32_t pin)
000000  4601              MOV      r1,r0
;;;86     {
;;;87         return (m_cb.pin_assignments[pin] >= 0 && m_cb.pin_assignments[pin] < GPIOTE_CH_NUM) ? true : false;
000002  4806              LDR      r0,|L42.28|
000004  5640              LDRSB    r0,[r0,r1]
000006  2800              CMP      r0,#0
000008  db05              BLT      |L42.22|
00000a  4804              LDR      r0,|L42.28|
00000c  5640              LDRSB    r0,[r0,r1]
00000e  2808              CMP      r0,#8
000010  da01              BGE      |L42.22|
000012  2001              MOVS     r0,#1
                  |L42.20|
;;;88     }
000014  4770              BX       lr
                  |L42.22|
000016  2000              MOVS     r0,#0                 ;87
000018  e7fc              B        |L42.20|
;;;89     
                          ENDP

00001a  0000              DCW      0x0000
                  |L42.28|
                          DCD      m_cb+0x30

                          AREA ||i.pin_in_use_clear||, CODE, READONLY, ALIGN=2

                  pin_in_use_clear PROC
;;;117    
;;;118    __STATIC_INLINE void pin_in_use_clear(uint32_t pin)
000000  22ff              MOVS     r2,#0xff
;;;119    {
;;;120        m_cb.pin_assignments[pin] = PIN_NOT_USED;
000002  4901              LDR      r1,|L43.8|
000004  540a              STRB     r2,[r1,r0]
;;;121    }
000006  4770              BX       lr
;;;122    
                          ENDP

                  |L43.8|
                          DCD      m_cb+0x30

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_cb
                          %        88

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\gpiote\\nrf_drv_gpiote.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_nrf_drv_gpiote_c_875a4e72____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_nrf_drv_gpiote_c_875a4e72____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_nrf_drv_gpiote_c_875a4e72____REVSH|
#line 402
|__asm___16_nrf_drv_gpiote_c_875a4e72____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_nrf_drv_gpiote_c_875a4e72____RRX|
#line 587
|__asm___16_nrf_drv_gpiote_c_875a4e72____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
